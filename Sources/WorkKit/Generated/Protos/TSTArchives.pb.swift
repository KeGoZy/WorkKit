// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TSTArchives.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum TST_CellType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case genericCellType = 0
  case spanCellType = 1
  case numberCellType = 2
  case textCellType = 3
  case formulaCellType = 4
  case dateCellType = 5
  case boolCellType = 6
  case durationCellType = 7
  case formulaErrorCellType = 8
  case automaticCellType = 9

  init() {
    self = .genericCellType
  }

}

enum TST_CellValueType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case emptyCellValueType = 0
  case numberCellValueType = 1
  case stringCellValueType = 2
  case providedCellValueType = 3
  case dateCellValueType = 4
  case boolCellValueType = 5
  case durationCellValueType = 6
  case errorCellValueType = 7
  case richTextCellType = 8
  case currencyCellValueType = 9

  init() {
    self = .emptyCellValueType
  }

}

enum TST_TableDimensionArchive: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case dimensionNeither = -1
  case dimensionRow = 0
  case dimensionColumn = 1

  init() {
    self = .dimensionNeither
  }

}

enum TST_SelectionTypeArchive: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case deprecatedCellSelectionType = 0
  case rowSelectionType = 1
  case columnSelectionType = 2
  case deprecatedCellEditingSelectionType = 3
  case deprecatedTableNameSelectionType = 4
  case deprecatedTableSelectionType = 5
  case regionSelectionType = 6
  case noSelectionType = 7

  init() {
    self = .deprecatedCellSelectionType
  }

}

enum TST_FillDirectionArchive: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case kTstfillDownArchive = 1
  case kTstfillUpArchive = 2
  case kTstfillRightArchive = 3
  case kTstfillLeftArchive = 4

  init() {
    self = .kTstfillDownArchive
  }

}

enum TST_MergeActionArchive: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case mergeActionInsert = 1
  case mergeActionRemove = 2
  case mergeActionShrink = 3
  case mergeActionGrow = 4

  init() {
    self = .mergeActionInsert
  }

}

enum TST_HideShowActionArchive: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case hideShowActionHide = 0
  case hideShowActionShow = 1

  init() {
    self = .hideShowActionHide
  }

}

struct TST_CellID: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var packedData: UInt32 {
    get {return _packedData ?? 0}
    set {_packedData = newValue}
  }
  /// Returns true if `packedData` has been explicitly set.
  var hasPackedData: Bool {return self._packedData != nil}
  /// Clears the value of `packedData`. Subsequent reads from it will return its default value.
  mutating func clearPackedData() {self._packedData = nil}

  var expandedCoord: TSCE_CellCoordinateArchive {
    get {return _expandedCoord ?? TSCE_CellCoordinateArchive()}
    set {_expandedCoord = newValue}
  }
  /// Returns true if `expandedCoord` has been explicitly set.
  var hasExpandedCoord: Bool {return self._expandedCoord != nil}
  /// Clears the value of `expandedCoord`. Subsequent reads from it will return its default value.
  mutating func clearExpandedCoord() {self._expandedCoord = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _packedData: UInt32? = nil
  fileprivate var _expandedCoord: TSCE_CellCoordinateArchive? = nil
}

struct TST_CellUIDLookupListArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var columnUids: TSCE_UidLookupListArchive {
    get {return _columnUids ?? TSCE_UidLookupListArchive()}
    set {_columnUids = newValue}
  }
  /// Returns true if `columnUids` has been explicitly set.
  var hasColumnUids: Bool {return self._columnUids != nil}
  /// Clears the value of `columnUids`. Subsequent reads from it will return its default value.
  mutating func clearColumnUids() {self._columnUids = nil}

  var rowUids: TSCE_UidLookupListArchive {
    get {return _rowUids ?? TSCE_UidLookupListArchive()}
    set {_rowUids = newValue}
  }
  /// Returns true if `rowUids` has been explicitly set.
  var hasRowUids: Bool {return self._rowUids != nil}
  /// Clears the value of `rowUids`. Subsequent reads from it will return its default value.
  mutating func clearRowUids() {self._rowUids = nil}

  var columnIndexes: [Int32] = []

  var rowIndexes: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _columnUids: TSCE_UidLookupListArchive? = nil
  fileprivate var _rowUids: TSCE_UidLookupListArchive? = nil
}

struct TST_CellUIDListArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rowUids: [TSP_UUID] = []

  var columnUids: [TSP_UUID] = []

  var compressedRowIndexes: [Int32] = []

  var compressedColumnIndexes: [Int32] = []

  var uncompressedLookupList: TST_CellUIDLookupListArchive {
    get {return _uncompressedLookupList ?? TST_CellUIDLookupListArchive()}
    set {_uncompressedLookupList = newValue}
  }
  /// Returns true if `uncompressedLookupList` has been explicitly set.
  var hasUncompressedLookupList: Bool {return self._uncompressedLookupList != nil}
  /// Clears the value of `uncompressedLookupList`. Subsequent reads from it will return its default value.
  mutating func clearUncompressedLookupList() {self._uncompressedLookupList = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _uncompressedLookupList: TST_CellUIDLookupListArchive? = nil
}

struct TST_TableSize: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var packedData: UInt32 {
    get {return _packedData ?? 0}
    set {_packedData = newValue}
  }
  /// Returns true if `packedData` has been explicitly set.
  var hasPackedData: Bool {return self._packedData != nil}
  /// Clears the value of `packedData`. Subsequent reads from it will return its default value.
  mutating func clearPackedData() {self._packedData = nil}

  var numColumns: UInt32 {
    get {return _numColumns ?? 0}
    set {_numColumns = newValue}
  }
  /// Returns true if `numColumns` has been explicitly set.
  var hasNumColumns: Bool {return self._numColumns != nil}
  /// Clears the value of `numColumns`. Subsequent reads from it will return its default value.
  mutating func clearNumColumns() {self._numColumns = nil}

  var numRows: UInt32 {
    get {return _numRows ?? 0}
    set {_numRows = newValue}
  }
  /// Returns true if `numRows` has been explicitly set.
  var hasNumRows: Bool {return self._numRows != nil}
  /// Clears the value of `numRows`. Subsequent reads from it will return its default value.
  mutating func clearNumRows() {self._numRows = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _packedData: UInt32? = nil
  fileprivate var _numColumns: UInt32? = nil
  fileprivate var _numRows: UInt32? = nil
}

struct TST_ExpandedTableSize: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var numColumns: UInt32 {
    get {return _numColumns ?? 0}
    set {_numColumns = newValue}
  }
  /// Returns true if `numColumns` has been explicitly set.
  var hasNumColumns: Bool {return self._numColumns != nil}
  /// Clears the value of `numColumns`. Subsequent reads from it will return its default value.
  mutating func clearNumColumns() {self._numColumns = nil}

  var numRows: UInt32 {
    get {return _numRows ?? 0}
    set {_numRows = newValue}
  }
  /// Returns true if `numRows` has been explicitly set.
  var hasNumRows: Bool {return self._numRows != nil}
  /// Clears the value of `numRows`. Subsequent reads from it will return its default value.
  mutating func clearNumRows() {self._numRows = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _numColumns: UInt32? = nil
  fileprivate var _numRows: UInt32? = nil
}

struct TST_CellRange: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var origin: TST_CellID {
    get {return _origin ?? TST_CellID()}
    set {_origin = newValue}
  }
  /// Returns true if `origin` has been explicitly set.
  var hasOrigin: Bool {return self._origin != nil}
  /// Clears the value of `origin`. Subsequent reads from it will return its default value.
  mutating func clearOrigin() {self._origin = nil}

  var size: TST_TableSize {
    get {return _size ?? TST_TableSize()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _origin: TST_CellID? = nil
  fileprivate var _size: TST_TableSize? = nil
}

struct TST_ExpandedCellRange: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var origin: TSCE_CellCoordinateArchive {
    get {return _origin ?? TSCE_CellCoordinateArchive()}
    set {_origin = newValue}
  }
  /// Returns true if `origin` has been explicitly set.
  var hasOrigin: Bool {return self._origin != nil}
  /// Clears the value of `origin`. Subsequent reads from it will return its default value.
  mutating func clearOrigin() {self._origin = nil}

  var size: TST_ExpandedTableSize {
    get {return _size ?? TST_ExpandedTableSize()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _origin: TSCE_CellCoordinateArchive? = nil
  fileprivate var _size: TST_ExpandedTableSize? = nil
}

struct TST_TableSelection: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cellRange: TST_CellRange {
    get {return _cellRange ?? TST_CellRange()}
    set {_cellRange = newValue}
  }
  /// Returns true if `cellRange` has been explicitly set.
  var hasCellRange: Bool {return self._cellRange != nil}
  /// Clears the value of `cellRange`. Subsequent reads from it will return its default value.
  mutating func clearCellRange() {self._cellRange = nil}

  var extendedCellRange: TST_CellRange {
    get {return _extendedCellRange ?? TST_CellRange()}
    set {_extendedCellRange = newValue}
  }
  /// Returns true if `extendedCellRange` has been explicitly set.
  var hasExtendedCellRange: Bool {return self._extendedCellRange != nil}
  /// Clears the value of `extendedCellRange`. Subsequent reads from it will return its default value.
  mutating func clearExtendedCellRange() {self._extendedCellRange = nil}

  var extendedCellRangeValid: Bool {
    get {return _extendedCellRangeValid ?? false}
    set {_extendedCellRangeValid = newValue}
  }
  /// Returns true if `extendedCellRangeValid` has been explicitly set.
  var hasExtendedCellRangeValid: Bool {return self._extendedCellRangeValid != nil}
  /// Clears the value of `extendedCellRangeValid`. Subsequent reads from it will return its default value.
  mutating func clearExtendedCellRangeValid() {self._extendedCellRangeValid = nil}

  var selectionType: TST_SelectionTypeArchive {
    get {return _selectionType ?? .deprecatedCellSelectionType}
    set {_selectionType = newValue}
  }
  /// Returns true if `selectionType` has been explicitly set.
  var hasSelectionType: Bool {return self._selectionType != nil}
  /// Clears the value of `selectionType`. Subsequent reads from it will return its default value.
  mutating func clearSelectionType() {self._selectionType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cellRange: TST_CellRange? = nil
  fileprivate var _extendedCellRange: TST_CellRange? = nil
  fileprivate var _extendedCellRangeValid: Bool? = nil
  fileprivate var _selectionType: TST_SelectionTypeArchive? = nil
}

struct TST_TileRowInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tileRowIndex: UInt32 {
    get {return _tileRowIndex ?? 0}
    set {_tileRowIndex = newValue}
  }
  /// Returns true if `tileRowIndex` has been explicitly set.
  var hasTileRowIndex: Bool {return self._tileRowIndex != nil}
  /// Clears the value of `tileRowIndex`. Subsequent reads from it will return its default value.
  mutating func clearTileRowIndex() {self._tileRowIndex = nil}

  var cellCount: UInt32 {
    get {return _cellCount ?? 0}
    set {_cellCount = newValue}
  }
  /// Returns true if `cellCount` has been explicitly set.
  var hasCellCount: Bool {return self._cellCount != nil}
  /// Clears the value of `cellCount`. Subsequent reads from it will return its default value.
  mutating func clearCellCount() {self._cellCount = nil}

  var cellStorageBufferPreBnc: Data {
    get {return _cellStorageBufferPreBnc ?? Data()}
    set {_cellStorageBufferPreBnc = newValue}
  }
  /// Returns true if `cellStorageBufferPreBnc` has been explicitly set.
  var hasCellStorageBufferPreBnc: Bool {return self._cellStorageBufferPreBnc != nil}
  /// Clears the value of `cellStorageBufferPreBnc`. Subsequent reads from it will return its default value.
  mutating func clearCellStorageBufferPreBnc() {self._cellStorageBufferPreBnc = nil}

  var cellOffsetsPreBnc: Data {
    get {return _cellOffsetsPreBnc ?? Data()}
    set {_cellOffsetsPreBnc = newValue}
  }
  /// Returns true if `cellOffsetsPreBnc` has been explicitly set.
  var hasCellOffsetsPreBnc: Bool {return self._cellOffsetsPreBnc != nil}
  /// Clears the value of `cellOffsetsPreBnc`. Subsequent reads from it will return its default value.
  mutating func clearCellOffsetsPreBnc() {self._cellOffsetsPreBnc = nil}

  var storageVersion: UInt32 {
    get {return _storageVersion ?? 0}
    set {_storageVersion = newValue}
  }
  /// Returns true if `storageVersion` has been explicitly set.
  var hasStorageVersion: Bool {return self._storageVersion != nil}
  /// Clears the value of `storageVersion`. Subsequent reads from it will return its default value.
  mutating func clearStorageVersion() {self._storageVersion = nil}

  var cellStorageBuffer: Data {
    get {return _cellStorageBuffer ?? Data()}
    set {_cellStorageBuffer = newValue}
  }
  /// Returns true if `cellStorageBuffer` has been explicitly set.
  var hasCellStorageBuffer: Bool {return self._cellStorageBuffer != nil}
  /// Clears the value of `cellStorageBuffer`. Subsequent reads from it will return its default value.
  mutating func clearCellStorageBuffer() {self._cellStorageBuffer = nil}

  var cellOffsets: Data {
    get {return _cellOffsets ?? Data()}
    set {_cellOffsets = newValue}
  }
  /// Returns true if `cellOffsets` has been explicitly set.
  var hasCellOffsets: Bool {return self._cellOffsets != nil}
  /// Clears the value of `cellOffsets`. Subsequent reads from it will return its default value.
  mutating func clearCellOffsets() {self._cellOffsets = nil}

  var hasWideOffsets_p: Bool {
    get {return _hasWideOffsets_p ?? false}
    set {_hasWideOffsets_p = newValue}
  }
  /// Returns true if `hasWideOffsets_p` has been explicitly set.
  var hasHasWideOffsets_p: Bool {return self._hasWideOffsets_p != nil}
  /// Clears the value of `hasWideOffsets_p`. Subsequent reads from it will return its default value.
  mutating func clearHasWideOffsets_p() {self._hasWideOffsets_p = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tileRowIndex: UInt32? = nil
  fileprivate var _cellCount: UInt32? = nil
  fileprivate var _cellStorageBufferPreBnc: Data? = nil
  fileprivate var _cellOffsetsPreBnc: Data? = nil
  fileprivate var _storageVersion: UInt32? = nil
  fileprivate var _cellStorageBuffer: Data? = nil
  fileprivate var _cellOffsets: Data? = nil
  fileprivate var _hasWideOffsets_p: Bool? = nil
}

struct TST_Tile: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var maxColumn: UInt32 {
    get {return _maxColumn ?? 0}
    set {_maxColumn = newValue}
  }
  /// Returns true if `maxColumn` has been explicitly set.
  var hasMaxColumn: Bool {return self._maxColumn != nil}
  /// Clears the value of `maxColumn`. Subsequent reads from it will return its default value.
  mutating func clearMaxColumn() {self._maxColumn = nil}

  var maxRow: UInt32 {
    get {return _maxRow ?? 0}
    set {_maxRow = newValue}
  }
  /// Returns true if `maxRow` has been explicitly set.
  var hasMaxRow: Bool {return self._maxRow != nil}
  /// Clears the value of `maxRow`. Subsequent reads from it will return its default value.
  mutating func clearMaxRow() {self._maxRow = nil}

  var numCells: UInt32 {
    get {return _numCells ?? 0}
    set {_numCells = newValue}
  }
  /// Returns true if `numCells` has been explicitly set.
  var hasNumCells: Bool {return self._numCells != nil}
  /// Clears the value of `numCells`. Subsequent reads from it will return its default value.
  mutating func clearNumCells() {self._numCells = nil}

  var numrows: UInt32 {
    get {return _numrows ?? 0}
    set {_numrows = newValue}
  }
  /// Returns true if `numrows` has been explicitly set.
  var hasNumrows: Bool {return self._numrows != nil}
  /// Clears the value of `numrows`. Subsequent reads from it will return its default value.
  mutating func clearNumrows() {self._numrows = nil}

  var rowInfos: [TST_TileRowInfo] = []

  var storageVersion: UInt32 {
    get {return _storageVersion ?? 0}
    set {_storageVersion = newValue}
  }
  /// Returns true if `storageVersion` has been explicitly set.
  var hasStorageVersion: Bool {return self._storageVersion != nil}
  /// Clears the value of `storageVersion`. Subsequent reads from it will return its default value.
  mutating func clearStorageVersion() {self._storageVersion = nil}

  var lastSavedInBnc: Bool {
    get {return _lastSavedInBnc ?? false}
    set {_lastSavedInBnc = newValue}
  }
  /// Returns true if `lastSavedInBnc` has been explicitly set.
  var hasLastSavedInBnc: Bool {return self._lastSavedInBnc != nil}
  /// Clears the value of `lastSavedInBnc`. Subsequent reads from it will return its default value.
  mutating func clearLastSavedInBnc() {self._lastSavedInBnc = nil}

  var shouldUseWideRows: Bool {
    get {return _shouldUseWideRows ?? false}
    set {_shouldUseWideRows = newValue}
  }
  /// Returns true if `shouldUseWideRows` has been explicitly set.
  var hasShouldUseWideRows: Bool {return self._shouldUseWideRows != nil}
  /// Clears the value of `shouldUseWideRows`. Subsequent reads from it will return its default value.
  mutating func clearShouldUseWideRows() {self._shouldUseWideRows = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _maxColumn: UInt32? = nil
  fileprivate var _maxRow: UInt32? = nil
  fileprivate var _numCells: UInt32? = nil
  fileprivate var _numrows: UInt32? = nil
  fileprivate var _storageVersion: UInt32? = nil
  fileprivate var _lastSavedInBnc: Bool? = nil
  fileprivate var _shouldUseWideRows: Bool? = nil
}

struct TST_TileStorage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tiles: [TST_TileStorage.Tile] = []

  var tileSize: UInt32 {
    get {return _tileSize ?? 0}
    set {_tileSize = newValue}
  }
  /// Returns true if `tileSize` has been explicitly set.
  var hasTileSize: Bool {return self._tileSize != nil}
  /// Clears the value of `tileSize`. Subsequent reads from it will return its default value.
  mutating func clearTileSize() {self._tileSize = nil}

  var shouldUseWideRows: Bool {
    get {return _shouldUseWideRows ?? false}
    set {_shouldUseWideRows = newValue}
  }
  /// Returns true if `shouldUseWideRows` has been explicitly set.
  var hasShouldUseWideRows: Bool {return self._shouldUseWideRows != nil}
  /// Clears the value of `shouldUseWideRows`. Subsequent reads from it will return its default value.
  mutating func clearShouldUseWideRows() {self._shouldUseWideRows = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Tile: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var tileid: UInt32 {
      get {return _tileid ?? 0}
      set {_tileid = newValue}
    }
    /// Returns true if `tileid` has been explicitly set.
    var hasTileid: Bool {return self._tileid != nil}
    /// Clears the value of `tileid`. Subsequent reads from it will return its default value.
    mutating func clearTileid() {self._tileid = nil}

    var tile: TSP_Reference {
      get {return _tile ?? TSP_Reference()}
      set {_tile = newValue}
    }
    /// Returns true if `tile` has been explicitly set.
    var hasTile: Bool {return self._tile != nil}
    /// Clears the value of `tile`. Subsequent reads from it will return its default value.
    mutating func clearTile() {self._tile = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _tileid: UInt32? = nil
    fileprivate var _tile: TSP_Reference? = nil
  }

  init() {}

  fileprivate var _tileSize: UInt32? = nil
  fileprivate var _shouldUseWideRows: Bool? = nil
}

struct TST_PopUpMenuModel: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// NOTE: This field was marked as deprecated in the .proto file.
  var item: [TST_PopUpMenuModel.CellValue] = []

  var tsceItem: [TSCE_CellValueArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum CellValueType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case nilType = 1
    case booleanType = 2
    case dateType = 3
    case numberType = 4
    case stringType = 5

    init() {
      self = .nilType
    }

  }

  struct CellValue: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var cellValueType: TST_PopUpMenuModel.CellValueType {
      get {return _storage._cellValueType ?? .nilType}
      set {_uniqueStorage()._cellValueType = newValue}
    }
    /// Returns true if `cellValueType` has been explicitly set.
    var hasCellValueType: Bool {return _storage._cellValueType != nil}
    /// Clears the value of `cellValueType`. Subsequent reads from it will return its default value.
    mutating func clearCellValueType() {_uniqueStorage()._cellValueType = nil}

    var booleanValue: TSCE_BooleanCellValueArchive {
      get {return _storage._booleanValue ?? TSCE_BooleanCellValueArchive()}
      set {_uniqueStorage()._booleanValue = newValue}
    }
    /// Returns true if `booleanValue` has been explicitly set.
    var hasBooleanValue: Bool {return _storage._booleanValue != nil}
    /// Clears the value of `booleanValue`. Subsequent reads from it will return its default value.
    mutating func clearBooleanValue() {_uniqueStorage()._booleanValue = nil}

    var dateValue: TSCE_DateCellValueArchive {
      get {return _storage._dateValue ?? TSCE_DateCellValueArchive()}
      set {_uniqueStorage()._dateValue = newValue}
    }
    /// Returns true if `dateValue` has been explicitly set.
    var hasDateValue: Bool {return _storage._dateValue != nil}
    /// Clears the value of `dateValue`. Subsequent reads from it will return its default value.
    mutating func clearDateValue() {_uniqueStorage()._dateValue = nil}

    var numberValue: TSCE_NumberCellValueArchive {
      get {return _storage._numberValue ?? TSCE_NumberCellValueArchive()}
      set {_uniqueStorage()._numberValue = newValue}
    }
    /// Returns true if `numberValue` has been explicitly set.
    var hasNumberValue: Bool {return _storage._numberValue != nil}
    /// Clears the value of `numberValue`. Subsequent reads from it will return its default value.
    mutating func clearNumberValue() {_uniqueStorage()._numberValue = nil}

    var stringValue: TSCE_StringCellValueArchive {
      get {return _storage._stringValue ?? TSCE_StringCellValueArchive()}
      set {_uniqueStorage()._stringValue = newValue}
    }
    /// Returns true if `stringValue` has been explicitly set.
    var hasStringValue: Bool {return _storage._stringValue != nil}
    /// Clears the value of `stringValue`. Subsequent reads from it will return its default value.
    mutating func clearStringValue() {_uniqueStorage()._stringValue = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

struct TST_ImportWarningSetArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var formulaImportWarning: TST_ImportWarningSetArchive.FormulaImportWarning {
    get {return _storage._formulaImportWarning ?? TST_ImportWarningSetArchive.FormulaImportWarning()}
    set {_uniqueStorage()._formulaImportWarning = newValue}
  }
  /// Returns true if `formulaImportWarning` has been explicitly set.
  var hasFormulaImportWarning: Bool {return _storage._formulaImportWarning != nil}
  /// Clears the value of `formulaImportWarning`. Subsequent reads from it will return its default value.
  mutating func clearFormulaImportWarning() {_uniqueStorage()._formulaImportWarning = nil}

  var condFormatAboveAvgEqualAvg: Bool {
    get {return _storage._condFormatAboveAvgEqualAvg ?? false}
    set {_uniqueStorage()._condFormatAboveAvgEqualAvg = newValue}
  }
  /// Returns true if `condFormatAboveAvgEqualAvg` has been explicitly set.
  var hasCondFormatAboveAvgEqualAvg: Bool {return _storage._condFormatAboveAvgEqualAvg != nil}
  /// Clears the value of `condFormatAboveAvgEqualAvg`. Subsequent reads from it will return its default value.
  mutating func clearCondFormatAboveAvgEqualAvg() {_uniqueStorage()._condFormatAboveAvgEqualAvg = nil}

  var condFormatAboveAvgStdDev: Bool {
    get {return _storage._condFormatAboveAvgStdDev ?? false}
    set {_uniqueStorage()._condFormatAboveAvgStdDev = newValue}
  }
  /// Returns true if `condFormatAboveAvgStdDev` has been explicitly set.
  var hasCondFormatAboveAvgStdDev: Bool {return _storage._condFormatAboveAvgStdDev != nil}
  /// Clears the value of `condFormatAboveAvgStdDev`. Subsequent reads from it will return its default value.
  mutating func clearCondFormatAboveAvgStdDev() {_uniqueStorage()._condFormatAboveAvgStdDev = nil}

  var condFormatComplexFormula: Bool {
    get {return _storage._condFormatComplexFormula ?? false}
    set {_uniqueStorage()._condFormatComplexFormula = newValue}
  }
  /// Returns true if `condFormatComplexFormula` has been explicitly set.
  var hasCondFormatComplexFormula: Bool {return _storage._condFormatComplexFormula != nil}
  /// Clears the value of `condFormatComplexFormula`. Subsequent reads from it will return its default value.
  mutating func clearCondFormatComplexFormula() {_uniqueStorage()._condFormatComplexFormula = nil}

  var condFormatContainsErrors: Bool {
    get {return _storage._condFormatContainsErrors ?? false}
    set {_uniqueStorage()._condFormatContainsErrors = newValue}
  }
  /// Returns true if `condFormatContainsErrors` has been explicitly set.
  var hasCondFormatContainsErrors: Bool {return _storage._condFormatContainsErrors != nil}
  /// Clears the value of `condFormatContainsErrors`. Subsequent reads from it will return its default value.
  mutating func clearCondFormatContainsErrors() {_uniqueStorage()._condFormatContainsErrors = nil}

  var condFormatExpr: Bool {
    get {return _storage._condFormatExpr ?? false}
    set {_uniqueStorage()._condFormatExpr = newValue}
  }
  /// Returns true if `condFormatExpr` has been explicitly set.
  var hasCondFormatExpr: Bool {return _storage._condFormatExpr != nil}
  /// Clears the value of `condFormatExpr`. Subsequent reads from it will return its default value.
  mutating func clearCondFormatExpr() {_uniqueStorage()._condFormatExpr = nil}

  var condFormatNotContainsErrors: Bool {
    get {return _storage._condFormatNotContainsErrors ?? false}
    set {_uniqueStorage()._condFormatNotContainsErrors = newValue}
  }
  /// Returns true if `condFormatNotContainsErrors` has been explicitly set.
  var hasCondFormatNotContainsErrors: Bool {return _storage._condFormatNotContainsErrors != nil}
  /// Clears the value of `condFormatNotContainsErrors`. Subsequent reads from it will return its default value.
  mutating func clearCondFormatNotContainsErrors() {_uniqueStorage()._condFormatNotContainsErrors = nil}

  var condFormatParametersNotAllSameType: Bool {
    get {return _storage._condFormatParametersNotAllSameType ?? false}
    set {_uniqueStorage()._condFormatParametersNotAllSameType = newValue}
  }
  /// Returns true if `condFormatParametersNotAllSameType` has been explicitly set.
  var hasCondFormatParametersNotAllSameType: Bool {return _storage._condFormatParametersNotAllSameType != nil}
  /// Clears the value of `condFormatParametersNotAllSameType`. Subsequent reads from it will return its default value.
  mutating func clearCondFormatParametersNotAllSameType() {_uniqueStorage()._condFormatParametersNotAllSameType = nil}

  var condFormatStopIfTrue: Bool {
    get {return _storage._condFormatStopIfTrue ?? false}
    set {_uniqueStorage()._condFormatStopIfTrue = newValue}
  }
  /// Returns true if `condFormatStopIfTrue` has been explicitly set.
  var hasCondFormatStopIfTrue: Bool {return _storage._condFormatStopIfTrue != nil}
  /// Clears the value of `condFormatStopIfTrue`. Subsequent reads from it will return its default value.
  mutating func clearCondFormatStopIfTrue() {_uniqueStorage()._condFormatStopIfTrue = nil}

  var condFormatUnsupportedOperator: Bool {
    get {return _storage._condFormatUnsupportedOperator ?? false}
    set {_uniqueStorage()._condFormatUnsupportedOperator = newValue}
  }
  /// Returns true if `condFormatUnsupportedOperator` has been explicitly set.
  var hasCondFormatUnsupportedOperator: Bool {return _storage._condFormatUnsupportedOperator != nil}
  /// Clears the value of `condFormatUnsupportedOperator`. Subsequent reads from it will return its default value.
  mutating func clearCondFormatUnsupportedOperator() {_uniqueStorage()._condFormatUnsupportedOperator = nil}

  var condFormatUnsupportedStyling: Bool {
    get {return _storage._condFormatUnsupportedStyling ?? false}
    set {_uniqueStorage()._condFormatUnsupportedStyling = newValue}
  }
  /// Returns true if `condFormatUnsupportedStyling` has been explicitly set.
  var hasCondFormatUnsupportedStyling: Bool {return _storage._condFormatUnsupportedStyling != nil}
  /// Clears the value of `condFormatUnsupportedStyling`. Subsequent reads from it will return its default value.
  mutating func clearCondFormatUnsupportedStyling() {_uniqueStorage()._condFormatUnsupportedStyling = nil}

  var condFormatUnsupportedTimePeriod: Bool {
    get {return _storage._condFormatUnsupportedTimePeriod ?? false}
    set {_uniqueStorage()._condFormatUnsupportedTimePeriod = newValue}
  }
  /// Returns true if `condFormatUnsupportedTimePeriod` has been explicitly set.
  var hasCondFormatUnsupportedTimePeriod: Bool {return _storage._condFormatUnsupportedTimePeriod != nil}
  /// Clears the value of `condFormatUnsupportedTimePeriod`. Subsequent reads from it will return its default value.
  mutating func clearCondFormatUnsupportedTimePeriod() {_uniqueStorage()._condFormatUnsupportedTimePeriod = nil}

  var errorCellWithNoFormula: Bool {
    get {return _storage._errorCellWithNoFormula ?? false}
    set {_uniqueStorage()._errorCellWithNoFormula = newValue}
  }
  /// Returns true if `errorCellWithNoFormula` has been explicitly set.
  var hasErrorCellWithNoFormula: Bool {return _storage._errorCellWithNoFormula != nil}
  /// Clears the value of `errorCellWithNoFormula`. Subsequent reads from it will return its default value.
  mutating func clearErrorCellWithNoFormula() {_uniqueStorage()._errorCellWithNoFormula = nil}

  var unsupportedCondFormat: Bool {
    get {return _storage._unsupportedCondFormat ?? false}
    set {_uniqueStorage()._unsupportedCondFormat = newValue}
  }
  /// Returns true if `unsupportedCondFormat` has been explicitly set.
  var hasUnsupportedCondFormat: Bool {return _storage._unsupportedCondFormat != nil}
  /// Clears the value of `unsupportedCondFormat`. Subsequent reads from it will return its default value.
  mutating func clearUnsupportedCondFormat() {_uniqueStorage()._unsupportedCondFormat = nil}

  var originalDataFormat: String {
    get {return _storage._originalDataFormat ?? String()}
    set {_uniqueStorage()._originalDataFormat = newValue}
  }
  /// Returns true if `originalDataFormat` has been explicitly set.
  var hasOriginalDataFormat: Bool {return _storage._originalDataFormat != nil}
  /// Clears the value of `originalDataFormat`. Subsequent reads from it will return its default value.
  mutating func clearOriginalDataFormat() {_uniqueStorage()._originalDataFormat = nil}

  var formulaWarningFilteredColumnFormulaNotCopied: Bool {
    get {return _storage._formulaWarningFilteredColumnFormulaNotCopied ?? false}
    set {_uniqueStorage()._formulaWarningFilteredColumnFormulaNotCopied = newValue}
  }
  /// Returns true if `formulaWarningFilteredColumnFormulaNotCopied` has been explicitly set.
  var hasFormulaWarningFilteredColumnFormulaNotCopied: Bool {return _storage._formulaWarningFilteredColumnFormulaNotCopied != nil}
  /// Clears the value of `formulaWarningFilteredColumnFormulaNotCopied`. Subsequent reads from it will return its default value.
  mutating func clearFormulaWarningFilteredColumnFormulaNotCopied() {_uniqueStorage()._formulaWarningFilteredColumnFormulaNotCopied = nil}

  var durationFormatRangeChanged: Bool {
    get {return _storage._durationFormatRangeChanged ?? false}
    set {_uniqueStorage()._durationFormatRangeChanged = newValue}
  }
  /// Returns true if `durationFormatRangeChanged` has been explicitly set.
  var hasDurationFormatRangeChanged: Bool {return _storage._durationFormatRangeChanged != nil}
  /// Clears the value of `durationFormatRangeChanged`. Subsequent reads from it will return its default value.
  mutating func clearDurationFormatRangeChanged() {_uniqueStorage()._durationFormatRangeChanged = nil}

  var sortedWarnings: [TSCE_WarningArchive] {
    get {return _storage._sortedWarnings}
    set {_uniqueStorage()._sortedWarnings = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum FormulaWarningType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case threeDReference = 1
    case arrayedFormula = 2
    case differentBehaviorForFunction = 3
    case errorToken = 4
    case externalReference = 5
    case naturalLanguageFormula = 6
    case referenceOutOfBounds = 7
    case sharedFormulaBaseNotFound = 8
    case unknownName = 9
    case unsupportedFormula = 10
    case unsupportedFunction = 11
    case unsupportedName = 12
    case transposedNoIssues = 13
    case transposedWithIssues = 14
    case transposedWithIssuesUnchanged = 15

    init() {
      self = .threeDReference
    }

  }

  struct FormulaImportWarning: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var formulaWarningType: TST_ImportWarningSetArchive.FormulaWarningType {
      get {return _formulaWarningType ?? .threeDReference}
      set {_formulaWarningType = newValue}
    }
    /// Returns true if `formulaWarningType` has been explicitly set.
    var hasFormulaWarningType: Bool {return self._formulaWarningType != nil}
    /// Clears the value of `formulaWarningType`. Subsequent reads from it will return its default value.
    mutating func clearFormulaWarningType() {self._formulaWarningType = nil}

    var originalFormula: String {
      get {return _originalFormula ?? String()}
      set {_originalFormula = newValue}
    }
    /// Returns true if `originalFormula` has been explicitly set.
    var hasOriginalFormula: Bool {return self._originalFormula != nil}
    /// Clears the value of `originalFormula`. Subsequent reads from it will return its default value.
    mutating func clearOriginalFormula() {self._originalFormula = nil}

    var supplementaryText: String {
      get {return _supplementaryText ?? String()}
      set {_supplementaryText = newValue}
    }
    /// Returns true if `supplementaryText` has been explicitly set.
    var hasSupplementaryText: Bool {return self._supplementaryText != nil}
    /// Clears the value of `supplementaryText`. Subsequent reads from it will return its default value.
    mutating func clearSupplementaryText() {self._supplementaryText = nil}

    var formulaWarningTypeInt: Int32 {
      get {return _formulaWarningTypeInt ?? 0}
      set {_formulaWarningTypeInt = newValue}
    }
    /// Returns true if `formulaWarningTypeInt` has been explicitly set.
    var hasFormulaWarningTypeInt: Bool {return self._formulaWarningTypeInt != nil}
    /// Clears the value of `formulaWarningTypeInt`. Subsequent reads from it will return its default value.
    mutating func clearFormulaWarningTypeInt() {self._formulaWarningTypeInt = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _formulaWarningType: TST_ImportWarningSetArchive.FormulaWarningType? = nil
    fileprivate var _originalFormula: String? = nil
    fileprivate var _supplementaryText: String? = nil
    fileprivate var _formulaWarningTypeInt: Int32? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CellRefImportWarningSetPairArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cellRef: TSCE_CellReferenceArchive {
    get {return _cellRef ?? TSCE_CellReferenceArchive()}
    set {_cellRef = newValue}
  }
  /// Returns true if `cellRef` has been explicitly set.
  var hasCellRef: Bool {return self._cellRef != nil}
  /// Clears the value of `cellRef`. Subsequent reads from it will return its default value.
  mutating func clearCellRef() {self._cellRef = nil}

  var warningSet: TST_ImportWarningSetArchive {
    get {return _warningSet ?? TST_ImportWarningSetArchive()}
    set {_warningSet = newValue}
  }
  /// Returns true if `warningSet` has been explicitly set.
  var hasWarningSet: Bool {return self._warningSet != nil}
  /// Clears the value of `warningSet`. Subsequent reads from it will return its default value.
  mutating func clearWarningSet() {self._warningSet = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cellRef: TSCE_CellReferenceArchive? = nil
  fileprivate var _warningSet: TST_ImportWarningSetArchive? = nil
}

struct TST_ImportWarningSetByCellRefArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cellrefWarningSetPair: [TST_CellRefImportWarningSetPairArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TST_TableDataList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var listType: TST_TableDataList.ListType {
    get {return _listType ?? .string}
    set {_listType = newValue}
  }
  /// Returns true if `listType` has been explicitly set.
  var hasListType: Bool {return self._listType != nil}
  /// Clears the value of `listType`. Subsequent reads from it will return its default value.
  mutating func clearListType() {self._listType = nil}

  var nextListID: UInt32 {
    get {return _nextListID ?? 0}
    set {_nextListID = newValue}
  }
  /// Returns true if `nextListID` has been explicitly set.
  var hasNextListID: Bool {return self._nextListID != nil}
  /// Clears the value of `nextListID`. Subsequent reads from it will return its default value.
  mutating func clearNextListID() {self._nextListID = nil}

  var entries: [TST_TableDataList.ListEntry] = []

  var segments: [TSP_Reference] = []

  var isNewForBnc: Bool {
    get {return _isNewForBnc ?? false}
    set {_isNewForBnc = newValue}
  }
  /// Returns true if `isNewForBnc` has been explicitly set.
  var hasIsNewForBnc: Bool {return self._isNewForBnc != nil}
  /// Clears the value of `isNewForBnc`. Subsequent reads from it will return its default value.
  mutating func clearIsNewForBnc() {self._isNewForBnc = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ListType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case string = 1
    case format = 2
    case formula = 3
    case style = 4
    case formulaError = 5
    case customFormat = 6
    case multipleChoiceListFormat = 7
    case richTextPayload = 8
    case conditionalStyle = 9
    case commentStorage = 10
    case importWarning = 11
    case controlCellSpec = 12

    init() {
      self = .string
    }

  }

  struct ListEntry: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var key: UInt32 {
      get {return _storage._key ?? 0}
      set {_uniqueStorage()._key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    var hasKey: Bool {return _storage._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    mutating func clearKey() {_uniqueStorage()._key = nil}

    var refcount: UInt32 {
      get {return _storage._refcount ?? 0}
      set {_uniqueStorage()._refcount = newValue}
    }
    /// Returns true if `refcount` has been explicitly set.
    var hasRefcount: Bool {return _storage._refcount != nil}
    /// Clears the value of `refcount`. Subsequent reads from it will return its default value.
    mutating func clearRefcount() {_uniqueStorage()._refcount = nil}

    var string: String {
      get {return _storage._string ?? String()}
      set {_uniqueStorage()._string = newValue}
    }
    /// Returns true if `string` has been explicitly set.
    var hasString: Bool {return _storage._string != nil}
    /// Clears the value of `string`. Subsequent reads from it will return its default value.
    mutating func clearString() {_uniqueStorage()._string = nil}

    var reference: TSP_Reference {
      get {return _storage._reference ?? TSP_Reference()}
      set {_uniqueStorage()._reference = newValue}
    }
    /// Returns true if `reference` has been explicitly set.
    var hasReference: Bool {return _storage._reference != nil}
    /// Clears the value of `reference`. Subsequent reads from it will return its default value.
    mutating func clearReference() {_uniqueStorage()._reference = nil}

    var formula: TSCE_FormulaArchive {
      get {return _storage._formula ?? TSCE_FormulaArchive()}
      set {_uniqueStorage()._formula = newValue}
    }
    /// Returns true if `formula` has been explicitly set.
    var hasFormula: Bool {return _storage._formula != nil}
    /// Clears the value of `formula`. Subsequent reads from it will return its default value.
    mutating func clearFormula() {_uniqueStorage()._formula = nil}

    var format: TSK_FormatStructArchive {
      get {return _storage._format ?? TSK_FormatStructArchive()}
      set {_uniqueStorage()._format = newValue}
    }
    /// Returns true if `format` has been explicitly set.
    var hasFormat: Bool {return _storage._format != nil}
    /// Clears the value of `format`. Subsequent reads from it will return its default value.
    mutating func clearFormat() {_uniqueStorage()._format = nil}

    var customFormat: TSK_CustomFormatArchive {
      get {return _storage._customFormat ?? TSK_CustomFormatArchive()}
      set {_uniqueStorage()._customFormat = newValue}
    }
    /// Returns true if `customFormat` has been explicitly set.
    var hasCustomFormat: Bool {return _storage._customFormat != nil}
    /// Clears the value of `customFormat`. Subsequent reads from it will return its default value.
    mutating func clearCustomFormat() {_uniqueStorage()._customFormat = nil}

    var richTextPayload: TSP_Reference {
      get {return _storage._richTextPayload ?? TSP_Reference()}
      set {_uniqueStorage()._richTextPayload = newValue}
    }
    /// Returns true if `richTextPayload` has been explicitly set.
    var hasRichTextPayload: Bool {return _storage._richTextPayload != nil}
    /// Clears the value of `richTextPayload`. Subsequent reads from it will return its default value.
    mutating func clearRichTextPayload() {_uniqueStorage()._richTextPayload = nil}

    var commentStorage: TSP_Reference {
      get {return _storage._commentStorage ?? TSP_Reference()}
      set {_uniqueStorage()._commentStorage = newValue}
    }
    /// Returns true if `commentStorage` has been explicitly set.
    var hasCommentStorage: Bool {return _storage._commentStorage != nil}
    /// Clears the value of `commentStorage`. Subsequent reads from it will return its default value.
    mutating func clearCommentStorage() {_uniqueStorage()._commentStorage = nil}

    var importWarningSet: TST_ImportWarningSetArchive {
      get {return _storage._importWarningSet ?? TST_ImportWarningSetArchive()}
      set {_uniqueStorage()._importWarningSet = newValue}
    }
    /// Returns true if `importWarningSet` has been explicitly set.
    var hasImportWarningSet: Bool {return _storage._importWarningSet != nil}
    /// Clears the value of `importWarningSet`. Subsequent reads from it will return its default value.
    mutating func clearImportWarningSet() {_uniqueStorage()._importWarningSet = nil}

    var cellSpec: TST_CellSpecArchive {
      get {return _storage._cellSpec ?? TST_CellSpecArchive()}
      set {_uniqueStorage()._cellSpec = newValue}
    }
    /// Returns true if `cellSpec` has been explicitly set.
    var hasCellSpec: Bool {return _storage._cellSpec != nil}
    /// Clears the value of `cellSpec`. Subsequent reads from it will return its default value.
    mutating func clearCellSpec() {_uniqueStorage()._cellSpec = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _listType: TST_TableDataList.ListType? = nil
  fileprivate var _nextListID: UInt32? = nil
  fileprivate var _isNewForBnc: Bool? = nil
}

struct TST_TableDataListSegment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var listType: TST_TableDataList.ListType {
    get {return _listType ?? .string}
    set {_listType = newValue}
  }
  /// Returns true if `listType` has been explicitly set.
  var hasListType: Bool {return self._listType != nil}
  /// Clears the value of `listType`. Subsequent reads from it will return its default value.
  mutating func clearListType() {self._listType = nil}

  var keyRange: TSP_Range {
    get {return _keyRange ?? TSP_Range()}
    set {_keyRange = newValue}
  }
  /// Returns true if `keyRange` has been explicitly set.
  var hasKeyRange: Bool {return self._keyRange != nil}
  /// Clears the value of `keyRange`. Subsequent reads from it will return its default value.
  mutating func clearKeyRange() {self._keyRange = nil}

  var entries: [TST_TableDataList.ListEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _listType: TST_TableDataList.ListType? = nil
  fileprivate var _keyRange: TSP_Range? = nil
}

struct TST_TableRBTree: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodes: [TST_TableRBTree.Node] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Node: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var key: UInt32 {
      get {return _key ?? 0}
      set {_key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    var hasKey: Bool {return self._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    mutating func clearKey() {self._key = nil}

    var value: UInt32 {
      get {return _value ?? 0}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _key: UInt32? = nil
    fileprivate var _value: UInt32? = nil
  }

  init() {}
}

struct TST_HeaderStorageBucket: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bucketHashFunction: UInt32 {
    get {return _bucketHashFunction ?? 0}
    set {_bucketHashFunction = newValue}
  }
  /// Returns true if `bucketHashFunction` has been explicitly set.
  var hasBucketHashFunction: Bool {return self._bucketHashFunction != nil}
  /// Clears the value of `bucketHashFunction`. Subsequent reads from it will return its default value.
  mutating func clearBucketHashFunction() {self._bucketHashFunction = nil}

  var headers: [TST_HeaderStorageBucket.Header] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Header: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var index: UInt32 {
      get {return _index ?? 0}
      set {_index = newValue}
    }
    /// Returns true if `index` has been explicitly set.
    var hasIndex: Bool {return self._index != nil}
    /// Clears the value of `index`. Subsequent reads from it will return its default value.
    mutating func clearIndex() {self._index = nil}

    var size: Float {
      get {return _size ?? 0}
      set {_size = newValue}
    }
    /// Returns true if `size` has been explicitly set.
    var hasSize: Bool {return self._size != nil}
    /// Clears the value of `size`. Subsequent reads from it will return its default value.
    mutating func clearSize() {self._size = nil}

    var hidingState: UInt32 {
      get {return _hidingState ?? 0}
      set {_hidingState = newValue}
    }
    /// Returns true if `hidingState` has been explicitly set.
    var hasHidingState: Bool {return self._hidingState != nil}
    /// Clears the value of `hidingState`. Subsequent reads from it will return its default value.
    mutating func clearHidingState() {self._hidingState = nil}

    var numberOfCells: UInt32 {
      get {return _numberOfCells ?? 0}
      set {_numberOfCells = newValue}
    }
    /// Returns true if `numberOfCells` has been explicitly set.
    var hasNumberOfCells: Bool {return self._numberOfCells != nil}
    /// Clears the value of `numberOfCells`. Subsequent reads from it will return its default value.
    mutating func clearNumberOfCells() {self._numberOfCells = nil}

    var cellStyle: TSP_Reference {
      get {return _cellStyle ?? TSP_Reference()}
      set {_cellStyle = newValue}
    }
    /// Returns true if `cellStyle` has been explicitly set.
    var hasCellStyle: Bool {return self._cellStyle != nil}
    /// Clears the value of `cellStyle`. Subsequent reads from it will return its default value.
    mutating func clearCellStyle() {self._cellStyle = nil}

    var textStyle: TSP_Reference {
      get {return _textStyle ?? TSP_Reference()}
      set {_textStyle = newValue}
    }
    /// Returns true if `textStyle` has been explicitly set.
    var hasTextStyle: Bool {return self._textStyle != nil}
    /// Clears the value of `textStyle`. Subsequent reads from it will return its default value.
    mutating func clearTextStyle() {self._textStyle = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _index: UInt32? = nil
    fileprivate var _size: Float? = nil
    fileprivate var _hidingState: UInt32? = nil
    fileprivate var _numberOfCells: UInt32? = nil
    fileprivate var _cellStyle: TSP_Reference? = nil
    fileprivate var _textStyle: TSP_Reference? = nil
  }

  init() {}

  fileprivate var _bucketHashFunction: UInt32? = nil
}

struct TST_HeaderStorage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bucketHashFunction: UInt32 {
    get {return _bucketHashFunction ?? 0}
    set {_bucketHashFunction = newValue}
  }
  /// Returns true if `bucketHashFunction` has been explicitly set.
  var hasBucketHashFunction: Bool {return self._bucketHashFunction != nil}
  /// Clears the value of `bucketHashFunction`. Subsequent reads from it will return its default value.
  mutating func clearBucketHashFunction() {self._bucketHashFunction = nil}

  var buckets: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bucketHashFunction: UInt32? = nil
}

struct TST_DataStore: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rowHeaders: TST_HeaderStorage {
    get {return _storage._rowHeaders ?? TST_HeaderStorage()}
    set {_uniqueStorage()._rowHeaders = newValue}
  }
  /// Returns true if `rowHeaders` has been explicitly set.
  var hasRowHeaders: Bool {return _storage._rowHeaders != nil}
  /// Clears the value of `rowHeaders`. Subsequent reads from it will return its default value.
  mutating func clearRowHeaders() {_uniqueStorage()._rowHeaders = nil}

  var columnHeaders: TSP_Reference {
    get {return _storage._columnHeaders ?? TSP_Reference()}
    set {_uniqueStorage()._columnHeaders = newValue}
  }
  /// Returns true if `columnHeaders` has been explicitly set.
  var hasColumnHeaders: Bool {return _storage._columnHeaders != nil}
  /// Clears the value of `columnHeaders`. Subsequent reads from it will return its default value.
  mutating func clearColumnHeaders() {_uniqueStorage()._columnHeaders = nil}

  var tiles: TST_TileStorage {
    get {return _storage._tiles ?? TST_TileStorage()}
    set {_uniqueStorage()._tiles = newValue}
  }
  /// Returns true if `tiles` has been explicitly set.
  var hasTiles: Bool {return _storage._tiles != nil}
  /// Clears the value of `tiles`. Subsequent reads from it will return its default value.
  mutating func clearTiles() {_uniqueStorage()._tiles = nil}

  var stringTable: TSP_Reference {
    get {return _storage._stringTable ?? TSP_Reference()}
    set {_uniqueStorage()._stringTable = newValue}
  }
  /// Returns true if `stringTable` has been explicitly set.
  var hasStringTable: Bool {return _storage._stringTable != nil}
  /// Clears the value of `stringTable`. Subsequent reads from it will return its default value.
  mutating func clearStringTable() {_uniqueStorage()._stringTable = nil}

  var styleTable: TSP_Reference {
    get {return _storage._styleTable ?? TSP_Reference()}
    set {_uniqueStorage()._styleTable = newValue}
  }
  /// Returns true if `styleTable` has been explicitly set.
  var hasStyleTable: Bool {return _storage._styleTable != nil}
  /// Clears the value of `styleTable`. Subsequent reads from it will return its default value.
  mutating func clearStyleTable() {_uniqueStorage()._styleTable = nil}

  var formulaTable: TSP_Reference {
    get {return _storage._formulaTable ?? TSP_Reference()}
    set {_uniqueStorage()._formulaTable = newValue}
  }
  /// Returns true if `formulaTable` has been explicitly set.
  var hasFormulaTable: Bool {return _storage._formulaTable != nil}
  /// Clears the value of `formulaTable`. Subsequent reads from it will return its default value.
  mutating func clearFormulaTable() {_uniqueStorage()._formulaTable = nil}

  var formulaErrorTable: TSP_Reference {
    get {return _storage._formulaErrorTable ?? TSP_Reference()}
    set {_uniqueStorage()._formulaErrorTable = newValue}
  }
  /// Returns true if `formulaErrorTable` has been explicitly set.
  var hasFormulaErrorTable: Bool {return _storage._formulaErrorTable != nil}
  /// Clears the value of `formulaErrorTable`. Subsequent reads from it will return its default value.
  mutating func clearFormulaErrorTable() {_uniqueStorage()._formulaErrorTable = nil}

  var formatTablePreBnc: TSP_Reference {
    get {return _storage._formatTablePreBnc ?? TSP_Reference()}
    set {_uniqueStorage()._formatTablePreBnc = newValue}
  }
  /// Returns true if `formatTablePreBnc` has been explicitly set.
  var hasFormatTablePreBnc: Bool {return _storage._formatTablePreBnc != nil}
  /// Clears the value of `formatTablePreBnc`. Subsequent reads from it will return its default value.
  mutating func clearFormatTablePreBnc() {_uniqueStorage()._formatTablePreBnc = nil}

  var multipleChoiceListFormatTable: TSP_Reference {
    get {return _storage._multipleChoiceListFormatTable ?? TSP_Reference()}
    set {_uniqueStorage()._multipleChoiceListFormatTable = newValue}
  }
  /// Returns true if `multipleChoiceListFormatTable` has been explicitly set.
  var hasMultipleChoiceListFormatTable: Bool {return _storage._multipleChoiceListFormatTable != nil}
  /// Clears the value of `multipleChoiceListFormatTable`. Subsequent reads from it will return its default value.
  mutating func clearMultipleChoiceListFormatTable() {_uniqueStorage()._multipleChoiceListFormatTable = nil}

  var mergeRegionMap: TSP_Reference {
    get {return _storage._mergeRegionMap ?? TSP_Reference()}
    set {_uniqueStorage()._mergeRegionMap = newValue}
  }
  /// Returns true if `mergeRegionMap` has been explicitly set.
  var hasMergeRegionMap: Bool {return _storage._mergeRegionMap != nil}
  /// Clears the value of `mergeRegionMap`. Subsequent reads from it will return its default value.
  mutating func clearMergeRegionMap() {_uniqueStorage()._mergeRegionMap = nil}

  var deprecatedCustomFormatTable: TSP_Reference {
    get {return _storage._deprecatedCustomFormatTable ?? TSP_Reference()}
    set {_uniqueStorage()._deprecatedCustomFormatTable = newValue}
  }
  /// Returns true if `deprecatedCustomFormatTable` has been explicitly set.
  var hasDeprecatedCustomFormatTable: Bool {return _storage._deprecatedCustomFormatTable != nil}
  /// Clears the value of `deprecatedCustomFormatTable`. Subsequent reads from it will return its default value.
  mutating func clearDeprecatedCustomFormatTable() {_uniqueStorage()._deprecatedCustomFormatTable = nil}

  var nextRowStripID: UInt32 {
    get {return _storage._nextRowStripID ?? 0}
    set {_uniqueStorage()._nextRowStripID = newValue}
  }
  /// Returns true if `nextRowStripID` has been explicitly set.
  var hasNextRowStripID: Bool {return _storage._nextRowStripID != nil}
  /// Clears the value of `nextRowStripID`. Subsequent reads from it will return its default value.
  mutating func clearNextRowStripID() {_uniqueStorage()._nextRowStripID = nil}

  var nextColumnStripID: UInt32 {
    get {return _storage._nextColumnStripID ?? 0}
    set {_uniqueStorage()._nextColumnStripID = newValue}
  }
  /// Returns true if `nextColumnStripID` has been explicitly set.
  var hasNextColumnStripID: Bool {return _storage._nextColumnStripID != nil}
  /// Clears the value of `nextColumnStripID`. Subsequent reads from it will return its default value.
  mutating func clearNextColumnStripID() {_uniqueStorage()._nextColumnStripID = nil}

  var rowTileTree: TST_TableRBTree {
    get {return _storage._rowTileTree ?? TST_TableRBTree()}
    set {_uniqueStorage()._rowTileTree = newValue}
  }
  /// Returns true if `rowTileTree` has been explicitly set.
  var hasRowTileTree: Bool {return _storage._rowTileTree != nil}
  /// Clears the value of `rowTileTree`. Subsequent reads from it will return its default value.
  mutating func clearRowTileTree() {_uniqueStorage()._rowTileTree = nil}

  var columnTileTree: TST_TableRBTree {
    get {return _storage._columnTileTree ?? TST_TableRBTree()}
    set {_uniqueStorage()._columnTileTree = newValue}
  }
  /// Returns true if `columnTileTree` has been explicitly set.
  var hasColumnTileTree: Bool {return _storage._columnTileTree != nil}
  /// Clears the value of `columnTileTree`. Subsequent reads from it will return its default value.
  mutating func clearColumnTileTree() {_uniqueStorage()._columnTileTree = nil}

  var storageVersionPreBnc: UInt32 {
    get {return _storage._storageVersionPreBnc ?? 0}
    set {_uniqueStorage()._storageVersionPreBnc = newValue}
  }
  /// Returns true if `storageVersionPreBnc` has been explicitly set.
  var hasStorageVersionPreBnc: Bool {return _storage._storageVersionPreBnc != nil}
  /// Clears the value of `storageVersionPreBnc`. Subsequent reads from it will return its default value.
  mutating func clearStorageVersionPreBnc() {_uniqueStorage()._storageVersionPreBnc = nil}

  var richTextTable: TSP_Reference {
    get {return _storage._richTextTable ?? TSP_Reference()}
    set {_uniqueStorage()._richTextTable = newValue}
  }
  /// Returns true if `richTextTable` has been explicitly set.
  var hasRichTextTable: Bool {return _storage._richTextTable != nil}
  /// Clears the value of `richTextTable`. Subsequent reads from it will return its default value.
  mutating func clearRichTextTable() {_uniqueStorage()._richTextTable = nil}

  var conditionalstyletable: TSP_Reference {
    get {return _storage._conditionalstyletable ?? TSP_Reference()}
    set {_uniqueStorage()._conditionalstyletable = newValue}
  }
  /// Returns true if `conditionalstyletable` has been explicitly set.
  var hasConditionalstyletable: Bool {return _storage._conditionalstyletable != nil}
  /// Clears the value of `conditionalstyletable`. Subsequent reads from it will return its default value.
  mutating func clearConditionalstyletable() {_uniqueStorage()._conditionalstyletable = nil}

  var commentStorageTable: TSP_Reference {
    get {return _storage._commentStorageTable ?? TSP_Reference()}
    set {_uniqueStorage()._commentStorageTable = newValue}
  }
  /// Returns true if `commentStorageTable` has been explicitly set.
  var hasCommentStorageTable: Bool {return _storage._commentStorageTable != nil}
  /// Clears the value of `commentStorageTable`. Subsequent reads from it will return its default value.
  mutating func clearCommentStorageTable() {_uniqueStorage()._commentStorageTable = nil}

  var importWarningSetTable: TSP_Reference {
    get {return _storage._importWarningSetTable ?? TSP_Reference()}
    set {_uniqueStorage()._importWarningSetTable = newValue}
  }
  /// Returns true if `importWarningSetTable` has been explicitly set.
  var hasImportWarningSetTable: Bool {return _storage._importWarningSetTable != nil}
  /// Clears the value of `importWarningSetTable`. Subsequent reads from it will return its default value.
  mutating func clearImportWarningSetTable() {_uniqueStorage()._importWarningSetTable = nil}

  var controlCellSpecTable: TSP_Reference {
    get {return _storage._controlCellSpecTable ?? TSP_Reference()}
    set {_uniqueStorage()._controlCellSpecTable = newValue}
  }
  /// Returns true if `controlCellSpecTable` has been explicitly set.
  var hasControlCellSpecTable: Bool {return _storage._controlCellSpecTable != nil}
  /// Clears the value of `controlCellSpecTable`. Subsequent reads from it will return its default value.
  mutating func clearControlCellSpecTable() {_uniqueStorage()._controlCellSpecTable = nil}

  var formatTable: TSP_Reference {
    get {return _storage._formatTable ?? TSP_Reference()}
    set {_uniqueStorage()._formatTable = newValue}
  }
  /// Returns true if `formatTable` has been explicitly set.
  var hasFormatTable: Bool {return _storage._formatTable != nil}
  /// Clears the value of `formatTable`. Subsequent reads from it will return its default value.
  mutating func clearFormatTable() {_uniqueStorage()._formatTable = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_TableInfoArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_DrawableArchive {
    get {return _storage._super ?? TSD_DrawableArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var tableModel: TSP_Reference {
    get {return _storage._tableModel ?? TSP_Reference()}
    set {_uniqueStorage()._tableModel = newValue}
  }
  /// Returns true if `tableModel` has been explicitly set.
  var hasTableModel: Bool {return _storage._tableModel != nil}
  /// Clears the value of `tableModel`. Subsequent reads from it will return its default value.
  mutating func clearTableModel() {_uniqueStorage()._tableModel = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var editingState: TSP_Reference {
    get {return _storage._editingState ?? TSP_Reference()}
    set {_uniqueStorage()._editingState = newValue}
  }
  /// Returns true if `editingState` has been explicitly set.
  var hasEditingState: Bool {return _storage._editingState != nil}
  /// Clears the value of `editingState`. Subsequent reads from it will return its default value.
  mutating func clearEditingState() {_uniqueStorage()._editingState = nil}

  var summaryModel: TSP_Reference {
    get {return _storage._summaryModel ?? TSP_Reference()}
    set {_uniqueStorage()._summaryModel = newValue}
  }
  /// Returns true if `summaryModel` has been explicitly set.
  var hasSummaryModel: Bool {return _storage._summaryModel != nil}
  /// Clears the value of `summaryModel`. Subsequent reads from it will return its default value.
  mutating func clearSummaryModel() {_uniqueStorage()._summaryModel = nil}

  var categoryOrder: TSP_Reference {
    get {return _storage._categoryOrder ?? TSP_Reference()}
    set {_uniqueStorage()._categoryOrder = newValue}
  }
  /// Returns true if `categoryOrder` has been explicitly set.
  var hasCategoryOrder: Bool {return _storage._categoryOrder != nil}
  /// Clears the value of `categoryOrder`. Subsequent reads from it will return its default value.
  mutating func clearCategoryOrder() {_uniqueStorage()._categoryOrder = nil}

  var viewColumnRowUids: TSP_Reference {
    get {return _storage._viewColumnRowUids ?? TSP_Reference()}
    set {_uniqueStorage()._viewColumnRowUids = newValue}
  }
  /// Returns true if `viewColumnRowUids` has been explicitly set.
  var hasViewColumnRowUids: Bool {return _storage._viewColumnRowUids != nil}
  /// Clears the value of `viewColumnRowUids`. Subsequent reads from it will return its default value.
  mutating func clearViewColumnRowUids() {_uniqueStorage()._viewColumnRowUids = nil}

  var groupByUuid: TSP_UUID {
    get {return _storage._groupByUuid ?? TSP_UUID()}
    set {_uniqueStorage()._groupByUuid = newValue}
  }
  /// Returns true if `groupByUuid` has been explicitly set.
  var hasGroupByUuid: Bool {return _storage._groupByUuid != nil}
  /// Clears the value of `groupByUuid`. Subsequent reads from it will return its default value.
  mutating func clearGroupByUuid() {_uniqueStorage()._groupByUuid = nil}

  var hiddenStatesUuid: TSP_UUID {
    get {return _storage._hiddenStatesUuid ?? TSP_UUID()}
    set {_uniqueStorage()._hiddenStatesUuid = newValue}
  }
  /// Returns true if `hiddenStatesUuid` has been explicitly set.
  var hasHiddenStatesUuid: Bool {return _storage._hiddenStatesUuid != nil}
  /// Clears the value of `hiddenStatesUuid`. Subsequent reads from it will return its default value.
  mutating func clearHiddenStatesUuid() {_uniqueStorage()._hiddenStatesUuid = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var formulaCoordSpaceInPre40: UInt32 {
    get {return _storage._formulaCoordSpaceInPre40 ?? 0}
    set {_uniqueStorage()._formulaCoordSpaceInPre40 = newValue}
  }
  /// Returns true if `formulaCoordSpaceInPre40` has been explicitly set.
  var hasFormulaCoordSpaceInPre40: Bool {return _storage._formulaCoordSpaceInPre40 != nil}
  /// Clears the value of `formulaCoordSpaceInPre40`. Subsequent reads from it will return its default value.
  mutating func clearFormulaCoordSpaceInPre40() {_uniqueStorage()._formulaCoordSpaceInPre40 = nil}

  var formulaCoordSpace: UInt32 {
    get {return _storage._formulaCoordSpace ?? 0}
    set {_uniqueStorage()._formulaCoordSpace = newValue}
  }
  /// Returns true if `formulaCoordSpace` has been explicitly set.
  var hasFormulaCoordSpace: Bool {return _storage._formulaCoordSpace != nil}
  /// Clears the value of `formulaCoordSpace`. Subsequent reads from it will return its default value.
  mutating func clearFormulaCoordSpace() {_uniqueStorage()._formulaCoordSpace = nil}

  var pasteboardCoordMapper: TSCE_CoordMapperArchive {
    get {return _storage._pasteboardCoordMapper ?? TSCE_CoordMapperArchive()}
    set {_uniqueStorage()._pasteboardCoordMapper = newValue}
  }
  /// Returns true if `pasteboardCoordMapper` has been explicitly set.
  var hasPasteboardCoordMapper: Bool {return _storage._pasteboardCoordMapper != nil}
  /// Clears the value of `pasteboardCoordMapper`. Subsequent reads from it will return its default value.
  mutating func clearPasteboardCoordMapper() {_uniqueStorage()._pasteboardCoordMapper = nil}

  var layoutEngine: TST_LayoutEngineArchive {
    get {return _storage._layoutEngine ?? TST_LayoutEngineArchive()}
    set {_uniqueStorage()._layoutEngine = newValue}
  }
  /// Returns true if `layoutEngine` has been explicitly set.
  var hasLayoutEngine: Bool {return _storage._layoutEngine != nil}
  /// Clears the value of `layoutEngine`. Subsequent reads from it will return its default value.
  mutating func clearLayoutEngine() {_uniqueStorage()._layoutEngine = nil}

  var pivotDataModel: TSP_Reference {
    get {return _storage._pivotDataModel ?? TSP_Reference()}
    set {_uniqueStorage()._pivotDataModel = newValue}
  }
  /// Returns true if `pivotDataModel` has been explicitly set.
  var hasPivotDataModel: Bool {return _storage._pivotDataModel != nil}
  /// Clears the value of `pivotDataModel`. Subsequent reads from it will return its default value.
  mutating func clearPivotDataModel() {_uniqueStorage()._pivotDataModel = nil}

  var isAPivotTable: Bool {
    get {return _storage._isAPivotTable ?? false}
    set {_uniqueStorage()._isAPivotTable = newValue}
  }
  /// Returns true if `isAPivotTable` has been explicitly set.
  var hasIsAPivotTable: Bool {return _storage._isAPivotTable != nil}
  /// Clears the value of `isAPivotTable`. Subsequent reads from it will return its default value.
  mutating func clearIsAPivotTable() {_uniqueStorage()._isAPivotTable = nil}

  var pivotOrder: TSP_Reference {
    get {return _storage._pivotOrder ?? TSP_Reference()}
    set {_uniqueStorage()._pivotOrder = newValue}
  }
  /// Returns true if `pivotOrder` has been explicitly set.
  var hasPivotOrder: Bool {return _storage._pivotOrder != nil}
  /// Clears the value of `pivotOrder`. Subsequent reads from it will return its default value.
  mutating func clearPivotOrder() {_uniqueStorage()._pivotOrder = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CategoryInfoArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_DrawableArchive {
    get {return _super ?? TSD_DrawableArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var tableModel: TSP_Reference {
    get {return _tableModel ?? TSP_Reference()}
    set {_tableModel = newValue}
  }
  /// Returns true if `tableModel` has been explicitly set.
  var hasTableModel: Bool {return self._tableModel != nil}
  /// Clears the value of `tableModel`. Subsequent reads from it will return its default value.
  mutating func clearTableModel() {self._tableModel = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_DrawableArchive? = nil
  fileprivate var _tableModel: TSP_Reference? = nil
}

struct TST_WPTableInfoArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableInfoArchive {
    get {return _super ?? TST_TableInfoArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var storage: TSP_Reference {
    get {return _storage ?? TSP_Reference()}
    set {_storage = newValue}
  }
  /// Returns true if `storage` has been explicitly set.
  var hasStorage: Bool {return self._storage != nil}
  /// Clears the value of `storage`. Subsequent reads from it will return its default value.
  mutating func clearStorage() {self._storage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableInfoArchive? = nil
  fileprivate var _storage: TSP_Reference? = nil
}

struct TST_TableStyleNetworkArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bodyTextStyle: TSP_Reference {
    get {return _storage._bodyTextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._bodyTextStyle = newValue}
  }
  /// Returns true if `bodyTextStyle` has been explicitly set.
  var hasBodyTextStyle: Bool {return _storage._bodyTextStyle != nil}
  /// Clears the value of `bodyTextStyle`. Subsequent reads from it will return its default value.
  mutating func clearBodyTextStyle() {_uniqueStorage()._bodyTextStyle = nil}

  var headerRowTextStyle: TSP_Reference {
    get {return _storage._headerRowTextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._headerRowTextStyle = newValue}
  }
  /// Returns true if `headerRowTextStyle` has been explicitly set.
  var hasHeaderRowTextStyle: Bool {return _storage._headerRowTextStyle != nil}
  /// Clears the value of `headerRowTextStyle`. Subsequent reads from it will return its default value.
  mutating func clearHeaderRowTextStyle() {_uniqueStorage()._headerRowTextStyle = nil}

  var headerColumnTextStyle: TSP_Reference {
    get {return _storage._headerColumnTextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._headerColumnTextStyle = newValue}
  }
  /// Returns true if `headerColumnTextStyle` has been explicitly set.
  var hasHeaderColumnTextStyle: Bool {return _storage._headerColumnTextStyle != nil}
  /// Clears the value of `headerColumnTextStyle`. Subsequent reads from it will return its default value.
  mutating func clearHeaderColumnTextStyle() {_uniqueStorage()._headerColumnTextStyle = nil}

  var footerRowTextStyle: TSP_Reference {
    get {return _storage._footerRowTextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._footerRowTextStyle = newValue}
  }
  /// Returns true if `footerRowTextStyle` has been explicitly set.
  var hasFooterRowTextStyle: Bool {return _storage._footerRowTextStyle != nil}
  /// Clears the value of `footerRowTextStyle`. Subsequent reads from it will return its default value.
  mutating func clearFooterRowTextStyle() {_uniqueStorage()._footerRowTextStyle = nil}

  var bodyCellStyle: TSP_Reference {
    get {return _storage._bodyCellStyle ?? TSP_Reference()}
    set {_uniqueStorage()._bodyCellStyle = newValue}
  }
  /// Returns true if `bodyCellStyle` has been explicitly set.
  var hasBodyCellStyle: Bool {return _storage._bodyCellStyle != nil}
  /// Clears the value of `bodyCellStyle`. Subsequent reads from it will return its default value.
  mutating func clearBodyCellStyle() {_uniqueStorage()._bodyCellStyle = nil}

  var headerRowStyle: TSP_Reference {
    get {return _storage._headerRowStyle ?? TSP_Reference()}
    set {_uniqueStorage()._headerRowStyle = newValue}
  }
  /// Returns true if `headerRowStyle` has been explicitly set.
  var hasHeaderRowStyle: Bool {return _storage._headerRowStyle != nil}
  /// Clears the value of `headerRowStyle`. Subsequent reads from it will return its default value.
  mutating func clearHeaderRowStyle() {_uniqueStorage()._headerRowStyle = nil}

  var headerColumnStyle: TSP_Reference {
    get {return _storage._headerColumnStyle ?? TSP_Reference()}
    set {_uniqueStorage()._headerColumnStyle = newValue}
  }
  /// Returns true if `headerColumnStyle` has been explicitly set.
  var hasHeaderColumnStyle: Bool {return _storage._headerColumnStyle != nil}
  /// Clears the value of `headerColumnStyle`. Subsequent reads from it will return its default value.
  mutating func clearHeaderColumnStyle() {_uniqueStorage()._headerColumnStyle = nil}

  var footerRowStyle: TSP_Reference {
    get {return _storage._footerRowStyle ?? TSP_Reference()}
    set {_uniqueStorage()._footerRowStyle = newValue}
  }
  /// Returns true if `footerRowStyle` has been explicitly set.
  var hasFooterRowStyle: Bool {return _storage._footerRowStyle != nil}
  /// Clears the value of `footerRowStyle`. Subsequent reads from it will return its default value.
  mutating func clearFooterRowStyle() {_uniqueStorage()._footerRowStyle = nil}

  var tableStyle: TSP_Reference {
    get {return _storage._tableStyle ?? TSP_Reference()}
    set {_uniqueStorage()._tableStyle = newValue}
  }
  /// Returns true if `tableStyle` has been explicitly set.
  var hasTableStyle: Bool {return _storage._tableStyle != nil}
  /// Clears the value of `tableStyle`. Subsequent reads from it will return its default value.
  mutating func clearTableStyle() {_uniqueStorage()._tableStyle = nil}

  var tableNameStyle: TSP_Reference {
    get {return _storage._tableNameStyle ?? TSP_Reference()}
    set {_uniqueStorage()._tableNameStyle = newValue}
  }
  /// Returns true if `tableNameStyle` has been explicitly set.
  var hasTableNameStyle: Bool {return _storage._tableNameStyle != nil}
  /// Clears the value of `tableNameStyle`. Subsequent reads from it will return its default value.
  mutating func clearTableNameStyle() {_uniqueStorage()._tableNameStyle = nil}

  var tableNameShapeStyle: TSP_Reference {
    get {return _storage._tableNameShapeStyle ?? TSP_Reference()}
    set {_uniqueStorage()._tableNameShapeStyle = newValue}
  }
  /// Returns true if `tableNameShapeStyle` has been explicitly set.
  var hasTableNameShapeStyle: Bool {return _storage._tableNameShapeStyle != nil}
  /// Clears the value of `tableNameShapeStyle`. Subsequent reads from it will return its default value.
  mutating func clearTableNameShapeStyle() {_uniqueStorage()._tableNameShapeStyle = nil}

  var presetID: UInt32 {
    get {return _storage._presetID ?? 0}
    set {_uniqueStorage()._presetID = newValue}
  }
  /// Returns true if `presetID` has been explicitly set.
  var hasPresetID: Bool {return _storage._presetID != nil}
  /// Clears the value of `presetID`. Subsequent reads from it will return its default value.
  mutating func clearPresetID() {_uniqueStorage()._presetID = nil}

  var categoryLevel1TextStyle: TSP_Reference {
    get {return _storage._categoryLevel1TextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._categoryLevel1TextStyle = newValue}
  }
  /// Returns true if `categoryLevel1TextStyle` has been explicitly set.
  var hasCategoryLevel1TextStyle: Bool {return _storage._categoryLevel1TextStyle != nil}
  /// Clears the value of `categoryLevel1TextStyle`. Subsequent reads from it will return its default value.
  mutating func clearCategoryLevel1TextStyle() {_uniqueStorage()._categoryLevel1TextStyle = nil}

  var categoryLevel2TextStyle: TSP_Reference {
    get {return _storage._categoryLevel2TextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._categoryLevel2TextStyle = newValue}
  }
  /// Returns true if `categoryLevel2TextStyle` has been explicitly set.
  var hasCategoryLevel2TextStyle: Bool {return _storage._categoryLevel2TextStyle != nil}
  /// Clears the value of `categoryLevel2TextStyle`. Subsequent reads from it will return its default value.
  mutating func clearCategoryLevel2TextStyle() {_uniqueStorage()._categoryLevel2TextStyle = nil}

  var categoryLevel3TextStyle: TSP_Reference {
    get {return _storage._categoryLevel3TextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._categoryLevel3TextStyle = newValue}
  }
  /// Returns true if `categoryLevel3TextStyle` has been explicitly set.
  var hasCategoryLevel3TextStyle: Bool {return _storage._categoryLevel3TextStyle != nil}
  /// Clears the value of `categoryLevel3TextStyle`. Subsequent reads from it will return its default value.
  mutating func clearCategoryLevel3TextStyle() {_uniqueStorage()._categoryLevel3TextStyle = nil}

  var categoryLevel4TextStyle: TSP_Reference {
    get {return _storage._categoryLevel4TextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._categoryLevel4TextStyle = newValue}
  }
  /// Returns true if `categoryLevel4TextStyle` has been explicitly set.
  var hasCategoryLevel4TextStyle: Bool {return _storage._categoryLevel4TextStyle != nil}
  /// Clears the value of `categoryLevel4TextStyle`. Subsequent reads from it will return its default value.
  mutating func clearCategoryLevel4TextStyle() {_uniqueStorage()._categoryLevel4TextStyle = nil}

  var categoryLevel5TextStyle: TSP_Reference {
    get {return _storage._categoryLevel5TextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._categoryLevel5TextStyle = newValue}
  }
  /// Returns true if `categoryLevel5TextStyle` has been explicitly set.
  var hasCategoryLevel5TextStyle: Bool {return _storage._categoryLevel5TextStyle != nil}
  /// Clears the value of `categoryLevel5TextStyle`. Subsequent reads from it will return its default value.
  mutating func clearCategoryLevel5TextStyle() {_uniqueStorage()._categoryLevel5TextStyle = nil}

  var categoryLevel1Style: TSP_Reference {
    get {return _storage._categoryLevel1Style ?? TSP_Reference()}
    set {_uniqueStorage()._categoryLevel1Style = newValue}
  }
  /// Returns true if `categoryLevel1Style` has been explicitly set.
  var hasCategoryLevel1Style: Bool {return _storage._categoryLevel1Style != nil}
  /// Clears the value of `categoryLevel1Style`. Subsequent reads from it will return its default value.
  mutating func clearCategoryLevel1Style() {_uniqueStorage()._categoryLevel1Style = nil}

  var categoryLevel2Style: TSP_Reference {
    get {return _storage._categoryLevel2Style ?? TSP_Reference()}
    set {_uniqueStorage()._categoryLevel2Style = newValue}
  }
  /// Returns true if `categoryLevel2Style` has been explicitly set.
  var hasCategoryLevel2Style: Bool {return _storage._categoryLevel2Style != nil}
  /// Clears the value of `categoryLevel2Style`. Subsequent reads from it will return its default value.
  mutating func clearCategoryLevel2Style() {_uniqueStorage()._categoryLevel2Style = nil}

  var categoryLevel3Style: TSP_Reference {
    get {return _storage._categoryLevel3Style ?? TSP_Reference()}
    set {_uniqueStorage()._categoryLevel3Style = newValue}
  }
  /// Returns true if `categoryLevel3Style` has been explicitly set.
  var hasCategoryLevel3Style: Bool {return _storage._categoryLevel3Style != nil}
  /// Clears the value of `categoryLevel3Style`. Subsequent reads from it will return its default value.
  mutating func clearCategoryLevel3Style() {_uniqueStorage()._categoryLevel3Style = nil}

  var categoryLevel4Style: TSP_Reference {
    get {return _storage._categoryLevel4Style ?? TSP_Reference()}
    set {_uniqueStorage()._categoryLevel4Style = newValue}
  }
  /// Returns true if `categoryLevel4Style` has been explicitly set.
  var hasCategoryLevel4Style: Bool {return _storage._categoryLevel4Style != nil}
  /// Clears the value of `categoryLevel4Style`. Subsequent reads from it will return its default value.
  mutating func clearCategoryLevel4Style() {_uniqueStorage()._categoryLevel4Style = nil}

  var categoryLevel5Style: TSP_Reference {
    get {return _storage._categoryLevel5Style ?? TSP_Reference()}
    set {_uniqueStorage()._categoryLevel5Style = newValue}
  }
  /// Returns true if `categoryLevel5Style` has been explicitly set.
  var hasCategoryLevel5Style: Bool {return _storage._categoryLevel5Style != nil}
  /// Clears the value of `categoryLevel5Style`. Subsequent reads from it will return its default value.
  mutating func clearCategoryLevel5Style() {_uniqueStorage()._categoryLevel5Style = nil}

  var labelLevel1TextStyle: TSP_Reference {
    get {return _storage._labelLevel1TextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._labelLevel1TextStyle = newValue}
  }
  /// Returns true if `labelLevel1TextStyle` has been explicitly set.
  var hasLabelLevel1TextStyle: Bool {return _storage._labelLevel1TextStyle != nil}
  /// Clears the value of `labelLevel1TextStyle`. Subsequent reads from it will return its default value.
  mutating func clearLabelLevel1TextStyle() {_uniqueStorage()._labelLevel1TextStyle = nil}

  var labelLevel2TextStyle: TSP_Reference {
    get {return _storage._labelLevel2TextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._labelLevel2TextStyle = newValue}
  }
  /// Returns true if `labelLevel2TextStyle` has been explicitly set.
  var hasLabelLevel2TextStyle: Bool {return _storage._labelLevel2TextStyle != nil}
  /// Clears the value of `labelLevel2TextStyle`. Subsequent reads from it will return its default value.
  mutating func clearLabelLevel2TextStyle() {_uniqueStorage()._labelLevel2TextStyle = nil}

  var labelLevel3TextStyle: TSP_Reference {
    get {return _storage._labelLevel3TextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._labelLevel3TextStyle = newValue}
  }
  /// Returns true if `labelLevel3TextStyle` has been explicitly set.
  var hasLabelLevel3TextStyle: Bool {return _storage._labelLevel3TextStyle != nil}
  /// Clears the value of `labelLevel3TextStyle`. Subsequent reads from it will return its default value.
  mutating func clearLabelLevel3TextStyle() {_uniqueStorage()._labelLevel3TextStyle = nil}

  var labelLevel4TextStyle: TSP_Reference {
    get {return _storage._labelLevel4TextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._labelLevel4TextStyle = newValue}
  }
  /// Returns true if `labelLevel4TextStyle` has been explicitly set.
  var hasLabelLevel4TextStyle: Bool {return _storage._labelLevel4TextStyle != nil}
  /// Clears the value of `labelLevel4TextStyle`. Subsequent reads from it will return its default value.
  mutating func clearLabelLevel4TextStyle() {_uniqueStorage()._labelLevel4TextStyle = nil}

  var labelLevel5TextStyle: TSP_Reference {
    get {return _storage._labelLevel5TextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._labelLevel5TextStyle = newValue}
  }
  /// Returns true if `labelLevel5TextStyle` has been explicitly set.
  var hasLabelLevel5TextStyle: Bool {return _storage._labelLevel5TextStyle != nil}
  /// Clears the value of `labelLevel5TextStyle`. Subsequent reads from it will return its default value.
  mutating func clearLabelLevel5TextStyle() {_uniqueStorage()._labelLevel5TextStyle = nil}

  var labelLevel1Style: TSP_Reference {
    get {return _storage._labelLevel1Style ?? TSP_Reference()}
    set {_uniqueStorage()._labelLevel1Style = newValue}
  }
  /// Returns true if `labelLevel1Style` has been explicitly set.
  var hasLabelLevel1Style: Bool {return _storage._labelLevel1Style != nil}
  /// Clears the value of `labelLevel1Style`. Subsequent reads from it will return its default value.
  mutating func clearLabelLevel1Style() {_uniqueStorage()._labelLevel1Style = nil}

  var labelLevel2Style: TSP_Reference {
    get {return _storage._labelLevel2Style ?? TSP_Reference()}
    set {_uniqueStorage()._labelLevel2Style = newValue}
  }
  /// Returns true if `labelLevel2Style` has been explicitly set.
  var hasLabelLevel2Style: Bool {return _storage._labelLevel2Style != nil}
  /// Clears the value of `labelLevel2Style`. Subsequent reads from it will return its default value.
  mutating func clearLabelLevel2Style() {_uniqueStorage()._labelLevel2Style = nil}

  var labelLevel3Style: TSP_Reference {
    get {return _storage._labelLevel3Style ?? TSP_Reference()}
    set {_uniqueStorage()._labelLevel3Style = newValue}
  }
  /// Returns true if `labelLevel3Style` has been explicitly set.
  var hasLabelLevel3Style: Bool {return _storage._labelLevel3Style != nil}
  /// Clears the value of `labelLevel3Style`. Subsequent reads from it will return its default value.
  mutating func clearLabelLevel3Style() {_uniqueStorage()._labelLevel3Style = nil}

  var labelLevel4Style: TSP_Reference {
    get {return _storage._labelLevel4Style ?? TSP_Reference()}
    set {_uniqueStorage()._labelLevel4Style = newValue}
  }
  /// Returns true if `labelLevel4Style` has been explicitly set.
  var hasLabelLevel4Style: Bool {return _storage._labelLevel4Style != nil}
  /// Clears the value of `labelLevel4Style`. Subsequent reads from it will return its default value.
  mutating func clearLabelLevel4Style() {_uniqueStorage()._labelLevel4Style = nil}

  var labelLevel5Style: TSP_Reference {
    get {return _storage._labelLevel5Style ?? TSP_Reference()}
    set {_uniqueStorage()._labelLevel5Style = newValue}
  }
  /// Returns true if `labelLevel5Style` has been explicitly set.
  var hasLabelLevel5Style: Bool {return _storage._labelLevel5Style != nil}
  /// Clears the value of `labelLevel5Style`. Subsequent reads from it will return its default value.
  mutating func clearLabelLevel5Style() {_uniqueStorage()._labelLevel5Style = nil}

  var pivotBodySummaryRowStyle: TSP_Reference {
    get {return _storage._pivotBodySummaryRowStyle ?? TSP_Reference()}
    set {_uniqueStorage()._pivotBodySummaryRowStyle = newValue}
  }
  /// Returns true if `pivotBodySummaryRowStyle` has been explicitly set.
  var hasPivotBodySummaryRowStyle: Bool {return _storage._pivotBodySummaryRowStyle != nil}
  /// Clears the value of `pivotBodySummaryRowStyle`. Subsequent reads from it will return its default value.
  mutating func clearPivotBodySummaryRowStyle() {_uniqueStorage()._pivotBodySummaryRowStyle = nil}

  var pivotBodySummaryColumnStyle: TSP_Reference {
    get {return _storage._pivotBodySummaryColumnStyle ?? TSP_Reference()}
    set {_uniqueStorage()._pivotBodySummaryColumnStyle = newValue}
  }
  /// Returns true if `pivotBodySummaryColumnStyle` has been explicitly set.
  var hasPivotBodySummaryColumnStyle: Bool {return _storage._pivotBodySummaryColumnStyle != nil}
  /// Clears the value of `pivotBodySummaryColumnStyle`. Subsequent reads from it will return its default value.
  mutating func clearPivotBodySummaryColumnStyle() {_uniqueStorage()._pivotBodySummaryColumnStyle = nil}

  var pivotHeaderColumnSummaryStyle: TSP_Reference {
    get {return _storage._pivotHeaderColumnSummaryStyle ?? TSP_Reference()}
    set {_uniqueStorage()._pivotHeaderColumnSummaryStyle = newValue}
  }
  /// Returns true if `pivotHeaderColumnSummaryStyle` has been explicitly set.
  var hasPivotHeaderColumnSummaryStyle: Bool {return _storage._pivotHeaderColumnSummaryStyle != nil}
  /// Clears the value of `pivotHeaderColumnSummaryStyle`. Subsequent reads from it will return its default value.
  mutating func clearPivotHeaderColumnSummaryStyle() {_uniqueStorage()._pivotHeaderColumnSummaryStyle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_TableGroupSortOrderUIDArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groupSortRules: [TST_TableGroupSortOrderUIDArchive.GroupSortRuleUIDArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct GroupSortRuleUIDArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var groupingColumnUid: TSP_UUID {
      get {return _groupingColumnUid ?? TSP_UUID()}
      set {_groupingColumnUid = newValue}
    }
    /// Returns true if `groupingColumnUid` has been explicitly set.
    var hasGroupingColumnUid: Bool {return self._groupingColumnUid != nil}
    /// Clears the value of `groupingColumnUid`. Subsequent reads from it will return its default value.
    mutating func clearGroupingColumnUid() {self._groupingColumnUid = nil}

    var columnUid: TSP_UUID {
      get {return _columnUid ?? TSP_UUID()}
      set {_columnUid = newValue}
    }
    /// Returns true if `columnUid` has been explicitly set.
    var hasColumnUid: Bool {return self._columnUid != nil}
    /// Clears the value of `columnUid`. Subsequent reads from it will return its default value.
    mutating func clearColumnUid() {self._columnUid = nil}

    var direction: TST_TableGroupSortOrderUIDArchive.GroupSortRuleUIDArchive.Direction {
      get {return _direction ?? .ascending}
      set {_direction = newValue}
    }
    /// Returns true if `direction` has been explicitly set.
    var hasDirection: Bool {return self._direction != nil}
    /// Clears the value of `direction`. Subsequent reads from it will return its default value.
    mutating func clearDirection() {self._direction = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Direction: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case ascending = 0
      case descending = 1

      init() {
        self = .ascending
      }

    }

    init() {}

    fileprivate var _groupingColumnUid: TSP_UUID? = nil
    fileprivate var _columnUid: TSP_UUID? = nil
    fileprivate var _direction: TST_TableGroupSortOrderUIDArchive.GroupSortRuleUIDArchive.Direction? = nil
  }

  init() {}
}

struct TST_TableSortOrderArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: TST_TableSortOrderArchive.SortType {
    get {return _type ?? .entireTable}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var rules: [TST_TableSortOrderArchive.SortRuleArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum SortType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case entireTable = 0
    case rowRange = 1

    init() {
      self = .entireTable
    }

  }

  struct SortRuleArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var index: UInt32 {
      get {return _index ?? 0}
      set {_index = newValue}
    }
    /// Returns true if `index` has been explicitly set.
    var hasIndex: Bool {return self._index != nil}
    /// Clears the value of `index`. Subsequent reads from it will return its default value.
    mutating func clearIndex() {self._index = nil}

    var direction: TST_TableSortOrderArchive.SortRuleArchive.Direction {
      get {return _direction ?? .ascending}
      set {_direction = newValue}
    }
    /// Returns true if `direction` has been explicitly set.
    var hasDirection: Bool {return self._direction != nil}
    /// Clears the value of `direction`. Subsequent reads from it will return its default value.
    mutating func clearDirection() {self._direction = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Direction: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case ascending = 0
      case descending = 1

      init() {
        self = .ascending
      }

    }

    init() {}

    fileprivate var _index: UInt32? = nil
    fileprivate var _direction: TST_TableSortOrderArchive.SortRuleArchive.Direction? = nil
  }

  init() {}

  fileprivate var _type: TST_TableSortOrderArchive.SortType? = nil
}

struct TST_TableSortOrderUIDArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: TST_TableSortOrderUIDArchive.SortType {
    get {return _type ?? .entireTable}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var rules: [TST_TableSortOrderUIDArchive.SortRuleArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum SortType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case entireTable = 0
    case rowRange = 1

    init() {
      self = .entireTable
    }

  }

  struct SortRuleArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var columnUid: TSP_UUID {
      get {return _columnUid ?? TSP_UUID()}
      set {_columnUid = newValue}
    }
    /// Returns true if `columnUid` has been explicitly set.
    var hasColumnUid: Bool {return self._columnUid != nil}
    /// Clears the value of `columnUid`. Subsequent reads from it will return its default value.
    mutating func clearColumnUid() {self._columnUid = nil}

    var direction: TST_TableSortOrderUIDArchive.SortRuleArchive.Direction {
      get {return _direction ?? .ascending}
      set {_direction = newValue}
    }
    /// Returns true if `direction` has been explicitly set.
    var hasDirection: Bool {return self._direction != nil}
    /// Clears the value of `direction`. Subsequent reads from it will return its default value.
    mutating func clearDirection() {self._direction = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Direction: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case ascending = 0
      case descending = 1

      init() {
        self = .ascending
      }

    }

    init() {}

    fileprivate var _columnUid: TSP_UUID? = nil
    fileprivate var _direction: TST_TableSortOrderUIDArchive.SortRuleArchive.Direction? = nil
  }

  init() {}

  fileprivate var _type: TST_TableSortOrderUIDArchive.SortType? = nil
}

struct TST_SortRuleReferenceTrackerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var referenceTracker: TSP_Reference {
    get {return _referenceTracker ?? TSP_Reference()}
    set {_referenceTracker = newValue}
  }
  /// Returns true if `referenceTracker` has been explicitly set.
  var hasReferenceTracker: Bool {return self._referenceTracker != nil}
  /// Clears the value of `referenceTracker`. Subsequent reads from it will return its default value.
  mutating func clearReferenceTracker() {self._referenceTracker = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _referenceTracker: TSP_Reference? = nil
}

struct TST_CellRegion: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cellRanges: [TST_CellRange] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TST_CellUIDRegionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cellUidRanges: [TSP_UUIDRectArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TST_StructuredTextImportRecord: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var importSettings: TSK_StructuredTextImportSettings {
    get {return _storage._importSettings ?? TSK_StructuredTextImportSettings()}
    set {_uniqueStorage()._importSettings = newValue}
  }
  /// Returns true if `importSettings` has been explicitly set.
  var hasImportSettings: Bool {return _storage._importSettings != nil}
  /// Clears the value of `importSettings`. Subsequent reads from it will return its default value.
  mutating func clearImportSettings() {_uniqueStorage()._importSettings = nil}

  var importSource: String {
    get {return _storage._importSource ?? String()}
    set {_uniqueStorage()._importSource = newValue}
  }
  /// Returns true if `importSource` has been explicitly set.
  var hasImportSource: Bool {return _storage._importSource != nil}
  /// Clears the value of `importSource`. Subsequent reads from it will return its default value.
  mutating func clearImportSource() {_uniqueStorage()._importSource = nil}

  var importDate: Double {
    get {return _storage._importDate ?? 0}
    set {_uniqueStorage()._importDate = newValue}
  }
  /// Returns true if `importDate` has been explicitly set.
  var hasImportDate: Bool {return _storage._importDate != nil}
  /// Clears the value of `importDate`. Subsequent reads from it will return its default value.
  mutating func clearImportDate() {_uniqueStorage()._importDate = nil}

  var sourceData: Data {
    get {return _storage._sourceData ?? Data()}
    set {_uniqueStorage()._sourceData = newValue}
  }
  /// Returns true if `sourceData` has been explicitly set.
  var hasSourceData: Bool {return _storage._sourceData != nil}
  /// Clears the value of `sourceData`. Subsequent reads from it will return its default value.
  mutating func clearSourceData() {_uniqueStorage()._sourceData = nil}

  var sourceEncoding: UInt64 {
    get {return _storage._sourceEncoding ?? 0}
    set {_uniqueStorage()._sourceEncoding = newValue}
  }
  /// Returns true if `sourceEncoding` has been explicitly set.
  var hasSourceEncoding: Bool {return _storage._sourceEncoding != nil}
  /// Clears the value of `sourceEncoding`. Subsequent reads from it will return its default value.
  mutating func clearSourceEncoding() {_uniqueStorage()._sourceEncoding = nil}

  var confidence: Float {
    get {return _storage._confidence ?? 0}
    set {_uniqueStorage()._confidence = newValue}
  }
  /// Returns true if `confidence` has been explicitly set.
  var hasConfidence: Bool {return _storage._confidence != nil}
  /// Clears the value of `confidence`. Subsequent reads from it will return its default value.
  mutating func clearConfidence() {_uniqueStorage()._confidence = nil}

  var importedRegion: TST_CellRegion {
    get {return _storage._importedRegion ?? TST_CellRegion()}
    set {_uniqueStorage()._importedRegion = newValue}
  }
  /// Returns true if `importedRegion` has been explicitly set.
  var hasImportedRegion: Bool {return _storage._importedRegion != nil}
  /// Clears the value of `importedRegion`. Subsequent reads from it will return its default value.
  mutating func clearImportedRegion() {_uniqueStorage()._importedRegion = nil}

  var sourceRowCount: UInt64 {
    get {return _storage._sourceRowCount ?? 0}
    set {_uniqueStorage()._sourceRowCount = newValue}
  }
  /// Returns true if `sourceRowCount` has been explicitly set.
  var hasSourceRowCount: Bool {return _storage._sourceRowCount != nil}
  /// Clears the value of `sourceRowCount`. Subsequent reads from it will return its default value.
  mutating func clearSourceRowCount() {_uniqueStorage()._sourceRowCount = nil}

  var sourceColumnCount: UInt64 {
    get {return _storage._sourceColumnCount ?? 0}
    set {_uniqueStorage()._sourceColumnCount = newValue}
  }
  /// Returns true if `sourceColumnCount` has been explicitly set.
  var hasSourceColumnCount: Bool {return _storage._sourceColumnCount != nil}
  /// Clears the value of `sourceColumnCount`. Subsequent reads from it will return its default value.
  mutating func clearSourceColumnCount() {_uniqueStorage()._sourceColumnCount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_TableModelArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tableID: String {
    get {return _storage._tableID ?? String()}
    set {_uniqueStorage()._tableID = newValue}
  }
  /// Returns true if `tableID` has been explicitly set.
  var hasTableID: Bool {return _storage._tableID != nil}
  /// Clears the value of `tableID`. Subsequent reads from it will return its default value.
  mutating func clearTableID() {_uniqueStorage()._tableID = nil}

  var fromTableID: String {
    get {return _storage._fromTableID ?? String()}
    set {_uniqueStorage()._fromTableID = newValue}
  }
  /// Returns true if `fromTableID` has been explicitly set.
  var hasFromTableID: Bool {return _storage._fromTableID != nil}
  /// Clears the value of `fromTableID`. Subsequent reads from it will return its default value.
  mutating func clearFromTableID() {_uniqueStorage()._fromTableID = nil}

  var wasCut: Bool {
    get {return _storage._wasCut ?? false}
    set {_uniqueStorage()._wasCut = newValue}
  }
  /// Returns true if `wasCut` has been explicitly set.
  var hasWasCut: Bool {return _storage._wasCut != nil}
  /// Clears the value of `wasCut`. Subsequent reads from it will return its default value.
  mutating func clearWasCut() {_uniqueStorage()._wasCut = nil}

  var tableStyle: TSP_Reference {
    get {return _storage._tableStyle ?? TSP_Reference()}
    set {_uniqueStorage()._tableStyle = newValue}
  }
  /// Returns true if `tableStyle` has been explicitly set.
  var hasTableStyle: Bool {return _storage._tableStyle != nil}
  /// Clears the value of `tableStyle`. Subsequent reads from it will return its default value.
  mutating func clearTableStyle() {_uniqueStorage()._tableStyle = nil}

  var bodyTextStyle: TSP_Reference {
    get {return _storage._bodyTextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._bodyTextStyle = newValue}
  }
  /// Returns true if `bodyTextStyle` has been explicitly set.
  var hasBodyTextStyle: Bool {return _storage._bodyTextStyle != nil}
  /// Clears the value of `bodyTextStyle`. Subsequent reads from it will return its default value.
  mutating func clearBodyTextStyle() {_uniqueStorage()._bodyTextStyle = nil}

  var headerRowTextStyle: TSP_Reference {
    get {return _storage._headerRowTextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._headerRowTextStyle = newValue}
  }
  /// Returns true if `headerRowTextStyle` has been explicitly set.
  var hasHeaderRowTextStyle: Bool {return _storage._headerRowTextStyle != nil}
  /// Clears the value of `headerRowTextStyle`. Subsequent reads from it will return its default value.
  mutating func clearHeaderRowTextStyle() {_uniqueStorage()._headerRowTextStyle = nil}

  var headerColumnTextStyle: TSP_Reference {
    get {return _storage._headerColumnTextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._headerColumnTextStyle = newValue}
  }
  /// Returns true if `headerColumnTextStyle` has been explicitly set.
  var hasHeaderColumnTextStyle: Bool {return _storage._headerColumnTextStyle != nil}
  /// Clears the value of `headerColumnTextStyle`. Subsequent reads from it will return its default value.
  mutating func clearHeaderColumnTextStyle() {_uniqueStorage()._headerColumnTextStyle = nil}

  var footerRowTextStyle: TSP_Reference {
    get {return _storage._footerRowTextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._footerRowTextStyle = newValue}
  }
  /// Returns true if `footerRowTextStyle` has been explicitly set.
  var hasFooterRowTextStyle: Bool {return _storage._footerRowTextStyle != nil}
  /// Clears the value of `footerRowTextStyle`. Subsequent reads from it will return its default value.
  mutating func clearFooterRowTextStyle() {_uniqueStorage()._footerRowTextStyle = nil}

  var bodyCellStyle: TSP_Reference {
    get {return _storage._bodyCellStyle ?? TSP_Reference()}
    set {_uniqueStorage()._bodyCellStyle = newValue}
  }
  /// Returns true if `bodyCellStyle` has been explicitly set.
  var hasBodyCellStyle: Bool {return _storage._bodyCellStyle != nil}
  /// Clears the value of `bodyCellStyle`. Subsequent reads from it will return its default value.
  mutating func clearBodyCellStyle() {_uniqueStorage()._bodyCellStyle = nil}

  var headerRowStyle: TSP_Reference {
    get {return _storage._headerRowStyle ?? TSP_Reference()}
    set {_uniqueStorage()._headerRowStyle = newValue}
  }
  /// Returns true if `headerRowStyle` has been explicitly set.
  var hasHeaderRowStyle: Bool {return _storage._headerRowStyle != nil}
  /// Clears the value of `headerRowStyle`. Subsequent reads from it will return its default value.
  mutating func clearHeaderRowStyle() {_uniqueStorage()._headerRowStyle = nil}

  var headerColumnStyle: TSP_Reference {
    get {return _storage._headerColumnStyle ?? TSP_Reference()}
    set {_uniqueStorage()._headerColumnStyle = newValue}
  }
  /// Returns true if `headerColumnStyle` has been explicitly set.
  var hasHeaderColumnStyle: Bool {return _storage._headerColumnStyle != nil}
  /// Clears the value of `headerColumnStyle`. Subsequent reads from it will return its default value.
  mutating func clearHeaderColumnStyle() {_uniqueStorage()._headerColumnStyle = nil}

  var footerRowStyle: TSP_Reference {
    get {return _storage._footerRowStyle ?? TSP_Reference()}
    set {_uniqueStorage()._footerRowStyle = newValue}
  }
  /// Returns true if `footerRowStyle` has been explicitly set.
  var hasFooterRowStyle: Bool {return _storage._footerRowStyle != nil}
  /// Clears the value of `footerRowStyle`. Subsequent reads from it will return its default value.
  mutating func clearFooterRowStyle() {_uniqueStorage()._footerRowStyle = nil}

  var tableNameStyle: TSP_Reference {
    get {return _storage._tableNameStyle ?? TSP_Reference()}
    set {_uniqueStorage()._tableNameStyle = newValue}
  }
  /// Returns true if `tableNameStyle` has been explicitly set.
  var hasTableNameStyle: Bool {return _storage._tableNameStyle != nil}
  /// Clears the value of `tableNameStyle`. Subsequent reads from it will return its default value.
  mutating func clearTableNameStyle() {_uniqueStorage()._tableNameStyle = nil}

  var tableNameShapeStyle: TSP_Reference {
    get {return _storage._tableNameShapeStyle ?? TSP_Reference()}
    set {_uniqueStorage()._tableNameShapeStyle = newValue}
  }
  /// Returns true if `tableNameShapeStyle` has been explicitly set.
  var hasTableNameShapeStyle: Bool {return _storage._tableNameShapeStyle != nil}
  /// Clears the value of `tableNameShapeStyle`. Subsequent reads from it will return its default value.
  mutating func clearTableNameShapeStyle() {_uniqueStorage()._tableNameShapeStyle = nil}

  var tableStylePreset: TSP_Reference {
    get {return _storage._tableStylePreset ?? TSP_Reference()}
    set {_uniqueStorage()._tableStylePreset = newValue}
  }
  /// Returns true if `tableStylePreset` has been explicitly set.
  var hasTableStylePreset: Bool {return _storage._tableStylePreset != nil}
  /// Clears the value of `tableStylePreset`. Subsequent reads from it will return its default value.
  mutating func clearTableStylePreset() {_uniqueStorage()._tableStylePreset = nil}

  var presetIndex: UInt32 {
    get {return _storage._presetIndex ?? 0}
    set {_uniqueStorage()._presetIndex = newValue}
  }
  /// Returns true if `presetIndex` has been explicitly set.
  var hasPresetIndex: Bool {return _storage._presetIndex != nil}
  /// Clears the value of `presetIndex`. Subsequent reads from it will return its default value.
  mutating func clearPresetIndex() {_uniqueStorage()._presetIndex = nil}

  var baseDataStore: TST_DataStore {
    get {return _storage._baseDataStore ?? TST_DataStore()}
    set {_uniqueStorage()._baseDataStore = newValue}
  }
  /// Returns true if `baseDataStore` has been explicitly set.
  var hasBaseDataStore: Bool {return _storage._baseDataStore != nil}
  /// Clears the value of `baseDataStore`. Subsequent reads from it will return its default value.
  mutating func clearBaseDataStore() {_uniqueStorage()._baseDataStore = nil}

  var provider: TSP_Reference {
    get {return _storage._provider ?? TSP_Reference()}
    set {_uniqueStorage()._provider = newValue}
  }
  /// Returns true if `provider` has been explicitly set.
  var hasProvider: Bool {return _storage._provider != nil}
  /// Clears the value of `provider`. Subsequent reads from it will return its default value.
  mutating func clearProvider() {_uniqueStorage()._provider = nil}

  var numberOfRows: UInt32 {
    get {return _storage._numberOfRows ?? 0}
    set {_uniqueStorage()._numberOfRows = newValue}
  }
  /// Returns true if `numberOfRows` has been explicitly set.
  var hasNumberOfRows: Bool {return _storage._numberOfRows != nil}
  /// Clears the value of `numberOfRows`. Subsequent reads from it will return its default value.
  mutating func clearNumberOfRows() {_uniqueStorage()._numberOfRows = nil}

  var numberOfColumns: UInt32 {
    get {return _storage._numberOfColumns ?? 0}
    set {_uniqueStorage()._numberOfColumns = newValue}
  }
  /// Returns true if `numberOfColumns` has been explicitly set.
  var hasNumberOfColumns: Bool {return _storage._numberOfColumns != nil}
  /// Clears the value of `numberOfColumns`. Subsequent reads from it will return its default value.
  mutating func clearNumberOfColumns() {_uniqueStorage()._numberOfColumns = nil}

  var tableName: String {
    get {return _storage._tableName ?? String()}
    set {_uniqueStorage()._tableName = newValue}
  }
  /// Returns true if `tableName` has been explicitly set.
  var hasTableName: Bool {return _storage._tableName != nil}
  /// Clears the value of `tableName`. Subsequent reads from it will return its default value.
  mutating func clearTableName() {_uniqueStorage()._tableName = nil}

  var tableNameEnabled: Bool {
    get {return _storage._tableNameEnabled ?? false}
    set {_uniqueStorage()._tableNameEnabled = newValue}
  }
  /// Returns true if `tableNameEnabled` has been explicitly set.
  var hasTableNameEnabled: Bool {return _storage._tableNameEnabled != nil}
  /// Clears the value of `tableNameEnabled`. Subsequent reads from it will return its default value.
  mutating func clearTableNameEnabled() {_uniqueStorage()._tableNameEnabled = nil}

  var tableNameHeight: Double {
    get {return _storage._tableNameHeight ?? 0}
    set {_uniqueStorage()._tableNameHeight = newValue}
  }
  /// Returns true if `tableNameHeight` has been explicitly set.
  var hasTableNameHeight: Bool {return _storage._tableNameHeight != nil}
  /// Clears the value of `tableNameHeight`. Subsequent reads from it will return its default value.
  mutating func clearTableNameHeight() {_uniqueStorage()._tableNameHeight = nil}

  var tableNameBorderEnabled: Bool {
    get {return _storage._tableNameBorderEnabled ?? false}
    set {_uniqueStorage()._tableNameBorderEnabled = newValue}
  }
  /// Returns true if `tableNameBorderEnabled` has been explicitly set.
  var hasTableNameBorderEnabled: Bool {return _storage._tableNameBorderEnabled != nil}
  /// Clears the value of `tableNameBorderEnabled`. Subsequent reads from it will return its default value.
  mutating func clearTableNameBorderEnabled() {_uniqueStorage()._tableNameBorderEnabled = nil}

  var numberOfHeaderRows: UInt32 {
    get {return _storage._numberOfHeaderRows ?? 0}
    set {_uniqueStorage()._numberOfHeaderRows = newValue}
  }
  /// Returns true if `numberOfHeaderRows` has been explicitly set.
  var hasNumberOfHeaderRows: Bool {return _storage._numberOfHeaderRows != nil}
  /// Clears the value of `numberOfHeaderRows`. Subsequent reads from it will return its default value.
  mutating func clearNumberOfHeaderRows() {_uniqueStorage()._numberOfHeaderRows = nil}

  var numberOfHeaderColumns: UInt32 {
    get {return _storage._numberOfHeaderColumns ?? 0}
    set {_uniqueStorage()._numberOfHeaderColumns = newValue}
  }
  /// Returns true if `numberOfHeaderColumns` has been explicitly set.
  var hasNumberOfHeaderColumns: Bool {return _storage._numberOfHeaderColumns != nil}
  /// Clears the value of `numberOfHeaderColumns`. Subsequent reads from it will return its default value.
  mutating func clearNumberOfHeaderColumns() {_uniqueStorage()._numberOfHeaderColumns = nil}

  var numberOfFooterRows: UInt32 {
    get {return _storage._numberOfFooterRows ?? 0}
    set {_uniqueStorage()._numberOfFooterRows = newValue}
  }
  /// Returns true if `numberOfFooterRows` has been explicitly set.
  var hasNumberOfFooterRows: Bool {return _storage._numberOfFooterRows != nil}
  /// Clears the value of `numberOfFooterRows`. Subsequent reads from it will return its default value.
  mutating func clearNumberOfFooterRows() {_uniqueStorage()._numberOfFooterRows = nil}

  var headerRowsFrozen: Bool {
    get {return _storage._headerRowsFrozen ?? false}
    set {_uniqueStorage()._headerRowsFrozen = newValue}
  }
  /// Returns true if `headerRowsFrozen` has been explicitly set.
  var hasHeaderRowsFrozen: Bool {return _storage._headerRowsFrozen != nil}
  /// Clears the value of `headerRowsFrozen`. Subsequent reads from it will return its default value.
  mutating func clearHeaderRowsFrozen() {_uniqueStorage()._headerRowsFrozen = nil}

  var headerColumnsFrozen: Bool {
    get {return _storage._headerColumnsFrozen ?? false}
    set {_uniqueStorage()._headerColumnsFrozen = newValue}
  }
  /// Returns true if `headerColumnsFrozen` has been explicitly set.
  var hasHeaderColumnsFrozen: Bool {return _storage._headerColumnsFrozen != nil}
  /// Clears the value of `headerColumnsFrozen`. Subsequent reads from it will return its default value.
  mutating func clearHeaderColumnsFrozen() {_uniqueStorage()._headerColumnsFrozen = nil}

  var numberOfHiddenRows: UInt32 {
    get {return _storage._numberOfHiddenRows ?? 0}
    set {_uniqueStorage()._numberOfHiddenRows = newValue}
  }
  /// Returns true if `numberOfHiddenRows` has been explicitly set.
  var hasNumberOfHiddenRows: Bool {return _storage._numberOfHiddenRows != nil}
  /// Clears the value of `numberOfHiddenRows`. Subsequent reads from it will return its default value.
  mutating func clearNumberOfHiddenRows() {_uniqueStorage()._numberOfHiddenRows = nil}

  var numberOfHiddenColumns: UInt32 {
    get {return _storage._numberOfHiddenColumns ?? 0}
    set {_uniqueStorage()._numberOfHiddenColumns = newValue}
  }
  /// Returns true if `numberOfHiddenColumns` has been explicitly set.
  var hasNumberOfHiddenColumns: Bool {return _storage._numberOfHiddenColumns != nil}
  /// Clears the value of `numberOfHiddenColumns`. Subsequent reads from it will return its default value.
  mutating func clearNumberOfHiddenColumns() {_uniqueStorage()._numberOfHiddenColumns = nil}

  var numberOfUserHiddenRows: UInt32 {
    get {return _storage._numberOfUserHiddenRows ?? 0}
    set {_uniqueStorage()._numberOfUserHiddenRows = newValue}
  }
  /// Returns true if `numberOfUserHiddenRows` has been explicitly set.
  var hasNumberOfUserHiddenRows: Bool {return _storage._numberOfUserHiddenRows != nil}
  /// Clears the value of `numberOfUserHiddenRows`. Subsequent reads from it will return its default value.
  mutating func clearNumberOfUserHiddenRows() {_uniqueStorage()._numberOfUserHiddenRows = nil}

  var numberOfUserHiddenColumns: UInt32 {
    get {return _storage._numberOfUserHiddenColumns ?? 0}
    set {_uniqueStorage()._numberOfUserHiddenColumns = newValue}
  }
  /// Returns true if `numberOfUserHiddenColumns` has been explicitly set.
  var hasNumberOfUserHiddenColumns: Bool {return _storage._numberOfUserHiddenColumns != nil}
  /// Clears the value of `numberOfUserHiddenColumns`. Subsequent reads from it will return its default value.
  mutating func clearNumberOfUserHiddenColumns() {_uniqueStorage()._numberOfUserHiddenColumns = nil}

  var numberOfFilteredRows: UInt32 {
    get {return _storage._numberOfFilteredRows ?? 0}
    set {_uniqueStorage()._numberOfFilteredRows = newValue}
  }
  /// Returns true if `numberOfFilteredRows` has been explicitly set.
  var hasNumberOfFilteredRows: Bool {return _storage._numberOfFilteredRows != nil}
  /// Clears the value of `numberOfFilteredRows`. Subsequent reads from it will return its default value.
  mutating func clearNumberOfFilteredRows() {_uniqueStorage()._numberOfFilteredRows = nil}

  var defaultRowHeight: Double {
    get {return _storage._defaultRowHeight ?? 0}
    set {_uniqueStorage()._defaultRowHeight = newValue}
  }
  /// Returns true if `defaultRowHeight` has been explicitly set.
  var hasDefaultRowHeight: Bool {return _storage._defaultRowHeight != nil}
  /// Clears the value of `defaultRowHeight`. Subsequent reads from it will return its default value.
  mutating func clearDefaultRowHeight() {_uniqueStorage()._defaultRowHeight = nil}

  var defaultColumnWidth: Double {
    get {return _storage._defaultColumnWidth ?? 0}
    set {_uniqueStorage()._defaultColumnWidth = newValue}
  }
  /// Returns true if `defaultColumnWidth` has been explicitly set.
  var hasDefaultColumnWidth: Bool {return _storage._defaultColumnWidth != nil}
  /// Clears the value of `defaultColumnWidth`. Subsequent reads from it will return its default value.
  mutating func clearDefaultColumnWidth() {_uniqueStorage()._defaultColumnWidth = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var originOffset: TST_CellID {
    get {return _storage._originOffset ?? TST_CellID()}
    set {_uniqueStorage()._originOffset = newValue}
  }
  /// Returns true if `originOffset` has been explicitly set.
  var hasOriginOffset: Bool {return _storage._originOffset != nil}
  /// Clears the value of `originOffset`. Subsequent reads from it will return its default value.
  mutating func clearOriginOffset() {_uniqueStorage()._originOffset = nil}

  var repeatingHeaderRowsEnabled: Bool {
    get {return _storage._repeatingHeaderRowsEnabled ?? false}
    set {_uniqueStorage()._repeatingHeaderRowsEnabled = newValue}
  }
  /// Returns true if `repeatingHeaderRowsEnabled` has been explicitly set.
  var hasRepeatingHeaderRowsEnabled: Bool {return _storage._repeatingHeaderRowsEnabled != nil}
  /// Clears the value of `repeatingHeaderRowsEnabled`. Subsequent reads from it will return its default value.
  mutating func clearRepeatingHeaderRowsEnabled() {_uniqueStorage()._repeatingHeaderRowsEnabled = nil}

  var styleApplyClearsAll: Bool {
    get {return _storage._styleApplyClearsAll ?? false}
    set {_uniqueStorage()._styleApplyClearsAll = newValue}
  }
  /// Returns true if `styleApplyClearsAll` has been explicitly set.
  var hasStyleApplyClearsAll: Bool {return _storage._styleApplyClearsAll != nil}
  /// Clears the value of `styleApplyClearsAll`. Subsequent reads from it will return its default value.
  mutating func clearStyleApplyClearsAll() {_uniqueStorage()._styleApplyClearsAll = nil}

  var repeatingHeaderColumnsEnabled: Bool {
    get {return _storage._repeatingHeaderColumnsEnabled ?? false}
    set {_uniqueStorage()._repeatingHeaderColumnsEnabled = newValue}
  }
  /// Returns true if `repeatingHeaderColumnsEnabled` has been explicitly set.
  var hasRepeatingHeaderColumnsEnabled: Bool {return _storage._repeatingHeaderColumnsEnabled != nil}
  /// Clears the value of `repeatingHeaderColumnsEnabled`. Subsequent reads from it will return its default value.
  mutating func clearRepeatingHeaderColumnsEnabled() {_uniqueStorage()._repeatingHeaderColumnsEnabled = nil}

  var hiddenStateFormulaOwnerForColumns: TSP_Reference {
    get {return _storage._hiddenStateFormulaOwnerForColumns ?? TSP_Reference()}
    set {_uniqueStorage()._hiddenStateFormulaOwnerForColumns = newValue}
  }
  /// Returns true if `hiddenStateFormulaOwnerForColumns` has been explicitly set.
  var hasHiddenStateFormulaOwnerForColumns: Bool {return _storage._hiddenStateFormulaOwnerForColumns != nil}
  /// Clears the value of `hiddenStateFormulaOwnerForColumns`. Subsequent reads from it will return its default value.
  mutating func clearHiddenStateFormulaOwnerForColumns() {_uniqueStorage()._hiddenStateFormulaOwnerForColumns = nil}

  var hiddenStateFormulaOwnerForRows: TSP_Reference {
    get {return _storage._hiddenStateFormulaOwnerForRows ?? TSP_Reference()}
    set {_uniqueStorage()._hiddenStateFormulaOwnerForRows = newValue}
  }
  /// Returns true if `hiddenStateFormulaOwnerForRows` has been explicitly set.
  var hasHiddenStateFormulaOwnerForRows: Bool {return _storage._hiddenStateFormulaOwnerForRows != nil}
  /// Clears the value of `hiddenStateFormulaOwnerForRows`. Subsequent reads from it will return its default value.
  mutating func clearHiddenStateFormulaOwnerForRows() {_uniqueStorage()._hiddenStateFormulaOwnerForRows = nil}

  var rowFilterSetPrePivot: TSP_Reference {
    get {return _storage._rowFilterSetPrePivot ?? TSP_Reference()}
    set {_uniqueStorage()._rowFilterSetPrePivot = newValue}
  }
  /// Returns true if `rowFilterSetPrePivot` has been explicitly set.
  var hasRowFilterSetPrePivot: Bool {return _storage._rowFilterSetPrePivot != nil}
  /// Clears the value of `rowFilterSetPrePivot`. Subsequent reads from it will return its default value.
  mutating func clearRowFilterSetPrePivot() {_uniqueStorage()._rowFilterSetPrePivot = nil}

  var conditionalStyleFormulaOwnerID: TSP_CFUUIDArchive {
    get {return _storage._conditionalStyleFormulaOwnerID ?? TSP_CFUUIDArchive()}
    set {_uniqueStorage()._conditionalStyleFormulaOwnerID = newValue}
  }
  /// Returns true if `conditionalStyleFormulaOwnerID` has been explicitly set.
  var hasConditionalStyleFormulaOwnerID: Bool {return _storage._conditionalStyleFormulaOwnerID != nil}
  /// Clears the value of `conditionalStyleFormulaOwnerID`. Subsequent reads from it will return its default value.
  mutating func clearConditionalStyleFormulaOwnerID() {_uniqueStorage()._conditionalStyleFormulaOwnerID = nil}

  var sortOrder: TST_TableSortOrderArchive {
    get {return _storage._sortOrder ?? TST_TableSortOrderArchive()}
    set {_uniqueStorage()._sortOrder = newValue}
  }
  /// Returns true if `sortOrder` has been explicitly set.
  var hasSortOrder: Bool {return _storage._sortOrder != nil}
  /// Clears the value of `sortOrder`. Subsequent reads from it will return its default value.
  mutating func clearSortOrder() {_uniqueStorage()._sortOrder = nil}

  var sortRuleReferenceTracker: TST_SortRuleReferenceTrackerArchive {
    get {return _storage._sortRuleReferenceTracker ?? TST_SortRuleReferenceTrackerArchive()}
    set {_uniqueStorage()._sortRuleReferenceTracker = newValue}
  }
  /// Returns true if `sortRuleReferenceTracker` has been explicitly set.
  var hasSortRuleReferenceTracker: Bool {return _storage._sortRuleReferenceTracker != nil}
  /// Clears the value of `sortRuleReferenceTracker`. Subsequent reads from it will return its default value.
  mutating func clearSortRuleReferenceTracker() {_uniqueStorage()._sortRuleReferenceTracker = nil}

  var baseColumnRowUids: TSP_Reference {
    get {return _storage._baseColumnRowUids ?? TSP_Reference()}
    set {_uniqueStorage()._baseColumnRowUids = newValue}
  }
  /// Returns true if `baseColumnRowUids` has been explicitly set.
  var hasBaseColumnRowUids: Bool {return _storage._baseColumnRowUids != nil}
  /// Clears the value of `baseColumnRowUids`. Subsequent reads from it will return its default value.
  mutating func clearBaseColumnRowUids() {_uniqueStorage()._baseColumnRowUids = nil}

  var mergeOwner: TST_MergeOwnerArchive {
    get {return _storage._mergeOwner ?? TST_MergeOwnerArchive()}
    set {_uniqueStorage()._mergeOwner = newValue}
  }
  /// Returns true if `mergeOwner` has been explicitly set.
  var hasMergeOwner: Bool {return _storage._mergeOwner != nil}
  /// Clears the value of `mergeOwner`. Subsequent reads from it will return its default value.
  mutating func clearMergeOwner() {_uniqueStorage()._mergeOwner = nil}

  var strokeSidecar: TSP_Reference {
    get {return _storage._strokeSidecar ?? TSP_Reference()}
    set {_uniqueStorage()._strokeSidecar = newValue}
  }
  /// Returns true if `strokeSidecar` has been explicitly set.
  var hasStrokeSidecar: Bool {return _storage._strokeSidecar != nil}
  /// Clears the value of `strokeSidecar`. Subsequent reads from it will return its default value.
  mutating func clearStrokeSidecar() {_uniqueStorage()._strokeSidecar = nil}

  var presetNeedsStrongOwnership: Bool {
    get {return _storage._presetNeedsStrongOwnership ?? false}
    set {_uniqueStorage()._presetNeedsStrongOwnership = newValue}
  }
  /// Returns true if `presetNeedsStrongOwnership` has been explicitly set.
  var hasPresetNeedsStrongOwnership: Bool {return _storage._presetNeedsStrongOwnership != nil}
  /// Clears the value of `presetNeedsStrongOwnership`. Subsequent reads from it will return its default value.
  mutating func clearPresetNeedsStrongOwnership() {_uniqueStorage()._presetNeedsStrongOwnership = nil}

  var textImportRecord: TST_StructuredTextImportRecord {
    get {return _storage._textImportRecord ?? TST_StructuredTextImportRecord()}
    set {_uniqueStorage()._textImportRecord = newValue}
  }
  /// Returns true if `textImportRecord` has been explicitly set.
  var hasTextImportRecord: Bool {return _storage._textImportRecord != nil}
  /// Clears the value of `textImportRecord`. Subsequent reads from it will return its default value.
  mutating func clearTextImportRecord() {_uniqueStorage()._textImportRecord = nil}

  var categoryLevel1Style: TSP_Reference {
    get {return _storage._categoryLevel1Style ?? TSP_Reference()}
    set {_uniqueStorage()._categoryLevel1Style = newValue}
  }
  /// Returns true if `categoryLevel1Style` has been explicitly set.
  var hasCategoryLevel1Style: Bool {return _storage._categoryLevel1Style != nil}
  /// Clears the value of `categoryLevel1Style`. Subsequent reads from it will return its default value.
  mutating func clearCategoryLevel1Style() {_uniqueStorage()._categoryLevel1Style = nil}

  var categoryLevel2Style: TSP_Reference {
    get {return _storage._categoryLevel2Style ?? TSP_Reference()}
    set {_uniqueStorage()._categoryLevel2Style = newValue}
  }
  /// Returns true if `categoryLevel2Style` has been explicitly set.
  var hasCategoryLevel2Style: Bool {return _storage._categoryLevel2Style != nil}
  /// Clears the value of `categoryLevel2Style`. Subsequent reads from it will return its default value.
  mutating func clearCategoryLevel2Style() {_uniqueStorage()._categoryLevel2Style = nil}

  var categoryLevel3Style: TSP_Reference {
    get {return _storage._categoryLevel3Style ?? TSP_Reference()}
    set {_uniqueStorage()._categoryLevel3Style = newValue}
  }
  /// Returns true if `categoryLevel3Style` has been explicitly set.
  var hasCategoryLevel3Style: Bool {return _storage._categoryLevel3Style != nil}
  /// Clears the value of `categoryLevel3Style`. Subsequent reads from it will return its default value.
  mutating func clearCategoryLevel3Style() {_uniqueStorage()._categoryLevel3Style = nil}

  var categoryLevel4Style: TSP_Reference {
    get {return _storage._categoryLevel4Style ?? TSP_Reference()}
    set {_uniqueStorage()._categoryLevel4Style = newValue}
  }
  /// Returns true if `categoryLevel4Style` has been explicitly set.
  var hasCategoryLevel4Style: Bool {return _storage._categoryLevel4Style != nil}
  /// Clears the value of `categoryLevel4Style`. Subsequent reads from it will return its default value.
  mutating func clearCategoryLevel4Style() {_uniqueStorage()._categoryLevel4Style = nil}

  var categoryLevel5Style: TSP_Reference {
    get {return _storage._categoryLevel5Style ?? TSP_Reference()}
    set {_uniqueStorage()._categoryLevel5Style = newValue}
  }
  /// Returns true if `categoryLevel5Style` has been explicitly set.
  var hasCategoryLevel5Style: Bool {return _storage._categoryLevel5Style != nil}
  /// Clears the value of `categoryLevel5Style`. Subsequent reads from it will return its default value.
  mutating func clearCategoryLevel5Style() {_uniqueStorage()._categoryLevel5Style = nil}

  var categoryLevel1TextStyle: TSP_Reference {
    get {return _storage._categoryLevel1TextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._categoryLevel1TextStyle = newValue}
  }
  /// Returns true if `categoryLevel1TextStyle` has been explicitly set.
  var hasCategoryLevel1TextStyle: Bool {return _storage._categoryLevel1TextStyle != nil}
  /// Clears the value of `categoryLevel1TextStyle`. Subsequent reads from it will return its default value.
  mutating func clearCategoryLevel1TextStyle() {_uniqueStorage()._categoryLevel1TextStyle = nil}

  var categoryLevel2TextStyle: TSP_Reference {
    get {return _storage._categoryLevel2TextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._categoryLevel2TextStyle = newValue}
  }
  /// Returns true if `categoryLevel2TextStyle` has been explicitly set.
  var hasCategoryLevel2TextStyle: Bool {return _storage._categoryLevel2TextStyle != nil}
  /// Clears the value of `categoryLevel2TextStyle`. Subsequent reads from it will return its default value.
  mutating func clearCategoryLevel2TextStyle() {_uniqueStorage()._categoryLevel2TextStyle = nil}

  var categoryLevel3TextStyle: TSP_Reference {
    get {return _storage._categoryLevel3TextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._categoryLevel3TextStyle = newValue}
  }
  /// Returns true if `categoryLevel3TextStyle` has been explicitly set.
  var hasCategoryLevel3TextStyle: Bool {return _storage._categoryLevel3TextStyle != nil}
  /// Clears the value of `categoryLevel3TextStyle`. Subsequent reads from it will return its default value.
  mutating func clearCategoryLevel3TextStyle() {_uniqueStorage()._categoryLevel3TextStyle = nil}

  var categoryLevel4TextStyle: TSP_Reference {
    get {return _storage._categoryLevel4TextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._categoryLevel4TextStyle = newValue}
  }
  /// Returns true if `categoryLevel4TextStyle` has been explicitly set.
  var hasCategoryLevel4TextStyle: Bool {return _storage._categoryLevel4TextStyle != nil}
  /// Clears the value of `categoryLevel4TextStyle`. Subsequent reads from it will return its default value.
  mutating func clearCategoryLevel4TextStyle() {_uniqueStorage()._categoryLevel4TextStyle = nil}

  var categoryLevel5TextStyle: TSP_Reference {
    get {return _storage._categoryLevel5TextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._categoryLevel5TextStyle = newValue}
  }
  /// Returns true if `categoryLevel5TextStyle` has been explicitly set.
  var hasCategoryLevel5TextStyle: Bool {return _storage._categoryLevel5TextStyle != nil}
  /// Clears the value of `categoryLevel5TextStyle`. Subsequent reads from it will return its default value.
  mutating func clearCategoryLevel5TextStyle() {_uniqueStorage()._categoryLevel5TextStyle = nil}

  var hiddenStatesOwner: TST_HiddenStatesOwnerArchive {
    get {return _storage._hiddenStatesOwner ?? TST_HiddenStatesOwnerArchive()}
    set {_uniqueStorage()._hiddenStatesOwner = newValue}
  }
  /// Returns true if `hiddenStatesOwner` has been explicitly set.
  var hasHiddenStatesOwner: Bool {return _storage._hiddenStatesOwner != nil}
  /// Clears the value of `hiddenStatesOwner`. Subsequent reads from it will return its default value.
  mutating func clearHiddenStatesOwner() {_uniqueStorage()._hiddenStatesOwner = nil}

  var labelLevel1Style: TSP_Reference {
    get {return _storage._labelLevel1Style ?? TSP_Reference()}
    set {_uniqueStorage()._labelLevel1Style = newValue}
  }
  /// Returns true if `labelLevel1Style` has been explicitly set.
  var hasLabelLevel1Style: Bool {return _storage._labelLevel1Style != nil}
  /// Clears the value of `labelLevel1Style`. Subsequent reads from it will return its default value.
  mutating func clearLabelLevel1Style() {_uniqueStorage()._labelLevel1Style = nil}

  var labelLevel2Style: TSP_Reference {
    get {return _storage._labelLevel2Style ?? TSP_Reference()}
    set {_uniqueStorage()._labelLevel2Style = newValue}
  }
  /// Returns true if `labelLevel2Style` has been explicitly set.
  var hasLabelLevel2Style: Bool {return _storage._labelLevel2Style != nil}
  /// Clears the value of `labelLevel2Style`. Subsequent reads from it will return its default value.
  mutating func clearLabelLevel2Style() {_uniqueStorage()._labelLevel2Style = nil}

  var labelLevel3Style: TSP_Reference {
    get {return _storage._labelLevel3Style ?? TSP_Reference()}
    set {_uniqueStorage()._labelLevel3Style = newValue}
  }
  /// Returns true if `labelLevel3Style` has been explicitly set.
  var hasLabelLevel3Style: Bool {return _storage._labelLevel3Style != nil}
  /// Clears the value of `labelLevel3Style`. Subsequent reads from it will return its default value.
  mutating func clearLabelLevel3Style() {_uniqueStorage()._labelLevel3Style = nil}

  var labelLevel4Style: TSP_Reference {
    get {return _storage._labelLevel4Style ?? TSP_Reference()}
    set {_uniqueStorage()._labelLevel4Style = newValue}
  }
  /// Returns true if `labelLevel4Style` has been explicitly set.
  var hasLabelLevel4Style: Bool {return _storage._labelLevel4Style != nil}
  /// Clears the value of `labelLevel4Style`. Subsequent reads from it will return its default value.
  mutating func clearLabelLevel4Style() {_uniqueStorage()._labelLevel4Style = nil}

  var labelLevel5Style: TSP_Reference {
    get {return _storage._labelLevel5Style ?? TSP_Reference()}
    set {_uniqueStorage()._labelLevel5Style = newValue}
  }
  /// Returns true if `labelLevel5Style` has been explicitly set.
  var hasLabelLevel5Style: Bool {return _storage._labelLevel5Style != nil}
  /// Clears the value of `labelLevel5Style`. Subsequent reads from it will return its default value.
  mutating func clearLabelLevel5Style() {_uniqueStorage()._labelLevel5Style = nil}

  var labelLevel1TextStyle: TSP_Reference {
    get {return _storage._labelLevel1TextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._labelLevel1TextStyle = newValue}
  }
  /// Returns true if `labelLevel1TextStyle` has been explicitly set.
  var hasLabelLevel1TextStyle: Bool {return _storage._labelLevel1TextStyle != nil}
  /// Clears the value of `labelLevel1TextStyle`. Subsequent reads from it will return its default value.
  mutating func clearLabelLevel1TextStyle() {_uniqueStorage()._labelLevel1TextStyle = nil}

  var labelLevel2TextStyle: TSP_Reference {
    get {return _storage._labelLevel2TextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._labelLevel2TextStyle = newValue}
  }
  /// Returns true if `labelLevel2TextStyle` has been explicitly set.
  var hasLabelLevel2TextStyle: Bool {return _storage._labelLevel2TextStyle != nil}
  /// Clears the value of `labelLevel2TextStyle`. Subsequent reads from it will return its default value.
  mutating func clearLabelLevel2TextStyle() {_uniqueStorage()._labelLevel2TextStyle = nil}

  var labelLevel3TextStyle: TSP_Reference {
    get {return _storage._labelLevel3TextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._labelLevel3TextStyle = newValue}
  }
  /// Returns true if `labelLevel3TextStyle` has been explicitly set.
  var hasLabelLevel3TextStyle: Bool {return _storage._labelLevel3TextStyle != nil}
  /// Clears the value of `labelLevel3TextStyle`. Subsequent reads from it will return its default value.
  mutating func clearLabelLevel3TextStyle() {_uniqueStorage()._labelLevel3TextStyle = nil}

  var labelLevel4TextStyle: TSP_Reference {
    get {return _storage._labelLevel4TextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._labelLevel4TextStyle = newValue}
  }
  /// Returns true if `labelLevel4TextStyle` has been explicitly set.
  var hasLabelLevel4TextStyle: Bool {return _storage._labelLevel4TextStyle != nil}
  /// Clears the value of `labelLevel4TextStyle`. Subsequent reads from it will return its default value.
  mutating func clearLabelLevel4TextStyle() {_uniqueStorage()._labelLevel4TextStyle = nil}

  var labelLevel5TextStyle: TSP_Reference {
    get {return _storage._labelLevel5TextStyle ?? TSP_Reference()}
    set {_uniqueStorage()._labelLevel5TextStyle = newValue}
  }
  /// Returns true if `labelLevel5TextStyle` has been explicitly set.
  var hasLabelLevel5TextStyle: Bool {return _storage._labelLevel5TextStyle != nil}
  /// Clears the value of `labelLevel5TextStyle`. Subsequent reads from it will return its default value.
  mutating func clearLabelLevel5TextStyle() {_uniqueStorage()._labelLevel5TextStyle = nil}

  var categoryOwnerDeprecated: TST_CategoryOwnerArchive {
    get {return _storage._categoryOwnerDeprecated ?? TST_CategoryOwnerArchive()}
    set {_uniqueStorage()._categoryOwnerDeprecated = newValue}
  }
  /// Returns true if `categoryOwnerDeprecated` has been explicitly set.
  var hasCategoryOwnerDeprecated: Bool {return _storage._categoryOwnerDeprecated != nil}
  /// Clears the value of `categoryOwnerDeprecated`. Subsequent reads from it will return its default value.
  mutating func clearCategoryOwnerDeprecated() {_uniqueStorage()._categoryOwnerDeprecated = nil}

  var pencilAnnotationOwner: TST_PencilAnnotationOwnerArchive {
    get {return _storage._pencilAnnotationOwner ?? TST_PencilAnnotationOwnerArchive()}
    set {_uniqueStorage()._pencilAnnotationOwner = newValue}
  }
  /// Returns true if `pencilAnnotationOwner` has been explicitly set.
  var hasPencilAnnotationOwner: Bool {return _storage._pencilAnnotationOwner != nil}
  /// Clears the value of `pencilAnnotationOwner`. Subsequent reads from it will return its default value.
  mutating func clearPencilAnnotationOwner() {_uniqueStorage()._pencilAnnotationOwner = nil}

  var fromGroupByUid: String {
    get {return _storage._fromGroupByUid ?? String()}
    set {_uniqueStorage()._fromGroupByUid = newValue}
  }
  /// Returns true if `fromGroupByUid` has been explicitly set.
  var hasFromGroupByUid: Bool {return _storage._fromGroupByUid != nil}
  /// Clears the value of `fromGroupByUid`. Subsequent reads from it will return its default value.
  mutating func clearFromGroupByUid() {_uniqueStorage()._fromGroupByUid = nil}

  var hauntedOwner: TSCE_HauntedOwnerArchive {
    get {return _storage._hauntedOwner ?? TSCE_HauntedOwnerArchive()}
    set {_uniqueStorage()._hauntedOwner = newValue}
  }
  /// Returns true if `hauntedOwner` has been explicitly set.
  var hasHauntedOwner: Bool {return _storage._hauntedOwner != nil}
  /// Clears the value of `hauntedOwner`. Subsequent reads from it will return its default value.
  mutating func clearHauntedOwner() {_uniqueStorage()._hauntedOwner = nil}

  var pivotOwner: TSP_Reference {
    get {return _storage._pivotOwner ?? TSP_Reference()}
    set {_uniqueStorage()._pivotOwner = newValue}
  }
  /// Returns true if `pivotOwner` has been explicitly set.
  var hasPivotOwner: Bool {return _storage._pivotOwner != nil}
  /// Clears the value of `pivotOwner`. Subsequent reads from it will return its default value.
  mutating func clearPivotOwner() {_uniqueStorage()._pivotOwner = nil}

  var categoryOwner: TSP_Reference {
    get {return _storage._categoryOwner ?? TSP_Reference()}
    set {_uniqueStorage()._categoryOwner = newValue}
  }
  /// Returns true if `categoryOwner` has been explicitly set.
  var hasCategoryOwner: Bool {return _storage._categoryOwner != nil}
  /// Clears the value of `categoryOwner`. Subsequent reads from it will return its default value.
  mutating func clearCategoryOwner() {_uniqueStorage()._categoryOwner = nil}

  var pivotBodySummaryRowStyle: TSP_Reference {
    get {return _storage._pivotBodySummaryRowStyle ?? TSP_Reference()}
    set {_uniqueStorage()._pivotBodySummaryRowStyle = newValue}
  }
  /// Returns true if `pivotBodySummaryRowStyle` has been explicitly set.
  var hasPivotBodySummaryRowStyle: Bool {return _storage._pivotBodySummaryRowStyle != nil}
  /// Clears the value of `pivotBodySummaryRowStyle`. Subsequent reads from it will return its default value.
  mutating func clearPivotBodySummaryRowStyle() {_uniqueStorage()._pivotBodySummaryRowStyle = nil}

  var pivotBodySummaryColumnStyle: TSP_Reference {
    get {return _storage._pivotBodySummaryColumnStyle ?? TSP_Reference()}
    set {_uniqueStorage()._pivotBodySummaryColumnStyle = newValue}
  }
  /// Returns true if `pivotBodySummaryColumnStyle` has been explicitly set.
  var hasPivotBodySummaryColumnStyle: Bool {return _storage._pivotBodySummaryColumnStyle != nil}
  /// Clears the value of `pivotBodySummaryColumnStyle`. Subsequent reads from it will return its default value.
  mutating func clearPivotBodySummaryColumnStyle() {_uniqueStorage()._pivotBodySummaryColumnStyle = nil}

  var pivotHeaderColumnSummaryStyle: TSP_Reference {
    get {return _storage._pivotHeaderColumnSummaryStyle ?? TSP_Reference()}
    set {_uniqueStorage()._pivotHeaderColumnSummaryStyle = newValue}
  }
  /// Returns true if `pivotHeaderColumnSummaryStyle` has been explicitly set.
  var hasPivotHeaderColumnSummaryStyle: Bool {return _storage._pivotHeaderColumnSummaryStyle != nil}
  /// Clears the value of `pivotHeaderColumnSummaryStyle`. Subsequent reads from it will return its default value.
  mutating func clearPivotHeaderColumnSummaryStyle() {_uniqueStorage()._pivotHeaderColumnSummaryStyle = nil}

  var pivotValueTypesByCol: [UInt32] {
    get {return _storage._pivotValueTypesByCol}
    set {_uniqueStorage()._pivotValueTypesByCol = newValue}
  }

  var pivotDateGroupingColumns: [UInt32] {
    get {return _storage._pivotDateGroupingColumns}
    set {_uniqueStorage()._pivotDateGroupingColumns = newValue}
  }

  var pivotDateGroupingTypes: [UInt32] {
    get {return _storage._pivotDateGroupingTypes}
    set {_uniqueStorage()._pivotDateGroupingTypes = newValue}
  }

  var spillOwner: TSCE_SpillOwnerArchive {
    get {return _storage._spillOwner ?? TSCE_SpillOwnerArchive()}
    set {_uniqueStorage()._spillOwner = newValue}
  }
  /// Returns true if `spillOwner` has been explicitly set.
  var hasSpillOwner: Bool {return _storage._spillOwner != nil}
  /// Clears the value of `spillOwner`. Subsequent reads from it will return its default value.
  mutating func clearSpillOwner() {_uniqueStorage()._spillOwner = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_SummaryModelArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tableInfo: TSP_Reference {
    get {return _storage._tableInfo ?? TSP_Reference()}
    set {_uniqueStorage()._tableInfo = newValue}
  }
  /// Returns true if `tableInfo` has been explicitly set.
  var hasTableInfo: Bool {return _storage._tableInfo != nil}
  /// Clears the value of `tableInfo`. Subsequent reads from it will return its default value.
  mutating func clearTableInfo() {_uniqueStorage()._tableInfo = nil}

  var dataStore: TST_DataStore {
    get {return _storage._dataStore ?? TST_DataStore()}
    set {_uniqueStorage()._dataStore = newValue}
  }
  /// Returns true if `dataStore` has been explicitly set.
  var hasDataStore: Bool {return _storage._dataStore != nil}
  /// Clears the value of `dataStore`. Subsequent reads from it will return its default value.
  mutating func clearDataStore() {_uniqueStorage()._dataStore = nil}

  var columnRowUids: TSP_Reference {
    get {return _storage._columnRowUids ?? TSP_Reference()}
    set {_uniqueStorage()._columnRowUids = newValue}
  }
  /// Returns true if `columnRowUids` has been explicitly set.
  var hasColumnRowUids: Bool {return _storage._columnRowUids != nil}
  /// Clears the value of `columnRowUids`. Subsequent reads from it will return its default value.
  mutating func clearColumnRowUids() {_uniqueStorage()._columnRowUids = nil}

  var aggregateFormulaOwnerUuid: TSP_UUID {
    get {return _storage._aggregateFormulaOwnerUuid ?? TSP_UUID()}
    set {_uniqueStorage()._aggregateFormulaOwnerUuid = newValue}
  }
  /// Returns true if `aggregateFormulaOwnerUuid` has been explicitly set.
  var hasAggregateFormulaOwnerUuid: Bool {return _storage._aggregateFormulaOwnerUuid != nil}
  /// Clears the value of `aggregateFormulaOwnerUuid`. Subsequent reads from it will return its default value.
  mutating func clearAggregateFormulaOwnerUuid() {_uniqueStorage()._aggregateFormulaOwnerUuid = nil}

  var summaryCellVendor: TSP_Reference {
    get {return _storage._summaryCellVendor ?? TSP_Reference()}
    set {_uniqueStorage()._summaryCellVendor = newValue}
  }
  /// Returns true if `summaryCellVendor` has been explicitly set.
  var hasSummaryCellVendor: Bool {return _storage._summaryCellVendor != nil}
  /// Clears the value of `summaryCellVendor`. Subsequent reads from it will return its default value.
  mutating func clearSummaryCellVendor() {_uniqueStorage()._summaryCellVendor = nil}

  var categoryColumnWidth: Double {
    get {return _storage._categoryColumnWidth ?? 0}
    set {_uniqueStorage()._categoryColumnWidth = newValue}
  }
  /// Returns true if `categoryColumnWidth` has been explicitly set.
  var hasCategoryColumnWidth: Bool {return _storage._categoryColumnWidth != nil}
  /// Clears the value of `categoryColumnWidth`. Subsequent reads from it will return its default value.
  mutating func clearCategoryColumnWidth() {_uniqueStorage()._categoryColumnWidth = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var summaryRowLevel1Height: Double {
    get {return _storage._summaryRowLevel1Height ?? 0}
    set {_uniqueStorage()._summaryRowLevel1Height = newValue}
  }
  /// Returns true if `summaryRowLevel1Height` has been explicitly set.
  var hasSummaryRowLevel1Height: Bool {return _storage._summaryRowLevel1Height != nil}
  /// Clears the value of `summaryRowLevel1Height`. Subsequent reads from it will return its default value.
  mutating func clearSummaryRowLevel1Height() {_uniqueStorage()._summaryRowLevel1Height = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var summaryRowLevel2Height: Double {
    get {return _storage._summaryRowLevel2Height ?? 0}
    set {_uniqueStorage()._summaryRowLevel2Height = newValue}
  }
  /// Returns true if `summaryRowLevel2Height` has been explicitly set.
  var hasSummaryRowLevel2Height: Bool {return _storage._summaryRowLevel2Height != nil}
  /// Clears the value of `summaryRowLevel2Height`. Subsequent reads from it will return its default value.
  mutating func clearSummaryRowLevel2Height() {_uniqueStorage()._summaryRowLevel2Height = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var summaryRowLevel3Height: Double {
    get {return _storage._summaryRowLevel3Height ?? 0}
    set {_uniqueStorage()._summaryRowLevel3Height = newValue}
  }
  /// Returns true if `summaryRowLevel3Height` has been explicitly set.
  var hasSummaryRowLevel3Height: Bool {return _storage._summaryRowLevel3Height != nil}
  /// Clears the value of `summaryRowLevel3Height`. Subsequent reads from it will return its default value.
  mutating func clearSummaryRowLevel3Height() {_uniqueStorage()._summaryRowLevel3Height = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var summaryRowLevel4Height: Double {
    get {return _storage._summaryRowLevel4Height ?? 0}
    set {_uniqueStorage()._summaryRowLevel4Height = newValue}
  }
  /// Returns true if `summaryRowLevel4Height` has been explicitly set.
  var hasSummaryRowLevel4Height: Bool {return _storage._summaryRowLevel4Height != nil}
  /// Clears the value of `summaryRowLevel4Height`. Subsequent reads from it will return its default value.
  mutating func clearSummaryRowLevel4Height() {_uniqueStorage()._summaryRowLevel4Height = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var summaryRowLevel5Height: Double {
    get {return _storage._summaryRowLevel5Height ?? 0}
    set {_uniqueStorage()._summaryRowLevel5Height = newValue}
  }
  /// Returns true if `summaryRowLevel5Height` has been explicitly set.
  var hasSummaryRowLevel5Height: Bool {return _storage._summaryRowLevel5Height != nil}
  /// Clears the value of `summaryRowLevel5Height`. Subsequent reads from it will return its default value.
  mutating func clearSummaryRowLevel5Height() {_uniqueStorage()._summaryRowLevel5Height = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var summaryLabelRowLevel1Height: Double {
    get {return _storage._summaryLabelRowLevel1Height ?? 0}
    set {_uniqueStorage()._summaryLabelRowLevel1Height = newValue}
  }
  /// Returns true if `summaryLabelRowLevel1Height` has been explicitly set.
  var hasSummaryLabelRowLevel1Height: Bool {return _storage._summaryLabelRowLevel1Height != nil}
  /// Clears the value of `summaryLabelRowLevel1Height`. Subsequent reads from it will return its default value.
  mutating func clearSummaryLabelRowLevel1Height() {_uniqueStorage()._summaryLabelRowLevel1Height = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var summaryLabelRowLevel2Height: Double {
    get {return _storage._summaryLabelRowLevel2Height ?? 0}
    set {_uniqueStorage()._summaryLabelRowLevel2Height = newValue}
  }
  /// Returns true if `summaryLabelRowLevel2Height` has been explicitly set.
  var hasSummaryLabelRowLevel2Height: Bool {return _storage._summaryLabelRowLevel2Height != nil}
  /// Clears the value of `summaryLabelRowLevel2Height`. Subsequent reads from it will return its default value.
  mutating func clearSummaryLabelRowLevel2Height() {_uniqueStorage()._summaryLabelRowLevel2Height = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var summaryLabelRowLevel3Height: Double {
    get {return _storage._summaryLabelRowLevel3Height ?? 0}
    set {_uniqueStorage()._summaryLabelRowLevel3Height = newValue}
  }
  /// Returns true if `summaryLabelRowLevel3Height` has been explicitly set.
  var hasSummaryLabelRowLevel3Height: Bool {return _storage._summaryLabelRowLevel3Height != nil}
  /// Clears the value of `summaryLabelRowLevel3Height`. Subsequent reads from it will return its default value.
  mutating func clearSummaryLabelRowLevel3Height() {_uniqueStorage()._summaryLabelRowLevel3Height = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var summaryLabelRowLevel4Height: Double {
    get {return _storage._summaryLabelRowLevel4Height ?? 0}
    set {_uniqueStorage()._summaryLabelRowLevel4Height = newValue}
  }
  /// Returns true if `summaryLabelRowLevel4Height` has been explicitly set.
  var hasSummaryLabelRowLevel4Height: Bool {return _storage._summaryLabelRowLevel4Height != nil}
  /// Clears the value of `summaryLabelRowLevel4Height`. Subsequent reads from it will return its default value.
  mutating func clearSummaryLabelRowLevel4Height() {_uniqueStorage()._summaryLabelRowLevel4Height = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var summaryLabelRowLevel5Height: Double {
    get {return _storage._summaryLabelRowLevel5Height ?? 0}
    set {_uniqueStorage()._summaryLabelRowLevel5Height = newValue}
  }
  /// Returns true if `summaryLabelRowLevel5Height` has been explicitly set.
  var hasSummaryLabelRowLevel5Height: Bool {return _storage._summaryLabelRowLevel5Height != nil}
  /// Clears the value of `summaryLabelRowLevel5Height`. Subsequent reads from it will return its default value.
  mutating func clearSummaryLabelRowLevel5Height() {_uniqueStorage()._summaryLabelRowLevel5Height = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var labelRowVisibility1: UInt32 {
    get {return _storage._labelRowVisibility1 ?? 0}
    set {_uniqueStorage()._labelRowVisibility1 = newValue}
  }
  /// Returns true if `labelRowVisibility1` has been explicitly set.
  var hasLabelRowVisibility1: Bool {return _storage._labelRowVisibility1 != nil}
  /// Clears the value of `labelRowVisibility1`. Subsequent reads from it will return its default value.
  mutating func clearLabelRowVisibility1() {_uniqueStorage()._labelRowVisibility1 = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var labelRowVisibility2: UInt32 {
    get {return _storage._labelRowVisibility2 ?? 0}
    set {_uniqueStorage()._labelRowVisibility2 = newValue}
  }
  /// Returns true if `labelRowVisibility2` has been explicitly set.
  var hasLabelRowVisibility2: Bool {return _storage._labelRowVisibility2 != nil}
  /// Clears the value of `labelRowVisibility2`. Subsequent reads from it will return its default value.
  mutating func clearLabelRowVisibility2() {_uniqueStorage()._labelRowVisibility2 = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var labelRowVisibility3: UInt32 {
    get {return _storage._labelRowVisibility3 ?? 0}
    set {_uniqueStorage()._labelRowVisibility3 = newValue}
  }
  /// Returns true if `labelRowVisibility3` has been explicitly set.
  var hasLabelRowVisibility3: Bool {return _storage._labelRowVisibility3 != nil}
  /// Clears the value of `labelRowVisibility3`. Subsequent reads from it will return its default value.
  mutating func clearLabelRowVisibility3() {_uniqueStorage()._labelRowVisibility3 = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var labelRowVisibility4: UInt32 {
    get {return _storage._labelRowVisibility4 ?? 0}
    set {_uniqueStorage()._labelRowVisibility4 = newValue}
  }
  /// Returns true if `labelRowVisibility4` has been explicitly set.
  var hasLabelRowVisibility4: Bool {return _storage._labelRowVisibility4 != nil}
  /// Clears the value of `labelRowVisibility4`. Subsequent reads from it will return its default value.
  mutating func clearLabelRowVisibility4() {_uniqueStorage()._labelRowVisibility4 = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var labelRowVisibility5: UInt32 {
    get {return _storage._labelRowVisibility5 ?? 0}
    set {_uniqueStorage()._labelRowVisibility5 = newValue}
  }
  /// Returns true if `labelRowVisibility5` has been explicitly set.
  var hasLabelRowVisibility5: Bool {return _storage._labelRowVisibility5 != nil}
  /// Clears the value of `labelRowVisibility5`. Subsequent reads from it will return its default value.
  mutating func clearLabelRowVisibility5() {_uniqueStorage()._labelRowVisibility5 = nil}

  var summaryRowHeightList: [Double] {
    get {return _storage._summaryRowHeightList}
    set {_uniqueStorage()._summaryRowHeightList = newValue}
  }

  var labelRowHeightList: [Double] {
    get {return _storage._labelRowHeightList}
    set {_uniqueStorage()._labelRowHeightList = newValue}
  }

  var labelRowVisibilityList: [UInt32] {
    get {return _storage._labelRowVisibilityList}
    set {_uniqueStorage()._labelRowVisibilityList = newValue}
  }

  var groupSortOrder: TST_TableGroupSortOrderUIDArchive {
    get {return _storage._groupSortOrder ?? TST_TableGroupSortOrderUIDArchive()}
    set {_uniqueStorage()._groupSortOrder = newValue}
  }
  /// Returns true if `groupSortOrder` has been explicitly set.
  var hasGroupSortOrder: Bool {return _storage._groupSortOrder != nil}
  /// Clears the value of `groupSortOrder`. Subsequent reads from it will return its default value.
  mutating func clearGroupSortOrder() {_uniqueStorage()._groupSortOrder = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_SummaryModelGroupByChangeStateArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cellMap: TSP_Reference {
    get {return _cellMap ?? TSP_Reference()}
    set {_cellMap = newValue}
  }
  /// Returns true if `cellMap` has been explicitly set.
  var hasCellMap: Bool {return self._cellMap != nil}
  /// Clears the value of `cellMap`. Subsequent reads from it will return its default value.
  mutating func clearCellMap() {self._cellMap = nil}

  var summaryRowHeightList: [Double] = []

  var labelRowHeightList: [Double] = []

  var labelRowVisibilityList: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cellMap: TSP_Reference? = nil
}

struct TST_ColumnRowUIDMapArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sortedColumnUids: [TSP_UUID] = []

  var columnIndexForUid: [UInt32] = []

  var columnUidForIndex: [UInt32] = []

  var sortedRowUids: [TSP_UUID] = []

  var rowIndexForUid: [UInt32] = []

  var rowUidForIndex: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TST_StrokeLayerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rowColumnIndex: UInt32 {
    get {return _rowColumnIndex ?? 0}
    set {_rowColumnIndex = newValue}
  }
  /// Returns true if `rowColumnIndex` has been explicitly set.
  var hasRowColumnIndex: Bool {return self._rowColumnIndex != nil}
  /// Clears the value of `rowColumnIndex`. Subsequent reads from it will return its default value.
  mutating func clearRowColumnIndex() {self._rowColumnIndex = nil}

  var strokeRuns: [TST_StrokeLayerArchive.StrokeRunArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct StrokeRunArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var origin: Int32 {
      get {return _origin ?? 0}
      set {_origin = newValue}
    }
    /// Returns true if `origin` has been explicitly set.
    var hasOrigin: Bool {return self._origin != nil}
    /// Clears the value of `origin`. Subsequent reads from it will return its default value.
    mutating func clearOrigin() {self._origin = nil}

    var length: UInt32 {
      get {return _length ?? 0}
      set {_length = newValue}
    }
    /// Returns true if `length` has been explicitly set.
    var hasLength: Bool {return self._length != nil}
    /// Clears the value of `length`. Subsequent reads from it will return its default value.
    mutating func clearLength() {self._length = nil}

    var stroke: TSD_StrokeArchive {
      get {return _stroke ?? TSD_StrokeArchive()}
      set {_stroke = newValue}
    }
    /// Returns true if `stroke` has been explicitly set.
    var hasStroke: Bool {return self._stroke != nil}
    /// Clears the value of `stroke`. Subsequent reads from it will return its default value.
    mutating func clearStroke() {self._stroke = nil}

    var order: UInt32 {
      get {return _order ?? 0}
      set {_order = newValue}
    }
    /// Returns true if `order` has been explicitly set.
    var hasOrder: Bool {return self._order != nil}
    /// Clears the value of `order`. Subsequent reads from it will return its default value.
    mutating func clearOrder() {self._order = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _origin: Int32? = nil
    fileprivate var _length: UInt32? = nil
    fileprivate var _stroke: TSD_StrokeArchive? = nil
    fileprivate var _order: UInt32? = nil
  }

  init() {}

  fileprivate var _rowColumnIndex: UInt32? = nil
}

struct TST_StrokeSidecarArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var maxOrder: UInt32 {
    get {return _maxOrder ?? 0}
    set {_maxOrder = newValue}
  }
  /// Returns true if `maxOrder` has been explicitly set.
  var hasMaxOrder: Bool {return self._maxOrder != nil}
  /// Clears the value of `maxOrder`. Subsequent reads from it will return its default value.
  mutating func clearMaxOrder() {self._maxOrder = nil}

  var columnCount: UInt32 {
    get {return _columnCount ?? 0}
    set {_columnCount = newValue}
  }
  /// Returns true if `columnCount` has been explicitly set.
  var hasColumnCount: Bool {return self._columnCount != nil}
  /// Clears the value of `columnCount`. Subsequent reads from it will return its default value.
  mutating func clearColumnCount() {self._columnCount = nil}

  var rowCount: UInt32 {
    get {return _rowCount ?? 0}
    set {_rowCount = newValue}
  }
  /// Returns true if `rowCount` has been explicitly set.
  var hasRowCount: Bool {return self._rowCount != nil}
  /// Clears the value of `rowCount`. Subsequent reads from it will return its default value.
  mutating func clearRowCount() {self._rowCount = nil}

  var leftColumnStrokeLayers: [TSP_Reference] = []

  var rightColumnStrokeLayers: [TSP_Reference] = []

  var topRowStrokeLayers: [TSP_Reference] = []

  var bottomRowStrokeLayers: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _maxOrder: UInt32? = nil
  fileprivate var _columnCount: UInt32? = nil
  fileprivate var _rowCount: UInt32? = nil
}

struct TST_DurationWrapperArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TST_Cell: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var valueType: TST_CellValueType {
    get {return _storage._valueType ?? .emptyCellValueType}
    set {_uniqueStorage()._valueType = newValue}
  }
  /// Returns true if `valueType` has been explicitly set.
  var hasValueType: Bool {return _storage._valueType != nil}
  /// Clears the value of `valueType`. Subsequent reads from it will return its default value.
  mutating func clearValueType() {_uniqueStorage()._valueType = nil}

  var cellStyle: TSP_Reference {
    get {return _storage._cellStyle ?? TSP_Reference()}
    set {_uniqueStorage()._cellStyle = newValue}
  }
  /// Returns true if `cellStyle` has been explicitly set.
  var hasCellStyle: Bool {return _storage._cellStyle != nil}
  /// Clears the value of `cellStyle`. Subsequent reads from it will return its default value.
  mutating func clearCellStyle() {_uniqueStorage()._cellStyle = nil}

  var textStyle: TSP_Reference {
    get {return _storage._textStyle ?? TSP_Reference()}
    set {_uniqueStorage()._textStyle = newValue}
  }
  /// Returns true if `textStyle` has been explicitly set.
  var hasTextStyle: Bool {return _storage._textStyle != nil}
  /// Clears the value of `textStyle`. Subsequent reads from it will return its default value.
  mutating func clearTextStyle() {_uniqueStorage()._textStyle = nil}

  var numberValue: Double {
    get {return _storage._numberValue ?? 0}
    set {_uniqueStorage()._numberValue = newValue}
  }
  /// Returns true if `numberValue` has been explicitly set.
  var hasNumberValue: Bool {return _storage._numberValue != nil}
  /// Clears the value of `numberValue`. Subsequent reads from it will return its default value.
  mutating func clearNumberValue() {_uniqueStorage()._numberValue = nil}

  var stringValue: String {
    get {return _storage._stringValue ?? String()}
    set {_uniqueStorage()._stringValue = newValue}
  }
  /// Returns true if `stringValue` has been explicitly set.
  var hasStringValue: Bool {return _storage._stringValue != nil}
  /// Clears the value of `stringValue`. Subsequent reads from it will return its default value.
  mutating func clearStringValue() {_uniqueStorage()._stringValue = nil}

  var boolValue: Bool {
    get {return _storage._boolValue ?? false}
    set {_uniqueStorage()._boolValue = newValue}
  }
  /// Returns true if `boolValue` has been explicitly set.
  var hasBoolValue: Bool {return _storage._boolValue != nil}
  /// Clears the value of `boolValue`. Subsequent reads from it will return its default value.
  mutating func clearBoolValue() {_uniqueStorage()._boolValue = nil}

  var currentFormat: TSK_FormatStructArchive {
    get {return _storage._currentFormat ?? TSK_FormatStructArchive()}
    set {_uniqueStorage()._currentFormat = newValue}
  }
  /// Returns true if `currentFormat` has been explicitly set.
  var hasCurrentFormat: Bool {return _storage._currentFormat != nil}
  /// Clears the value of `currentFormat`. Subsequent reads from it will return its default value.
  mutating func clearCurrentFormat() {_uniqueStorage()._currentFormat = nil}

  var formulaError: TSP_Reference {
    get {return _storage._formulaError ?? TSP_Reference()}
    set {_uniqueStorage()._formulaError = newValue}
  }
  /// Returns true if `formulaError` has been explicitly set.
  var hasFormulaError: Bool {return _storage._formulaError != nil}
  /// Clears the value of `formulaError`. Subsequent reads from it will return its default value.
  mutating func clearFormulaError() {_uniqueStorage()._formulaError = nil}

  var numberFormat: TSK_FormatStructArchive {
    get {return _storage._numberFormat ?? TSK_FormatStructArchive()}
    set {_uniqueStorage()._numberFormat = newValue}
  }
  /// Returns true if `numberFormat` has been explicitly set.
  var hasNumberFormat: Bool {return _storage._numberFormat != nil}
  /// Clears the value of `numberFormat`. Subsequent reads from it will return its default value.
  mutating func clearNumberFormat() {_uniqueStorage()._numberFormat = nil}

  var currencyFormat: TSK_FormatStructArchive {
    get {return _storage._currencyFormat ?? TSK_FormatStructArchive()}
    set {_uniqueStorage()._currencyFormat = newValue}
  }
  /// Returns true if `currencyFormat` has been explicitly set.
  var hasCurrencyFormat: Bool {return _storage._currencyFormat != nil}
  /// Clears the value of `currencyFormat`. Subsequent reads from it will return its default value.
  mutating func clearCurrencyFormat() {_uniqueStorage()._currencyFormat = nil}

  var durationFormat: TSK_FormatStructArchive {
    get {return _storage._durationFormat ?? TSK_FormatStructArchive()}
    set {_uniqueStorage()._durationFormat = newValue}
  }
  /// Returns true if `durationFormat` has been explicitly set.
  var hasDurationFormat: Bool {return _storage._durationFormat != nil}
  /// Clears the value of `durationFormat`. Subsequent reads from it will return its default value.
  mutating func clearDurationFormat() {_uniqueStorage()._durationFormat = nil}

  var dateFormat: TSK_FormatStructArchive {
    get {return _storage._dateFormat ?? TSK_FormatStructArchive()}
    set {_uniqueStorage()._dateFormat = newValue}
  }
  /// Returns true if `dateFormat` has been explicitly set.
  var hasDateFormat: Bool {return _storage._dateFormat != nil}
  /// Clears the value of `dateFormat`. Subsequent reads from it will return its default value.
  mutating func clearDateFormat() {_uniqueStorage()._dateFormat = nil}

  var customFormat: TSK_FormatStructArchive {
    get {return _storage._customFormat ?? TSK_FormatStructArchive()}
    set {_uniqueStorage()._customFormat = newValue}
  }
  /// Returns true if `customFormat` has been explicitly set.
  var hasCustomFormat: Bool {return _storage._customFormat != nil}
  /// Clears the value of `customFormat`. Subsequent reads from it will return its default value.
  mutating func clearCustomFormat() {_uniqueStorage()._customFormat = nil}

  var baseFormat: TSK_FormatStructArchive {
    get {return _storage._baseFormat ?? TSK_FormatStructArchive()}
    set {_uniqueStorage()._baseFormat = newValue}
  }
  /// Returns true if `baseFormat` has been explicitly set.
  var hasBaseFormat: Bool {return _storage._baseFormat != nil}
  /// Clears the value of `baseFormat`. Subsequent reads from it will return its default value.
  mutating func clearBaseFormat() {_uniqueStorage()._baseFormat = nil}

  var explicitFormatFlags: UInt32 {
    get {return _storage._explicitFormatFlags ?? 0}
    set {_uniqueStorage()._explicitFormatFlags = newValue}
  }
  /// Returns true if `explicitFormatFlags` has been explicitly set.
  var hasExplicitFormatFlags: Bool {return _storage._explicitFormatFlags != nil}
  /// Clears the value of `explicitFormatFlags`. Subsequent reads from it will return its default value.
  mutating func clearExplicitFormatFlags() {_uniqueStorage()._explicitFormatFlags = nil}

  var richText: TSP_Reference {
    get {return _storage._richText ?? TSP_Reference()}
    set {_uniqueStorage()._richText = newValue}
  }
  /// Returns true if `richText` has been explicitly set.
  var hasRichText: Bool {return _storage._richText != nil}
  /// Clears the value of `richText`. Subsequent reads from it will return its default value.
  mutating func clearRichText() {_uniqueStorage()._richText = nil}

  var conditionalStyle: TSP_Reference {
    get {return _storage._conditionalStyle ?? TSP_Reference()}
    set {_uniqueStorage()._conditionalStyle = newValue}
  }
  /// Returns true if `conditionalStyle` has been explicitly set.
  var hasConditionalStyle: Bool {return _storage._conditionalStyle != nil}
  /// Clears the value of `conditionalStyle`. Subsequent reads from it will return its default value.
  mutating func clearConditionalStyle() {_uniqueStorage()._conditionalStyle = nil}

  var commentStorage: TSP_Reference {
    get {return _storage._commentStorage ?? TSP_Reference()}
    set {_uniqueStorage()._commentStorage = newValue}
  }
  /// Returns true if `commentStorage` has been explicitly set.
  var hasCommentStorage: Bool {return _storage._commentStorage != nil}
  /// Clears the value of `commentStorage`. Subsequent reads from it will return its default value.
  mutating func clearCommentStorage() {_uniqueStorage()._commentStorage = nil}

  var conditionalStyleAppliedRule: UInt32 {
    get {return _storage._conditionalStyleAppliedRule ?? 0}
    set {_uniqueStorage()._conditionalStyleAppliedRule = newValue}
  }
  /// Returns true if `conditionalStyleAppliedRule` has been explicitly set.
  var hasConditionalStyleAppliedRule: Bool {return _storage._conditionalStyleAppliedRule != nil}
  /// Clears the value of `conditionalStyleAppliedRule`. Subsequent reads from it will return its default value.
  mutating func clearConditionalStyleAppliedRule() {_uniqueStorage()._conditionalStyleAppliedRule = nil}

  var importWarningSet: TST_ImportWarningSetArchive {
    get {return _storage._importWarningSet ?? TST_ImportWarningSetArchive()}
    set {_uniqueStorage()._importWarningSet = newValue}
  }
  /// Returns true if `importWarningSet` has been explicitly set.
  var hasImportWarningSet: Bool {return _storage._importWarningSet != nil}
  /// Clears the value of `importWarningSet`. Subsequent reads from it will return its default value.
  mutating func clearImportWarningSet() {_uniqueStorage()._importWarningSet = nil}

  var customFormatObject: TSK_CustomFormatArchive {
    get {return _storage._customFormatObject ?? TSK_CustomFormatArchive()}
    set {_uniqueStorage()._customFormatObject = newValue}
  }
  /// Returns true if `customFormatObject` has been explicitly set.
  var hasCustomFormatObject: Bool {return _storage._customFormatObject != nil}
  /// Clears the value of `customFormatObject`. Subsequent reads from it will return its default value.
  mutating func clearCustomFormatObject() {_uniqueStorage()._customFormatObject = nil}

  var cellBorder: TST_CellBorderArchive {
    get {return _storage._cellBorder ?? TST_CellBorderArchive()}
    set {_uniqueStorage()._cellBorder = newValue}
  }
  /// Returns true if `cellBorder` has been explicitly set.
  var hasCellBorder: Bool {return _storage._cellBorder != nil}
  /// Clears the value of `cellBorder`. Subsequent reads from it will return its default value.
  mutating func clearCellBorder() {_uniqueStorage()._cellBorder = nil}

  var cellSpec: TST_CellSpecArchive {
    get {return _storage._cellSpec ?? TST_CellSpecArchive()}
    set {_uniqueStorage()._cellSpec = newValue}
  }
  /// Returns true if `cellSpec` has been explicitly set.
  var hasCellSpec: Bool {return _storage._cellSpec != nil}
  /// Clears the value of `cellSpec`. Subsequent reads from it will return its default value.
  mutating func clearCellSpec() {_uniqueStorage()._cellSpec = nil}

  var cellFormatKind: UInt32 {
    get {return _storage._cellFormatKind ?? 0}
    set {_uniqueStorage()._cellFormatKind = newValue}
  }
  /// Returns true if `cellFormatKind` has been explicitly set.
  var hasCellFormatKind: Bool {return _storage._cellFormatKind != nil}
  /// Clears the value of `cellFormatKind`. Subsequent reads from it will return its default value.
  mutating func clearCellFormatKind() {_uniqueStorage()._cellFormatKind = nil}

  var textFormat: TSK_FormatStructArchive {
    get {return _storage._textFormat ?? TSK_FormatStructArchive()}
    set {_uniqueStorage()._textFormat = newValue}
  }
  /// Returns true if `textFormat` has been explicitly set.
  var hasTextFormat: Bool {return _storage._textFormat != nil}
  /// Clears the value of `textFormat`. Subsequent reads from it will return its default value.
  mutating func clearTextFormat() {_uniqueStorage()._textFormat = nil}

  var booleanFormat: TSK_FormatStructArchive {
    get {return _storage._booleanFormat ?? TSK_FormatStructArchive()}
    set {_uniqueStorage()._booleanFormat = newValue}
  }
  /// Returns true if `booleanFormat` has been explicitly set.
  var hasBooleanFormat: Bool {return _storage._booleanFormat != nil}
  /// Clears the value of `booleanFormat`. Subsequent reads from it will return its default value.
  mutating func clearBooleanFormat() {_uniqueStorage()._booleanFormat = nil}

  var decimalValueLow: UInt64 {
    get {return _storage._decimalValueLow ?? 0}
    set {_uniqueStorage()._decimalValueLow = newValue}
  }
  /// Returns true if `decimalValueLow` has been explicitly set.
  var hasDecimalValueLow: Bool {return _storage._decimalValueLow != nil}
  /// Clears the value of `decimalValueLow`. Subsequent reads from it will return its default value.
  mutating func clearDecimalValueLow() {_uniqueStorage()._decimalValueLow = nil}

  var decimalValueHigh: UInt64 {
    get {return _storage._decimalValueHigh ?? 0}
    set {_uniqueStorage()._decimalValueHigh = newValue}
  }
  /// Returns true if `decimalValueHigh` has been explicitly set.
  var hasDecimalValueHigh: Bool {return _storage._decimalValueHigh != nil}
  /// Clears the value of `decimalValueHigh`. Subsequent reads from it will return its default value.
  mutating func clearDecimalValueHigh() {_uniqueStorage()._decimalValueHigh = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_MergeRegionMapArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cellRange: [TST_CellRange] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TST_CellMapArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cellTiles: [TSP_Reference] {
    get {return _storage._cellTiles}
    set {_uniqueStorage()._cellTiles = newValue}
  }

  var uidBased: Bool {
    get {return _storage._uidBased ?? false}
    set {_uniqueStorage()._uidBased = newValue}
  }
  /// Returns true if `uidBased` has been explicitly set.
  var hasUidBased: Bool {return _storage._uidBased != nil}
  /// Clears the value of `uidBased`. Subsequent reads from it will return its default value.
  mutating func clearUidBased() {_uniqueStorage()._uidBased = nil}

  var expandedCellIds: [TSCE_CellCoordinateArchive] {
    get {return _storage._expandedCellIds}
    set {_uniqueStorage()._expandedCellIds = newValue}
  }

  var cellUidList: TST_CellUIDListArchive {
    get {return _storage._cellUidList ?? TST_CellUIDListArchive()}
    set {_uniqueStorage()._cellUidList = newValue}
  }
  /// Returns true if `cellUidList` has been explicitly set.
  var hasCellUidList: Bool {return _storage._cellUidList != nil}
  /// Clears the value of `cellUidList`. Subsequent reads from it will return its default value.
  mutating func clearCellUidList() {_uniqueStorage()._cellUidList = nil}

  var mergeUidRanges: [TSP_UUIDRectArchive] {
    get {return _storage._mergeUidRanges}
    set {_uniqueStorage()._mergeUidRanges = newValue}
  }

  var unmergeUidRanges: [TSP_UUIDRectArchive] {
    get {return _storage._unmergeUidRanges}
    set {_uniqueStorage()._unmergeUidRanges = newValue}
  }

  var mergeActions: [TST_MergeOperationArchive] {
    get {return _storage._mergeActions}
    set {_uniqueStorage()._mergeActions = newValue}
  }

  var mayModifyFormulasInCells: Bool {
    get {return _storage._mayModifyFormulasInCells ?? true}
    set {_uniqueStorage()._mayModifyFormulasInCells = newValue}
  }
  /// Returns true if `mayModifyFormulasInCells` has been explicitly set.
  var hasMayModifyFormulasInCells: Bool {return _storage._mayModifyFormulasInCells != nil}
  /// Clears the value of `mayModifyFormulasInCells`. Subsequent reads from it will return its default value.
  mutating func clearMayModifyFormulasInCells() {_uniqueStorage()._mayModifyFormulasInCells = nil}

  var mayModifyValuesReferencedByFormulas: Bool {
    get {return _storage._mayModifyValuesReferencedByFormulas ?? true}
    set {_uniqueStorage()._mayModifyValuesReferencedByFormulas = newValue}
  }
  /// Returns true if `mayModifyValuesReferencedByFormulas` has been explicitly set.
  var hasMayModifyValuesReferencedByFormulas: Bool {return _storage._mayModifyValuesReferencedByFormulas != nil}
  /// Clears the value of `mayModifyValuesReferencedByFormulas`. Subsequent reads from it will return its default value.
  mutating func clearMayModifyValuesReferencedByFormulas() {_uniqueStorage()._mayModifyValuesReferencedByFormulas = nil}

  var shouldResetSpillFormulas: Bool {
    get {return _storage._shouldResetSpillFormulas ?? true}
    set {_uniqueStorage()._shouldResetSpillFormulas = newValue}
  }
  /// Returns true if `shouldResetSpillFormulas` has been explicitly set.
  var hasShouldResetSpillFormulas: Bool {return _storage._shouldResetSpillFormulas != nil}
  /// Clears the value of `shouldResetSpillFormulas`. Subsequent reads from it will return its default value.
  mutating func clearShouldResetSpillFormulas() {_uniqueStorage()._shouldResetSpillFormulas = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CellListArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cells: [TST_CellListArchive.OptionalCell] = []

  var trailingEmptyCellCount: UInt32 {
    get {return _trailingEmptyCellCount ?? 0}
    set {_trailingEmptyCellCount = newValue}
  }
  /// Returns true if `trailingEmptyCellCount` has been explicitly set.
  var hasTrailingEmptyCellCount: Bool {return self._trailingEmptyCellCount != nil}
  /// Clears the value of `trailingEmptyCellCount`. Subsequent reads from it will return its default value.
  mutating func clearTrailingEmptyCellCount() {self._trailingEmptyCellCount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct OptionalCell: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var cell: TST_Cell {
      get {return _cell ?? TST_Cell()}
      set {_cell = newValue}
    }
    /// Returns true if `cell` has been explicitly set.
    var hasCell: Bool {return self._cell != nil}
    /// Clears the value of `cell`. Subsequent reads from it will return its default value.
    mutating func clearCell() {self._cell = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _cell: TST_Cell? = nil
  }

  init() {}

  fileprivate var _trailingEmptyCellCount: UInt32? = nil
}

struct TST_ConcurrentCellMapArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cellLists: [TSP_Reference] = []

  var uidBased: Bool {
    get {return _uidBased ?? false}
    set {_uidBased = newValue}
  }
  /// Returns true if `uidBased` has been explicitly set.
  var hasUidBased: Bool {return self._uidBased != nil}
  /// Clears the value of `uidBased`. Subsequent reads from it will return its default value.
  mutating func clearUidBased() {self._uidBased = nil}

  var mergeActions: [TST_MergeOperationArchive] = []

  var mayModifyFormulasInCells: Bool {
    get {return _mayModifyFormulasInCells ?? true}
    set {_mayModifyFormulasInCells = newValue}
  }
  /// Returns true if `mayModifyFormulasInCells` has been explicitly set.
  var hasMayModifyFormulasInCells: Bool {return self._mayModifyFormulasInCells != nil}
  /// Clears the value of `mayModifyFormulasInCells`. Subsequent reads from it will return its default value.
  mutating func clearMayModifyFormulasInCells() {self._mayModifyFormulasInCells = nil}

  var mayModifyValuesReferencedByFormulas: Bool {
    get {return _mayModifyValuesReferencedByFormulas ?? true}
    set {_mayModifyValuesReferencedByFormulas = newValue}
  }
  /// Returns true if `mayModifyValuesReferencedByFormulas` has been explicitly set.
  var hasMayModifyValuesReferencedByFormulas: Bool {return self._mayModifyValuesReferencedByFormulas != nil}
  /// Clears the value of `mayModifyValuesReferencedByFormulas`. Subsequent reads from it will return its default value.
  mutating func clearMayModifyValuesReferencedByFormulas() {self._mayModifyValuesReferencedByFormulas = nil}

  var affectsCellBorders: Bool {
    get {return _affectsCellBorders ?? true}
    set {_affectsCellBorders = newValue}
  }
  /// Returns true if `affectsCellBorders` has been explicitly set.
  var hasAffectsCellBorders: Bool {return self._affectsCellBorders != nil}
  /// Clears the value of `affectsCellBorders`. Subsequent reads from it will return its default value.
  mutating func clearAffectsCellBorders() {self._affectsCellBorders = nil}

  var skipDirtyingRanges: Bool {
    get {return _skipDirtyingRanges ?? false}
    set {_skipDirtyingRanges = newValue}
  }
  /// Returns true if `skipDirtyingRanges` has been explicitly set.
  var hasSkipDirtyingRanges: Bool {return self._skipDirtyingRanges != nil}
  /// Clears the value of `skipDirtyingRanges`. Subsequent reads from it will return its default value.
  mutating func clearSkipDirtyingRanges() {self._skipDirtyingRanges = nil}

  var shouldResetSpillFormulas: Bool {
    get {return _shouldResetSpillFormulas ?? true}
    set {_shouldResetSpillFormulas = newValue}
  }
  /// Returns true if `shouldResetSpillFormulas` has been explicitly set.
  var hasShouldResetSpillFormulas: Bool {return self._shouldResetSpillFormulas != nil}
  /// Clears the value of `shouldResetSpillFormulas`. Subsequent reads from it will return its default value.
  mutating func clearShouldResetSpillFormulas() {self._shouldResetSpillFormulas = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _uidBased: Bool? = nil
  fileprivate var _mayModifyFormulasInCells: Bool? = nil
  fileprivate var _mayModifyValuesReferencedByFormulas: Bool? = nil
  fileprivate var _affectsCellBorders: Bool? = nil
  fileprivate var _skipDirtyingRanges: Bool? = nil
  fileprivate var _shouldResetSpillFormulas: Bool? = nil
}

struct TST_ConcurrentCellListArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cells: [TST_ConcurrentCellListArchive.OptionalCell] = []

  var cellUidRange: TSP_UUIDRectArchive {
    get {return _cellUidRange ?? TSP_UUIDRectArchive()}
    set {_cellUidRange = newValue}
  }
  /// Returns true if `cellUidRange` has been explicitly set.
  var hasCellUidRange: Bool {return self._cellUidRange != nil}
  /// Clears the value of `cellUidRange`. Subsequent reads from it will return its default value.
  mutating func clearCellUidRange() {self._cellUidRange = nil}

  var cellRange: TST_CellRange {
    get {return _cellRange ?? TST_CellRange()}
    set {_cellRange = newValue}
  }
  /// Returns true if `cellRange` has been explicitly set.
  var hasCellRange: Bool {return self._cellRange != nil}
  /// Clears the value of `cellRange`. Subsequent reads from it will return its default value.
  mutating func clearCellRange() {self._cellRange = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct OptionalCell: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var cell: TST_Cell {
      get {return _cell ?? TST_Cell()}
      set {_cell = newValue}
    }
    /// Returns true if `cell` has been explicitly set.
    var hasCell: Bool {return self._cell != nil}
    /// Clears the value of `cell`. Subsequent reads from it will return its default value.
    mutating func clearCell() {self._cell = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _cell: TST_Cell? = nil
  }

  init() {}

  fileprivate var _cellUidRange: TSP_UUIDRectArchive? = nil
  fileprivate var _cellRange: TST_CellRange? = nil
}

struct TST_CellFormatAndValueArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var valueType: TST_CellValueType {
    get {return _storage._valueType ?? .emptyCellValueType}
    set {_uniqueStorage()._valueType = newValue}
  }
  /// Returns true if `valueType` has been explicitly set.
  var hasValueType: Bool {return _storage._valueType != nil}
  /// Clears the value of `valueType`. Subsequent reads from it will return its default value.
  mutating func clearValueType() {_uniqueStorage()._valueType = nil}

  var numberValue: Double {
    get {return _storage._numberValue ?? 0}
    set {_uniqueStorage()._numberValue = newValue}
  }
  /// Returns true if `numberValue` has been explicitly set.
  var hasNumberValue: Bool {return _storage._numberValue != nil}
  /// Clears the value of `numberValue`. Subsequent reads from it will return its default value.
  mutating func clearNumberValue() {_uniqueStorage()._numberValue = nil}

  var stringValue: String {
    get {return _storage._stringValue ?? String()}
    set {_uniqueStorage()._stringValue = newValue}
  }
  /// Returns true if `stringValue` has been explicitly set.
  var hasStringValue: Bool {return _storage._stringValue != nil}
  /// Clears the value of `stringValue`. Subsequent reads from it will return its default value.
  mutating func clearStringValue() {_uniqueStorage()._stringValue = nil}

  var boolValue: Bool {
    get {return _storage._boolValue ?? false}
    set {_uniqueStorage()._boolValue = newValue}
  }
  /// Returns true if `boolValue` has been explicitly set.
  var hasBoolValue: Bool {return _storage._boolValue != nil}
  /// Clears the value of `boolValue`. Subsequent reads from it will return its default value.
  mutating func clearBoolValue() {_uniqueStorage()._boolValue = nil}

  var richTextStorage: TSP_Reference {
    get {return _storage._richTextStorage ?? TSP_Reference()}
    set {_uniqueStorage()._richTextStorage = newValue}
  }
  /// Returns true if `richTextStorage` has been explicitly set.
  var hasRichTextStorage: Bool {return _storage._richTextStorage != nil}
  /// Clears the value of `richTextStorage`. Subsequent reads from it will return its default value.
  mutating func clearRichTextStorage() {_uniqueStorage()._richTextStorage = nil}

  var useAllSpareFormats: Bool {
    get {return _storage._useAllSpareFormats ?? false}
    set {_uniqueStorage()._useAllSpareFormats = newValue}
  }
  /// Returns true if `useAllSpareFormats` has been explicitly set.
  var hasUseAllSpareFormats: Bool {return _storage._useAllSpareFormats != nil}
  /// Clears the value of `useAllSpareFormats`. Subsequent reads from it will return its default value.
  mutating func clearUseAllSpareFormats() {_uniqueStorage()._useAllSpareFormats = nil}

  var explicitFlags: UInt32 {
    get {return _storage._explicitFlags ?? 0}
    set {_uniqueStorage()._explicitFlags = newValue}
  }
  /// Returns true if `explicitFlags` has been explicitly set.
  var hasExplicitFlags: Bool {return _storage._explicitFlags != nil}
  /// Clears the value of `explicitFlags`. Subsequent reads from it will return its default value.
  mutating func clearExplicitFlags() {_uniqueStorage()._explicitFlags = nil}

  var cellFormatKind: UInt32 {
    get {return _storage._cellFormatKind ?? 0}
    set {_uniqueStorage()._cellFormatKind = newValue}
  }
  /// Returns true if `cellFormatKind` has been explicitly set.
  var hasCellFormatKind: Bool {return _storage._cellFormatKind != nil}
  /// Clears the value of `cellFormatKind`. Subsequent reads from it will return its default value.
  mutating func clearCellFormatKind() {_uniqueStorage()._cellFormatKind = nil}

  var numberFormat: TSK_FormatStructArchive {
    get {return _storage._numberFormat ?? TSK_FormatStructArchive()}
    set {_uniqueStorage()._numberFormat = newValue}
  }
  /// Returns true if `numberFormat` has been explicitly set.
  var hasNumberFormat: Bool {return _storage._numberFormat != nil}
  /// Clears the value of `numberFormat`. Subsequent reads from it will return its default value.
  mutating func clearNumberFormat() {_uniqueStorage()._numberFormat = nil}

  var currencyFormat: TSK_FormatStructArchive {
    get {return _storage._currencyFormat ?? TSK_FormatStructArchive()}
    set {_uniqueStorage()._currencyFormat = newValue}
  }
  /// Returns true if `currencyFormat` has been explicitly set.
  var hasCurrencyFormat: Bool {return _storage._currencyFormat != nil}
  /// Clears the value of `currencyFormat`. Subsequent reads from it will return its default value.
  mutating func clearCurrencyFormat() {_uniqueStorage()._currencyFormat = nil}

  var dateFormat: TSK_FormatStructArchive {
    get {return _storage._dateFormat ?? TSK_FormatStructArchive()}
    set {_uniqueStorage()._dateFormat = newValue}
  }
  /// Returns true if `dateFormat` has been explicitly set.
  var hasDateFormat: Bool {return _storage._dateFormat != nil}
  /// Clears the value of `dateFormat`. Subsequent reads from it will return its default value.
  mutating func clearDateFormat() {_uniqueStorage()._dateFormat = nil}

  var durationFormat: TSK_FormatStructArchive {
    get {return _storage._durationFormat ?? TSK_FormatStructArchive()}
    set {_uniqueStorage()._durationFormat = newValue}
  }
  /// Returns true if `durationFormat` has been explicitly set.
  var hasDurationFormat: Bool {return _storage._durationFormat != nil}
  /// Clears the value of `durationFormat`. Subsequent reads from it will return its default value.
  mutating func clearDurationFormat() {_uniqueStorage()._durationFormat = nil}

  var textFormat: TSK_FormatStructArchive {
    get {return _storage._textFormat ?? TSK_FormatStructArchive()}
    set {_uniqueStorage()._textFormat = newValue}
  }
  /// Returns true if `textFormat` has been explicitly set.
  var hasTextFormat: Bool {return _storage._textFormat != nil}
  /// Clears the value of `textFormat`. Subsequent reads from it will return its default value.
  mutating func clearTextFormat() {_uniqueStorage()._textFormat = nil}

  var booleanFormat: TSK_FormatStructArchive {
    get {return _storage._booleanFormat ?? TSK_FormatStructArchive()}
    set {_uniqueStorage()._booleanFormat = newValue}
  }
  /// Returns true if `booleanFormat` has been explicitly set.
  var hasBooleanFormat: Bool {return _storage._booleanFormat != nil}
  /// Clears the value of `booleanFormat`. Subsequent reads from it will return its default value.
  mutating func clearBooleanFormat() {_uniqueStorage()._booleanFormat = nil}

  var formattedValue: String {
    get {return _storage._formattedValue ?? String()}
    set {_uniqueStorage()._formattedValue = newValue}
  }
  /// Returns true if `formattedValue` has been explicitly set.
  var hasFormattedValue: Bool {return _storage._formattedValue != nil}
  /// Clears the value of `formattedValue`. Subsequent reads from it will return its default value.
  mutating func clearFormattedValue() {_uniqueStorage()._formattedValue = nil}

  var formattedRichTextValue: TSP_Reference {
    get {return _storage._formattedRichTextValue ?? TSP_Reference()}
    set {_uniqueStorage()._formattedRichTextValue = newValue}
  }
  /// Returns true if `formattedRichTextValue` has been explicitly set.
  var hasFormattedRichTextValue: Bool {return _storage._formattedRichTextValue != nil}
  /// Clears the value of `formattedRichTextValue`. Subsequent reads from it will return its default value.
  mutating func clearFormattedRichTextValue() {_uniqueStorage()._formattedRichTextValue = nil}

  var applySpareFormatOnly: Bool {
    get {return _storage._applySpareFormatOnly ?? false}
    set {_uniqueStorage()._applySpareFormatOnly = newValue}
  }
  /// Returns true if `applySpareFormatOnly` has been explicitly set.
  var hasApplySpareFormatOnly: Bool {return _storage._applySpareFormatOnly != nil}
  /// Clears the value of `applySpareFormatOnly`. Subsequent reads from it will return its default value.
  mutating func clearApplySpareFormatOnly() {_uniqueStorage()._applySpareFormatOnly = nil}

  var spareFormatType: Bool {
    get {return _storage._spareFormatType ?? false}
    set {_uniqueStorage()._spareFormatType = newValue}
  }
  /// Returns true if `spareFormatType` has been explicitly set.
  var hasSpareFormatType: Bool {return _storage._spareFormatType != nil}
  /// Clears the value of `spareFormatType`. Subsequent reads from it will return its default value.
  mutating func clearSpareFormatType() {_uniqueStorage()._spareFormatType = nil}

  var decimalLow: UInt64 {
    get {return _storage._decimalLow ?? 0}
    set {_uniqueStorage()._decimalLow = newValue}
  }
  /// Returns true if `decimalLow` has been explicitly set.
  var hasDecimalLow: Bool {return _storage._decimalLow != nil}
  /// Clears the value of `decimalLow`. Subsequent reads from it will return its default value.
  mutating func clearDecimalLow() {_uniqueStorage()._decimalLow = nil}

  var decimalHigh: UInt64 {
    get {return _storage._decimalHigh ?? 0}
    set {_uniqueStorage()._decimalHigh = newValue}
  }
  /// Returns true if `decimalHigh` has been explicitly set.
  var hasDecimalHigh: Bool {return _storage._decimalHigh != nil}
  /// Clears the value of `decimalHigh`. Subsequent reads from it will return its default value.
  mutating func clearDecimalHigh() {_uniqueStorage()._decimalHigh = nil}

  var suppressApplyValue: Bool {
    get {return _storage._suppressApplyValue ?? false}
    set {_uniqueStorage()._suppressApplyValue = newValue}
  }
  /// Returns true if `suppressApplyValue` has been explicitly set.
  var hasSuppressApplyValue: Bool {return _storage._suppressApplyValue != nil}
  /// Clears the value of `suppressApplyValue`. Subsequent reads from it will return its default value.
  mutating func clearSuppressApplyValue() {_uniqueStorage()._suppressApplyValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CellSpecArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var interactionType: UInt32 {
    get {return _storage._interactionType ?? 0}
    set {_uniqueStorage()._interactionType = newValue}
  }
  /// Returns true if `interactionType` has been explicitly set.
  var hasInteractionType: Bool {return _storage._interactionType != nil}
  /// Clears the value of `interactionType`. Subsequent reads from it will return its default value.
  mutating func clearInteractionType() {_uniqueStorage()._interactionType = nil}

  var formula: TSCE_FormulaArchive {
    get {return _storage._formula ?? TSCE_FormulaArchive()}
    set {_uniqueStorage()._formula = newValue}
  }
  /// Returns true if `formula` has been explicitly set.
  var hasFormula: Bool {return _storage._formula != nil}
  /// Clears the value of `formula`. Subsequent reads from it will return its default value.
  mutating func clearFormula() {_uniqueStorage()._formula = nil}

  var rangeControlMin: Double {
    get {return _storage._rangeControlMin ?? 0}
    set {_uniqueStorage()._rangeControlMin = newValue}
  }
  /// Returns true if `rangeControlMin` has been explicitly set.
  var hasRangeControlMin: Bool {return _storage._rangeControlMin != nil}
  /// Clears the value of `rangeControlMin`. Subsequent reads from it will return its default value.
  mutating func clearRangeControlMin() {_uniqueStorage()._rangeControlMin = nil}

  var rangeControlMax: Double {
    get {return _storage._rangeControlMax ?? 0}
    set {_uniqueStorage()._rangeControlMax = newValue}
  }
  /// Returns true if `rangeControlMax` has been explicitly set.
  var hasRangeControlMax: Bool {return _storage._rangeControlMax != nil}
  /// Clears the value of `rangeControlMax`. Subsequent reads from it will return its default value.
  mutating func clearRangeControlMax() {_uniqueStorage()._rangeControlMax = nil}

  var rangeControlInc: Double {
    get {return _storage._rangeControlInc ?? 0}
    set {_uniqueStorage()._rangeControlInc = newValue}
  }
  /// Returns true if `rangeControlInc` has been explicitly set.
  var hasRangeControlInc: Bool {return _storage._rangeControlInc != nil}
  /// Clears the value of `rangeControlInc`. Subsequent reads from it will return its default value.
  mutating func clearRangeControlInc() {_uniqueStorage()._rangeControlInc = nil}

  var chooserControlPopupModel: TSP_Reference {
    get {return _storage._chooserControlPopupModel ?? TSP_Reference()}
    set {_uniqueStorage()._chooserControlPopupModel = newValue}
  }
  /// Returns true if `chooserControlPopupModel` has been explicitly set.
  var hasChooserControlPopupModel: Bool {return _storage._chooserControlPopupModel != nil}
  /// Clears the value of `chooserControlPopupModel`. Subsequent reads from it will return its default value.
  mutating func clearChooserControlPopupModel() {_uniqueStorage()._chooserControlPopupModel = nil}

  var chooserControlStartWFirst: Bool {
    get {return _storage._chooserControlStartWFirst ?? false}
    set {_uniqueStorage()._chooserControlStartWFirst = newValue}
  }
  /// Returns true if `chooserControlStartWFirst` has been explicitly set.
  var hasChooserControlStartWFirst: Bool {return _storage._chooserControlStartWFirst != nil}
  /// Clears the value of `chooserControlStartWFirst`. Subsequent reads from it will return its default value.
  mutating func clearChooserControlStartWFirst() {_uniqueStorage()._chooserControlStartWFirst = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var categorySummaryShouldDisplayLabel: Bool {
    get {return _storage._categorySummaryShouldDisplayLabel ?? false}
    set {_uniqueStorage()._categorySummaryShouldDisplayLabel = newValue}
  }
  /// Returns true if `categorySummaryShouldDisplayLabel` has been explicitly set.
  var hasCategorySummaryShouldDisplayLabel: Bool {return _storage._categorySummaryShouldDisplayLabel != nil}
  /// Clears the value of `categorySummaryShouldDisplayLabel`. Subsequent reads from it will return its default value.
  mutating func clearCategorySummaryShouldDisplayLabel() {_uniqueStorage()._categorySummaryShouldDisplayLabel = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommentStorageWrapperArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var commentStorage: TSP_Reference {
    get {return _commentStorage ?? TSP_Reference()}
    set {_commentStorage = newValue}
  }
  /// Returns true if `commentStorage` has been explicitly set.
  var hasCommentStorage: Bool {return self._commentStorage != nil}
  /// Clears the value of `commentStorage`. Subsequent reads from it will return its default value.
  mutating func clearCommentStorage() {self._commentStorage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commentStorage: TSP_Reference? = nil
}

struct TST_CellDiffArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var propertyMapToSet: TSS_CommandPropertyMapArchive {
    get {return _propertyMapToSet ?? TSS_CommandPropertyMapArchive()}
    set {_propertyMapToSet = newValue}
  }
  /// Returns true if `propertyMapToSet` has been explicitly set.
  var hasPropertyMapToSet: Bool {return self._propertyMapToSet != nil}
  /// Clears the value of `propertyMapToSet`. Subsequent reads from it will return its default value.
  mutating func clearPropertyMapToSet() {self._propertyMapToSet = nil}

  var propertyMapToReset: TSS_CommandPropertyMapArchive {
    get {return _propertyMapToReset ?? TSS_CommandPropertyMapArchive()}
    set {_propertyMapToReset = newValue}
  }
  /// Returns true if `propertyMapToReset` has been explicitly set.
  var hasPropertyMapToReset: Bool {return self._propertyMapToReset != nil}
  /// Clears the value of `propertyMapToReset`. Subsequent reads from it will return its default value.
  mutating func clearPropertyMapToReset() {self._propertyMapToReset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _propertyMapToSet: TSS_CommandPropertyMapArchive? = nil
  fileprivate var _propertyMapToReset: TSS_CommandPropertyMapArchive? = nil
}

struct TST_CellDiffArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var largeArray: TSP_LargeArray {
    get {return _largeArray ?? TSP_LargeArray()}
    set {_largeArray = newValue}
  }
  /// Returns true if `largeArray` has been explicitly set.
  var hasLargeArray: Bool {return self._largeArray != nil}
  /// Clears the value of `largeArray`. Subsequent reads from it will return its default value.
  mutating func clearLargeArray() {self._largeArray = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _largeArray: TSP_LargeArray? = nil
}

struct TST_CellDiffArraySegment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var largeArraySegment: TSP_LargeArraySegment {
    get {return _largeArraySegment ?? TSP_LargeArraySegment()}
    set {_largeArraySegment = newValue}
  }
  /// Returns true if `largeArraySegment` has been explicitly set.
  var hasLargeArraySegment: Bool {return self._largeArraySegment != nil}
  /// Clears the value of `largeArraySegment`. Subsequent reads from it will return its default value.
  mutating func clearLargeArraySegment() {self._largeArraySegment = nil}

  var elements: [TST_CellDiffArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _largeArraySegment: TSP_LargeArraySegment? = nil
}

struct TST_CellDiffMapArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uidBased: Bool {
    get {return _uidBased ?? false}
    set {_uidBased = newValue}
  }
  /// Returns true if `uidBased` has been explicitly set.
  var hasUidBased: Bool {return self._uidBased != nil}
  /// Clears the value of `uidBased`. Subsequent reads from it will return its default value.
  mutating func clearUidBased() {self._uidBased = nil}

  var expandedCellIds: [TSCE_CellCoordinateArchive] = []

  var cellUids: TST_CellUIDListArchive {
    get {return _cellUids ?? TST_CellUIDListArchive()}
    set {_cellUids = newValue}
  }
  /// Returns true if `cellUids` has been explicitly set.
  var hasCellUids: Bool {return self._cellUids != nil}
  /// Clears the value of `cellUids`. Subsequent reads from it will return its default value.
  mutating func clearCellUids() {self._cellUids = nil}

  var cellDiffArray: TSP_Reference {
    get {return _cellDiffArray ?? TSP_Reference()}
    set {_cellDiffArray = newValue}
  }
  /// Returns true if `cellDiffArray` has been explicitly set.
  var hasCellDiffArray: Bool {return self._cellDiffArray != nil}
  /// Clears the value of `cellDiffArray`. Subsequent reads from it will return its default value.
  mutating func clearCellDiffArray() {self._cellDiffArray = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _uidBased: Bool? = nil
  fileprivate var _cellUids: TST_CellUIDListArchive? = nil
  fileprivate var _cellDiffArray: TSP_Reference? = nil
}

struct TST_HierarchicalCellDiffMapArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var numRowRules: Int32 {
    get {return _numRowRules ?? 0}
    set {_numRowRules = newValue}
  }
  /// Returns true if `numRowRules` has been explicitly set.
  var hasNumRowRules: Bool {return self._numRowRules != nil}
  /// Clears the value of `numRowRules`. Subsequent reads from it will return its default value.
  mutating func clearNumRowRules() {self._numRowRules = nil}

  var numColumnRules: Int32 {
    get {return _numColumnRules ?? 0}
    set {_numColumnRules = newValue}
  }
  /// Returns true if `numColumnRules` has been explicitly set.
  var hasNumColumnRules: Bool {return self._numColumnRules != nil}
  /// Clears the value of `numColumnRules`. Subsequent reads from it will return its default value.
  mutating func clearNumColumnRules() {self._numColumnRules = nil}

  var rowHeaderUids: [TSP_UUID] = []

  var columnHeaderUids: [TSP_UUID] = []

  var aggregateRuleUids: [TSP_UUID] = []

  var activeFlatteningDimension: TST_TableDimensionArchive {
    get {return _activeFlatteningDimension ?? .dimensionNeither}
    set {_activeFlatteningDimension = newValue}
  }
  /// Returns true if `activeFlatteningDimension` has been explicitly set.
  var hasActiveFlatteningDimension: Bool {return self._activeFlatteningDimension != nil}
  /// Clears the value of `activeFlatteningDimension`. Subsequent reads from it will return its default value.
  mutating func clearActiveFlatteningDimension() {self._activeFlatteningDimension = nil}

  var rowValueUids: [TSP_UUID] = []

  var rowLevelPreorder: [UInt32] = []

  var columnValueUids: [TSP_UUID] = []

  var columnLevelPreorder: [UInt32] = []

  var cellDiffStorage: [TST_HierarchicalCellDiffMapArchive.BoxedRow] = []

  var rowSizes: [Double] = []

  var columnSizes: [Double] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct BoxedRow: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var columnIndexSet: TSP_IndexSet {
      get {return _columnIndexSet ?? TSP_IndexSet()}
      set {_columnIndexSet = newValue}
    }
    /// Returns true if `columnIndexSet` has been explicitly set.
    var hasColumnIndexSet: Bool {return self._columnIndexSet != nil}
    /// Clears the value of `columnIndexSet`. Subsequent reads from it will return its default value.
    mutating func clearColumnIndexSet() {self._columnIndexSet = nil}

    var cellDiffList: [TST_CellDiffArchive] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _columnIndexSet: TSP_IndexSet? = nil
  }

  init() {}

  fileprivate var _numRowRules: Int32? = nil
  fileprivate var _numColumnRules: Int32? = nil
  fileprivate var _activeFlatteningDimension: TST_TableDimensionArchive? = nil
}

struct TST_DoubleStyleMapArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var capacity: UInt32 {
    get {return _capacity ?? 0}
    set {_capacity = newValue}
  }
  /// Returns true if `capacity` has been explicitly set.
  var hasCapacity: Bool {return self._capacity != nil}
  /// Clears the value of `capacity`. Subsequent reads from it will return its default value.
  mutating func clearCapacity() {self._capacity = nil}

  var count: UInt32 {
    get {return _count ?? 0}
    set {_count = newValue}
  }
  /// Returns true if `count` has been explicitly set.
  var hasCount: Bool {return self._count != nil}
  /// Clears the value of `count`. Subsequent reads from it will return its default value.
  mutating func clearCount() {self._count = nil}

  var cellMapEntry: [TST_DoubleStyleMapArchive.DoubleStyleMapEntryArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct DoubleStyleMapEntryArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var cellID: TST_CellID {
      get {return _cellID ?? TST_CellID()}
      set {_cellID = newValue}
    }
    /// Returns true if `cellID` has been explicitly set.
    var hasCellID: Bool {return self._cellID != nil}
    /// Clears the value of `cellID`. Subsequent reads from it will return its default value.
    mutating func clearCellID() {self._cellID = nil}

    var oldStyle: TSP_Reference {
      get {return _oldStyle ?? TSP_Reference()}
      set {_oldStyle = newValue}
    }
    /// Returns true if `oldStyle` has been explicitly set.
    var hasOldStyle: Bool {return self._oldStyle != nil}
    /// Clears the value of `oldStyle`. Subsequent reads from it will return its default value.
    mutating func clearOldStyle() {self._oldStyle = nil}

    var newStyle: TSP_Reference {
      get {return _newStyle ?? TSP_Reference()}
      set {_newStyle = newValue}
    }
    /// Returns true if `newStyle` has been explicitly set.
    var hasNewStyle: Bool {return self._newStyle != nil}
    /// Clears the value of `newStyle`. Subsequent reads from it will return its default value.
    mutating func clearNewStyle() {self._newStyle = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _cellID: TST_CellID? = nil
    fileprivate var _oldStyle: TSP_Reference? = nil
    fileprivate var _newStyle: TSP_Reference? = nil
  }

  init() {}

  fileprivate var _capacity: UInt32? = nil
  fileprivate var _count: UInt32? = nil
}

struct TST_StyleTableMapArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var capacity: UInt32 {
    get {return _capacity ?? 0}
    set {_capacity = newValue}
  }
  /// Returns true if `capacity` has been explicitly set.
  var hasCapacity: Bool {return self._capacity != nil}
  /// Clears the value of `capacity`. Subsequent reads from it will return its default value.
  mutating func clearCapacity() {self._capacity = nil}

  var count: UInt32 {
    get {return _count ?? 0}
    set {_count = newValue}
  }
  /// Returns true if `count` has been explicitly set.
  var hasCount: Bool {return self._count != nil}
  /// Clears the value of `count`. Subsequent reads from it will return its default value.
  mutating func clearCount() {self._count = nil}

  var mapEntry: [TST_StyleTableMapArchive.StyleTableMapEntryArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct StyleTableMapEntryArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var key: UInt32 {
      get {return _key ?? 0}
      set {_key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    var hasKey: Bool {return self._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    mutating func clearKey() {self._key = nil}

    var oldStyle: TSP_Reference {
      get {return _oldStyle ?? TSP_Reference()}
      set {_oldStyle = newValue}
    }
    /// Returns true if `oldStyle` has been explicitly set.
    var hasOldStyle: Bool {return self._oldStyle != nil}
    /// Clears the value of `oldStyle`. Subsequent reads from it will return its default value.
    mutating func clearOldStyle() {self._oldStyle = nil}

    var newStyle: TSP_Reference {
      get {return _newStyle ?? TSP_Reference()}
      set {_newStyle = newValue}
    }
    /// Returns true if `newStyle` has been explicitly set.
    var hasNewStyle: Bool {return self._newStyle != nil}
    /// Clears the value of `newStyle`. Subsequent reads from it will return its default value.
    mutating func clearNewStyle() {self._newStyle = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _key: UInt32? = nil
    fileprivate var _oldStyle: TSP_Reference? = nil
    fileprivate var _newStyle: TSP_Reference? = nil
  }

  init() {}

  fileprivate var _capacity: UInt32? = nil
  fileprivate var _count: UInt32? = nil
}

struct TST_SelectionArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// NOTE: This field was marked as deprecated in the .proto file.
  var tableModel: TSP_Reference {
    get {return _storage._tableModel ?? TSP_Reference()}
    set {_uniqueStorage()._tableModel = newValue}
  }
  /// Returns true if `tableModel` has been explicitly set.
  var hasTableModel: Bool {return _storage._tableModel != nil}
  /// Clears the value of `tableModel`. Subsequent reads from it will return its default value.
  mutating func clearTableModel() {_uniqueStorage()._tableModel = nil}

  var selectionType: TST_SelectionTypeArchive {
    get {return _storage._selectionType ?? .deprecatedCellSelectionType}
    set {_uniqueStorage()._selectionType = newValue}
  }
  /// Returns true if `selectionType` has been explicitly set.
  var hasSelectionType: Bool {return _storage._selectionType != nil}
  /// Clears the value of `selectionType`. Subsequent reads from it will return its default value.
  mutating func clearSelectionType() {_uniqueStorage()._selectionType = nil}

  var anchorCell: TST_CellID {
    get {return _storage._anchorCell ?? TST_CellID()}
    set {_uniqueStorage()._anchorCell = newValue}
  }
  /// Returns true if `anchorCell` has been explicitly set.
  var hasAnchorCell: Bool {return _storage._anchorCell != nil}
  /// Clears the value of `anchorCell`. Subsequent reads from it will return its default value.
  mutating func clearAnchorCell() {_uniqueStorage()._anchorCell = nil}

  var cellRanges: [TST_CellRange] {
    get {return _storage._cellRanges}
    set {_uniqueStorage()._cellRanges = newValue}
  }

  var baseRanges: [TST_CellRange] {
    get {return _storage._baseRanges}
    set {_uniqueStorage()._baseRanges = newValue}
  }

  var cursorCell: TST_CellID {
    get {return _storage._cursorCell ?? TST_CellID()}
    set {_uniqueStorage()._cursorCell = newValue}
  }
  /// Returns true if `cursorCell` has been explicitly set.
  var hasCursorCell: Bool {return _storage._cursorCell != nil}
  /// Clears the value of `cursorCell`. Subsequent reads from it will return its default value.
  mutating func clearCursorCell() {_uniqueStorage()._cursorCell = nil}

  var tableInfo: TSP_Reference {
    get {return _storage._tableInfo ?? TSP_Reference()}
    set {_uniqueStorage()._tableInfo = newValue}
  }
  /// Returns true if `tableInfo` has been explicitly set.
  var hasTableInfo: Bool {return _storage._tableInfo != nil}
  /// Clears the value of `tableInfo`. Subsequent reads from it will return its default value.
  mutating func clearTableInfo() {_uniqueStorage()._tableInfo = nil}

  var cellUidRegion: TST_CellUIDRegionArchive {
    get {return _storage._cellUidRegion ?? TST_CellUIDRegionArchive()}
    set {_uniqueStorage()._cellUidRegion = newValue}
  }
  /// Returns true if `cellUidRegion` has been explicitly set.
  var hasCellUidRegion: Bool {return _storage._cellUidRegion != nil}
  /// Clears the value of `cellUidRegion`. Subsequent reads from it will return its default value.
  mutating func clearCellUidRegion() {_uniqueStorage()._cellUidRegion = nil}

  var baseUidRegion: TST_CellUIDRegionArchive {
    get {return _storage._baseUidRegion ?? TST_CellUIDRegionArchive()}
    set {_uniqueStorage()._baseUidRegion = newValue}
  }
  /// Returns true if `baseUidRegion` has been explicitly set.
  var hasBaseUidRegion: Bool {return _storage._baseUidRegion != nil}
  /// Clears the value of `baseUidRegion`. Subsequent reads from it will return its default value.
  mutating func clearBaseUidRegion() {_uniqueStorage()._baseUidRegion = nil}

  var anchorCellUid: TSP_UUIDCoordArchive {
    get {return _storage._anchorCellUid ?? TSP_UUIDCoordArchive()}
    set {_uniqueStorage()._anchorCellUid = newValue}
  }
  /// Returns true if `anchorCellUid` has been explicitly set.
  var hasAnchorCellUid: Bool {return _storage._anchorCellUid != nil}
  /// Clears the value of `anchorCellUid`. Subsequent reads from it will return its default value.
  mutating func clearAnchorCellUid() {_uniqueStorage()._anchorCellUid = nil}

  var cursorCellUid: TSP_UUIDCoordArchive {
    get {return _storage._cursorCellUid ?? TSP_UUIDCoordArchive()}
    set {_uniqueStorage()._cursorCellUid = newValue}
  }
  /// Returns true if `cursorCellUid` has been explicitly set.
  var hasCursorCellUid: Bool {return _storage._cursorCellUid != nil}
  /// Clears the value of `cursorCellUid`. Subsequent reads from it will return its default value.
  mutating func clearCursorCellUid() {_uniqueStorage()._cursorCellUid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_DeathhawkRdar39989167CellSelectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tableInfo: TSP_Reference {
    get {return _tableInfo ?? TSP_Reference()}
    set {_tableInfo = newValue}
  }
  /// Returns true if `tableInfo` has been explicitly set.
  var hasTableInfo: Bool {return self._tableInfo != nil}
  /// Clears the value of `tableInfo`. Subsequent reads from it will return its default value.
  mutating func clearTableInfo() {self._tableInfo = nil}

  var selectionType: TST_SelectionTypeArchive {
    get {return _selectionType ?? .deprecatedCellSelectionType}
    set {_selectionType = newValue}
  }
  /// Returns true if `selectionType` has been explicitly set.
  var hasSelectionType: Bool {return self._selectionType != nil}
  /// Clears the value of `selectionType`. Subsequent reads from it will return its default value.
  mutating func clearSelectionType() {self._selectionType = nil}

  var cellUidRegion: TST_CellUIDRegionArchive {
    get {return _cellUidRegion ?? TST_CellUIDRegionArchive()}
    set {_cellUidRegion = newValue}
  }
  /// Returns true if `cellUidRegion` has been explicitly set.
  var hasCellUidRegion: Bool {return self._cellUidRegion != nil}
  /// Clears the value of `cellUidRegion`. Subsequent reads from it will return its default value.
  mutating func clearCellUidRegion() {self._cellUidRegion = nil}

  var baseUidRegion: TST_CellUIDRegionArchive {
    get {return _baseUidRegion ?? TST_CellUIDRegionArchive()}
    set {_baseUidRegion = newValue}
  }
  /// Returns true if `baseUidRegion` has been explicitly set.
  var hasBaseUidRegion: Bool {return self._baseUidRegion != nil}
  /// Clears the value of `baseUidRegion`. Subsequent reads from it will return its default value.
  mutating func clearBaseUidRegion() {self._baseUidRegion = nil}

  var anchorCellUid: TSP_UUIDCoordArchive {
    get {return _anchorCellUid ?? TSP_UUIDCoordArchive()}
    set {_anchorCellUid = newValue}
  }
  /// Returns true if `anchorCellUid` has been explicitly set.
  var hasAnchorCellUid: Bool {return self._anchorCellUid != nil}
  /// Clears the value of `anchorCellUid`. Subsequent reads from it will return its default value.
  mutating func clearAnchorCellUid() {self._anchorCellUid = nil}

  var cursorCellUid: TSP_UUIDCoordArchive {
    get {return _cursorCellUid ?? TSP_UUIDCoordArchive()}
    set {_cursorCellUid = newValue}
  }
  /// Returns true if `cursorCellUid` has been explicitly set.
  var hasCursorCellUid: Bool {return self._cursorCellUid != nil}
  /// Clears the value of `cursorCellUid`. Subsequent reads from it will return its default value.
  mutating func clearCursorCellUid() {self._cursorCellUid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tableInfo: TSP_Reference? = nil
  fileprivate var _selectionType: TST_SelectionTypeArchive? = nil
  fileprivate var _cellUidRegion: TST_CellUIDRegionArchive? = nil
  fileprivate var _baseUidRegion: TST_CellUIDRegionArchive? = nil
  fileprivate var _anchorCellUid: TSP_UUIDCoordArchive? = nil
  fileprivate var _cursorCellUid: TSP_UUIDCoordArchive? = nil
}

struct TST_StrokeSelectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mask: Int32 {
    get {return _mask ?? 0}
    set {_mask = newValue}
  }
  /// Returns true if `mask` has been explicitly set.
  var hasMask: Bool {return self._mask != nil}
  /// Clears the value of `mask`. Subsequent reads from it will return its default value.
  mutating func clearMask() {self._mask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mask: Int32? = nil
}

struct TST_ControlCellSelectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TST_StockCellSelectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TST_TableNameSelectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TST_AutofillSelectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sourceCellRange: TST_CellRange {
    get {return _sourceCellRange ?? TST_CellRange()}
    set {_sourceCellRange = newValue}
  }
  /// Returns true if `sourceCellRange` has been explicitly set.
  var hasSourceCellRange: Bool {return self._sourceCellRange != nil}
  /// Clears the value of `sourceCellRange`. Subsequent reads from it will return its default value.
  mutating func clearSourceCellRange() {self._sourceCellRange = nil}

  var targetCellRange: TST_CellRange {
    get {return _targetCellRange ?? TST_CellRange()}
    set {_targetCellRange = newValue}
  }
  /// Returns true if `targetCellRange` has been explicitly set.
  var hasTargetCellRange: Bool {return self._targetCellRange != nil}
  /// Clears the value of `targetCellRange`. Subsequent reads from it will return its default value.
  mutating func clearTargetCellRange() {self._targetCellRange = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sourceCellRange: TST_CellRange? = nil
  fileprivate var _targetCellRange: TST_CellRange? = nil
}

struct TST_FilterRulePrePivotArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var predicate: TST_FormulaPredicatePrePivotArchive {
    get {return _predicate ?? TST_FormulaPredicatePrePivotArchive()}
    set {_predicate = newValue}
  }
  /// Returns true if `predicate` has been explicitly set.
  var hasPredicate: Bool {return self._predicate != nil}
  /// Clears the value of `predicate`. Subsequent reads from it will return its default value.
  mutating func clearPredicate() {self._predicate = nil}

  var disabled: Bool {
    get {return _disabled ?? false}
    set {_disabled = newValue}
  }
  /// Returns true if `disabled` has been explicitly set.
  var hasDisabled: Bool {return self._disabled != nil}
  /// Clears the value of `disabled`. Subsequent reads from it will return its default value.
  mutating func clearDisabled() {self._disabled = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _predicate: TST_FormulaPredicatePrePivotArchive? = nil
  fileprivate var _disabled: Bool? = nil
}

struct TST_FilterRuleArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var predicate: TST_FormulaPredicateArchive {
    get {return _predicate ?? TST_FormulaPredicateArchive()}
    set {_predicate = newValue}
  }
  /// Returns true if `predicate` has been explicitly set.
  var hasPredicate: Bool {return self._predicate != nil}
  /// Clears the value of `predicate`. Subsequent reads from it will return its default value.
  mutating func clearPredicate() {self._predicate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _predicate: TST_FormulaPredicateArchive? = nil
}

struct TST_TableStyleArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_StyleArchive {
    get {return _super ?? TSS_StyleArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var overrideCount: UInt32 {
    get {return _overrideCount ?? 0}
    set {_overrideCount = newValue}
  }
  /// Returns true if `overrideCount` has been explicitly set.
  var hasOverrideCount: Bool {return self._overrideCount != nil}
  /// Clears the value of `overrideCount`. Subsequent reads from it will return its default value.
  mutating func clearOverrideCount() {self._overrideCount = nil}

  var tableProperties: TST_TableStylePropertiesArchive {
    get {return _tableProperties ?? TST_TableStylePropertiesArchive()}
    set {_tableProperties = newValue}
  }
  /// Returns true if `tableProperties` has been explicitly set.
  var hasTableProperties: Bool {return self._tableProperties != nil}
  /// Clears the value of `tableProperties`. Subsequent reads from it will return its default value.
  mutating func clearTableProperties() {self._tableProperties = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSS_StyleArchive? = nil
  fileprivate var _overrideCount: UInt32? = nil
  fileprivate var _tableProperties: TST_TableStylePropertiesArchive? = nil
}

struct TST_CellStyleArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_StyleArchive {
    get {return _super ?? TSS_StyleArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var overrideCount: UInt32 {
    get {return _overrideCount ?? 0}
    set {_overrideCount = newValue}
  }
  /// Returns true if `overrideCount` has been explicitly set.
  var hasOverrideCount: Bool {return self._overrideCount != nil}
  /// Clears the value of `overrideCount`. Subsequent reads from it will return its default value.
  mutating func clearOverrideCount() {self._overrideCount = nil}

  var cellProperties: TST_CellStylePropertiesArchive {
    get {return _cellProperties ?? TST_CellStylePropertiesArchive()}
    set {_cellProperties = newValue}
  }
  /// Returns true if `cellProperties` has been explicitly set.
  var hasCellProperties: Bool {return self._cellProperties != nil}
  /// Clears the value of `cellProperties`. Subsequent reads from it will return its default value.
  mutating func clearCellProperties() {self._cellProperties = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSS_StyleArchive? = nil
  fileprivate var _overrideCount: UInt32? = nil
  fileprivate var _cellProperties: TST_CellStylePropertiesArchive? = nil
}

struct TST_FormulaPredArgDataArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var doubleValue: Double {
    get {return _doubleValue ?? 0}
    set {_doubleValue = newValue}
  }
  /// Returns true if `doubleValue` has been explicitly set.
  var hasDoubleValue: Bool {return self._doubleValue != nil}
  /// Clears the value of `doubleValue`. Subsequent reads from it will return its default value.
  mutating func clearDoubleValue() {self._doubleValue = nil}

  var decimalLow: UInt64 {
    get {return _decimalLow ?? 0}
    set {_decimalLow = newValue}
  }
  /// Returns true if `decimalLow` has been explicitly set.
  var hasDecimalLow: Bool {return self._decimalLow != nil}
  /// Clears the value of `decimalLow`. Subsequent reads from it will return its default value.
  mutating func clearDecimalLow() {self._decimalLow = nil}

  var decimalHigh: UInt64 {
    get {return _decimalHigh ?? 0}
    set {_decimalHigh = newValue}
  }
  /// Returns true if `decimalHigh` has been explicitly set.
  var hasDecimalHigh: Bool {return self._decimalHigh != nil}
  /// Clears the value of `decimalHigh`. Subsequent reads from it will return its default value.
  mutating func clearDecimalHigh() {self._decimalHigh = nil}

  var stringValue: String {
    get {return _stringValue ?? String()}
    set {_stringValue = newValue}
  }
  /// Returns true if `stringValue` has been explicitly set.
  var hasStringValue: Bool {return self._stringValue != nil}
  /// Clears the value of `stringValue`. Subsequent reads from it will return its default value.
  mutating func clearStringValue() {self._stringValue = nil}

  var dateValue: Double {
    get {return _dateValue ?? 0}
    set {_dateValue = newValue}
  }
  /// Returns true if `dateValue` has been explicitly set.
  var hasDateValue: Bool {return self._dateValue != nil}
  /// Clears the value of `dateValue`. Subsequent reads from it will return its default value.
  mutating func clearDateValue() {self._dateValue = nil}

  var durationTimeinterval: Double {
    get {return _durationTimeinterval ?? 0}
    set {_durationTimeinterval = newValue}
  }
  /// Returns true if `durationTimeinterval` has been explicitly set.
  var hasDurationTimeinterval: Bool {return self._durationTimeinterval != nil}
  /// Clears the value of `durationTimeinterval`. Subsequent reads from it will return its default value.
  mutating func clearDurationTimeinterval() {self._durationTimeinterval = nil}

  var durationUnits: Int32 {
    get {return _durationUnits ?? 0}
    set {_durationUnits = newValue}
  }
  /// Returns true if `durationUnits` has been explicitly set.
  var hasDurationUnits: Bool {return self._durationUnits != nil}
  /// Clears the value of `durationUnits`. Subsequent reads from it will return its default value.
  mutating func clearDurationUnits() {self._durationUnits = nil}

  var booleanValue: Bool {
    get {return _booleanValue ?? false}
    set {_booleanValue = newValue}
  }
  /// Returns true if `booleanValue` has been explicitly set.
  var hasBooleanValue: Bool {return self._booleanValue != nil}
  /// Clears the value of `booleanValue`. Subsequent reads from it will return its default value.
  mutating func clearBooleanValue() {self._booleanValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _doubleValue: Double? = nil
  fileprivate var _decimalLow: UInt64? = nil
  fileprivate var _decimalHigh: UInt64? = nil
  fileprivate var _stringValue: String? = nil
  fileprivate var _dateValue: Double? = nil
  fileprivate var _durationTimeinterval: Double? = nil
  fileprivate var _durationUnits: Int32? = nil
  fileprivate var _booleanValue: Bool? = nil
}

struct TST_FormulaPredArgArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var argType: Int32 {
    get {return _storage._argType ?? 0}
    set {_uniqueStorage()._argType = newValue}
  }
  /// Returns true if `argType` has been explicitly set.
  var hasArgType: Bool {return _storage._argType != nil}
  /// Clears the value of `argType`. Subsequent reads from it will return its default value.
  mutating func clearArgType() {_uniqueStorage()._argType = nil}

  var argValue: TST_FormulaPredArgDataArchive {
    get {return _storage._argValue ?? TST_FormulaPredArgDataArchive()}
    set {_uniqueStorage()._argValue = newValue}
  }
  /// Returns true if `argValue` has been explicitly set.
  var hasArgValue: Bool {return _storage._argValue != nil}
  /// Clears the value of `argValue`. Subsequent reads from it will return its default value.
  mutating func clearArgValue() {_uniqueStorage()._argValue = nil}

  var baseCellRef: TSCE_CellReferenceArchive {
    get {return _storage._baseCellRef ?? TSCE_CellReferenceArchive()}
    set {_uniqueStorage()._baseCellRef = newValue}
  }
  /// Returns true if `baseCellRef` has been explicitly set.
  var hasBaseCellRef: Bool {return _storage._baseCellRef != nil}
  /// Clears the value of `baseCellRef`. Subsequent reads from it will return its default value.
  mutating func clearBaseCellRef() {_uniqueStorage()._baseCellRef = nil}

  var relativeCellRef: TSCE_RelativeCellRefArchive {
    get {return _storage._relativeCellRef ?? TSCE_RelativeCellRefArchive()}
    set {_uniqueStorage()._relativeCellRef = newValue}
  }
  /// Returns true if `relativeCellRef` has been explicitly set.
  var hasRelativeCellRef: Bool {return _storage._relativeCellRef != nil}
  /// Clears the value of `relativeCellRef`. Subsequent reads from it will return its default value.
  mutating func clearRelativeCellRef() {_uniqueStorage()._relativeCellRef = nil}

  var categoryRef: TSCE_CategoryReferenceArchive {
    get {return _storage._categoryRef ?? TSCE_CategoryReferenceArchive()}
    set {_uniqueStorage()._categoryRef = newValue}
  }
  /// Returns true if `categoryRef` has been explicitly set.
  var hasCategoryRef: Bool {return _storage._categoryRef != nil}
  /// Clears the value of `categoryRef`. Subsequent reads from it will return its default value.
  mutating func clearCategoryRef() {_uniqueStorage()._categoryRef = nil}

  var uidTractList: TSCE_ASTNodeArrayArchive.ASTUidTractList {
    get {return _storage._uidTractList ?? TSCE_ASTNodeArrayArchive.ASTUidTractList()}
    set {_uniqueStorage()._uidTractList = newValue}
  }
  /// Returns true if `uidTractList` has been explicitly set.
  var hasUidTractList: Bool {return _storage._uidTractList != nil}
  /// Clears the value of `uidTractList`. Subsequent reads from it will return its default value.
  mutating func clearUidTractList() {_uniqueStorage()._uidTractList = nil}

  var hostCellCoord: TSCE_CellCoordinateArchive {
    get {return _storage._hostCellCoord ?? TSCE_CellCoordinateArchive()}
    set {_uniqueStorage()._hostCellCoord = newValue}
  }
  /// Returns true if `hostCellCoord` has been explicitly set.
  var hasHostCellCoord: Bool {return _storage._hostCellCoord != nil}
  /// Clears the value of `hostCellCoord`. Subsequent reads from it will return its default value.
  mutating func clearHostCellCoord() {_uniqueStorage()._hostCellCoord = nil}

  var preserveRow: Bool {
    get {return _storage._preserveRow ?? false}
    set {_uniqueStorage()._preserveRow = newValue}
  }
  /// Returns true if `preserveRow` has been explicitly set.
  var hasPreserveRow: Bool {return _storage._preserveRow != nil}
  /// Clears the value of `preserveRow`. Subsequent reads from it will return its default value.
  mutating func clearPreserveRow() {_uniqueStorage()._preserveRow = nil}

  var preserveColumn: Bool {
    get {return _storage._preserveColumn ?? false}
    set {_uniqueStorage()._preserveColumn = newValue}
  }
  /// Returns true if `preserveColumn` has been explicitly set.
  var hasPreserveColumn: Bool {return _storage._preserveColumn != nil}
  /// Clears the value of `preserveColumn`. Subsequent reads from it will return its default value.
  mutating func clearPreserveColumn() {_uniqueStorage()._preserveColumn = nil}

  var listEntries: [TST_FormulaPredArgDataArchive] {
    get {return _storage._listEntries}
    set {_uniqueStorage()._listEntries = newValue}
  }

  var viewTractRef: TSCE_ViewTractRefArchive {
    get {return _storage._viewTractRef ?? TSCE_ViewTractRefArchive()}
    set {_uniqueStorage()._viewTractRef = newValue}
  }
  /// Returns true if `viewTractRef` has been explicitly set.
  var hasViewTractRef: Bool {return _storage._viewTractRef != nil}
  /// Clears the value of `viewTractRef`. Subsequent reads from it will return its default value.
  mutating func clearViewTractRef() {_uniqueStorage()._viewTractRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_FormulaPredicatePrePivotArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var formula: TSCE_FormulaArchive {
    get {return _storage._formula ?? TSCE_FormulaArchive()}
    set {_uniqueStorage()._formula = newValue}
  }
  /// Returns true if `formula` has been explicitly set.
  var hasFormula: Bool {return _storage._formula != nil}
  /// Clears the value of `formula`. Subsequent reads from it will return its default value.
  mutating func clearFormula() {_uniqueStorage()._formula = nil}

  var predicateType: Int32 {
    get {return _storage._predicateType ?? 0}
    set {_uniqueStorage()._predicateType = newValue}
  }
  /// Returns true if `predicateType` has been explicitly set.
  var hasPredicateType: Bool {return _storage._predicateType != nil}
  /// Clears the value of `predicateType`. Subsequent reads from it will return its default value.
  mutating func clearPredicateType() {_uniqueStorage()._predicateType = nil}

  var qualifier1: Int32 {
    get {return _storage._qualifier1 ?? 0}
    set {_uniqueStorage()._qualifier1 = newValue}
  }
  /// Returns true if `qualifier1` has been explicitly set.
  var hasQualifier1: Bool {return _storage._qualifier1 != nil}
  /// Clears the value of `qualifier1`. Subsequent reads from it will return its default value.
  mutating func clearQualifier1() {_uniqueStorage()._qualifier1 = nil}

  var qualifier2: Int32 {
    get {return _storage._qualifier2 ?? 0}
    set {_uniqueStorage()._qualifier2 = newValue}
  }
  /// Returns true if `qualifier2` has been explicitly set.
  var hasQualifier2: Bool {return _storage._qualifier2 != nil}
  /// Clears the value of `qualifier2`. Subsequent reads from it will return its default value.
  mutating func clearQualifier2() {_uniqueStorage()._qualifier2 = nil}

  var paramIndex1: Int32 {
    get {return _storage._paramIndex1 ?? 0}
    set {_uniqueStorage()._paramIndex1 = newValue}
  }
  /// Returns true if `paramIndex1` has been explicitly set.
  var hasParamIndex1: Bool {return _storage._paramIndex1 != nil}
  /// Clears the value of `paramIndex1`. Subsequent reads from it will return its default value.
  mutating func clearParamIndex1() {_uniqueStorage()._paramIndex1 = nil}

  var paramIndex2: Int32 {
    get {return _storage._paramIndex2 ?? 0}
    set {_uniqueStorage()._paramIndex2 = newValue}
  }
  /// Returns true if `paramIndex2` has been explicitly set.
  var hasParamIndex2: Bool {return _storage._paramIndex2 != nil}
  /// Clears the value of `paramIndex2`. Subsequent reads from it will return its default value.
  mutating func clearParamIndex2() {_uniqueStorage()._paramIndex2 = nil}

  var paramIndex0: Int32 {
    get {return _storage._paramIndex0 ?? 0}
    set {_uniqueStorage()._paramIndex0 = newValue}
  }
  /// Returns true if `paramIndex0` has been explicitly set.
  var hasParamIndex0: Bool {return _storage._paramIndex0 != nil}
  /// Clears the value of `paramIndex0`. Subsequent reads from it will return its default value.
  mutating func clearParamIndex0() {_uniqueStorage()._paramIndex0 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_FormulaPredicateArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var predicateType: Int32 {
    get {return _storage._predicateType ?? 0}
    set {_uniqueStorage()._predicateType = newValue}
  }
  /// Returns true if `predicateType` has been explicitly set.
  var hasPredicateType: Bool {return _storage._predicateType != nil}
  /// Clears the value of `predicateType`. Subsequent reads from it will return its default value.
  mutating func clearPredicateType() {_uniqueStorage()._predicateType = nil}

  var qualifier1: Int32 {
    get {return _storage._qualifier1 ?? 0}
    set {_uniqueStorage()._qualifier1 = newValue}
  }
  /// Returns true if `qualifier1` has been explicitly set.
  var hasQualifier1: Bool {return _storage._qualifier1 != nil}
  /// Clears the value of `qualifier1`. Subsequent reads from it will return its default value.
  mutating func clearQualifier1() {_uniqueStorage()._qualifier1 = nil}

  var qualifier2: Int32 {
    get {return _storage._qualifier2 ?? 0}
    set {_uniqueStorage()._qualifier2 = newValue}
  }
  /// Returns true if `qualifier2` has been explicitly set.
  var hasQualifier2: Bool {return _storage._qualifier2 != nil}
  /// Clears the value of `qualifier2`. Subsequent reads from it will return its default value.
  mutating func clearQualifier2() {_uniqueStorage()._qualifier2 = nil}

  var paramValue0: TST_FormulaPredArgArchive {
    get {return _storage._paramValue0 ?? TST_FormulaPredArgArchive()}
    set {_uniqueStorage()._paramValue0 = newValue}
  }
  /// Returns true if `paramValue0` has been explicitly set.
  var hasParamValue0: Bool {return _storage._paramValue0 != nil}
  /// Clears the value of `paramValue0`. Subsequent reads from it will return its default value.
  mutating func clearParamValue0() {_uniqueStorage()._paramValue0 = nil}

  var paramValue1: TST_FormulaPredArgArchive {
    get {return _storage._paramValue1 ?? TST_FormulaPredArgArchive()}
    set {_uniqueStorage()._paramValue1 = newValue}
  }
  /// Returns true if `paramValue1` has been explicitly set.
  var hasParamValue1: Bool {return _storage._paramValue1 != nil}
  /// Clears the value of `paramValue1`. Subsequent reads from it will return its default value.
  mutating func clearParamValue1() {_uniqueStorage()._paramValue1 = nil}

  var paramValue2: TST_FormulaPredArgArchive {
    get {return _storage._paramValue2 ?? TST_FormulaPredArgArchive()}
    set {_uniqueStorage()._paramValue2 = newValue}
  }
  /// Returns true if `paramValue2` has been explicitly set.
  var hasParamValue2: Bool {return _storage._paramValue2 != nil}
  /// Clears the value of `paramValue2`. Subsequent reads from it will return its default value.
  mutating func clearParamValue2() {_uniqueStorage()._paramValue2 = nil}

  var formula: TSCE_FormulaArchive {
    get {return _storage._formula ?? TSCE_FormulaArchive()}
    set {_uniqueStorage()._formula = newValue}
  }
  /// Returns true if `formula` has been explicitly set.
  var hasFormula: Bool {return _storage._formula != nil}
  /// Clears the value of `formula`. Subsequent reads from it will return its default value.
  mutating func clearFormula() {_uniqueStorage()._formula = nil}

  var forConditionalStyle: Bool {
    get {return _storage._forConditionalStyle ?? false}
    set {_uniqueStorage()._forConditionalStyle = newValue}
  }
  /// Returns true if `forConditionalStyle` has been explicitly set.
  var hasForConditionalStyle: Bool {return _storage._forConditionalStyle != nil}
  /// Clears the value of `forConditionalStyle`. Subsequent reads from it will return its default value.
  mutating func clearForConditionalStyle() {_uniqueStorage()._forConditionalStyle = nil}

  var hostTableUid: TSP_UUID {
    get {return _storage._hostTableUid ?? TSP_UUID()}
    set {_uniqueStorage()._hostTableUid = newValue}
  }
  /// Returns true if `hostTableUid` has been explicitly set.
  var hasHostTableUid: Bool {return _storage._hostTableUid != nil}
  /// Clears the value of `hostTableUid`. Subsequent reads from it will return its default value.
  mutating func clearHostTableUid() {_uniqueStorage()._hostTableUid = nil}

  var hostColumnUid: TSP_UUID {
    get {return _storage._hostColumnUid ?? TSP_UUID()}
    set {_uniqueStorage()._hostColumnUid = newValue}
  }
  /// Returns true if `hostColumnUid` has been explicitly set.
  var hasHostColumnUid: Bool {return _storage._hostColumnUid != nil}
  /// Clears the value of `hostColumnUid`. Subsequent reads from it will return its default value.
  mutating func clearHostColumnUid() {_uniqueStorage()._hostColumnUid = nil}

  var hostRowUid: TSP_UUID {
    get {return _storage._hostRowUid ?? TSP_UUID()}
    set {_uniqueStorage()._hostRowUid = newValue}
  }
  /// Returns true if `hostRowUid` has been explicitly set.
  var hasHostRowUid: Bool {return _storage._hostRowUid != nil}
  /// Clears the value of `hostRowUid`. Subsequent reads from it will return its default value.
  mutating func clearHostRowUid() {_uniqueStorage()._hostRowUid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_ConditionalStyleSetArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ruleCount: UInt32 {
    get {return _ruleCount ?? 0}
    set {_ruleCount = newValue}
  }
  /// Returns true if `ruleCount` has been explicitly set.
  var hasRuleCount: Bool {return self._ruleCount != nil}
  /// Clears the value of `ruleCount`. Subsequent reads from it will return its default value.
  mutating func clearRuleCount() {self._ruleCount = nil}

  var rulesPrepivot: [TST_ConditionalStyleSetArchive.ConditionalStyleRulePrePivot] = []

  var rules: TST_ConditionalStyleSetArchive.ConditionalStyleRules {
    get {return _rules ?? TST_ConditionalStyleSetArchive.ConditionalStyleRules()}
    set {_rules = newValue}
  }
  /// Returns true if `rules` has been explicitly set.
  var hasRules: Bool {return self._rules != nil}
  /// Clears the value of `rules`. Subsequent reads from it will return its default value.
  mutating func clearRules() {self._rules = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ConditionalStyleRulePrePivot: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var predicate: TST_FormulaPredicatePrePivotArchive {
      get {return _predicate ?? TST_FormulaPredicatePrePivotArchive()}
      set {_predicate = newValue}
    }
    /// Returns true if `predicate` has been explicitly set.
    var hasPredicate: Bool {return self._predicate != nil}
    /// Clears the value of `predicate`. Subsequent reads from it will return its default value.
    mutating func clearPredicate() {self._predicate = nil}

    var cellStyle: TSP_Reference {
      get {return _cellStyle ?? TSP_Reference()}
      set {_cellStyle = newValue}
    }
    /// Returns true if `cellStyle` has been explicitly set.
    var hasCellStyle: Bool {return self._cellStyle != nil}
    /// Clears the value of `cellStyle`. Subsequent reads from it will return its default value.
    mutating func clearCellStyle() {self._cellStyle = nil}

    var textStyle: TSP_Reference {
      get {return _textStyle ?? TSP_Reference()}
      set {_textStyle = newValue}
    }
    /// Returns true if `textStyle` has been explicitly set.
    var hasTextStyle: Bool {return self._textStyle != nil}
    /// Clears the value of `textStyle`. Subsequent reads from it will return its default value.
    mutating func clearTextStyle() {self._textStyle = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _predicate: TST_FormulaPredicatePrePivotArchive? = nil
    fileprivate var _cellStyle: TSP_Reference? = nil
    fileprivate var _textStyle: TSP_Reference? = nil
  }

  struct ConditionalStyleRule: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var predicate: TST_FormulaPredicateArchive {
      get {return _predicate ?? TST_FormulaPredicateArchive()}
      set {_predicate = newValue}
    }
    /// Returns true if `predicate` has been explicitly set.
    var hasPredicate: Bool {return self._predicate != nil}
    /// Clears the value of `predicate`. Subsequent reads from it will return its default value.
    mutating func clearPredicate() {self._predicate = nil}

    var cellStyle: TSP_Reference {
      get {return _cellStyle ?? TSP_Reference()}
      set {_cellStyle = newValue}
    }
    /// Returns true if `cellStyle` has been explicitly set.
    var hasCellStyle: Bool {return self._cellStyle != nil}
    /// Clears the value of `cellStyle`. Subsequent reads from it will return its default value.
    mutating func clearCellStyle() {self._cellStyle = nil}

    var textStyle: TSP_Reference {
      get {return _textStyle ?? TSP_Reference()}
      set {_textStyle = newValue}
    }
    /// Returns true if `textStyle` has been explicitly set.
    var hasTextStyle: Bool {return self._textStyle != nil}
    /// Clears the value of `textStyle`. Subsequent reads from it will return its default value.
    mutating func clearTextStyle() {self._textStyle = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _predicate: TST_FormulaPredicateArchive? = nil
    fileprivate var _cellStyle: TSP_Reference? = nil
    fileprivate var _textStyle: TSP_Reference? = nil
  }

  struct ConditionalStyleRules: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rule: [TST_ConditionalStyleSetArchive.ConditionalStyleRule] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _ruleCount: UInt32? = nil
  fileprivate var _rules: TST_ConditionalStyleSetArchive.ConditionalStyleRules? = nil
}

struct TST_FilterSetArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: TST_FilterSetArchive.FilterSetType {
    get {return _type ?? .filterSetArchiveTypeAll}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var isEnabled: Bool {
    get {return _isEnabled ?? true}
    set {_isEnabled = newValue}
  }
  /// Returns true if `isEnabled` has been explicitly set.
  var hasIsEnabled: Bool {return self._isEnabled != nil}
  /// Clears the value of `isEnabled`. Subsequent reads from it will return its default value.
  mutating func clearIsEnabled() {self._isEnabled = nil}

  var filterRulesPrepivot: [TST_FilterRulePrePivotArchive] = []

  var needsFormulaRewriteForImport: Bool {
    get {return _needsFormulaRewriteForImport ?? false}
    set {_needsFormulaRewriteForImport = newValue}
  }
  /// Returns true if `needsFormulaRewriteForImport` has been explicitly set.
  var hasNeedsFormulaRewriteForImport: Bool {return self._needsFormulaRewriteForImport != nil}
  /// Clears the value of `needsFormulaRewriteForImport`. Subsequent reads from it will return its default value.
  mutating func clearNeedsFormulaRewriteForImport() {self._needsFormulaRewriteForImport = nil}

  var filterOffsets: [UInt32] = []

  var filterEnabled: [Bool] = []

  var filterRules: [TST_FilterRuleArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum FilterSetType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case filterSetArchiveTypeAll = 0
    case filterSetArchiveTypeAny = 1

    init() {
      self = .filterSetArchiveTypeAll
    }

  }

  init() {}

  fileprivate var _type: TST_FilterSetArchive.FilterSetType? = nil
  fileprivate var _isEnabled: Bool? = nil
  fileprivate var _needsFormulaRewriteForImport: Bool? = nil
}

struct TST_UniqueIndexArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var columnUid: TSP_UUID {
    get {return _columnUid ?? TSP_UUID()}
    set {_columnUid = newValue}
  }
  /// Returns true if `columnUid` has been explicitly set.
  var hasColumnUid: Bool {return self._columnUid != nil}
  /// Clears the value of `columnUid`. Subsequent reads from it will return its default value.
  mutating func clearColumnUid() {self._columnUid = nil}

  var uniqueEntries: [TST_UniqueIndexArchive.UniqueIndexEntryArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct UniqueIndexEntryArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var stringValue: String {
      get {return _stringValue ?? String()}
      set {_stringValue = newValue}
    }
    /// Returns true if `stringValue` has been explicitly set.
    var hasStringValue: Bool {return self._stringValue != nil}
    /// Clears the value of `stringValue`. Subsequent reads from it will return its default value.
    mutating func clearStringValue() {self._stringValue = nil}

    var rowUids: [TSP_UUID] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _stringValue: String? = nil
  }

  init() {}

  fileprivate var _columnUid: TSP_UUID? = nil
}

struct TST_HiddenStateExtentArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hiddenStateExtentUid: TSP_UUID {
    get {return _hiddenStateExtentUid ?? TSP_UUID()}
    set {_hiddenStateExtentUid = newValue}
  }
  /// Returns true if `hiddenStateExtentUid` has been explicitly set.
  var hasHiddenStateExtentUid: Bool {return self._hiddenStateExtentUid != nil}
  /// Clears the value of `hiddenStateExtentUid`. Subsequent reads from it will return its default value.
  mutating func clearHiddenStateExtentUid() {self._hiddenStateExtentUid = nil}

  var baseHiddenStates: [TST_HiddenStateExtentArchive.RowOrColumnState] = []

  var rowOrColumnDirection: TST_HiddenStateExtentArchive.RowOrColumnDirection {
    get {return _rowOrColumnDirection ?? .columnDirection}
    set {_rowOrColumnDirection = newValue}
  }
  /// Returns true if `rowOrColumnDirection` has been explicitly set.
  var hasRowOrColumnDirection: Bool {return self._rowOrColumnDirection != nil}
  /// Clears the value of `rowOrColumnDirection`. Subsequent reads from it will return its default value.
  mutating func clearRowOrColumnDirection() {self._rowOrColumnDirection = nil}

  var thresholdValue: [TSCE_CellValueArchive] = []

  var needsToUpdateFilterSetForImport: Bool {
    get {return _needsToUpdateFilterSetForImport ?? false}
    set {_needsToUpdateFilterSetForImport = newValue}
  }
  /// Returns true if `needsToUpdateFilterSetForImport` has been explicitly set.
  var hasNeedsToUpdateFilterSetForImport: Bool {return self._needsToUpdateFilterSetForImport != nil}
  /// Clears the value of `needsToUpdateFilterSetForImport`. Subsequent reads from it will return its default value.
  mutating func clearNeedsToUpdateFilterSetForImport() {self._needsToUpdateFilterSetForImport = nil}

  var collapsedGroupUids: [TSP_UUID] = []

  var filterSet: TSP_Reference {
    get {return _filterSet ?? TSP_Reference()}
    set {_filterSet = newValue}
  }
  /// Returns true if `filterSet` has been explicitly set.
  var hasFilterSet: Bool {return self._filterSet != nil}
  /// Clears the value of `filterSet`. Subsequent reads from it will return its default value.
  mutating func clearFilterSet() {self._filterSet = nil}

  var summaryPivotHiddenIndexes: TSCE_IndexSetArchive {
    get {return _summaryPivotHiddenIndexes ?? TSCE_IndexSetArchive()}
    set {_summaryPivotHiddenIndexes = newValue}
  }
  /// Returns true if `summaryPivotHiddenIndexes` has been explicitly set.
  var hasSummaryPivotHiddenIndexes: Bool {return self._summaryPivotHiddenIndexes != nil}
  /// Clears the value of `summaryPivotHiddenIndexes`. Subsequent reads from it will return its default value.
  mutating func clearSummaryPivotHiddenIndexes() {self._summaryPivotHiddenIndexes = nil}

  var summaryFilteredIndexes: TSCE_IndexSetArchive {
    get {return _summaryFilteredIndexes ?? TSCE_IndexSetArchive()}
    set {_summaryFilteredIndexes = newValue}
  }
  /// Returns true if `summaryFilteredIndexes` has been explicitly set.
  var hasSummaryFilteredIndexes: Bool {return self._summaryFilteredIndexes != nil}
  /// Clears the value of `summaryFilteredIndexes`. Subsequent reads from it will return its default value.
  mutating func clearSummaryFilteredIndexes() {self._summaryFilteredIndexes = nil}

  var uniqueIndexes: [TST_UniqueIndexArchive] = []

  var summaryHiddenStates: [TST_HiddenStateExtentArchive.RowOrColumnState] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum RowOrColumnDirection: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case columnDirection = 0
    case rowDirection = 1

    init() {
      self = .columnDirection
    }

  }

  struct RowOrColumnState: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rowOrColumnUid: TSP_UUID {
      get {return _rowOrColumnUid ?? TSP_UUID()}
      set {_rowOrColumnUid = newValue}
    }
    /// Returns true if `rowOrColumnUid` has been explicitly set.
    var hasRowOrColumnUid: Bool {return self._rowOrColumnUid != nil}
    /// Clears the value of `rowOrColumnUid`. Subsequent reads from it will return its default value.
    mutating func clearRowOrColumnUid() {self._rowOrColumnUid = nil}

    var userHidden: Bool {
      get {return _userHidden ?? false}
      set {_userHidden = newValue}
    }
    /// Returns true if `userHidden` has been explicitly set.
    var hasUserHidden: Bool {return self._userHidden != nil}
    /// Clears the value of `userHidden`. Subsequent reads from it will return its default value.
    mutating func clearUserHidden() {self._userHidden = nil}

    var filtered: Bool {
      get {return _filtered ?? false}
      set {_filtered = newValue}
    }
    /// Returns true if `filtered` has been explicitly set.
    var hasFiltered: Bool {return self._filtered != nil}
    /// Clears the value of `filtered`. Subsequent reads from it will return its default value.
    mutating func clearFiltered() {self._filtered = nil}

    var pivotHidden: Bool {
      get {return _pivotHidden ?? false}
      set {_pivotHidden = newValue}
    }
    /// Returns true if `pivotHidden` has been explicitly set.
    var hasPivotHidden: Bool {return self._pivotHidden != nil}
    /// Clears the value of `pivotHidden`. Subsequent reads from it will return its default value.
    mutating func clearPivotHidden() {self._pivotHidden = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _rowOrColumnUid: TSP_UUID? = nil
    fileprivate var _userHidden: Bool? = nil
    fileprivate var _filtered: Bool? = nil
    fileprivate var _pivotHidden: Bool? = nil
  }

  init() {}

  fileprivate var _hiddenStateExtentUid: TSP_UUID? = nil
  fileprivate var _rowOrColumnDirection: TST_HiddenStateExtentArchive.RowOrColumnDirection? = nil
  fileprivate var _needsToUpdateFilterSetForImport: Bool? = nil
  fileprivate var _filterSet: TSP_Reference? = nil
  fileprivate var _summaryPivotHiddenIndexes: TSCE_IndexSetArchive? = nil
  fileprivate var _summaryFilteredIndexes: TSCE_IndexSetArchive? = nil
}

struct TST_HiddenStatesArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hiddenStatesUid: TSP_UUID {
    get {return _storage._hiddenStatesUid ?? TSP_UUID()}
    set {_uniqueStorage()._hiddenStatesUid = newValue}
  }
  /// Returns true if `hiddenStatesUid` has been explicitly set.
  var hasHiddenStatesUid: Bool {return _storage._hiddenStatesUid != nil}
  /// Clears the value of `hiddenStatesUid`. Subsequent reads from it will return its default value.
  mutating func clearHiddenStatesUid() {_uniqueStorage()._hiddenStatesUid = nil}

  var columnHiddenStateExtent: TST_HiddenStateExtentArchive {
    get {return _storage._columnHiddenStateExtent ?? TST_HiddenStateExtentArchive()}
    set {_uniqueStorage()._columnHiddenStateExtent = newValue}
  }
  /// Returns true if `columnHiddenStateExtent` has been explicitly set.
  var hasColumnHiddenStateExtent: Bool {return _storage._columnHiddenStateExtent != nil}
  /// Clears the value of `columnHiddenStateExtent`. Subsequent reads from it will return its default value.
  mutating func clearColumnHiddenStateExtent() {_uniqueStorage()._columnHiddenStateExtent = nil}

  var rowHiddenStateExtent: TST_HiddenStateExtentArchive {
    get {return _storage._rowHiddenStateExtent ?? TST_HiddenStateExtentArchive()}
    set {_uniqueStorage()._rowHiddenStateExtent = newValue}
  }
  /// Returns true if `rowHiddenStateExtent` has been explicitly set.
  var hasRowHiddenStateExtent: Bool {return _storage._rowHiddenStateExtent != nil}
  /// Clears the value of `rowHiddenStateExtent`. Subsequent reads from it will return its default value.
  mutating func clearRowHiddenStateExtent() {_uniqueStorage()._rowHiddenStateExtent = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_HiddenStatesOwnerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerUid: TSP_UUID {
    get {return _ownerUid ?? TSP_UUID()}
    set {_ownerUid = newValue}
  }
  /// Returns true if `ownerUid` has been explicitly set.
  var hasOwnerUid: Bool {return self._ownerUid != nil}
  /// Clears the value of `ownerUid`. Subsequent reads from it will return its default value.
  mutating func clearOwnerUid() {self._ownerUid = nil}

  var hiddenStates: [TST_HiddenStatesArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ownerUid: TSP_UUID? = nil
}

struct TST_ExpandCollapseStateArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uidsCollapsed: [TSP_UUID] = []

  var uidsExpanded: [TSP_UUID] = []

  var dimension: TST_TableDimensionArchive {
    get {return _dimension ?? .dimensionNeither}
    set {_dimension = newValue}
  }
  /// Returns true if `dimension` has been explicitly set.
  var hasDimension: Bool {return self._dimension != nil}
  /// Clears the value of `dimension`. Subsequent reads from it will return its default value.
  mutating func clearDimension() {self._dimension = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _dimension: TST_TableDimensionArchive? = nil
}

struct TST_TokenAttachmentArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_UIGraphicalAttachment {
    get {return _super ?? TSWP_UIGraphicalAttachment()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var expressionNode: TSP_Reference {
    get {return _expressionNode ?? TSP_Reference()}
    set {_expressionNode = newValue}
  }
  /// Returns true if `expressionNode` has been explicitly set.
  var hasExpressionNode: Bool {return self._expressionNode != nil}
  /// Clears the value of `expressionNode`. Subsequent reads from it will return its default value.
  mutating func clearExpressionNode() {self._expressionNode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_UIGraphicalAttachment? = nil
  fileprivate var _expressionNode: TSP_Reference? = nil
}

struct TST_ExpressionNodeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var children: [TSP_Reference] = []

  var firstIndex: UInt64 {
    get {return _firstIndex ?? 0}
    set {_firstIndex = newValue}
  }
  /// Returns true if `firstIndex` has been explicitly set.
  var hasFirstIndex: Bool {return self._firstIndex != nil}
  /// Clears the value of `firstIndex`. Subsequent reads from it will return its default value.
  mutating func clearFirstIndex() {self._firstIndex = nil}

  var lastIndex: UInt64 {
    get {return _lastIndex ?? 0}
    set {_lastIndex = newValue}
  }
  /// Returns true if `lastIndex` has been explicitly set.
  var hasLastIndex: Bool {return self._lastIndex != nil}
  /// Clears the value of `lastIndex`. Subsequent reads from it will return its default value.
  mutating func clearLastIndex() {self._lastIndex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _firstIndex: UInt64? = nil
  fileprivate var _lastIndex: UInt64? = nil
}

struct TST_BooleanNodeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_ExpressionNodeArchive {
    get {return _super ?? TST_ExpressionNodeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var value: Bool {
    get {return _value ?? false}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_ExpressionNodeArchive? = nil
  fileprivate var _value: Bool? = nil
}

struct TST_NumberNodeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_ExpressionNodeArchive {
    get {return _super ?? TST_ExpressionNodeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var number: Double {
    get {return _number ?? 0}
    set {_number = newValue}
  }
  /// Returns true if `number` has been explicitly set.
  var hasNumber: Bool {return self._number != nil}
  /// Clears the value of `number`. Subsequent reads from it will return its default value.
  mutating func clearNumber() {self._number = nil}

  var decimalLow: UInt64 {
    get {return _decimalLow ?? 0}
    set {_decimalLow = newValue}
  }
  /// Returns true if `decimalLow` has been explicitly set.
  var hasDecimalLow: Bool {return self._decimalLow != nil}
  /// Clears the value of `decimalLow`. Subsequent reads from it will return its default value.
  mutating func clearDecimalLow() {self._decimalLow = nil}

  var decimalHigh: UInt64 {
    get {return _decimalHigh ?? 0}
    set {_decimalHigh = newValue}
  }
  /// Returns true if `decimalHigh` has been explicitly set.
  var hasDecimalHigh: Bool {return self._decimalHigh != nil}
  /// Clears the value of `decimalHigh`. Subsequent reads from it will return its default value.
  mutating func clearDecimalHigh() {self._decimalHigh = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_ExpressionNodeArchive? = nil
  fileprivate var _number: Double? = nil
  fileprivate var _decimalLow: UInt64? = nil
  fileprivate var _decimalHigh: UInt64? = nil
}

struct TST_StringNodeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_ExpressionNodeArchive {
    get {return _super ?? TST_ExpressionNodeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_ExpressionNodeArchive? = nil
  fileprivate var _value: String? = nil
}

struct TST_IdentifierNodeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_ExpressionNodeArchive {
    get {return _super ?? TST_ExpressionNodeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var identifier: String {
    get {return _identifier ?? String()}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {self._identifier = nil}

  var symbol: UInt32 {
    get {return _symbol ?? 0}
    set {_symbol = newValue}
  }
  /// Returns true if `symbol` has been explicitly set.
  var hasSymbol: Bool {return self._symbol != nil}
  /// Clears the value of `symbol`. Subsequent reads from it will return its default value.
  mutating func clearSymbol() {self._symbol = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_ExpressionNodeArchive? = nil
  fileprivate var _identifier: String? = nil
  fileprivate var _symbol: UInt32? = nil
}

struct TST_ArrayNodeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_ExpressionNodeArchive {
    get {return _super ?? TST_ExpressionNodeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var columns: UInt32 {
    get {return _columns ?? 0}
    set {_columns = newValue}
  }
  /// Returns true if `columns` has been explicitly set.
  var hasColumns: Bool {return self._columns != nil}
  /// Clears the value of `columns`. Subsequent reads from it will return its default value.
  mutating func clearColumns() {self._columns = nil}

  var rows: UInt32 {
    get {return _rows ?? 0}
    set {_rows = newValue}
  }
  /// Returns true if `rows` has been explicitly set.
  var hasRows: Bool {return self._rows != nil}
  /// Clears the value of `rows`. Subsequent reads from it will return its default value.
  mutating func clearRows() {self._rows = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_ExpressionNodeArchive? = nil
  fileprivate var _columns: UInt32? = nil
  fileprivate var _rows: UInt32? = nil
}

struct TST_ListNodeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_ExpressionNodeArchive {
    get {return _super ?? TST_ExpressionNodeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_ExpressionNodeArchive? = nil
}

struct TST_OperatorNodeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_ExpressionNodeArchive {
    get {return _super ?? TST_ExpressionNodeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var operatorChar: UInt32 {
    get {return _operatorChar ?? 0}
    set {_operatorChar = newValue}
  }
  /// Returns true if `operatorChar` has been explicitly set.
  var hasOperatorChar: Bool {return self._operatorChar != nil}
  /// Clears the value of `operatorChar`. Subsequent reads from it will return its default value.
  mutating func clearOperatorChar() {self._operatorChar = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_ExpressionNodeArchive? = nil
  fileprivate var _operatorChar: UInt32? = nil
}

struct TST_PostfixOperatorNodeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_OperatorNodeArchive {
    get {return _super ?? TST_OperatorNodeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_OperatorNodeArchive? = nil
}

struct TST_PrefixOperatorNodeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_OperatorNodeArchive {
    get {return _super ?? TST_OperatorNodeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_OperatorNodeArchive? = nil
}

struct TST_FunctionNodeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_ExpressionNodeArchive {
    get {return _super ?? TST_ExpressionNodeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var functionIndex: UInt32 {
    get {return _functionIndex ?? 0}
    set {_functionIndex = newValue}
  }
  /// Returns true if `functionIndex` has been explicitly set.
  var hasFunctionIndex: Bool {return self._functionIndex != nil}
  /// Clears the value of `functionIndex`. Subsequent reads from it will return its default value.
  mutating func clearFunctionIndex() {self._functionIndex = nil}

  var invalidFunctionName: String {
    get {return _invalidFunctionName ?? String()}
    set {_invalidFunctionName = newValue}
  }
  /// Returns true if `invalidFunctionName` has been explicitly set.
  var hasInvalidFunctionName: Bool {return self._invalidFunctionName != nil}
  /// Clears the value of `invalidFunctionName`. Subsequent reads from it will return its default value.
  mutating func clearInvalidFunctionName() {self._invalidFunctionName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_ExpressionNodeArchive? = nil
  fileprivate var _functionIndex: UInt32? = nil
  fileprivate var _invalidFunctionName: String? = nil
}

struct TST_FunctionEndNodeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_ExpressionNodeArchive {
    get {return _super ?? TST_ExpressionNodeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_ExpressionNodeArchive? = nil
}

struct TST_DateNodeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_ExpressionNodeArchive {
    get {return _super ?? TST_ExpressionNodeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var format: String {
    get {return _format ?? String()}
    set {_format = newValue}
  }
  /// Returns true if `format` has been explicitly set.
  var hasFormat: Bool {return self._format != nil}
  /// Clears the value of `format`. Subsequent reads from it will return its default value.
  mutating func clearFormat() {self._format = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_ExpressionNodeArchive? = nil
  fileprivate var _value: String? = nil
  fileprivate var _format: String? = nil
}

struct TST_ReferenceNodeArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_ExpressionNodeArchive {
    get {return _storage._super ?? TST_ExpressionNodeArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var rangeReference: TSCE_RangeReferenceArchive {
    get {return _storage._rangeReference ?? TSCE_RangeReferenceArchive()}
    set {_uniqueStorage()._rangeReference = newValue}
  }
  /// Returns true if `rangeReference` has been explicitly set.
  var hasRangeReference: Bool {return _storage._rangeReference != nil}
  /// Clears the value of `rangeReference`. Subsequent reads from it will return its default value.
  mutating func clearRangeReference() {_uniqueStorage()._rangeReference = nil}

  var preserveFlags: UInt32 {
    get {return _storage._preserveFlags ?? 0}
    set {_uniqueStorage()._preserveFlags = newValue}
  }
  /// Returns true if `preserveFlags` has been explicitly set.
  var hasPreserveFlags: Bool {return _storage._preserveFlags != nil}
  /// Clears the value of `preserveFlags`. Subsequent reads from it will return its default value.
  mutating func clearPreserveFlags() {_uniqueStorage()._preserveFlags = nil}

  var hostTableID: String {
    get {return _storage._hostTableID ?? String()}
    set {_uniqueStorage()._hostTableID = newValue}
  }
  /// Returns true if `hostTableID` has been explicitly set.
  var hasHostTableID: Bool {return _storage._hostTableID != nil}
  /// Clears the value of `hostTableID`. Subsequent reads from it will return its default value.
  mutating func clearHostTableID() {_uniqueStorage()._hostTableID = nil}

  var hostCellRef: TSCE_CellReferenceArchive {
    get {return _storage._hostCellRef ?? TSCE_CellReferenceArchive()}
    set {_uniqueStorage()._hostCellRef = newValue}
  }
  /// Returns true if `hostCellRef` has been explicitly set.
  var hasHostCellRef: Bool {return _storage._hostCellRef != nil}
  /// Clears the value of `hostCellRef`. Subsequent reads from it will return its default value.
  mutating func clearHostCellRef() {_uniqueStorage()._hostCellRef = nil}

  var tableUid: TSP_UUID {
    get {return _storage._tableUid ?? TSP_UUID()}
    set {_uniqueStorage()._tableUid = newValue}
  }
  /// Returns true if `tableUid` has been explicitly set.
  var hasTableUid: Bool {return _storage._tableUid != nil}
  /// Clears the value of `tableUid`. Subsequent reads from it will return its default value.
  mutating func clearTableUid() {_uniqueStorage()._tableUid = nil}

  var rangeTopLeft: TSP_UUIDCoordArchive {
    get {return _storage._rangeTopLeft ?? TSP_UUIDCoordArchive()}
    set {_uniqueStorage()._rangeTopLeft = newValue}
  }
  /// Returns true if `rangeTopLeft` has been explicitly set.
  var hasRangeTopLeft: Bool {return _storage._rangeTopLeft != nil}
  /// Clears the value of `rangeTopLeft`. Subsequent reads from it will return its default value.
  mutating func clearRangeTopLeft() {_uniqueStorage()._rangeTopLeft = nil}

  var rangeBottomRight: TSP_UUIDCoordArchive {
    get {return _storage._rangeBottomRight ?? TSP_UUIDCoordArchive()}
    set {_uniqueStorage()._rangeBottomRight = newValue}
  }
  /// Returns true if `rangeBottomRight` has been explicitly set.
  var hasRangeBottomRight: Bool {return _storage._rangeBottomRight != nil}
  /// Clears the value of `rangeBottomRight`. Subsequent reads from it will return its default value.
  mutating func clearRangeBottomRight() {_uniqueStorage()._rangeBottomRight = nil}

  var categoryRef: TSCE_CategoryReferenceArchive {
    get {return _storage._categoryRef ?? TSCE_CategoryReferenceArchive()}
    set {_uniqueStorage()._categoryRef = newValue}
  }
  /// Returns true if `categoryRef` has been explicitly set.
  var hasCategoryRef: Bool {return _storage._categoryRef != nil}
  /// Clears the value of `categoryRef`. Subsequent reads from it will return its default value.
  mutating func clearCategoryRef() {_uniqueStorage()._categoryRef = nil}

  var uidRangeRect: TSP_UUIDRectArchive {
    get {return _storage._uidRangeRect ?? TSP_UUIDRectArchive()}
    set {_uniqueStorage()._uidRangeRect = newValue}
  }
  /// Returns true if `uidRangeRect` has been explicitly set.
  var hasUidRangeRect: Bool {return _storage._uidRangeRect != nil}
  /// Clears the value of `uidRangeRect`. Subsequent reads from it will return its default value.
  mutating func clearUidRangeRect() {_uniqueStorage()._uidRangeRect = nil}

  var spillRangeOpSuffix: Bool {
    get {return _storage._spillRangeOpSuffix ?? false}
    set {_uniqueStorage()._spillRangeOpSuffix = newValue}
  }
  /// Returns true if `spillRangeOpSuffix` has been explicitly set.
  var hasSpillRangeOpSuffix: Bool {return _storage._spillRangeOpSuffix != nil}
  /// Clears the value of `spillRangeOpSuffix`. Subsequent reads from it will return its default value.
  mutating func clearSpillRangeOpSuffix() {_uniqueStorage()._spillRangeOpSuffix = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_DurationNodeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_ExpressionNodeArchive {
    get {return _super ?? TST_ExpressionNodeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var timeinterval: Double {
    get {return _timeinterval ?? 0}
    set {_timeinterval = newValue}
  }
  /// Returns true if `timeinterval` has been explicitly set.
  var hasTimeinterval: Bool {return self._timeinterval != nil}
  /// Clears the value of `timeinterval`. Subsequent reads from it will return its default value.
  mutating func clearTimeinterval() {self._timeinterval = nil}

  var smallest: UInt32 {
    get {return _smallest ?? 0}
    set {_smallest = newValue}
  }
  /// Returns true if `smallest` has been explicitly set.
  var hasSmallest: Bool {return self._smallest != nil}
  /// Clears the value of `smallest`. Subsequent reads from it will return its default value.
  mutating func clearSmallest() {self._smallest = nil}

  var largest: UInt32 {
    get {return _largest ?? 0}
    set {_largest = newValue}
  }
  /// Returns true if `largest` has been explicitly set.
  var hasLargest: Bool {return self._largest != nil}
  /// Clears the value of `largest`. Subsequent reads from it will return its default value.
  mutating func clearLargest() {self._largest = nil}

  var style: UInt32 {
    get {return _style ?? 0}
    set {_style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  var hasStyle: Bool {return self._style != nil}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  mutating func clearStyle() {self._style = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_ExpressionNodeArchive? = nil
  fileprivate var _timeinterval: Double? = nil
  fileprivate var _smallest: UInt32? = nil
  fileprivate var _largest: UInt32? = nil
  fileprivate var _style: UInt32? = nil
}

struct TST_ArgumentPlaceholderNodeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_ExpressionNodeArchive {
    get {return _super ?? TST_ExpressionNodeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var functionIndex: UInt32 {
    get {return _functionIndex ?? 0}
    set {_functionIndex = newValue}
  }
  /// Returns true if `functionIndex` has been explicitly set.
  var hasFunctionIndex: Bool {return self._functionIndex != nil}
  /// Clears the value of `functionIndex`. Subsequent reads from it will return its default value.
  mutating func clearFunctionIndex() {self._functionIndex = nil}

  var argumentIndex: UInt32 {
    get {return _argumentIndex ?? 0}
    set {_argumentIndex = newValue}
  }
  /// Returns true if `argumentIndex` has been explicitly set.
  var hasArgumentIndex: Bool {return self._argumentIndex != nil}
  /// Clears the value of `argumentIndex`. Subsequent reads from it will return its default value.
  mutating func clearArgumentIndex() {self._argumentIndex = nil}

  var mode: UInt32 {
    get {return _mode ?? 0}
    set {_mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  var hasMode: Bool {return self._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  mutating func clearMode() {self._mode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_ExpressionNodeArchive? = nil
  fileprivate var _functionIndex: UInt32? = nil
  fileprivate var _argumentIndex: UInt32? = nil
  fileprivate var _mode: UInt32? = nil
}

struct TST_EmptyExpressionNodeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_ExpressionNodeArchive {
    get {return _super ?? TST_ExpressionNodeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_ExpressionNodeArchive? = nil
}

struct TST_VariableNodeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_ExpressionNodeArchive {
    get {return _super ?? TST_ExpressionNodeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var identifier: String {
    get {return _identifier ?? String()}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {self._identifier = nil}

  var symbol: UInt32 {
    get {return _symbol ?? 0}
    set {_symbol = newValue}
  }
  /// Returns true if `symbol` has been explicitly set.
  var hasSymbol: Bool {return self._symbol != nil}
  /// Clears the value of `symbol`. Subsequent reads from it will return its default value.
  mutating func clearSymbol() {self._symbol = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_ExpressionNodeArchive? = nil
  fileprivate var _identifier: String? = nil
  fileprivate var _symbol: UInt32? = nil
}

struct TST_SpillOriginRefNodeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_ExpressionNodeArchive {
    get {return _super ?? TST_ExpressionNodeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var spillOriginCoord: TSCE_CellCoordinateArchive {
    get {return _spillOriginCoord ?? TSCE_CellCoordinateArchive()}
    set {_spillOriginCoord = newValue}
  }
  /// Returns true if `spillOriginCoord` has been explicitly set.
  var hasSpillOriginCoord: Bool {return self._spillOriginCoord != nil}
  /// Clears the value of `spillOriginCoord`. Subsequent reads from it will return its default value.
  mutating func clearSpillOriginCoord() {self._spillOriginCoord = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_ExpressionNodeArchive? = nil
  fileprivate var _spillOriginCoord: TSCE_CellCoordinateArchive? = nil
}

struct TST_LayoutHintArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isValid: Bool {
    get {return _storage._isValid ?? false}
    set {_uniqueStorage()._isValid = newValue}
  }
  /// Returns true if `isValid` has been explicitly set.
  var hasIsValid: Bool {return _storage._isValid != nil}
  /// Clears the value of `isValid`. Subsequent reads from it will return its default value.
  mutating func clearIsValid() {_uniqueStorage()._isValid = nil}

  var cellRange: TST_CellRange {
    get {return _storage._cellRange ?? TST_CellRange()}
    set {_uniqueStorage()._cellRange = newValue}
  }
  /// Returns true if `cellRange` has been explicitly set.
  var hasCellRange: Bool {return _storage._cellRange != nil}
  /// Clears the value of `cellRange`. Subsequent reads from it will return its default value.
  mutating func clearCellRange() {_uniqueStorage()._cellRange = nil}

  var hintID: TST_CellID {
    get {return _storage._hintID ?? TST_CellID()}
    set {_uniqueStorage()._hintID = newValue}
  }
  /// Returns true if `hintID` has been explicitly set.
  var hasHintID: Bool {return _storage._hintID != nil}
  /// Clears the value of `hintID`. Subsequent reads from it will return its default value.
  mutating func clearHintID() {_uniqueStorage()._hintID = nil}

  var maximumSize: TSP_Size {
    get {return _storage._maximumSize ?? TSP_Size()}
    set {_uniqueStorage()._maximumSize = newValue}
  }
  /// Returns true if `maximumSize` has been explicitly set.
  var hasMaximumSize: Bool {return _storage._maximumSize != nil}
  /// Clears the value of `maximumSize`. Subsequent reads from it will return its default value.
  mutating func clearMaximumSize() {_uniqueStorage()._maximumSize = nil}

  var partitionPosition: UInt32 {
    get {return _storage._partitionPosition ?? 0}
    set {_uniqueStorage()._partitionPosition = newValue}
  }
  /// Returns true if `partitionPosition` has been explicitly set.
  var hasPartitionPosition: Bool {return _storage._partitionPosition != nil}
  /// Clears the value of `partitionPosition`. Subsequent reads from it will return its default value.
  mutating func clearPartitionPosition() {_uniqueStorage()._partitionPosition = nil}

  var horizontal: Bool {
    get {return _storage._horizontal ?? false}
    set {_uniqueStorage()._horizontal = newValue}
  }
  /// Returns true if `horizontal` has been explicitly set.
  var hasHorizontal: Bool {return _storage._horizontal != nil}
  /// Clears the value of `horizontal`. Subsequent reads from it will return its default value.
  mutating func clearHorizontal() {_uniqueStorage()._horizontal = nil}

  var effectiveSize: TSP_Size {
    get {return _storage._effectiveSize ?? TSP_Size()}
    set {_uniqueStorage()._effectiveSize = newValue}
  }
  /// Returns true if `effectiveSize` has been explicitly set.
  var hasEffectiveSize: Bool {return _storage._effectiveSize != nil}
  /// Clears the value of `effectiveSize`. Subsequent reads from it will return its default value.
  mutating func clearEffectiveSize() {_uniqueStorage()._effectiveSize = nil}

  var partitioningPass: UInt32 {
    get {return _storage._partitioningPass ?? 0}
    set {_uniqueStorage()._partitioningPass = newValue}
  }
  /// Returns true if `partitioningPass` has been explicitly set.
  var hasPartitioningPass: Bool {return _storage._partitioningPass != nil}
  /// Clears the value of `partitioningPass`. Subsequent reads from it will return its default value.
  mutating func clearPartitioningPass() {_uniqueStorage()._partitioningPass = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CompletionTokenAttachmentArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TokenAttachmentArchive {
    get {return _super ?? TST_TokenAttachmentArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var completionText: String {
    get {return _completionText ?? String()}
    set {_completionText = newValue}
  }
  /// Returns true if `completionText` has been explicitly set.
  var hasCompletionText: Bool {return self._completionText != nil}
  /// Clears the value of `completionText`. Subsequent reads from it will return its default value.
  mutating func clearCompletionText() {self._completionText = nil}

  var caretPosition: UInt32 {
    get {return _caretPosition ?? 0}
    set {_caretPosition = newValue}
  }
  /// Returns true if `caretPosition` has been explicitly set.
  var hasCaretPosition: Bool {return self._caretPosition != nil}
  /// Clears the value of `caretPosition`. Subsequent reads from it will return its default value.
  mutating func clearCaretPosition() {self._caretPosition = nil}

  var prefixStart: UInt32 {
    get {return _prefixStart ?? 0}
    set {_prefixStart = newValue}
  }
  /// Returns true if `prefixStart` has been explicitly set.
  var hasPrefixStart: Bool {return self._prefixStart != nil}
  /// Clears the value of `prefixStart`. Subsequent reads from it will return its default value.
  mutating func clearPrefixStart() {self._prefixStart = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TokenAttachmentArchive? = nil
  fileprivate var _completionText: String? = nil
  fileprivate var _caretPosition: UInt32? = nil
  fileprivate var _prefixStart: UInt32? = nil
}

struct TST_HiddenStateFormulaOwnerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerID: TSP_CFUUIDArchive {
    get {return _ownerID ?? TSP_CFUUIDArchive()}
    set {_ownerID = newValue}
  }
  /// Returns true if `ownerID` has been explicitly set.
  var hasOwnerID: Bool {return self._ownerID != nil}
  /// Clears the value of `ownerID`. Subsequent reads from it will return its default value.
  mutating func clearOwnerID() {self._ownerID = nil}

  var thresholdValue: [TSCE_CellValueArchive] = []

  var needsToUpdateFilterSetForImport: Bool {
    get {return _needsToUpdateFilterSetForImport ?? false}
    set {_needsToUpdateFilterSetForImport = newValue}
  }
  /// Returns true if `needsToUpdateFilterSetForImport` has been explicitly set.
  var hasNeedsToUpdateFilterSetForImport: Bool {return self._needsToUpdateFilterSetForImport != nil}
  /// Clears the value of `needsToUpdateFilterSetForImport`. Subsequent reads from it will return its default value.
  mutating func clearNeedsToUpdateFilterSetForImport() {self._needsToUpdateFilterSetForImport = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ownerID: TSP_CFUUIDArchive? = nil
  fileprivate var _needsToUpdateFilterSetForImport: Bool? = nil
}

struct TST_FormulaStoreArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nextFormulaIndex: UInt32 {
    get {return _nextFormulaIndex ?? 0}
    set {_nextFormulaIndex = newValue}
  }
  /// Returns true if `nextFormulaIndex` has been explicitly set.
  var hasNextFormulaIndex: Bool {return self._nextFormulaIndex != nil}
  /// Clears the value of `nextFormulaIndex`. Subsequent reads from it will return its default value.
  mutating func clearNextFormulaIndex() {self._nextFormulaIndex = nil}

  var formulas: [TST_FormulaStoreArchive.FormulaStorePair] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct FormulaStorePair: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var formulaIndex: UInt32 {
      get {return _storage._formulaIndex ?? 0}
      set {_uniqueStorage()._formulaIndex = newValue}
    }
    /// Returns true if `formulaIndex` has been explicitly set.
    var hasFormulaIndex: Bool {return _storage._formulaIndex != nil}
    /// Clears the value of `formulaIndex`. Subsequent reads from it will return its default value.
    mutating func clearFormulaIndex() {_uniqueStorage()._formulaIndex = nil}

    var formula: TSCE_FormulaArchive {
      get {return _storage._formula ?? TSCE_FormulaArchive()}
      set {_uniqueStorage()._formula = newValue}
    }
    /// Returns true if `formula` has been explicitly set.
    var hasFormula: Bool {return _storage._formula != nil}
    /// Clears the value of `formula`. Subsequent reads from it will return its default value.
    mutating func clearFormula() {_uniqueStorage()._formula = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _nextFormulaIndex: UInt32? = nil
}

struct TST_MergeOperationArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mergeType: TST_MergeActionArchive {
    get {return _mergeType ?? .mergeActionInsert}
    set {_mergeType = newValue}
  }
  /// Returns true if `mergeType` has been explicitly set.
  var hasMergeType: Bool {return self._mergeType != nil}
  /// Clears the value of `mergeType`. Subsequent reads from it will return its default value.
  mutating func clearMergeType() {self._mergeType = nil}

  var mergeRanges: [TSP_UUIDRectArchive] = []

  var mergeFormulas: [TSCE_FormulaArchive] = []

  var mergeFormulaIndexes: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mergeType: TST_MergeActionArchive? = nil
}

struct TST_MergeOwnerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerID: TSP_CFUUIDArchive {
    get {return _ownerID ?? TSP_CFUUIDArchive()}
    set {_ownerID = newValue}
  }
  /// Returns true if `ownerID` has been explicitly set.
  var hasOwnerID: Bool {return self._ownerID != nil}
  /// Clears the value of `ownerID`. Subsequent reads from it will return its default value.
  mutating func clearOwnerID() {self._ownerID = nil}

  var formulaStore: TST_FormulaStoreArchive {
    get {return _formulaStore ?? TST_FormulaStoreArchive()}
    set {_formulaStore = newValue}
  }
  /// Returns true if `formulaStore` has been explicitly set.
  var hasFormulaStore: Bool {return self._formulaStore != nil}
  /// Clears the value of `formulaStore`. Subsequent reads from it will return its default value.
  mutating func clearFormulaStore() {self._formulaStore = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ownerID: TSP_CFUUIDArchive? = nil
  fileprivate var _formulaStore: TST_FormulaStoreArchive? = nil
}

struct TST_PencilAnnotationArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tableInfo: TSP_Reference {
    get {return _tableInfo ?? TSP_Reference()}
    set {_tableInfo = newValue}
  }
  /// Returns true if `tableInfo` has been explicitly set.
  var hasTableInfo: Bool {return self._tableInfo != nil}
  /// Clears the value of `tableInfo`. Subsequent reads from it will return its default value.
  mutating func clearTableInfo() {self._tableInfo = nil}

  var pencilAnnotationStorage: TSP_Reference {
    get {return _pencilAnnotationStorage ?? TSP_Reference()}
    set {_pencilAnnotationStorage = newValue}
  }
  /// Returns true if `pencilAnnotationStorage` has been explicitly set.
  var hasPencilAnnotationStorage: Bool {return self._pencilAnnotationStorage != nil}
  /// Clears the value of `pencilAnnotationStorage`. Subsequent reads from it will return its default value.
  mutating func clearPencilAnnotationStorage() {self._pencilAnnotationStorage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tableInfo: TSP_Reference? = nil
  fileprivate var _pencilAnnotationStorage: TSP_Reference? = nil
}

struct TST_PencilAnnotationOwnerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerID: TSP_CFUUIDArchive {
    get {return _ownerID ?? TSP_CFUUIDArchive()}
    set {_ownerID = newValue}
  }
  /// Returns true if `ownerID` has been explicitly set.
  var hasOwnerID: Bool {return self._ownerID != nil}
  /// Clears the value of `ownerID`. Subsequent reads from it will return its default value.
  mutating func clearOwnerID() {self._ownerID = nil}

  var formulaStore: TST_FormulaStoreArchive {
    get {return _formulaStore ?? TST_FormulaStoreArchive()}
    set {_formulaStore = newValue}
  }
  /// Returns true if `formulaStore` has been explicitly set.
  var hasFormulaStore: Bool {return self._formulaStore != nil}
  /// Clears the value of `formulaStore`. Subsequent reads from it will return its default value.
  mutating func clearFormulaStore() {self._formulaStore = nil}

  var annotations: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ownerID: TSP_CFUUIDArchive? = nil
  fileprivate var _formulaStore: TST_FormulaStoreArchive? = nil
}

struct TST_AccumulatorArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var boolCount: UInt32 {
    get {return _boolCount ?? 0}
    set {_boolCount = newValue}
  }
  /// Returns true if `boolCount` has been explicitly set.
  var hasBoolCount: Bool {return self._boolCount != nil}
  /// Clears the value of `boolCount`. Subsequent reads from it will return its default value.
  mutating func clearBoolCount() {self._boolCount = nil}

  var numberCount: UInt32 {
    get {return _numberCount ?? 0}
    set {_numberCount = newValue}
  }
  /// Returns true if `numberCount` has been explicitly set.
  var hasNumberCount: Bool {return self._numberCount != nil}
  /// Clears the value of `numberCount`. Subsequent reads from it will return its default value.
  mutating func clearNumberCount() {self._numberCount = nil}

  var dateCount: UInt32 {
    get {return _dateCount ?? 0}
    set {_dateCount = newValue}
  }
  /// Returns true if `dateCount` has been explicitly set.
  var hasDateCount: Bool {return self._dateCount != nil}
  /// Clears the value of `dateCount`. Subsequent reads from it will return its default value.
  mutating func clearDateCount() {self._dateCount = nil}

  var durationCount: UInt32 {
    get {return _durationCount ?? 0}
    set {_durationCount = newValue}
  }
  /// Returns true if `durationCount` has been explicitly set.
  var hasDurationCount: Bool {return self._durationCount != nil}
  /// Clears the value of `durationCount`. Subsequent reads from it will return its default value.
  mutating func clearDurationCount() {self._durationCount = nil}

  var stringCount: UInt32 {
    get {return _stringCount ?? 0}
    set {_stringCount = newValue}
  }
  /// Returns true if `stringCount` has been explicitly set.
  var hasStringCount: Bool {return self._stringCount != nil}
  /// Clears the value of `stringCount`. Subsequent reads from it will return its default value.
  mutating func clearStringCount() {self._stringCount = nil}

  var minValue: TSCE_CellValueArchive {
    get {return _minValue ?? TSCE_CellValueArchive()}
    set {_minValue = newValue}
  }
  /// Returns true if `minValue` has been explicitly set.
  var hasMinValue: Bool {return self._minValue != nil}
  /// Clears the value of `minValue`. Subsequent reads from it will return its default value.
  mutating func clearMinValue() {self._minValue = nil}

  var maxValue: TSCE_CellValueArchive {
    get {return _maxValue ?? TSCE_CellValueArchive()}
    set {_maxValue = newValue}
  }
  /// Returns true if `maxValue` has been explicitly set.
  var hasMaxValue: Bool {return self._maxValue != nil}
  /// Clears the value of `maxValue`. Subsequent reads from it will return its default value.
  mutating func clearMaxValue() {self._maxValue = nil}

  var numberTotalValue: TSCE_CellValueArchive {
    get {return _numberTotalValue ?? TSCE_CellValueArchive()}
    set {_numberTotalValue = newValue}
  }
  /// Returns true if `numberTotalValue` has been explicitly set.
  var hasNumberTotalValue: Bool {return self._numberTotalValue != nil}
  /// Clears the value of `numberTotalValue`. Subsequent reads from it will return its default value.
  mutating func clearNumberTotalValue() {self._numberTotalValue = nil}

  var firstDateSeen: TSCE_CellValueArchive {
    get {return _firstDateSeen ?? TSCE_CellValueArchive()}
    set {_firstDateSeen = newValue}
  }
  /// Returns true if `firstDateSeen` has been explicitly set.
  var hasFirstDateSeen: Bool {return self._firstDateSeen != nil}
  /// Clears the value of `firstDateSeen`. Subsequent reads from it will return its default value.
  mutating func clearFirstDateSeen() {self._firstDateSeen = nil}

  var totalSecsSinceRefDate: Double {
    get {return _totalSecsSinceRefDate ?? 0}
    set {_totalSecsSinceRefDate = newValue}
  }
  /// Returns true if `totalSecsSinceRefDate` has been explicitly set.
  var hasTotalSecsSinceRefDate: Bool {return self._totalSecsSinceRefDate != nil}
  /// Clears the value of `totalSecsSinceRefDate`. Subsequent reads from it will return its default value.
  mutating func clearTotalSecsSinceRefDate() {self._totalSecsSinceRefDate = nil}

  var secsToAdd: Double {
    get {return _secsToAdd ?? 0}
    set {_secsToAdd = newValue}
  }
  /// Returns true if `secsToAdd` has been explicitly set.
  var hasSecsToAdd: Bool {return self._secsToAdd != nil}
  /// Clears the value of `secsToAdd`. Subsequent reads from it will return its default value.
  mutating func clearSecsToAdd() {self._secsToAdd = nil}

  var boolTrueCount: UInt32 {
    get {return _boolTrueCount ?? 0}
    set {_boolTrueCount = newValue}
  }
  /// Returns true if `boolTrueCount` has been explicitly set.
  var hasBoolTrueCount: Bool {return self._boolTrueCount != nil}
  /// Clears the value of `boolTrueCount`. Subsequent reads from it will return its default value.
  mutating func clearBoolTrueCount() {self._boolTrueCount = nil}

  var errorCount: UInt32 {
    get {return _errorCount ?? 0}
    set {_errorCount = newValue}
  }
  /// Returns true if `errorCount` has been explicitly set.
  var hasErrorCount: Bool {return self._errorCount != nil}
  /// Clears the value of `errorCount`. Subsequent reads from it will return its default value.
  mutating func clearErrorCount() {self._errorCount = nil}

  var isCircularRef: Bool {
    get {return _isCircularRef ?? false}
    set {_isCircularRef = newValue}
  }
  /// Returns true if `isCircularRef` has been explicitly set.
  var hasIsCircularRef: Bool {return self._isCircularRef != nil}
  /// Clears the value of `isCircularRef`. Subsequent reads from it will return its default value.
  mutating func clearIsCircularRef() {self._isCircularRef = nil}

  var productValue: TSCE_CellValueArchive {
    get {return _productValue ?? TSCE_CellValueArchive()}
    set {_productValue = newValue}
  }
  /// Returns true if `productValue` has been explicitly set.
  var hasProductValue: Bool {return self._productValue != nil}
  /// Clears the value of `productValue`. Subsequent reads from it will return its default value.
  mutating func clearProductValue() {self._productValue = nil}

  var noContentCount: UInt32 {
    get {return _noContentCount ?? 0}
    set {_noContentCount = newValue}
  }
  /// Returns true if `noContentCount` has been explicitly set.
  var hasNoContentCount: Bool {return self._noContentCount != nil}
  /// Clears the value of `noContentCount`. Subsequent reads from it will return its default value.
  mutating func clearNoContentCount() {self._noContentCount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _boolCount: UInt32? = nil
  fileprivate var _numberCount: UInt32? = nil
  fileprivate var _dateCount: UInt32? = nil
  fileprivate var _durationCount: UInt32? = nil
  fileprivate var _stringCount: UInt32? = nil
  fileprivate var _minValue: TSCE_CellValueArchive? = nil
  fileprivate var _maxValue: TSCE_CellValueArchive? = nil
  fileprivate var _numberTotalValue: TSCE_CellValueArchive? = nil
  fileprivate var _firstDateSeen: TSCE_CellValueArchive? = nil
  fileprivate var _totalSecsSinceRefDate: Double? = nil
  fileprivate var _secsToAdd: Double? = nil
  fileprivate var _boolTrueCount: UInt32? = nil
  fileprivate var _errorCount: UInt32? = nil
  fileprivate var _isCircularRef: Bool? = nil
  fileprivate var _productValue: TSCE_CellValueArchive? = nil
  fileprivate var _noContentCount: UInt32? = nil
}

struct TST_GroupColumnArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var columnUid: TSP_UUID {
    get {return _columnUid ?? TSP_UUID()}
    set {_columnUid = newValue}
  }
  /// Returns true if `columnUid` has been explicitly set.
  var hasColumnUid: Bool {return self._columnUid != nil}
  /// Clears the value of `columnUid`. Subsequent reads from it will return its default value.
  mutating func clearColumnUid() {self._columnUid = nil}

  var groupingType: UInt32 {
    get {return _groupingType ?? 0}
    set {_groupingType = newValue}
  }
  /// Returns true if `groupingType` has been explicitly set.
  var hasGroupingType: Bool {return self._groupingType != nil}
  /// Clears the value of `groupingType`. Subsequent reads from it will return its default value.
  mutating func clearGroupingType() {self._groupingType = nil}

  var groupingFunctor: TSCE_FunctorArchive {
    get {return _groupingFunctor ?? TSCE_FunctorArchive()}
    set {_groupingFunctor = newValue}
  }
  /// Returns true if `groupingFunctor` has been explicitly set.
  var hasGroupingFunctor: Bool {return self._groupingFunctor != nil}
  /// Clears the value of `groupingFunctor`. Subsequent reads from it will return its default value.
  mutating func clearGroupingFunctor() {self._groupingFunctor = nil}

  var groupingColumnUid: TSP_UUID {
    get {return _groupingColumnUid ?? TSP_UUID()}
    set {_groupingColumnUid = newValue}
  }
  /// Returns true if `groupingColumnUid` has been explicitly set.
  var hasGroupingColumnUid: Bool {return self._groupingColumnUid != nil}
  /// Clears the value of `groupingColumnUid`. Subsequent reads from it will return its default value.
  mutating func clearGroupingColumnUid() {self._groupingColumnUid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _columnUid: TSP_UUID? = nil
  fileprivate var _groupingType: UInt32? = nil
  fileprivate var _groupingFunctor: TSCE_FunctorArchive? = nil
  fileprivate var _groupingColumnUid: TSP_UUID? = nil
}

struct TST_GroupColumnListArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groupColumn: [TST_GroupColumnArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TST_ColumnAggregateArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var columnUid: TSP_UUID {
    get {return _columnUid ?? TSP_UUID()}
    set {_columnUid = newValue}
  }
  /// Returns true if `columnUid` has been explicitly set.
  var hasColumnUid: Bool {return self._columnUid != nil}
  /// Clears the value of `columnUid`. Subsequent reads from it will return its default value.
  mutating func clearColumnUid() {self._columnUid = nil}

  var level: UInt32 {
    get {return _level ?? 0}
    set {_level = newValue}
  }
  /// Returns true if `level` has been explicitly set.
  var hasLevel: Bool {return self._level != nil}
  /// Clears the value of `level`. Subsequent reads from it will return its default value.
  mutating func clearLevel() {self._level = nil}

  var aggType: UInt32 {
    get {return _aggType ?? 0}
    set {_aggType = newValue}
  }
  /// Returns true if `aggType` has been explicitly set.
  var hasAggType: Bool {return self._aggType != nil}
  /// Clears the value of `aggType`. Subsequent reads from it will return its default value.
  mutating func clearAggType() {self._aggType = nil}

  var showAsType: UInt32 {
    get {return _showAsType ?? 0}
    set {_showAsType = newValue}
  }
  /// Returns true if `showAsType` has been explicitly set.
  var hasShowAsType: Bool {return self._showAsType != nil}
  /// Clears the value of `showAsType`. Subsequent reads from it will return its default value.
  mutating func clearShowAsType() {self._showAsType = nil}

  var columnAggregateUid: TSP_UUID {
    get {return _columnAggregateUid ?? TSP_UUID()}
    set {_columnAggregateUid = newValue}
  }
  /// Returns true if `columnAggregateUid` has been explicitly set.
  var hasColumnAggregateUid: Bool {return self._columnAggregateUid != nil}
  /// Clears the value of `columnAggregateUid`. Subsequent reads from it will return its default value.
  mutating func clearColumnAggregateUid() {self._columnAggregateUid = nil}

  var runningTotalGroupColumnUid: TSP_UUID {
    get {return _runningTotalGroupColumnUid ?? TSP_UUID()}
    set {_runningTotalGroupColumnUid = newValue}
  }
  /// Returns true if `runningTotalGroupColumnUid` has been explicitly set.
  var hasRunningTotalGroupColumnUid: Bool {return self._runningTotalGroupColumnUid != nil}
  /// Clears the value of `runningTotalGroupColumnUid`. Subsequent reads from it will return its default value.
  mutating func clearRunningTotalGroupColumnUid() {self._runningTotalGroupColumnUid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _columnUid: TSP_UUID? = nil
  fileprivate var _level: UInt32? = nil
  fileprivate var _aggType: UInt32? = nil
  fileprivate var _showAsType: UInt32? = nil
  fileprivate var _columnAggregateUid: TSP_UUID? = nil
  fileprivate var _runningTotalGroupColumnUid: TSP_UUID? = nil
}

struct TST_ColumnAggregateListArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var aggregates: [TST_ColumnAggregateArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TST_GroupByArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groupByUid: TSP_UUID {
    get {return _storage._groupByUid ?? TSP_UUID()}
    set {_uniqueStorage()._groupByUid = newValue}
  }
  /// Returns true if `groupByUid` has been explicitly set.
  var hasGroupByUid: Bool {return _storage._groupByUid != nil}
  /// Clears the value of `groupByUid`. Subsequent reads from it will return its default value.
  mutating func clearGroupByUid() {_uniqueStorage()._groupByUid = nil}

  var groupColumn: [TST_GroupColumnArchive] {
    get {return _storage._groupColumn}
    set {_uniqueStorage()._groupColumn = newValue}
  }

  var groupNodeRoot: TST_GroupByArchive.GroupNodeArchive {
    get {return _storage._groupNodeRoot ?? TST_GroupByArchive.GroupNodeArchive()}
    set {_uniqueStorage()._groupNodeRoot = newValue}
  }
  /// Returns true if `groupNodeRoot` has been explicitly set.
  var hasGroupNodeRoot: Bool {return _storage._groupNodeRoot != nil}
  /// Clears the value of `groupNodeRoot`. Subsequent reads from it will return its default value.
  mutating func clearGroupNodeRoot() {_uniqueStorage()._groupNodeRoot = nil}

  var aggregator: [TST_GroupByArchive.AggregatorArchive] {
    get {return _storage._aggregator}
    set {_uniqueStorage()._aggregator = newValue}
  }

  var columnAggType: [TST_ColumnAggregateArchive] {
    get {return _storage._columnAggType}
    set {_uniqueStorage()._columnAggType = newValue}
  }

  var isEnabled: Bool {
    get {return _storage._isEnabled ?? false}
    set {_uniqueStorage()._isEnabled = newValue}
  }
  /// Returns true if `isEnabled` has been explicitly set.
  var hasIsEnabled: Bool {return _storage._isEnabled != nil}
  /// Clears the value of `isEnabled`. Subsequent reads from it will return its default value.
  mutating func clearIsEnabled() {_uniqueStorage()._isEnabled = nil}

  var indirectAggTypeChangeFormula: TSCE_CellCoordinateArchive {
    get {return _storage._indirectAggTypeChangeFormula ?? TSCE_CellCoordinateArchive()}
    set {_uniqueStorage()._indirectAggTypeChangeFormula = newValue}
  }
  /// Returns true if `indirectAggTypeChangeFormula` has been explicitly set.
  var hasIndirectAggTypeChangeFormula: Bool {return _storage._indirectAggTypeChangeFormula != nil}
  /// Clears the value of `indirectAggTypeChangeFormula`. Subsequent reads from it will return its default value.
  mutating func clearIndirectAggTypeChangeFormula() {_uniqueStorage()._indirectAggTypeChangeFormula = nil}

  var groupingColumnsFormula: TSCE_CellCoordinateArchive {
    get {return _storage._groupingColumnsFormula ?? TSCE_CellCoordinateArchive()}
    set {_uniqueStorage()._groupingColumnsFormula = newValue}
  }
  /// Returns true if `groupingColumnsFormula` has been explicitly set.
  var hasGroupingColumnsFormula: Bool {return _storage._groupingColumnsFormula != nil}
  /// Clears the value of `groupingColumnsFormula`. Subsequent reads from it will return its default value.
  mutating func clearGroupingColumnsFormula() {_uniqueStorage()._groupingColumnsFormula = nil}

  var aggsInGroupRootFormula: TSCE_CellCoordinateArchive {
    get {return _storage._aggsInGroupRootFormula ?? TSCE_CellCoordinateArchive()}
    set {_uniqueStorage()._aggsInGroupRootFormula = newValue}
  }
  /// Returns true if `aggsInGroupRootFormula` has been explicitly set.
  var hasAggsInGroupRootFormula: Bool {return _storage._aggsInGroupRootFormula != nil}
  /// Clears the value of `aggsInGroupRootFormula`. Subsequent reads from it will return its default value.
  mutating func clearAggsInGroupRootFormula() {_uniqueStorage()._aggsInGroupRootFormula = nil}

  var groupingColumnHeadersFormula: TSCE_CellCoordinateArchive {
    get {return _storage._groupingColumnHeadersFormula ?? TSCE_CellCoordinateArchive()}
    set {_uniqueStorage()._groupingColumnHeadersFormula = newValue}
  }
  /// Returns true if `groupingColumnHeadersFormula` has been explicitly set.
  var hasGroupingColumnHeadersFormula: Bool {return _storage._groupingColumnHeadersFormula != nil}
  /// Clears the value of `groupingColumnHeadersFormula`. Subsequent reads from it will return its default value.
  mutating func clearGroupingColumnHeadersFormula() {_uniqueStorage()._groupingColumnHeadersFormula = nil}

  var columnOrderChangedFormula: TSCE_CellCoordinateArchive {
    get {return _storage._columnOrderChangedFormula ?? TSCE_CellCoordinateArchive()}
    set {_uniqueStorage()._columnOrderChangedFormula = newValue}
  }
  /// Returns true if `columnOrderChangedFormula` has been explicitly set.
  var hasColumnOrderChangedFormula: Bool {return _storage._columnOrderChangedFormula != nil}
  /// Clears the value of `columnOrderChangedFormula`. Subsequent reads from it will return its default value.
  mutating func clearColumnOrderChangedFormula() {_uniqueStorage()._columnOrderChangedFormula = nil}

  var rowOrderChangedFormula: TSCE_CellCoordinateArchive {
    get {return _storage._rowOrderChangedFormula ?? TSCE_CellCoordinateArchive()}
    set {_uniqueStorage()._rowOrderChangedFormula = newValue}
  }
  /// Returns true if `rowOrderChangedFormula` has been explicitly set.
  var hasRowOrderChangedFormula: Bool {return _storage._rowOrderChangedFormula != nil}
  /// Clears the value of `rowOrderChangedFormula`. Subsequent reads from it will return its default value.
  mutating func clearRowOrderChangedFormula() {_uniqueStorage()._rowOrderChangedFormula = nil}

  var rowOrderChangedIgnoringRecalcFormula: TSCE_CellCoordinateArchive {
    get {return _storage._rowOrderChangedIgnoringRecalcFormula ?? TSCE_CellCoordinateArchive()}
    set {_uniqueStorage()._rowOrderChangedIgnoringRecalcFormula = newValue}
  }
  /// Returns true if `rowOrderChangedIgnoringRecalcFormula` has been explicitly set.
  var hasRowOrderChangedIgnoringRecalcFormula: Bool {return _storage._rowOrderChangedIgnoringRecalcFormula != nil}
  /// Clears the value of `rowOrderChangedIgnoringRecalcFormula`. Subsequent reads from it will return its default value.
  mutating func clearRowOrderChangedIgnoringRecalcFormula() {_uniqueStorage()._rowOrderChangedIgnoringRecalcFormula = nil}

  var ownerIndex: Int32 {
    get {return _storage._ownerIndex ?? 8}
    set {_uniqueStorage()._ownerIndex = newValue}
  }
  /// Returns true if `ownerIndex` has been explicitly set.
  var hasOwnerIndex: Bool {return _storage._ownerIndex != nil}
  /// Clears the value of `ownerIndex`. Subsequent reads from it will return its default value.
  mutating func clearOwnerIndex() {_uniqueStorage()._ownerIndex = nil}

  var rowUidLookup: TSCE_UidLookupListArchive {
    get {return _storage._rowUidLookup ?? TSCE_UidLookupListArchive()}
    set {_uniqueStorage()._rowUidLookup = newValue}
  }
  /// Returns true if `rowUidLookup` has been explicitly set.
  var hasRowUidLookup: Bool {return _storage._rowUidLookup != nil}
  /// Clears the value of `rowUidLookup`. Subsequent reads from it will return its default value.
  mutating func clearRowUidLookup() {_uniqueStorage()._rowUidLookup = nil}

  var hiddenStatesChangedFormula: TSCE_CellCoordinateArchive {
    get {return _storage._hiddenStatesChangedFormula ?? TSCE_CellCoordinateArchive()}
    set {_uniqueStorage()._hiddenStatesChangedFormula = newValue}
  }
  /// Returns true if `hiddenStatesChangedFormula` has been explicitly set.
  var hasHiddenStatesChangedFormula: Bool {return _storage._hiddenStatesChangedFormula != nil}
  /// Clears the value of `hiddenStatesChangedFormula`. Subsequent reads from it will return its default value.
  mutating func clearHiddenStatesChangedFormula() {_uniqueStorage()._hiddenStatesChangedFormula = nil}

  var aggregatorRef: [TSP_Reference] {
    get {return _storage._aggregatorRef}
    set {_uniqueStorage()._aggregatorRef = newValue}
  }

  var groupNodeRootRef: TSP_Reference {
    get {return _storage._groupNodeRootRef ?? TSP_Reference()}
    set {_uniqueStorage()._groupNodeRootRef = newValue}
  }
  /// Returns true if `groupNodeRootRef` has been explicitly set.
  var hasGroupNodeRootRef: Bool {return _storage._groupNodeRootRef != nil}
  /// Clears the value of `groupNodeRootRef`. Subsequent reads from it will return its default value.
  mutating func clearGroupNodeRootRef() {_uniqueStorage()._groupNodeRootRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct AggNodeArchive: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var formulaCoord: TSCE_CellCoordinateArchive {
      get {return _storage._formulaCoord ?? TSCE_CellCoordinateArchive()}
      set {_uniqueStorage()._formulaCoord = newValue}
    }
    /// Returns true if `formulaCoord` has been explicitly set.
    var hasFormulaCoord: Bool {return _storage._formulaCoord != nil}
    /// Clears the value of `formulaCoord`. Subsequent reads from it will return its default value.
    mutating func clearFormulaCoord() {_uniqueStorage()._formulaCoord = nil}

    var accum: TST_AccumulatorArchive {
      get {return _storage._accum ?? TST_AccumulatorArchive()}
      set {_uniqueStorage()._accum = newValue}
    }
    /// Returns true if `accum` has been explicitly set.
    var hasAccum: Bool {return _storage._accum != nil}
    /// Clears the value of `accum`. Subsequent reads from it will return its default value.
    mutating func clearAccum() {_uniqueStorage()._accum = nil}

    var child: [TST_GroupByArchive.AggNodeArchive] {
      get {return _storage._child}
      set {_uniqueStorage()._child = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct AggregatorArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var columnUid: TSP_UUID {
      get {return _columnUid ?? TSP_UUID()}
      set {_columnUid = newValue}
    }
    /// Returns true if `columnUid` has been explicitly set.
    var hasColumnUid: Bool {return self._columnUid != nil}
    /// Clears the value of `columnUid`. Subsequent reads from it will return its default value.
    mutating func clearColumnUid() {self._columnUid = nil}

    var aggNode: TST_GroupByArchive.AggNodeArchive {
      get {return _aggNode ?? TST_GroupByArchive.AggNodeArchive()}
      set {_aggNode = newValue}
    }
    /// Returns true if `aggNode` has been explicitly set.
    var hasAggNode: Bool {return self._aggNode != nil}
    /// Clears the value of `aggNode`. Subsequent reads from it will return its default value.
    mutating func clearAggNode() {self._aggNode = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _columnUid: TSP_UUID? = nil
    fileprivate var _aggNode: TST_GroupByArchive.AggNodeArchive? = nil
  }

  struct GroupNodeArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var groupUid: TSP_UUID {
      get {return _groupUid ?? TSP_UUID()}
      set {_groupUid = newValue}
    }
    /// Returns true if `groupUid` has been explicitly set.
    var hasGroupUid: Bool {return self._groupUid != nil}
    /// Clears the value of `groupUid`. Subsequent reads from it will return its default value.
    mutating func clearGroupUid() {self._groupUid = nil}

    var child: [TST_GroupByArchive.GroupNodeArchive] = []

    var rowUid: [TSP_UUID] = []

    var aggFormulaCoords: [TSCE_CellCoordinateArchive] = []

    var formatManager: TST_GroupByArchive.GroupNodeArchive.FormatManagerArchive {
      get {return _formatManager ?? TST_GroupByArchive.GroupNodeArchive.FormatManagerArchive()}
      set {_formatManager = newValue}
    }
    /// Returns true if `formatManager` has been explicitly set.
    var hasFormatManager: Bool {return self._formatManager != nil}
    /// Clears the value of `formatManager`. Subsequent reads from it will return its default value.
    mutating func clearFormatManager() {self._formatManager = nil}

    var groupCellValue: TSCE_CellValueArchive {
      get {return _groupCellValue ?? TSCE_CellValueArchive()}
      set {_groupCellValue = newValue}
    }
    /// Returns true if `groupCellValue` has been explicitly set.
    var hasGroupCellValue: Bool {return self._groupCellValue != nil}
    /// Clears the value of `groupCellValue`. Subsequent reads from it will return its default value.
    mutating func clearGroupCellValue() {self._groupCellValue = nil}

    var rowIndexes: TSCE_IndexSetArchive {
      get {return _rowIndexes ?? TSCE_IndexSetArchive()}
      set {_rowIndexes = newValue}
    }
    /// Returns true if `rowIndexes` has been explicitly set.
    var hasRowIndexes: Bool {return self._rowIndexes != nil}
    /// Clears the value of `rowIndexes`. Subsequent reads from it will return its default value.
    mutating func clearRowIndexes() {self._rowIndexes = nil}

    var rowLookupUids: TSCE_IndexSetArchive {
      get {return _rowLookupUids ?? TSCE_IndexSetArchive()}
      set {_rowLookupUids = newValue}
    }
    /// Returns true if `rowLookupUids` has been explicitly set.
    var hasRowLookupUids: Bool {return self._rowLookupUids != nil}
    /// Clears the value of `rowLookupUids`. Subsequent reads from it will return its default value.
    mutating func clearRowLookupUids() {self._rowLookupUids = nil}

    var childRef: [TSP_Reference] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct FormatManagerArchive: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var cellValue: TSCE_CellValueArchive {
        get {return _cellValue ?? TSCE_CellValueArchive()}
        set {_cellValue = newValue}
      }
      /// Returns true if `cellValue` has been explicitly set.
      var hasCellValue: Bool {return self._cellValue != nil}
      /// Clears the value of `cellValue`. Subsequent reads from it will return its default value.
      mutating func clearCellValue() {self._cellValue = nil}

      var formats: [TSK_FormatStructArchive] = []

      var rowSets: [TST_GroupByArchive.GroupNodeArchive.FormatManagerArchive.RowSetArchive] = []

      var rowUidLookupSets: [TSCE_IndexSetArchive] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      struct RowSetArchive: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var rowUids: [TSP_UUID] = []

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}

      fileprivate var _cellValue: TSCE_CellValueArchive? = nil
    }

    init() {}

    fileprivate var _groupUid: TSP_UUID? = nil
    fileprivate var _formatManager: TST_GroupByArchive.GroupNodeArchive.FormatManagerArchive? = nil
    fileprivate var _groupCellValue: TSCE_CellValueArchive? = nil
    fileprivate var _rowIndexes: TSCE_IndexSetArchive? = nil
    fileprivate var _rowLookupUids: TSCE_IndexSetArchive? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CategoryOwnerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerUid: TSP_UUID {
    get {return _ownerUid ?? TSP_UUID()}
    set {_ownerUid = newValue}
  }
  /// Returns true if `ownerUid` has been explicitly set.
  var hasOwnerUid: Bool {return self._ownerUid != nil}
  /// Clears the value of `ownerUid`. Subsequent reads from it will return its default value.
  mutating func clearOwnerUid() {self._ownerUid = nil}

  var groupBy: [TST_GroupByArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ownerUid: TSP_UUID? = nil
}

struct TST_CategoryOwnerRefArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groupBy: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TST_PivotGroupingColumnOptionsMapArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uids: [TSP_UUID] = []

  var flags: [UInt32] = []

  var aggregateRuleUids: [TSP_UUID] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TST_PivotOwnerArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pivotOwnerUid: TSP_UUID {
    get {return _storage._pivotOwnerUid ?? TSP_UUID()}
    set {_uniqueStorage()._pivotOwnerUid = newValue}
  }
  /// Returns true if `pivotOwnerUid` has been explicitly set.
  var hasPivotOwnerUid: Bool {return _storage._pivotOwnerUid != nil}
  /// Clears the value of `pivotOwnerUid`. Subsequent reads from it will return its default value.
  mutating func clearPivotOwnerUid() {_uniqueStorage()._pivotOwnerUid = nil}

  var groupingColumnsForRows: TST_GroupColumnListArchive {
    get {return _storage._groupingColumnsForRows ?? TST_GroupColumnListArchive()}
    set {_uniqueStorage()._groupingColumnsForRows = newValue}
  }
  /// Returns true if `groupingColumnsForRows` has been explicitly set.
  var hasGroupingColumnsForRows: Bool {return _storage._groupingColumnsForRows != nil}
  /// Clears the value of `groupingColumnsForRows`. Subsequent reads from it will return its default value.
  mutating func clearGroupingColumnsForRows() {_uniqueStorage()._groupingColumnsForRows = nil}

  var groupingColumnsForColumns: TST_GroupColumnListArchive {
    get {return _storage._groupingColumnsForColumns ?? TST_GroupColumnListArchive()}
    set {_uniqueStorage()._groupingColumnsForColumns = newValue}
  }
  /// Returns true if `groupingColumnsForColumns` has been explicitly set.
  var hasGroupingColumnsForColumns: Bool {return _storage._groupingColumnsForColumns != nil}
  /// Clears the value of `groupingColumnsForColumns`. Subsequent reads from it will return its default value.
  mutating func clearGroupingColumnsForColumns() {_uniqueStorage()._groupingColumnsForColumns = nil}

  var aggregateColumns: TST_ColumnAggregateListArchive {
    get {return _storage._aggregateColumns ?? TST_ColumnAggregateListArchive()}
    set {_uniqueStorage()._aggregateColumns = newValue}
  }
  /// Returns true if `aggregateColumns` has been explicitly set.
  var hasAggregateColumns: Bool {return _storage._aggregateColumns != nil}
  /// Clears the value of `aggregateColumns`. Subsequent reads from it will return its default value.
  mutating func clearAggregateColumns() {_uniqueStorage()._aggregateColumns = nil}

  var flatteningDimension: Int32 {
    get {return _storage._flatteningDimension ?? 0}
    set {_uniqueStorage()._flatteningDimension = newValue}
  }
  /// Returns true if `flatteningDimension` has been explicitly set.
  var hasFlatteningDimension: Bool {return _storage._flatteningDimension != nil}
  /// Clears the value of `flatteningDimension`. Subsequent reads from it will return its default value.
  mutating func clearFlatteningDimension() {_uniqueStorage()._flatteningDimension = nil}

  var isEmptyPivot: Bool {
    get {return _storage._isEmptyPivot ?? false}
    set {_uniqueStorage()._isEmptyPivot = newValue}
  }
  /// Returns true if `isEmptyPivot` has been explicitly set.
  var hasIsEmptyPivot: Bool {return _storage._isEmptyPivot != nil}
  /// Clears the value of `isEmptyPivot`. Subsequent reads from it will return its default value.
  mutating func clearIsEmptyPivot() {_uniqueStorage()._isEmptyPivot = nil}

  var sourceTableUid: TSP_UUID {
    get {return _storage._sourceTableUid ?? TSP_UUID()}
    set {_uniqueStorage()._sourceTableUid = newValue}
  }
  /// Returns true if `sourceTableUid` has been explicitly set.
  var hasSourceTableUid: Bool {return _storage._sourceTableUid != nil}
  /// Clears the value of `sourceTableUid`. Subsequent reads from it will return its default value.
  mutating func clearSourceTableUid() {_uniqueStorage()._sourceTableUid = nil}

  var refreshTimestamp: Double {
    get {return _storage._refreshTimestamp ?? 0}
    set {_uniqueStorage()._refreshTimestamp = newValue}
  }
  /// Returns true if `refreshTimestamp` has been explicitly set.
  var hasRefreshTimestamp: Bool {return _storage._refreshTimestamp != nil}
  /// Clears the value of `refreshTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearRefreshTimestamp() {_uniqueStorage()._refreshTimestamp = nil}

  var grpgColOptionsMap: TSP_Reference {
    get {return _storage._grpgColOptionsMap ?? TSP_Reference()}
    set {_uniqueStorage()._grpgColOptionsMap = newValue}
  }
  /// Returns true if `grpgColOptionsMap` has been explicitly set.
  var hasGrpgColOptionsMap: Bool {return _storage._grpgColOptionsMap != nil}
  /// Clears the value of `grpgColOptionsMap`. Subsequent reads from it will return its default value.
  mutating func clearGrpgColOptionsMap() {_uniqueStorage()._grpgColOptionsMap = nil}

  var hideGrandTotalRows: Bool {
    get {return _storage._hideGrandTotalRows ?? false}
    set {_uniqueStorage()._hideGrandTotalRows = newValue}
  }
  /// Returns true if `hideGrandTotalRows` has been explicitly set.
  var hasHideGrandTotalRows: Bool {return _storage._hideGrandTotalRows != nil}
  /// Clears the value of `hideGrandTotalRows`. Subsequent reads from it will return its default value.
  mutating func clearHideGrandTotalRows() {_uniqueStorage()._hideGrandTotalRows = nil}

  var sourceTableName: String {
    get {return _storage._sourceTableName ?? String()}
    set {_uniqueStorage()._sourceTableName = newValue}
  }
  /// Returns true if `sourceTableName` has been explicitly set.
  var hasSourceTableName: Bool {return _storage._sourceTableName != nil}
  /// Clears the value of `sourceTableName`. Subsequent reads from it will return its default value.
  mutating func clearSourceTableName() {_uniqueStorage()._sourceTableName = nil}

  var hideGrandTotalColumns: Bool {
    get {return _storage._hideGrandTotalColumns ?? false}
    set {_uniqueStorage()._hideGrandTotalColumns = newValue}
  }
  /// Returns true if `hideGrandTotalColumns` has been explicitly set.
  var hasHideGrandTotalColumns: Bool {return _storage._hideGrandTotalColumns != nil}
  /// Clears the value of `hideGrandTotalColumns`. Subsequent reads from it will return its default value.
  mutating func clearHideGrandTotalColumns() {_uniqueStorage()._hideGrandTotalColumns = nil}

  var formulaStore: TST_FormulaStoreArchive {
    get {return _storage._formulaStore ?? TST_FormulaStoreArchive()}
    set {_uniqueStorage()._formulaStore = newValue}
  }
  /// Returns true if `formulaStore` has been explicitly set.
  var hasFormulaStore: Bool {return _storage._formulaStore != nil}
  /// Clears the value of `formulaStore`. Subsequent reads from it will return its default value.
  mutating func clearFormulaStore() {_uniqueStorage()._formulaStore = nil}

  var refreshUid: TSP_UUID {
    get {return _storage._refreshUid ?? TSP_UUID()}
    set {_uniqueStorage()._refreshUid = newValue}
  }
  /// Returns true if `refreshUid` has been explicitly set.
  var hasRefreshUid: Bool {return _storage._refreshUid != nil}
  /// Clears the value of `refreshUid`. Subsequent reads from it will return its default value.
  mutating func clearRefreshUid() {_uniqueStorage()._refreshUid = nil}

  var rowColumnRuleChangeUid: TSP_UUID {
    get {return _storage._rowColumnRuleChangeUid ?? TSP_UUID()}
    set {_uniqueStorage()._rowColumnRuleChangeUid = newValue}
  }
  /// Returns true if `rowColumnRuleChangeUid` has been explicitly set.
  var hasRowColumnRuleChangeUid: Bool {return _storage._rowColumnRuleChangeUid != nil}
  /// Clears the value of `rowColumnRuleChangeUid`. Subsequent reads from it will return its default value.
  mutating func clearRowColumnRuleChangeUid() {_uniqueStorage()._rowColumnRuleChangeUid = nil}

  var aggregateRuleChangeUid: TSP_UUID {
    get {return _storage._aggregateRuleChangeUid ?? TSP_UUID()}
    set {_uniqueStorage()._aggregateRuleChangeUid = newValue}
  }
  /// Returns true if `aggregateRuleChangeUid` has been explicitly set.
  var hasAggregateRuleChangeUid: Bool {return _storage._aggregateRuleChangeUid != nil}
  /// Clears the value of `aggregateRuleChangeUid`. Subsequent reads from it will return its default value.
  mutating func clearAggregateRuleChangeUid() {_uniqueStorage()._aggregateRuleChangeUid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_RichTextPayloadArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var storage: TSP_Reference {
    get {return _storage ?? TSP_Reference()}
    set {_storage = newValue}
  }
  /// Returns true if `storage` has been explicitly set.
  var hasStorage: Bool {return self._storage != nil}
  /// Clears the value of `storage`. Subsequent reads from it will return its default value.
  mutating func clearStorage() {self._storage = nil}

  var range: TSP_Range {
    get {return _range ?? TSP_Range()}
    set {_range = newValue}
  }
  /// Returns true if `range` has been explicitly set.
  var hasRange: Bool {return self._range != nil}
  /// Clears the value of `range`. Subsequent reads from it will return its default value.
  mutating func clearRange() {self._range = nil}

  var cellid: TST_CellID {
    get {return _cellid ?? TST_CellID()}
    set {_cellid = newValue}
  }
  /// Returns true if `cellid` has been explicitly set.
  var hasCellid: Bool {return self._cellid != nil}
  /// Clears the value of `cellid`. Subsequent reads from it will return its default value.
  mutating func clearCellid() {self._cellid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage: TSP_Reference? = nil
  fileprivate var _range: TSP_Range? = nil
  fileprivate var _cellid: TST_CellID? = nil
}

struct TST_FormulaEqualsTokenAttachmentArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_UIGraphicalAttachment {
    get {return _super ?? TSWP_UIGraphicalAttachment()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_UIGraphicalAttachment? = nil
}

struct TST_CellFillStandIn: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fill: TSD_FillArchive {
    get {return _storage._fill ?? TSD_FillArchive()}
    set {_uniqueStorage()._fill = newValue}
  }
  /// Returns true if `fill` has been explicitly set.
  var hasFill: Bool {return _storage._fill != nil}
  /// Clears the value of `fill`. Subsequent reads from it will return its default value.
  mutating func clearFill() {_uniqueStorage()._fill = nil}

  var typeIsMixed: Bool {
    get {return _storage._typeIsMixed ?? false}
    set {_uniqueStorage()._typeIsMixed = newValue}
  }
  /// Returns true if `typeIsMixed` has been explicitly set.
  var hasTypeIsMixed: Bool {return _storage._typeIsMixed != nil}
  /// Clears the value of `typeIsMixed`. Subsequent reads from it will return its default value.
  mutating func clearTypeIsMixed() {_uniqueStorage()._typeIsMixed = nil}

  var colorHasBeenModified: Bool {
    get {return _storage._colorHasBeenModified ?? false}
    set {_uniqueStorage()._colorHasBeenModified = newValue}
  }
  /// Returns true if `colorHasBeenModified` has been explicitly set.
  var hasColorHasBeenModified: Bool {return _storage._colorHasBeenModified != nil}
  /// Clears the value of `colorHasBeenModified`. Subsequent reads from it will return its default value.
  mutating func clearColorHasBeenModified() {_uniqueStorage()._colorHasBeenModified = nil}

  var colorIsMixed: Bool {
    get {return _storage._colorIsMixed ?? false}
    set {_uniqueStorage()._colorIsMixed = newValue}
  }
  /// Returns true if `colorIsMixed` has been explicitly set.
  var hasColorIsMixed: Bool {return _storage._colorIsMixed != nil}
  /// Clears the value of `colorIsMixed`. Subsequent reads from it will return its default value.
  mutating func clearColorIsMixed() {_uniqueStorage()._colorIsMixed = nil}

  var firstColorHasBeenModified: Bool {
    get {return _storage._firstColorHasBeenModified ?? false}
    set {_uniqueStorage()._firstColorHasBeenModified = newValue}
  }
  /// Returns true if `firstColorHasBeenModified` has been explicitly set.
  var hasFirstColorHasBeenModified: Bool {return _storage._firstColorHasBeenModified != nil}
  /// Clears the value of `firstColorHasBeenModified`. Subsequent reads from it will return its default value.
  mutating func clearFirstColorHasBeenModified() {_uniqueStorage()._firstColorHasBeenModified = nil}

  var firstColorIsMixed: Bool {
    get {return _storage._firstColorIsMixed ?? false}
    set {_uniqueStorage()._firstColorIsMixed = newValue}
  }
  /// Returns true if `firstColorIsMixed` has been explicitly set.
  var hasFirstColorIsMixed: Bool {return _storage._firstColorIsMixed != nil}
  /// Clears the value of `firstColorIsMixed`. Subsequent reads from it will return its default value.
  mutating func clearFirstColorIsMixed() {_uniqueStorage()._firstColorIsMixed = nil}

  var lastColorHasBeenModified: Bool {
    get {return _storage._lastColorHasBeenModified ?? false}
    set {_uniqueStorage()._lastColorHasBeenModified = newValue}
  }
  /// Returns true if `lastColorHasBeenModified` has been explicitly set.
  var hasLastColorHasBeenModified: Bool {return _storage._lastColorHasBeenModified != nil}
  /// Clears the value of `lastColorHasBeenModified`. Subsequent reads from it will return its default value.
  mutating func clearLastColorHasBeenModified() {_uniqueStorage()._lastColorHasBeenModified = nil}

  var lastColorIsMixed: Bool {
    get {return _storage._lastColorIsMixed ?? false}
    set {_uniqueStorage()._lastColorIsMixed = newValue}
  }
  /// Returns true if `lastColorIsMixed` has been explicitly set.
  var hasLastColorIsMixed: Bool {return _storage._lastColorIsMixed != nil}
  /// Clears the value of `lastColorIsMixed`. Subsequent reads from it will return its default value.
  mutating func clearLastColorIsMixed() {_uniqueStorage()._lastColorIsMixed = nil}

  var gradientTypeHasBeenModified: Bool {
    get {return _storage._gradientTypeHasBeenModified ?? false}
    set {_uniqueStorage()._gradientTypeHasBeenModified = newValue}
  }
  /// Returns true if `gradientTypeHasBeenModified` has been explicitly set.
  var hasGradientTypeHasBeenModified: Bool {return _storage._gradientTypeHasBeenModified != nil}
  /// Clears the value of `gradientTypeHasBeenModified`. Subsequent reads from it will return its default value.
  mutating func clearGradientTypeHasBeenModified() {_uniqueStorage()._gradientTypeHasBeenModified = nil}

  var gradientTypeIsMixed: Bool {
    get {return _storage._gradientTypeIsMixed ?? false}
    set {_uniqueStorage()._gradientTypeIsMixed = newValue}
  }
  /// Returns true if `gradientTypeIsMixed` has been explicitly set.
  var hasGradientTypeIsMixed: Bool {return _storage._gradientTypeIsMixed != nil}
  /// Clears the value of `gradientTypeIsMixed`. Subsequent reads from it will return its default value.
  mutating func clearGradientTypeIsMixed() {_uniqueStorage()._gradientTypeIsMixed = nil}

  var gradientAngleHasBeenModified: Bool {
    get {return _storage._gradientAngleHasBeenModified ?? false}
    set {_uniqueStorage()._gradientAngleHasBeenModified = newValue}
  }
  /// Returns true if `gradientAngleHasBeenModified` has been explicitly set.
  var hasGradientAngleHasBeenModified: Bool {return _storage._gradientAngleHasBeenModified != nil}
  /// Clears the value of `gradientAngleHasBeenModified`. Subsequent reads from it will return its default value.
  mutating func clearGradientAngleHasBeenModified() {_uniqueStorage()._gradientAngleHasBeenModified = nil}

  var gradientAngleIsMixed: Bool {
    get {return _storage._gradientAngleIsMixed ?? false}
    set {_uniqueStorage()._gradientAngleIsMixed = newValue}
  }
  /// Returns true if `gradientAngleIsMixed` has been explicitly set.
  var hasGradientAngleIsMixed: Bool {return _storage._gradientAngleIsMixed != nil}
  /// Clears the value of `gradientAngleIsMixed`. Subsequent reads from it will return its default value.
  mutating func clearGradientAngleIsMixed() {_uniqueStorage()._gradientAngleIsMixed = nil}

  var imageDataHasBeenModified: Bool {
    get {return _storage._imageDataHasBeenModified ?? false}
    set {_uniqueStorage()._imageDataHasBeenModified = newValue}
  }
  /// Returns true if `imageDataHasBeenModified` has been explicitly set.
  var hasImageDataHasBeenModified: Bool {return _storage._imageDataHasBeenModified != nil}
  /// Clears the value of `imageDataHasBeenModified`. Subsequent reads from it will return its default value.
  mutating func clearImageDataHasBeenModified() {_uniqueStorage()._imageDataHasBeenModified = nil}

  var imageDataIsMixed: Bool {
    get {return _storage._imageDataIsMixed ?? false}
    set {_uniqueStorage()._imageDataIsMixed = newValue}
  }
  /// Returns true if `imageDataIsMixed` has been explicitly set.
  var hasImageDataIsMixed: Bool {return _storage._imageDataIsMixed != nil}
  /// Clears the value of `imageDataIsMixed`. Subsequent reads from it will return its default value.
  mutating func clearImageDataIsMixed() {_uniqueStorage()._imageDataIsMixed = nil}

  var tintColorHasBeenModified: Bool {
    get {return _storage._tintColorHasBeenModified ?? false}
    set {_uniqueStorage()._tintColorHasBeenModified = newValue}
  }
  /// Returns true if `tintColorHasBeenModified` has been explicitly set.
  var hasTintColorHasBeenModified: Bool {return _storage._tintColorHasBeenModified != nil}
  /// Clears the value of `tintColorHasBeenModified`. Subsequent reads from it will return its default value.
  mutating func clearTintColorHasBeenModified() {_uniqueStorage()._tintColorHasBeenModified = nil}

  var tintColorIsMixed: Bool {
    get {return _storage._tintColorIsMixed ?? false}
    set {_uniqueStorage()._tintColorIsMixed = newValue}
  }
  /// Returns true if `tintColorIsMixed` has been explicitly set.
  var hasTintColorIsMixed: Bool {return _storage._tintColorIsMixed != nil}
  /// Clears the value of `tintColorIsMixed`. Subsequent reads from it will return its default value.
  mutating func clearTintColorIsMixed() {_uniqueStorage()._tintColorIsMixed = nil}

  var scaleHasBeenModified: Bool {
    get {return _storage._scaleHasBeenModified ?? false}
    set {_uniqueStorage()._scaleHasBeenModified = newValue}
  }
  /// Returns true if `scaleHasBeenModified` has been explicitly set.
  var hasScaleHasBeenModified: Bool {return _storage._scaleHasBeenModified != nil}
  /// Clears the value of `scaleHasBeenModified`. Subsequent reads from it will return its default value.
  mutating func clearScaleHasBeenModified() {_uniqueStorage()._scaleHasBeenModified = nil}

  var scaleIsMixed: Bool {
    get {return _storage._scaleIsMixed ?? false}
    set {_uniqueStorage()._scaleIsMixed = newValue}
  }
  /// Returns true if `scaleIsMixed` has been explicitly set.
  var hasScaleIsMixed: Bool {return _storage._scaleIsMixed != nil}
  /// Clears the value of `scaleIsMixed`. Subsequent reads from it will return its default value.
  mutating func clearScaleIsMixed() {_uniqueStorage()._scaleIsMixed = nil}

  var techniqueHasBeenModified: Bool {
    get {return _storage._techniqueHasBeenModified ?? false}
    set {_uniqueStorage()._techniqueHasBeenModified = newValue}
  }
  /// Returns true if `techniqueHasBeenModified` has been explicitly set.
  var hasTechniqueHasBeenModified: Bool {return _storage._techniqueHasBeenModified != nil}
  /// Clears the value of `techniqueHasBeenModified`. Subsequent reads from it will return its default value.
  mutating func clearTechniqueHasBeenModified() {_uniqueStorage()._techniqueHasBeenModified = nil}

  var techniqueIsMixed: Bool {
    get {return _storage._techniqueIsMixed ?? false}
    set {_uniqueStorage()._techniqueIsMixed = newValue}
  }
  /// Returns true if `techniqueIsMixed` has been explicitly set.
  var hasTechniqueIsMixed: Bool {return _storage._techniqueIsMixed != nil}
  /// Clears the value of `techniqueIsMixed`. Subsequent reads from it will return its default value.
  mutating func clearTechniqueIsMixed() {_uniqueStorage()._techniqueIsMixed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_FormulaSelectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_SelectionArchive {
    get {return _super ?? TSWP_SelectionArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var activeTokenCharIndex: UInt32 {
    get {return _activeTokenCharIndex ?? 0}
    set {_activeTokenCharIndex = newValue}
  }
  /// Returns true if `activeTokenCharIndex` has been explicitly set.
  var hasActiveTokenCharIndex: Bool {return self._activeTokenCharIndex != nil}
  /// Clears the value of `activeTokenCharIndex`. Subsequent reads from it will return its default value.
  mutating func clearActiveTokenCharIndex() {self._activeTokenCharIndex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_SelectionArchive? = nil
  fileprivate var _activeTokenCharIndex: UInt32? = nil
}

struct TST_CellBorderArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var topStroke: TSD_StrokeArchive {
    get {return _topStroke ?? TSD_StrokeArchive()}
    set {_topStroke = newValue}
  }
  /// Returns true if `topStroke` has been explicitly set.
  var hasTopStroke: Bool {return self._topStroke != nil}
  /// Clears the value of `topStroke`. Subsequent reads from it will return its default value.
  mutating func clearTopStroke() {self._topStroke = nil}

  var topStrokeOrder: Int32 {
    get {return _topStrokeOrder ?? 0}
    set {_topStrokeOrder = newValue}
  }
  /// Returns true if `topStrokeOrder` has been explicitly set.
  var hasTopStrokeOrder: Bool {return self._topStrokeOrder != nil}
  /// Clears the value of `topStrokeOrder`. Subsequent reads from it will return its default value.
  mutating func clearTopStrokeOrder() {self._topStrokeOrder = nil}

  var rightStroke: TSD_StrokeArchive {
    get {return _rightStroke ?? TSD_StrokeArchive()}
    set {_rightStroke = newValue}
  }
  /// Returns true if `rightStroke` has been explicitly set.
  var hasRightStroke: Bool {return self._rightStroke != nil}
  /// Clears the value of `rightStroke`. Subsequent reads from it will return its default value.
  mutating func clearRightStroke() {self._rightStroke = nil}

  var rightStrokeOrder: Int32 {
    get {return _rightStrokeOrder ?? 0}
    set {_rightStrokeOrder = newValue}
  }
  /// Returns true if `rightStrokeOrder` has been explicitly set.
  var hasRightStrokeOrder: Bool {return self._rightStrokeOrder != nil}
  /// Clears the value of `rightStrokeOrder`. Subsequent reads from it will return its default value.
  mutating func clearRightStrokeOrder() {self._rightStrokeOrder = nil}

  var bottomStroke: TSD_StrokeArchive {
    get {return _bottomStroke ?? TSD_StrokeArchive()}
    set {_bottomStroke = newValue}
  }
  /// Returns true if `bottomStroke` has been explicitly set.
  var hasBottomStroke: Bool {return self._bottomStroke != nil}
  /// Clears the value of `bottomStroke`. Subsequent reads from it will return its default value.
  mutating func clearBottomStroke() {self._bottomStroke = nil}

  var bottomStrokeOrder: Int32 {
    get {return _bottomStrokeOrder ?? 0}
    set {_bottomStrokeOrder = newValue}
  }
  /// Returns true if `bottomStrokeOrder` has been explicitly set.
  var hasBottomStrokeOrder: Bool {return self._bottomStrokeOrder != nil}
  /// Clears the value of `bottomStrokeOrder`. Subsequent reads from it will return its default value.
  mutating func clearBottomStrokeOrder() {self._bottomStrokeOrder = nil}

  var leftStroke: TSD_StrokeArchive {
    get {return _leftStroke ?? TSD_StrokeArchive()}
    set {_leftStroke = newValue}
  }
  /// Returns true if `leftStroke` has been explicitly set.
  var hasLeftStroke: Bool {return self._leftStroke != nil}
  /// Clears the value of `leftStroke`. Subsequent reads from it will return its default value.
  mutating func clearLeftStroke() {self._leftStroke = nil}

  var leftStrokeOrder: Int32 {
    get {return _leftStrokeOrder ?? 0}
    set {_leftStrokeOrder = newValue}
  }
  /// Returns true if `leftStrokeOrder` has been explicitly set.
  var hasLeftStrokeOrder: Bool {return self._leftStrokeOrder != nil}
  /// Clears the value of `leftStrokeOrder`. Subsequent reads from it will return its default value.
  mutating func clearLeftStrokeOrder() {self._leftStrokeOrder = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _topStroke: TSD_StrokeArchive? = nil
  fileprivate var _topStrokeOrder: Int32? = nil
  fileprivate var _rightStroke: TSD_StrokeArchive? = nil
  fileprivate var _rightStrokeOrder: Int32? = nil
  fileprivate var _bottomStroke: TSD_StrokeArchive? = nil
  fileprivate var _bottomStrokeOrder: Int32? = nil
  fileprivate var _leftStroke: TSD_StrokeArchive? = nil
  fileprivate var _leftStrokeOrder: Int32? = nil
}

struct TST_DefaultCellStylesContainerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tableStyleNetwork: TSP_Reference {
    get {return _tableStyleNetwork ?? TSP_Reference()}
    set {_tableStyleNetwork = newValue}
  }
  /// Returns true if `tableStyleNetwork` has been explicitly set.
  var hasTableStyleNetwork: Bool {return self._tableStyleNetwork != nil}
  /// Clears the value of `tableStyleNetwork`. Subsequent reads from it will return its default value.
  mutating func clearTableStyleNetwork() {self._tableStyleNetwork = nil}

  var rowUids: [TSP_UUID] = []

  var columnUids: [TSP_UUID] = []

  var rowTypes: [UInt32] = []

  var columnTypes: [UInt32] = []

  var isAPivotTable: Bool {
    get {return _isAPivotTable ?? false}
    set {_isAPivotTable = newValue}
  }
  /// Returns true if `isAPivotTable` has been explicitly set.
  var hasIsAPivotTable: Bool {return self._isAPivotTable != nil}
  /// Clears the value of `isAPivotTable`. Subsequent reads from it will return its default value.
  mutating func clearIsAPivotTable() {self._isAPivotTable = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tableStyleNetwork: TSP_Reference? = nil
  fileprivate var _isAPivotTable: Bool? = nil
}

struct TST_MultiTableRemapperArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mappingPurpose: TST_MultiTableRemapperArchive.Purpose {
    get {return _mappingPurpose ?? .default}
    set {_mappingPurpose = newValue}
  }
  /// Returns true if `mappingPurpose` has been explicitly set.
  var hasMappingPurpose: Bool {return self._mappingPurpose != nil}
  /// Clears the value of `mappingPurpose`. Subsequent reads from it will return its default value.
  mutating func clearMappingPurpose() {self._mappingPurpose = nil}

  var shouldStealReferences: Bool {
    get {return _shouldStealReferences ?? false}
    set {_shouldStealReferences = newValue}
  }
  /// Returns true if `shouldStealReferences` has been explicitly set.
  var hasShouldStealReferences: Bool {return self._shouldStealReferences != nil}
  /// Clears the value of `shouldStealReferences`. Subsequent reads from it will return its default value.
  mutating func clearShouldStealReferences() {self._shouldStealReferences = nil}

  var canReuseTableNames: Bool {
    get {return _canReuseTableNames ?? false}
    set {_canReuseTableNames = newValue}
  }
  /// Returns true if `canReuseTableNames` has been explicitly set.
  var hasCanReuseTableNames: Bool {return self._canReuseTableNames != nil}
  /// Clears the value of `canReuseTableNames`. Subsequent reads from it will return its default value.
  mutating func clearCanReuseTableNames() {self._canReuseTableNames = nil}

  var ownerUidMapper: [TSCE_OwnerUIDMapperArchive] = []

  var backingTablesForCharts: TSP_UUIDMapArchive {
    get {return _backingTablesForCharts ?? TSP_UUIDMapArchive()}
    set {_backingTablesForCharts = newValue}
  }
  /// Returns true if `backingTablesForCharts` has been explicitly set.
  var hasBackingTablesForCharts: Bool {return self._backingTablesForCharts != nil}
  /// Clears the value of `backingTablesForCharts`. Subsequent reads from it will return its default value.
  mutating func clearBackingTablesForCharts() {self._backingTablesForCharts = nil}

  var crossDocumentPaste: Bool {
    get {return _crossDocumentPaste ?? false}
    set {_crossDocumentPaste = newValue}
  }
  /// Returns true if `crossDocumentPaste` has been explicitly set.
  var hasCrossDocumentPaste: Bool {return self._crossDocumentPaste != nil}
  /// Clears the value of `crossDocumentPaste`. Subsequent reads from it will return its default value.
  mutating func clearCrossDocumentPaste() {self._crossDocumentPaste = nil}

  var nestedInnerMapper: Bool {
    get {return _nestedInnerMapper ?? false}
    set {_nestedInnerMapper = newValue}
  }
  /// Returns true if `nestedInnerMapper` has been explicitly set.
  var hasNestedInnerMapper: Bool {return self._nestedInnerMapper != nil}
  /// Clears the value of `nestedInnerMapper`. Subsequent reads from it will return its default value.
  mutating func clearNestedInnerMapper() {self._nestedInnerMapper = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Purpose: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case `default` = 0
    case grouping = 1
    case pagesSectionDuplicationNoncollab = 2

    init() {
      self = .default
    }

  }

  init() {}

  fileprivate var _mappingPurpose: TST_MultiTableRemapperArchive.Purpose? = nil
  fileprivate var _shouldStealReferences: Bool? = nil
  fileprivate var _canReuseTableNames: Bool? = nil
  fileprivate var _backingTablesForCharts: TSP_UUIDMapArchive? = nil
  fileprivate var _crossDocumentPaste: Bool? = nil
  fileprivate var _nestedInnerMapper: Bool? = nil
}

struct TST_ChangePropagationMapWrapper: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var replacementBehavior: Int32 {
    get {return _storage._replacementBehavior ?? 0}
    set {_uniqueStorage()._replacementBehavior = newValue}
  }
  /// Returns true if `replacementBehavior` has been explicitly set.
  var hasReplacementBehavior: Bool {return _storage._replacementBehavior != nil}
  /// Clears the value of `replacementBehavior`. Subsequent reads from it will return its default value.
  mutating func clearReplacementBehavior() {_uniqueStorage()._replacementBehavior = nil}

  var styleReplacePrototypes: [TSP_Reference] {
    get {return _storage._styleReplacePrototypes}
    set {_uniqueStorage()._styleReplacePrototypes = newValue}
  }

  var styleReplaceReplacements: [TSP_Reference] {
    get {return _storage._styleReplaceReplacements}
    set {_uniqueStorage()._styleReplaceReplacements = newValue}
  }

  var styleModifyStyles: [TSP_Reference] {
    get {return _storage._styleModifyStyles}
    set {_uniqueStorage()._styleModifyStyles = newValue}
  }

  var styleModifyOldPropMaps: [TSP_Reference] {
    get {return _storage._styleModifyOldPropMaps}
    set {_uniqueStorage()._styleModifyOldPropMaps = newValue}
  }

  var styleModifyNewPropMaps: [TSP_Reference] {
    get {return _storage._styleModifyNewPropMaps}
    set {_uniqueStorage()._styleModifyNewPropMaps = newValue}
  }

  var styleDeletePrototypes: [TSP_Reference] {
    get {return _storage._styleDeletePrototypes}
    set {_uniqueStorage()._styleDeletePrototypes = newValue}
  }

  var styleDeleteReplacements: [TSP_Reference] {
    get {return _storage._styleDeleteReplacements}
    set {_uniqueStorage()._styleDeleteReplacements = newValue}
  }

  var tablePresetReplacePrototype: TSP_Reference {
    get {return _storage._tablePresetReplacePrototype ?? TSP_Reference()}
    set {_uniqueStorage()._tablePresetReplacePrototype = newValue}
  }
  /// Returns true if `tablePresetReplacePrototype` has been explicitly set.
  var hasTablePresetReplacePrototype: Bool {return _storage._tablePresetReplacePrototype != nil}
  /// Clears the value of `tablePresetReplacePrototype`. Subsequent reads from it will return its default value.
  mutating func clearTablePresetReplacePrototype() {_uniqueStorage()._tablePresetReplacePrototype = nil}

  var tablePresetReplaceReplacement: TSP_Reference {
    get {return _storage._tablePresetReplaceReplacement ?? TSP_Reference()}
    set {_uniqueStorage()._tablePresetReplaceReplacement = newValue}
  }
  /// Returns true if `tablePresetReplaceReplacement` has been explicitly set.
  var hasTablePresetReplaceReplacement: Bool {return _storage._tablePresetReplaceReplacement != nil}
  /// Clears the value of `tablePresetReplaceReplacement`. Subsequent reads from it will return its default value.
  mutating func clearTablePresetReplaceReplacement() {_uniqueStorage()._tablePresetReplaceReplacement = nil}

  var tablePresetDeletePrototype: TSP_Reference {
    get {return _storage._tablePresetDeletePrototype ?? TSP_Reference()}
    set {_uniqueStorage()._tablePresetDeletePrototype = newValue}
  }
  /// Returns true if `tablePresetDeletePrototype` has been explicitly set.
  var hasTablePresetDeletePrototype: Bool {return _storage._tablePresetDeletePrototype != nil}
  /// Clears the value of `tablePresetDeletePrototype`. Subsequent reads from it will return its default value.
  mutating func clearTablePresetDeletePrototype() {_uniqueStorage()._tablePresetDeletePrototype = nil}

  var tablePresetDeleteReplacement: TSP_Reference {
    get {return _storage._tablePresetDeleteReplacement ?? TSP_Reference()}
    set {_uniqueStorage()._tablePresetDeleteReplacement = newValue}
  }
  /// Returns true if `tablePresetDeleteReplacement` has been explicitly set.
  var hasTablePresetDeleteReplacement: Bool {return _storage._tablePresetDeleteReplacement != nil}
  /// Clears the value of `tablePresetDeleteReplacement`. Subsequent reads from it will return its default value.
  mutating func clearTablePresetDeleteReplacement() {_uniqueStorage()._tablePresetDeleteReplacement = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_SummaryCellVendorArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tableInfo: TSP_Reference {
    get {return _tableInfo ?? TSP_Reference()}
    set {_tableInfo = newValue}
  }
  /// Returns true if `tableInfo` has been explicitly set.
  var hasTableInfo: Bool {return self._tableInfo != nil}
  /// Clears the value of `tableInfo`. Subsequent reads from it will return its default value.
  mutating func clearTableInfo() {self._tableInfo = nil}

  var entries: [TST_SummaryCellVendorArchive.SummaryCellEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct SummaryCellEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var wildcardUid: TSP_UUID {
      get {return _wildcardUid ?? TSP_UUID()}
      set {_wildcardUid = newValue}
    }
    /// Returns true if `wildcardUid` has been explicitly set.
    var hasWildcardUid: Bool {return self._wildcardUid != nil}
    /// Clears the value of `wildcardUid`. Subsequent reads from it will return its default value.
    mutating func clearWildcardUid() {self._wildcardUid = nil}

    var columnUid: TSP_UUID {
      get {return _columnUid ?? TSP_UUID()}
      set {_columnUid = newValue}
    }
    /// Returns true if `columnUid` has been explicitly set.
    var hasColumnUid: Bool {return self._columnUid != nil}
    /// Clears the value of `columnUid`. Subsequent reads from it will return its default value.
    mutating func clearColumnUid() {self._columnUid = nil}

    var cell: TST_Cell {
      get {return _cell ?? TST_Cell()}
      set {_cell = newValue}
    }
    /// Returns true if `cell` has been explicitly set.
    var hasCell: Bool {return self._cell != nil}
    /// Clears the value of `cell`. Subsequent reads from it will return its default value.
    mutating func clearCell() {self._cell = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _wildcardUid: TSP_UUID? = nil
    fileprivate var _columnUid: TSP_UUID? = nil
    fileprivate var _cell: TST_Cell? = nil
  }

  init() {}

  fileprivate var _tableInfo: TSP_Reference? = nil
}

struct TST_CategoryOrderArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tableInfo: TSP_Reference {
    get {return _tableInfo ?? TSP_Reference()}
    set {_tableInfo = newValue}
  }
  /// Returns true if `tableInfo` has been explicitly set.
  var hasTableInfo: Bool {return self._tableInfo != nil}
  /// Clears the value of `tableInfo`. Subsequent reads from it will return its default value.
  mutating func clearTableInfo() {self._tableInfo = nil}

  var uidMap: TSP_Reference {
    get {return _uidMap ?? TSP_Reference()}
    set {_uidMap = newValue}
  }
  /// Returns true if `uidMap` has been explicitly set.
  var hasUidMap: Bool {return self._uidMap != nil}
  /// Clears the value of `uidMap`. Subsequent reads from it will return its default value.
  mutating func clearUidMap() {self._uidMap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tableInfo: TSP_Reference? = nil
  fileprivate var _uidMap: TSP_Reference? = nil
}

struct TST_PivotOrderArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uidMap: TSP_Reference {
    get {return _uidMap ?? TSP_Reference()}
    set {_uidMap = newValue}
  }
  /// Returns true if `uidMap` has been explicitly set.
  var hasUidMap: Bool {return self._uidMap != nil}
  /// Clears the value of `uidMap`. Subsequent reads from it will return its default value.
  mutating func clearUidMap() {self._uidMap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _uidMap: TSP_Reference? = nil
}

struct TST_HeaderNameMgrTileArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var firstFragment: String {
    get {return _firstFragment ?? String()}
    set {_firstFragment = newValue}
  }
  /// Returns true if `firstFragment` has been explicitly set.
  var hasFirstFragment: Bool {return self._firstFragment != nil}
  /// Clears the value of `firstFragment`. Subsequent reads from it will return its default value.
  mutating func clearFirstFragment() {self._firstFragment = nil}

  var lastFragment: String {
    get {return _lastFragment ?? String()}
    set {_lastFragment = newValue}
  }
  /// Returns true if `lastFragment` has been explicitly set.
  var hasLastFragment: Bool {return self._lastFragment != nil}
  /// Clears the value of `lastFragment`. Subsequent reads from it will return its default value.
  mutating func clearLastFragment() {self._lastFragment = nil}

  var nameFragEntries: [TST_HeaderNameMgrTileArchive.NameFragmentArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct NameFragmentArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nameFragment: String {
      get {return _nameFragment ?? String()}
      set {_nameFragment = newValue}
    }
    /// Returns true if `nameFragment` has been explicitly set.
    var hasNameFragment: Bool {return self._nameFragment != nil}
    /// Clears the value of `nameFragment`. Subsequent reads from it will return its default value.
    mutating func clearNameFragment() {self._nameFragment = nil}

    var namePrecedent: TSCE_CellCoordinateArchive {
      get {return _namePrecedent ?? TSCE_CellCoordinateArchive()}
      set {_namePrecedent = newValue}
    }
    /// Returns true if `namePrecedent` has been explicitly set.
    var hasNamePrecedent: Bool {return self._namePrecedent != nil}
    /// Clears the value of `namePrecedent`. Subsequent reads from it will return its default value.
    mutating func clearNamePrecedent() {self._namePrecedent = nil}

    var usesOfNameFragment: TSCE_UidCellRefSetArchive {
      get {return _usesOfNameFragment ?? TSCE_UidCellRefSetArchive()}
      set {_usesOfNameFragment = newValue}
    }
    /// Returns true if `usesOfNameFragment` has been explicitly set.
    var hasUsesOfNameFragment: Bool {return self._usesOfNameFragment != nil}
    /// Clears the value of `usesOfNameFragment`. Subsequent reads from it will return its default value.
    mutating func clearUsesOfNameFragment() {self._usesOfNameFragment = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _nameFragment: String? = nil
    fileprivate var _namePrecedent: TSCE_CellCoordinateArchive? = nil
    fileprivate var _usesOfNameFragment: TSCE_UidCellRefSetArchive? = nil
  }

  init() {}

  fileprivate var _firstFragment: String? = nil
  fileprivate var _lastFragment: String? = nil
}

struct TST_HeaderNameMgrArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerUid: TSP_UUID {
    get {return _ownerUid ?? TSP_UUID()}
    set {_ownerUid = newValue}
  }
  /// Returns true if `ownerUid` has been explicitly set.
  var hasOwnerUid: Bool {return self._ownerUid != nil}
  /// Clears the value of `ownerUid`. Subsequent reads from it will return its default value.
  mutating func clearOwnerUid() {self._ownerUid = nil}

  var nrmOwnerUid: TSP_UUID {
    get {return _nrmOwnerUid ?? TSP_UUID()}
    set {_nrmOwnerUid = newValue}
  }
  /// Returns true if `nrmOwnerUid` has been explicitly set.
  var hasNrmOwnerUid: Bool {return self._nrmOwnerUid != nil}
  /// Clears the value of `nrmOwnerUid`. Subsequent reads from it will return its default value.
  mutating func clearNrmOwnerUid() {self._nrmOwnerUid = nil}

  var perTables: [TST_HeaderNameMgrArchive.PerTableArchive] = []

  var nameFragTiles: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PerTableArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var tableUid: TSP_UUID {
      get {return _tableUid ?? TSP_UUID()}
      set {_tableUid = newValue}
    }
    /// Returns true if `tableUid` has been explicitly set.
    var hasTableUid: Bool {return self._tableUid != nil}
    /// Clears the value of `tableUid`. Subsequent reads from it will return its default value.
    mutating func clearTableUid() {self._tableUid = nil}

    var perTablePrecedent: TSCE_CellCoordinateArchive {
      get {return _perTablePrecedent ?? TSCE_CellCoordinateArchive()}
      set {_perTablePrecedent = newValue}
    }
    /// Returns true if `perTablePrecedent` has been explicitly set.
    var hasPerTablePrecedent: Bool {return self._perTablePrecedent != nil}
    /// Clears the value of `perTablePrecedent`. Subsequent reads from it will return its default value.
    mutating func clearPerTablePrecedent() {self._perTablePrecedent = nil}

    var isDeleted: Bool {
      get {return _isDeleted ?? false}
      set {_isDeleted = newValue}
    }
    /// Returns true if `isDeleted` has been explicitly set.
    var hasIsDeleted: Bool {return self._isDeleted != nil}
    /// Clears the value of `isDeleted`. Subsequent reads from it will return its default value.
    mutating func clearIsDeleted() {self._isDeleted = nil}

    var headerRowUids: [TSP_UUID] = []

    var headerColumnUids: [TSP_UUID] = []

    var updateHeaderRowUids: [TSP_UUID] = []

    var updateHeaderColumnUids: [TSP_UUID] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _tableUid: TSP_UUID? = nil
    fileprivate var _perTablePrecedent: TSCE_CellCoordinateArchive? = nil
    fileprivate var _isDeleted: Bool? = nil
  }

  init() {}

  fileprivate var _ownerUid: TSP_UUID? = nil
  fileprivate var _nrmOwnerUid: TSP_UUID? = nil
}

struct TST_WidthHeightCacheFittingEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fittingIndex: UInt32 {
    get {return _fittingIndex ?? 0}
    set {_fittingIndex = newValue}
  }
  /// Returns true if `fittingIndex` has been explicitly set.
  var hasFittingIndex: Bool {return self._fittingIndex != nil}
  /// Clears the value of `fittingIndex`. Subsequent reads from it will return its default value.
  mutating func clearFittingIndex() {self._fittingIndex = nil}

  var fittingSize: Float {
    get {return _fittingSize ?? 0}
    set {_fittingSize = newValue}
  }
  /// Returns true if `fittingSize` has been explicitly set.
  var hasFittingSize: Bool {return self._fittingSize != nil}
  /// Clears the value of `fittingSize`. Subsequent reads from it will return its default value.
  mutating func clearFittingSize() {self._fittingSize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fittingIndex: UInt32? = nil
  fileprivate var _fittingSize: Float? = nil
}

struct TST_WidthHeightCache: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rowsFittingEntries: [TST_WidthHeightCacheFittingEntry] = []

  var columnsCount: UInt32 {
    get {return _columnsCount ?? 0}
    set {_columnsCount = newValue}
  }
  /// Returns true if `columnsCount` has been explicitly set.
  var hasColumnsCount: Bool {return self._columnsCount != nil}
  /// Clears the value of `columnsCount`. Subsequent reads from it will return its default value.
  mutating func clearColumnsCount() {self._columnsCount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _columnsCount: UInt32? = nil
}

struct TST_LayoutEngineArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var widthHeightCache: TST_WidthHeightCache {
    get {return _widthHeightCache ?? TST_WidthHeightCache()}
    set {_widthHeightCache = newValue}
  }
  /// Returns true if `widthHeightCache` has been explicitly set.
  var hasWidthHeightCache: Bool {return self._widthHeightCache != nil}
  /// Clears the value of `widthHeightCache`. Subsequent reads from it will return its default value.
  mutating func clearWidthHeightCache() {self._widthHeightCache = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _widthHeightCache: TST_WidthHeightCache? = nil
}

struct TST_CollaboratorTableCursorSubselectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cellUidList: TST_CellUIDListArchive {
    get {return _cellUidList ?? TST_CellUIDListArchive()}
    set {_cellUidList = newValue}
  }
  /// Returns true if `cellUidList` has been explicitly set.
  var hasCellUidList: Bool {return self._cellUidList != nil}
  /// Clears the value of `cellUidList`. Subsequent reads from it will return its default value.
  mutating func clearCellUidList() {self._cellUidList = nil}

  var selectionType: TST_SelectionTypeArchive {
    get {return _selectionType ?? .deprecatedCellSelectionType}
    set {_selectionType = newValue}
  }
  /// Returns true if `selectionType` has been explicitly set.
  var hasSelectionType: Bool {return self._selectionType != nil}
  /// Clears the value of `selectionType`. Subsequent reads from it will return its default value.
  mutating func clearSelectionType() {self._selectionType = nil}

  var rowColumnUidList: [TSP_UUID] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cellUidList: TST_CellUIDListArchive? = nil
  fileprivate var _selectionType: TST_SelectionTypeArchive? = nil
}

// MARK: - Extension support defined in TSTArchives.proto.

// MARK: - Extension Properties

// Swift Extensions on the extended Messages to add easy access to the declared
// extension fields. The names are based on the extension field name from the proto
// declaration. To avoid naming collisions, the names are prefixed with the name of
// the scope where the extend directive occurs.

extension TSCK_CollaboratorCursorArchive {

  var TST_CollaboratorTableCursorSubselectionArchive_tableCursorSubselection: TST_CollaboratorTableCursorSubselectionArchive {
    get {return getExtensionValue(ext: TST_CollaboratorTableCursorSubselectionArchive.Extensions.table_cursor_subselection) ?? TST_CollaboratorTableCursorSubselectionArchive()}
    set {setExtensionValue(ext: TST_CollaboratorTableCursorSubselectionArchive.Extensions.table_cursor_subselection, value: newValue)}
  }
  /// Returns true if extension `TST_CollaboratorTableCursorSubselectionArchive.Extensions.table_cursor_subselection`
  /// has been explicitly set.
  var hasTST_CollaboratorTableCursorSubselectionArchive_tableCursorSubselection: Bool {
    return hasExtensionValue(ext: TST_CollaboratorTableCursorSubselectionArchive.Extensions.table_cursor_subselection)
  }
  /// Clears the value of extension `TST_CollaboratorTableCursorSubselectionArchive.Extensions.table_cursor_subselection`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTST_CollaboratorTableCursorSubselectionArchive_tableCursorSubselection() {
    clearExtensionValue(ext: TST_CollaboratorTableCursorSubselectionArchive.Extensions.table_cursor_subselection)
  }
}

extension TSS_CommandPropertyEntryArchive {

  var TST_importWarningSet: TST_ImportWarningSetArchive {
    get {return getExtensionValue(ext: TST_Extensions_import_warning_set) ?? TST_ImportWarningSetArchive()}
    set {setExtensionValue(ext: TST_Extensions_import_warning_set, value: newValue)}
  }
  /// Returns true if extension `TST_Extensions_import_warning_set`
  /// has been explicitly set.
  var hasTST_importWarningSet: Bool {
    return hasExtensionValue(ext: TST_Extensions_import_warning_set)
  }
  /// Clears the value of extension `TST_Extensions_import_warning_set`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTST_importWarningSet() {
    clearExtensionValue(ext: TST_Extensions_import_warning_set)
  }

  var TST_formatAndValue: TST_CellFormatAndValueArchive {
    get {return getExtensionValue(ext: TST_Extensions_format_and_value) ?? TST_CellFormatAndValueArchive()}
    set {setExtensionValue(ext: TST_Extensions_format_and_value, value: newValue)}
  }
  /// Returns true if extension `TST_Extensions_format_and_value`
  /// has been explicitly set.
  var hasTST_formatAndValue: Bool {
    return hasExtensionValue(ext: TST_Extensions_format_and_value)
  }
  /// Clears the value of extension `TST_Extensions_format_and_value`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTST_formatAndValue() {
    clearExtensionValue(ext: TST_Extensions_format_and_value)
  }

  var TST_cellBorder: TST_CellBorderArchive {
    get {return getExtensionValue(ext: TST_Extensions_cell_border) ?? TST_CellBorderArchive()}
    set {setExtensionValue(ext: TST_Extensions_cell_border, value: newValue)}
  }
  /// Returns true if extension `TST_Extensions_cell_border`
  /// has been explicitly set.
  var hasTST_cellBorder: Bool {
    return hasExtensionValue(ext: TST_Extensions_cell_border)
  }
  /// Clears the value of extension `TST_Extensions_cell_border`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTST_cellBorder() {
    clearExtensionValue(ext: TST_Extensions_cell_border)
  }

  var TST_commentStorage: TST_CommentStorageWrapperArchive {
    get {return getExtensionValue(ext: TST_Extensions_comment_storage) ?? TST_CommentStorageWrapperArchive()}
    set {setExtensionValue(ext: TST_Extensions_comment_storage, value: newValue)}
  }
  /// Returns true if extension `TST_Extensions_comment_storage`
  /// has been explicitly set.
  var hasTST_commentStorage: Bool {
    return hasExtensionValue(ext: TST_Extensions_comment_storage)
  }
  /// Clears the value of extension `TST_Extensions_comment_storage`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTST_commentStorage() {
    clearExtensionValue(ext: TST_Extensions_comment_storage)
  }

  var TST_cellSpec: TST_CellSpecArchive {
    get {return getExtensionValue(ext: TST_Extensions_cell_spec) ?? TST_CellSpecArchive()}
    set {setExtensionValue(ext: TST_Extensions_cell_spec, value: newValue)}
  }
  /// Returns true if extension `TST_Extensions_cell_spec`
  /// has been explicitly set.
  var hasTST_cellSpec: Bool {
    return hasExtensionValue(ext: TST_Extensions_cell_spec)
  }
  /// Clears the value of extension `TST_Extensions_cell_spec`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTST_cellSpec() {
    clearExtensionValue(ext: TST_Extensions_cell_spec)
  }

}

// MARK: - File's ExtensionMap: TST_Tstarchives_Extensions

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
let TST_Tstarchives_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  TST_Extensions_import_warning_set,
  TST_Extensions_format_and_value,
  TST_Extensions_cell_border,
  TST_Extensions_comment_storage,
  TST_Extensions_cell_spec,
  TST_CollaboratorTableCursorSubselectionArchive.Extensions.table_cursor_subselection
]

// Extension Objects - The only reason these might be needed is when manually
// constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
// accessors for the extension fields on the messages directly.

let TST_Extensions_import_warning_set = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TST_ImportWarningSetArchive>, TSS_CommandPropertyEntryArchive>(
  _protobuf_fieldNumber: 500,
  fieldName: "TST.import_warning_set"
)

let TST_Extensions_format_and_value = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TST_CellFormatAndValueArchive>, TSS_CommandPropertyEntryArchive>(
  _protobuf_fieldNumber: 501,
  fieldName: "TST.format_and_value"
)

let TST_Extensions_cell_border = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TST_CellBorderArchive>, TSS_CommandPropertyEntryArchive>(
  _protobuf_fieldNumber: 503,
  fieldName: "TST.cell_border"
)

let TST_Extensions_comment_storage = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TST_CommentStorageWrapperArchive>, TSS_CommandPropertyEntryArchive>(
  _protobuf_fieldNumber: 504,
  fieldName: "TST.comment_storage"
)

let TST_Extensions_cell_spec = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TST_CellSpecArchive>, TSS_CommandPropertyEntryArchive>(
  _protobuf_fieldNumber: 505,
  fieldName: "TST.cell_spec"
)

extension TST_CollaboratorTableCursorSubselectionArchive {
  enum Extensions {
    static let table_cursor_subselection = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TST_CollaboratorTableCursorSubselectionArchive>, TSCK_CollaboratorCursorArchive>(
      _protobuf_fieldNumber: 200,
      fieldName: "TST.CollaboratorTableCursorSubselectionArchive.table_cursor_subselection"
    )
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TST"

extension TST_CellType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0genericCellType\0\u{1}spanCellType\0\u{1}numberCellType\0\u{1}textCellType\0\u{1}formulaCellType\0\u{1}dateCellType\0\u{1}boolCellType\0\u{1}durationCellType\0\u{1}formulaErrorCellType\0\u{1}automaticCellType\0")
}

extension TST_CellValueType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0emptyCellValueType\0\u{1}numberCellValueType\0\u{1}stringCellValueType\0\u{1}providedCellValueType\0\u{1}dateCellValueType\0\u{1}boolCellValueType\0\u{1}durationCellValueType\0\u{1}errorCellValueType\0\u{1}richTextCellType\0\u{1}currencyCellValueType\0")
}

extension TST_TableDimensionArchive: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{7f}\u{7f}\u{7f}\u{7f}\u{7f}\u{3}dimensionNeither\0\u{1}dimensionRow\0\u{1}dimensionColumn\0")
}

extension TST_SelectionTypeArchive: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0deprecatedCellSelectionType\0\u{1}rowSelectionType\0\u{1}columnSelectionType\0\u{1}deprecatedCellEditingSelectionType\0\u{1}deprecatedTableNameSelectionType\0\u{1}deprecatedTableSelectionType\0\u{1}regionSelectionType\0\u{1}noSelectionType\0")
}

extension TST_FillDirectionArchive: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}kTSTFillDownArchive\0\u{1}kTSTFillUpArchive\0\u{1}kTSTFillRightArchive\0\u{1}kTSTFillLeftArchive\0")
}

extension TST_MergeActionArchive: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}mergeActionInsert\0\u{1}mergeActionRemove\0\u{1}mergeActionShrink\0\u{1}mergeActionGrow\0")
}

extension TST_HideShowActionArchive: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0hideShowActionHide\0\u{1}hideShowActionShow\0")
}

extension TST_CellID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellID"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}packedData\0\u{3}expanded_coord\0")

  public var isInitialized: Bool {
    if self._packedData == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._packedData) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expandedCoord) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._packedData {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._expandedCoord {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CellID, rhs: TST_CellID) -> Bool {
    if lhs._packedData != rhs._packedData {return false}
    if lhs._expandedCoord != rhs._expandedCoord {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CellUIDLookupListArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellUIDLookupListArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}column_uids\0\u{3}row_uids\0\u{3}column_indexes\0\u{3}row_indexes\0")

  public var isInitialized: Bool {
    if let v = self._columnUids, !v.isInitialized {return false}
    if let v = self._rowUids, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._columnUids) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rowUids) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.columnIndexes) }()
      case 4: try { try decoder.decodeRepeatedInt32Field(value: &self.rowIndexes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._columnUids {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rowUids {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.columnIndexes.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.columnIndexes, fieldNumber: 3)
    }
    if !self.rowIndexes.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.rowIndexes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CellUIDLookupListArchive, rhs: TST_CellUIDLookupListArchive) -> Bool {
    if lhs._columnUids != rhs._columnUids {return false}
    if lhs._rowUids != rhs._rowUids {return false}
    if lhs.columnIndexes != rhs.columnIndexes {return false}
    if lhs.rowIndexes != rhs.rowIndexes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CellUIDListArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellUIDListArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}row_uids\0\u{3}column_uids\0\u{3}compressed_row_indexes\0\u{3}compressed_column_indexes\0\u{3}uncompressed_lookup_list\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.rowUids) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.columnUids) {return false}
    if let v = self._uncompressedLookupList, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rowUids) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.columnUids) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.compressedRowIndexes) }()
      case 4: try { try decoder.decodeRepeatedInt32Field(value: &self.compressedColumnIndexes) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._uncompressedLookupList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.rowUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rowUids, fieldNumber: 1)
    }
    if !self.columnUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.columnUids, fieldNumber: 2)
    }
    if !self.compressedRowIndexes.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.compressedRowIndexes, fieldNumber: 3)
    }
    if !self.compressedColumnIndexes.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.compressedColumnIndexes, fieldNumber: 4)
    }
    try { if let v = self._uncompressedLookupList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CellUIDListArchive, rhs: TST_CellUIDListArchive) -> Bool {
    if lhs.rowUids != rhs.rowUids {return false}
    if lhs.columnUids != rhs.columnUids {return false}
    if lhs.compressedRowIndexes != rhs.compressedRowIndexes {return false}
    if lhs.compressedColumnIndexes != rhs.compressedColumnIndexes {return false}
    if lhs._uncompressedLookupList != rhs._uncompressedLookupList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TableSize"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}packedData\0\u{3}num_columns\0\u{3}num_rows\0")

  public var isInitialized: Bool {
    if self._packedData == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._packedData) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._numColumns) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._numRows) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._packedData {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._numColumns {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._numRows {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableSize, rhs: TST_TableSize) -> Bool {
    if lhs._packedData != rhs._packedData {return false}
    if lhs._numColumns != rhs._numColumns {return false}
    if lhs._numRows != rhs._numRows {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ExpandedTableSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExpandedTableSize"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}num_columns\0\u{3}num_rows\0")

  public var isInitialized: Bool {
    if self._numColumns == nil {return false}
    if self._numRows == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._numColumns) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._numRows) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._numColumns {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._numRows {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ExpandedTableSize, rhs: TST_ExpandedTableSize) -> Bool {
    if lhs._numColumns != rhs._numColumns {return false}
    if lhs._numRows != rhs._numRows {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CellRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellRange"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}origin\0\u{1}size\0")

  public var isInitialized: Bool {
    if self._origin == nil {return false}
    if self._size == nil {return false}
    if let v = self._origin, !v.isInitialized {return false}
    if let v = self._size, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CellRange, rhs: TST_CellRange) -> Bool {
    if lhs._origin != rhs._origin {return false}
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ExpandedCellRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExpandedCellRange"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}origin\0\u{1}size\0")

  public var isInitialized: Bool {
    if self._origin == nil {return false}
    if self._size == nil {return false}
    if let v = self._size, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ExpandedCellRange, rhs: TST_ExpandedCellRange) -> Bool {
    if lhs._origin != rhs._origin {return false}
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableSelection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TableSelection"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}cellRange\0\u{1}extendedCellRange\0\u{1}extendedCellRangeValid\0\u{3}selection_type\0")

  public var isInitialized: Bool {
    if self._cellRange == nil {return false}
    if self._extendedCellRange == nil {return false}
    if self._extendedCellRangeValid == nil {return false}
    if self._selectionType == nil {return false}
    if let v = self._cellRange, !v.isInitialized {return false}
    if let v = self._extendedCellRange, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cellRange) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._extendedCellRange) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._extendedCellRangeValid) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._selectionType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cellRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._extendedCellRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._extendedCellRangeValid {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._selectionType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableSelection, rhs: TST_TableSelection) -> Bool {
    if lhs._cellRange != rhs._cellRange {return false}
    if lhs._extendedCellRange != rhs._extendedCellRange {return false}
    if lhs._extendedCellRangeValid != rhs._extendedCellRangeValid {return false}
    if lhs._selectionType != rhs._selectionType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TileRowInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TileRowInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}tile_row_index\0\u{3}cell_count\0\u{3}cell_storage_buffer_pre_bnc\0\u{3}cell_offsets_pre_bnc\0\u{3}storage_version\0\u{3}cell_storage_buffer\0\u{3}cell_offsets\0\u{3}has_wide_offsets\0")

  public var isInitialized: Bool {
    if self._tileRowIndex == nil {return false}
    if self._cellCount == nil {return false}
    if self._cellStorageBufferPreBnc == nil {return false}
    if self._cellOffsetsPreBnc == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._tileRowIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._cellCount) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._cellStorageBufferPreBnc) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._cellOffsetsPreBnc) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._storageVersion) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._cellStorageBuffer) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self._cellOffsets) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._hasWideOffsets_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tileRowIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cellCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cellStorageBufferPreBnc {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._cellOffsetsPreBnc {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._storageVersion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._cellStorageBuffer {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._cellOffsets {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._hasWideOffsets_p {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TileRowInfo, rhs: TST_TileRowInfo) -> Bool {
    if lhs._tileRowIndex != rhs._tileRowIndex {return false}
    if lhs._cellCount != rhs._cellCount {return false}
    if lhs._cellStorageBufferPreBnc != rhs._cellStorageBufferPreBnc {return false}
    if lhs._cellOffsetsPreBnc != rhs._cellOffsetsPreBnc {return false}
    if lhs._storageVersion != rhs._storageVersion {return false}
    if lhs._cellStorageBuffer != rhs._cellStorageBuffer {return false}
    if lhs._cellOffsets != rhs._cellOffsets {return false}
    if lhs._hasWideOffsets_p != rhs._hasWideOffsets_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_Tile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Tile"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}maxColumn\0\u{1}maxRow\0\u{1}numCells\0\u{1}numrows\0\u{1}rowInfos\0\u{3}storage_version\0\u{3}last_saved_in_BNC\0\u{3}should_use_wide_rows\0")

  public var isInitialized: Bool {
    if self._maxColumn == nil {return false}
    if self._maxRow == nil {return false}
    if self._numCells == nil {return false}
    if self._numrows == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rowInfos) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._maxColumn) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._maxRow) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._numCells) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._numrows) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.rowInfos) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._storageVersion) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._lastSavedInBnc) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._shouldUseWideRows) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._maxColumn {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._maxRow {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._numCells {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._numrows {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    if !self.rowInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rowInfos, fieldNumber: 5)
    }
    try { if let v = self._storageVersion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._lastSavedInBnc {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._shouldUseWideRows {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_Tile, rhs: TST_Tile) -> Bool {
    if lhs._maxColumn != rhs._maxColumn {return false}
    if lhs._maxRow != rhs._maxRow {return false}
    if lhs._numCells != rhs._numCells {return false}
    if lhs._numrows != rhs._numrows {return false}
    if lhs.rowInfos != rhs.rowInfos {return false}
    if lhs._storageVersion != rhs._storageVersion {return false}
    if lhs._lastSavedInBnc != rhs._lastSavedInBnc {return false}
    if lhs._shouldUseWideRows != rhs._shouldUseWideRows {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TileStorage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TileStorage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}tiles\0\u{3}tile_size\0\u{3}should_use_wide_rows\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.tiles) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tiles) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._tileSize) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._shouldUseWideRows) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tiles, fieldNumber: 1)
    }
    try { if let v = self._tileSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._shouldUseWideRows {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TileStorage, rhs: TST_TileStorage) -> Bool {
    if lhs.tiles != rhs.tiles {return false}
    if lhs._tileSize != rhs._tileSize {return false}
    if lhs._shouldUseWideRows != rhs._shouldUseWideRows {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TileStorage.Tile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_TileStorage.protoMessageName + ".Tile"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}tileid\0\u{1}tile\0")

  public var isInitialized: Bool {
    if self._tileid == nil {return false}
    if self._tile == nil {return false}
    if let v = self._tile, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._tileid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tile) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tileid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TileStorage.Tile, rhs: TST_TileStorage.Tile) -> Bool {
    if lhs._tileid != rhs._tileid {return false}
    if lhs._tile != rhs._tile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_PopUpMenuModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PopUpMenuModel"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}item\0\u{3}tsce_item\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.item) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.tsceItem) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.item) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tsceItem) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.item.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.item, fieldNumber: 1)
    }
    if !self.tsceItem.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tsceItem, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_PopUpMenuModel, rhs: TST_PopUpMenuModel) -> Bool {
    if lhs.item != rhs.item {return false}
    if lhs.tsceItem != rhs.tsceItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_PopUpMenuModel.CellValueType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}NIL_TYPE\0\u{1}BOOLEAN_TYPE\0\u{1}DATE_TYPE\0\u{1}NUMBER_TYPE\0\u{1}STRING_TYPE\0")
}

extension TST_PopUpMenuModel.CellValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_PopUpMenuModel.protoMessageName + ".CellValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cell_value_type\0\u{3}boolean_value\0\u{3}date_value\0\u{3}number_value\0\u{3}string_value\0")

  fileprivate class _StorageClass {
    var _cellValueType: TST_PopUpMenuModel.CellValueType? = nil
    var _booleanValue: TSCE_BooleanCellValueArchive? = nil
    var _dateValue: TSCE_DateCellValueArchive? = nil
    var _numberValue: TSCE_NumberCellValueArchive? = nil
    var _stringValue: TSCE_StringCellValueArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _cellValueType = source._cellValueType
      _booleanValue = source._booleanValue
      _dateValue = source._dateValue
      _numberValue = source._numberValue
      _stringValue = source._stringValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._cellValueType == nil {return false}
      if let v = _storage._booleanValue, !v.isInitialized {return false}
      if let v = _storage._dateValue, !v.isInitialized {return false}
      if let v = _storage._numberValue, !v.isInitialized {return false}
      if let v = _storage._stringValue, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._cellValueType) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._booleanValue) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._dateValue) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._numberValue) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._stringValue) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._cellValueType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._booleanValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._dateValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._numberValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._stringValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_PopUpMenuModel.CellValue, rhs: TST_PopUpMenuModel.CellValue) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._cellValueType != rhs_storage._cellValueType {return false}
        if _storage._booleanValue != rhs_storage._booleanValue {return false}
        if _storage._dateValue != rhs_storage._dateValue {return false}
        if _storage._numberValue != rhs_storage._numberValue {return false}
        if _storage._stringValue != rhs_storage._stringValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ImportWarningSetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImportWarningSetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}formula_import_warning\0\u{3}cond_format_above_avg_equal_avg\0\u{3}cond_format_above_avg_std_dev\0\u{3}cond_format_complex_formula\0\u{3}cond_format_contains_errors\0\u{3}cond_format_expr\0\u{3}cond_format_not_contains_errors\0\u{3}cond_format_parameters_not_all_same_type\0\u{3}cond_format_stop_if_true\0\u{3}cond_format_unsupported_operator\0\u{3}cond_format_unsupported_styling\0\u{3}cond_format_unsupported_time_period\0\u{3}error_cell_with_no_formula\0\u{3}unsupported_cond_format\0\u{3}original_data_format\0\u{3}formula_warning_filtered_column_formula_not_copied\0\u{3}duration_format_range_changed\0\u{3}sorted_warnings\0")

  fileprivate class _StorageClass {
    var _formulaImportWarning: TST_ImportWarningSetArchive.FormulaImportWarning? = nil
    var _condFormatAboveAvgEqualAvg: Bool? = nil
    var _condFormatAboveAvgStdDev: Bool? = nil
    var _condFormatComplexFormula: Bool? = nil
    var _condFormatContainsErrors: Bool? = nil
    var _condFormatExpr: Bool? = nil
    var _condFormatNotContainsErrors: Bool? = nil
    var _condFormatParametersNotAllSameType: Bool? = nil
    var _condFormatStopIfTrue: Bool? = nil
    var _condFormatUnsupportedOperator: Bool? = nil
    var _condFormatUnsupportedStyling: Bool? = nil
    var _condFormatUnsupportedTimePeriod: Bool? = nil
    var _errorCellWithNoFormula: Bool? = nil
    var _unsupportedCondFormat: Bool? = nil
    var _originalDataFormat: String? = nil
    var _formulaWarningFilteredColumnFormulaNotCopied: Bool? = nil
    var _durationFormatRangeChanged: Bool? = nil
    var _sortedWarnings: [TSCE_WarningArchive] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _formulaImportWarning = source._formulaImportWarning
      _condFormatAboveAvgEqualAvg = source._condFormatAboveAvgEqualAvg
      _condFormatAboveAvgStdDev = source._condFormatAboveAvgStdDev
      _condFormatComplexFormula = source._condFormatComplexFormula
      _condFormatContainsErrors = source._condFormatContainsErrors
      _condFormatExpr = source._condFormatExpr
      _condFormatNotContainsErrors = source._condFormatNotContainsErrors
      _condFormatParametersNotAllSameType = source._condFormatParametersNotAllSameType
      _condFormatStopIfTrue = source._condFormatStopIfTrue
      _condFormatUnsupportedOperator = source._condFormatUnsupportedOperator
      _condFormatUnsupportedStyling = source._condFormatUnsupportedStyling
      _condFormatUnsupportedTimePeriod = source._condFormatUnsupportedTimePeriod
      _errorCellWithNoFormula = source._errorCellWithNoFormula
      _unsupportedCondFormat = source._unsupportedCondFormat
      _originalDataFormat = source._originalDataFormat
      _formulaWarningFilteredColumnFormulaNotCopied = source._formulaWarningFilteredColumnFormulaNotCopied
      _durationFormatRangeChanged = source._durationFormatRangeChanged
      _sortedWarnings = source._sortedWarnings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._formulaImportWarning, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._sortedWarnings) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._formulaImportWarning) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._condFormatAboveAvgEqualAvg) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._condFormatAboveAvgStdDev) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._condFormatComplexFormula) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._condFormatContainsErrors) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._condFormatExpr) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._condFormatNotContainsErrors) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._condFormatParametersNotAllSameType) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._condFormatStopIfTrue) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._condFormatUnsupportedOperator) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._condFormatUnsupportedStyling) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._condFormatUnsupportedTimePeriod) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._errorCellWithNoFormula) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._unsupportedCondFormat) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._originalDataFormat) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._formulaWarningFilteredColumnFormulaNotCopied) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._durationFormatRangeChanged) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._sortedWarnings) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._formulaImportWarning {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._condFormatAboveAvgEqualAvg {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._condFormatAboveAvgStdDev {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._condFormatComplexFormula {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._condFormatContainsErrors {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._condFormatExpr {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._condFormatNotContainsErrors {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._condFormatParametersNotAllSameType {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._condFormatStopIfTrue {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._condFormatUnsupportedOperator {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._condFormatUnsupportedStyling {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._condFormatUnsupportedTimePeriod {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._errorCellWithNoFormula {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._unsupportedCondFormat {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._originalDataFormat {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._formulaWarningFilteredColumnFormulaNotCopied {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._durationFormatRangeChanged {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      } }()
      if !_storage._sortedWarnings.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sortedWarnings, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ImportWarningSetArchive, rhs: TST_ImportWarningSetArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._formulaImportWarning != rhs_storage._formulaImportWarning {return false}
        if _storage._condFormatAboveAvgEqualAvg != rhs_storage._condFormatAboveAvgEqualAvg {return false}
        if _storage._condFormatAboveAvgStdDev != rhs_storage._condFormatAboveAvgStdDev {return false}
        if _storage._condFormatComplexFormula != rhs_storage._condFormatComplexFormula {return false}
        if _storage._condFormatContainsErrors != rhs_storage._condFormatContainsErrors {return false}
        if _storage._condFormatExpr != rhs_storage._condFormatExpr {return false}
        if _storage._condFormatNotContainsErrors != rhs_storage._condFormatNotContainsErrors {return false}
        if _storage._condFormatParametersNotAllSameType != rhs_storage._condFormatParametersNotAllSameType {return false}
        if _storage._condFormatStopIfTrue != rhs_storage._condFormatStopIfTrue {return false}
        if _storage._condFormatUnsupportedOperator != rhs_storage._condFormatUnsupportedOperator {return false}
        if _storage._condFormatUnsupportedStyling != rhs_storage._condFormatUnsupportedStyling {return false}
        if _storage._condFormatUnsupportedTimePeriod != rhs_storage._condFormatUnsupportedTimePeriod {return false}
        if _storage._errorCellWithNoFormula != rhs_storage._errorCellWithNoFormula {return false}
        if _storage._unsupportedCondFormat != rhs_storage._unsupportedCondFormat {return false}
        if _storage._originalDataFormat != rhs_storage._originalDataFormat {return false}
        if _storage._formulaWarningFilteredColumnFormulaNotCopied != rhs_storage._formulaWarningFilteredColumnFormulaNotCopied {return false}
        if _storage._durationFormatRangeChanged != rhs_storage._durationFormatRangeChanged {return false}
        if _storage._sortedWarnings != rhs_storage._sortedWarnings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ImportWarningSetArchive.FormulaWarningType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}THREE_D_REFERENCE\0\u{1}ARRAYED_FORMULA\0\u{1}DIFFERENT_BEHAVIOR_FOR_FUNCTION\0\u{1}ERROR_TOKEN\0\u{1}EXTERNAL_REFERENCE\0\u{1}NATURAL_LANGUAGE_FORMULA\0\u{1}REFERENCE_OUT_OF_BOUNDS\0\u{1}SHARED_FORMULA_BASE_NOT_FOUND\0\u{1}UNKNOWN_NAME\0\u{1}UNSUPPORTED_FORMULA\0\u{1}UNSUPPORTED_FUNCTION\0\u{1}UNSUPPORTED_NAME\0\u{1}TRANSPOSED_NO_ISSUES\0\u{1}TRANSPOSED_WITH_ISSUES\0\u{1}TRANSPOSED_WITH_ISSUES_UNCHANGED\0")
}

extension TST_ImportWarningSetArchive.FormulaImportWarning: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_ImportWarningSetArchive.protoMessageName + ".FormulaImportWarning"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}formula_warning_type\0\u{3}original_formula\0\u{3}supplementary_text\0\u{3}formula_warning_type_int\0")

  public var isInitialized: Bool {
    if self._formulaWarningType == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._formulaWarningType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._originalFormula) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._supplementaryText) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._formulaWarningTypeInt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._formulaWarningType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._originalFormula {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._supplementaryText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._formulaWarningTypeInt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ImportWarningSetArchive.FormulaImportWarning, rhs: TST_ImportWarningSetArchive.FormulaImportWarning) -> Bool {
    if lhs._formulaWarningType != rhs._formulaWarningType {return false}
    if lhs._originalFormula != rhs._originalFormula {return false}
    if lhs._supplementaryText != rhs._supplementaryText {return false}
    if lhs._formulaWarningTypeInt != rhs._formulaWarningTypeInt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CellRefImportWarningSetPairArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellRefImportWarningSetPairArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cell_ref\0\u{4}\u{2}warning_set\0")

  public var isInitialized: Bool {
    if self._cellRef == nil {return false}
    if let v = self._cellRef, !v.isInitialized {return false}
    if let v = self._warningSet, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cellRef) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._warningSet) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cellRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._warningSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CellRefImportWarningSetPairArchive, rhs: TST_CellRefImportWarningSetPairArchive) -> Bool {
    if lhs._cellRef != rhs._cellRef {return false}
    if lhs._warningSet != rhs._warningSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ImportWarningSetByCellRefArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImportWarningSetByCellRefArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cellref_warning_set_pair\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.cellrefWarningSetPair) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cellrefWarningSetPair) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cellrefWarningSetPair.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cellrefWarningSetPair, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ImportWarningSetByCellRefArchive, rhs: TST_ImportWarningSetByCellRefArchive) -> Bool {
    if lhs.cellrefWarningSetPair != rhs.cellrefWarningSetPair {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableDataList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TableDataList"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}listType\0\u{1}nextListID\0\u{1}entries\0\u{1}segments\0\u{3}is_new_for_bnc\0")

  public var isInitialized: Bool {
    if self._listType == nil {return false}
    if self._nextListID == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.entries) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.segments) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._listType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._nextListID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.segments) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._isNewForBnc) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._listType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nextListID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 3)
    }
    if !self.segments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.segments, fieldNumber: 4)
    }
    try { if let v = self._isNewForBnc {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableDataList, rhs: TST_TableDataList) -> Bool {
    if lhs._listType != rhs._listType {return false}
    if lhs._nextListID != rhs._nextListID {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.segments != rhs.segments {return false}
    if lhs._isNewForBnc != rhs._isNewForBnc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableDataList.ListType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}STRING\0\u{1}FORMAT\0\u{1}FORMULA\0\u{1}STYLE\0\u{1}FORMULA_ERROR\0\u{1}CUSTOM_FORMAT\0\u{1}MULTIPLE_CHOICE_LIST_FORMAT\0\u{1}RICH_TEXT_PAYLOAD\0\u{1}CONDITIONAL_STYLE\0\u{1}COMMENT_STORAGE\0\u{1}IMPORT_WARNING\0\u{1}CONTROL_CELL_SPEC\0")
}

extension TST_TableDataList.ListEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_TableDataList.protoMessageName + ".ListEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}refcount\0\u{1}string\0\u{1}reference\0\u{1}formula\0\u{1}format\0\u{4}\u{2}custom_format\0\u{3}rich_text_payload\0\u{3}comment_storage\0\u{3}import_warning_set\0\u{3}cell_spec\0")

  fileprivate class _StorageClass {
    var _key: UInt32? = nil
    var _refcount: UInt32? = nil
    var _string: String? = nil
    var _reference: TSP_Reference? = nil
    var _formula: TSCE_FormulaArchive? = nil
    var _format: TSK_FormatStructArchive? = nil
    var _customFormat: TSK_CustomFormatArchive? = nil
    var _richTextPayload: TSP_Reference? = nil
    var _commentStorage: TSP_Reference? = nil
    var _importWarningSet: TST_ImportWarningSetArchive? = nil
    var _cellSpec: TST_CellSpecArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _refcount = source._refcount
      _string = source._string
      _reference = source._reference
      _formula = source._formula
      _format = source._format
      _customFormat = source._customFormat
      _richTextPayload = source._richTextPayload
      _commentStorage = source._commentStorage
      _importWarningSet = source._importWarningSet
      _cellSpec = source._cellSpec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._key == nil {return false}
      if _storage._refcount == nil {return false}
      if let v = _storage._reference, !v.isInitialized {return false}
      if let v = _storage._formula, !v.isInitialized {return false}
      if let v = _storage._format, !v.isInitialized {return false}
      if let v = _storage._customFormat, !v.isInitialized {return false}
      if let v = _storage._richTextPayload, !v.isInitialized {return false}
      if let v = _storage._commentStorage, !v.isInitialized {return false}
      if let v = _storage._importWarningSet, !v.isInitialized {return false}
      if let v = _storage._cellSpec, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._key) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._refcount) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._string) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._reference) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._formula) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._format) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._customFormat) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._richTextPayload) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._commentStorage) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._importWarningSet) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._cellSpec) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._key {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._refcount {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._string {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._reference {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._formula {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._format {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._customFormat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._richTextPayload {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._commentStorage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._importWarningSet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._cellSpec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableDataList.ListEntry, rhs: TST_TableDataList.ListEntry) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._refcount != rhs_storage._refcount {return false}
        if _storage._string != rhs_storage._string {return false}
        if _storage._reference != rhs_storage._reference {return false}
        if _storage._formula != rhs_storage._formula {return false}
        if _storage._format != rhs_storage._format {return false}
        if _storage._customFormat != rhs_storage._customFormat {return false}
        if _storage._richTextPayload != rhs_storage._richTextPayload {return false}
        if _storage._commentStorage != rhs_storage._commentStorage {return false}
        if _storage._importWarningSet != rhs_storage._importWarningSet {return false}
        if _storage._cellSpec != rhs_storage._cellSpec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableDataListSegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TableDataListSegment"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}list_type\0\u{3}key_range\0\u{1}entries\0")

  public var isInitialized: Bool {
    if self._listType == nil {return false}
    if self._keyRange == nil {return false}
    if let v = self._keyRange, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.entries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._listType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._keyRange) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._listType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._keyRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableDataListSegment, rhs: TST_TableDataListSegment) -> Bool {
    if lhs._listType != rhs._listType {return false}
    if lhs._keyRange != rhs._keyRange {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableRBTree: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TableRBTree"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}nodes\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.nodes) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableRBTree, rhs: TST_TableRBTree) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableRBTree.Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_TableRBTree.protoMessageName + ".Node"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}value\0")

  public var isInitialized: Bool {
    if self._key == nil {return false}
    if self._value == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._key) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableRBTree.Node, rhs: TST_TableRBTree.Node) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_HeaderStorageBucket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeaderStorageBucket"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}bucketHashFunction\0\u{1}headers\0")

  public var isInitialized: Bool {
    if self._bucketHashFunction == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.headers) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._bucketHashFunction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bucketHashFunction {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_HeaderStorageBucket, rhs: TST_HeaderStorageBucket) -> Bool {
    if lhs._bucketHashFunction != rhs._bucketHashFunction {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_HeaderStorageBucket.Header: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_HeaderStorageBucket.protoMessageName + ".Header"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}index\0\u{1}size\0\u{1}hidingState\0\u{1}numberOfCells\0\u{3}cell_style\0\u{3}text_style\0")

  public var isInitialized: Bool {
    if self._index == nil {return false}
    if self._size == nil {return false}
    if self._hidingState == nil {return false}
    if self._numberOfCells == nil {return false}
    if let v = self._cellStyle, !v.isInitialized {return false}
    if let v = self._textStyle, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._index) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._size) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._hidingState) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._numberOfCells) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._cellStyle) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._textStyle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._index {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hidingState {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._numberOfCells {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._cellStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._textStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_HeaderStorageBucket.Header, rhs: TST_HeaderStorageBucket.Header) -> Bool {
    if lhs._index != rhs._index {return false}
    if lhs._size != rhs._size {return false}
    if lhs._hidingState != rhs._hidingState {return false}
    if lhs._numberOfCells != rhs._numberOfCells {return false}
    if lhs._cellStyle != rhs._cellStyle {return false}
    if lhs._textStyle != rhs._textStyle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_HeaderStorage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeaderStorage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}bucketHashFunction\0\u{1}buckets\0")

  public var isInitialized: Bool {
    if self._bucketHashFunction == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.buckets) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._bucketHashFunction) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.buckets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bucketHashFunction {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.buckets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buckets, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_HeaderStorage, rhs: TST_HeaderStorage) -> Bool {
    if lhs._bucketHashFunction != rhs._bucketHashFunction {return false}
    if lhs.buckets != rhs.buckets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_DataStore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataStore"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rowHeaders\0\u{1}columnHeaders\0\u{1}tiles\0\u{1}stringTable\0\u{1}styleTable\0\u{3}formula_table\0\u{1}nextRowStripID\0\u{1}nextColumnStripID\0\u{1}rowTileTree\0\u{1}columnTileTree\0\u{3}format_table_pre_bnc\0\u{1}formulaErrorTable\0\u{3}merge_region_map\0\u{3}storage_version_pre_bnc\0\u{3}deprecated_custom_format_table\0\u{1}multipleChoiceListFormatTable\0\u{3}rich_text_table\0\u{1}conditionalstyletable\0\u{1}commentStorageTable\0\u{1}importWarningSetTable\0\u{3}control_cell_spec_table\0\u{3}format_table\0")

  fileprivate class _StorageClass {
    var _rowHeaders: TST_HeaderStorage? = nil
    var _columnHeaders: TSP_Reference? = nil
    var _tiles: TST_TileStorage? = nil
    var _stringTable: TSP_Reference? = nil
    var _styleTable: TSP_Reference? = nil
    var _formulaTable: TSP_Reference? = nil
    var _formulaErrorTable: TSP_Reference? = nil
    var _formatTablePreBnc: TSP_Reference? = nil
    var _multipleChoiceListFormatTable: TSP_Reference? = nil
    var _mergeRegionMap: TSP_Reference? = nil
    var _deprecatedCustomFormatTable: TSP_Reference? = nil
    var _nextRowStripID: UInt32? = nil
    var _nextColumnStripID: UInt32? = nil
    var _rowTileTree: TST_TableRBTree? = nil
    var _columnTileTree: TST_TableRBTree? = nil
    var _storageVersionPreBnc: UInt32? = nil
    var _richTextTable: TSP_Reference? = nil
    var _conditionalstyletable: TSP_Reference? = nil
    var _commentStorageTable: TSP_Reference? = nil
    var _importWarningSetTable: TSP_Reference? = nil
    var _controlCellSpecTable: TSP_Reference? = nil
    var _formatTable: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rowHeaders = source._rowHeaders
      _columnHeaders = source._columnHeaders
      _tiles = source._tiles
      _stringTable = source._stringTable
      _styleTable = source._styleTable
      _formulaTable = source._formulaTable
      _formulaErrorTable = source._formulaErrorTable
      _formatTablePreBnc = source._formatTablePreBnc
      _multipleChoiceListFormatTable = source._multipleChoiceListFormatTable
      _mergeRegionMap = source._mergeRegionMap
      _deprecatedCustomFormatTable = source._deprecatedCustomFormatTable
      _nextRowStripID = source._nextRowStripID
      _nextColumnStripID = source._nextColumnStripID
      _rowTileTree = source._rowTileTree
      _columnTileTree = source._columnTileTree
      _storageVersionPreBnc = source._storageVersionPreBnc
      _richTextTable = source._richTextTable
      _conditionalstyletable = source._conditionalstyletable
      _commentStorageTable = source._commentStorageTable
      _importWarningSetTable = source._importWarningSetTable
      _controlCellSpecTable = source._controlCellSpecTable
      _formatTable = source._formatTable
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._rowHeaders == nil {return false}
      if _storage._columnHeaders == nil {return false}
      if _storage._tiles == nil {return false}
      if _storage._stringTable == nil {return false}
      if _storage._styleTable == nil {return false}
      if _storage._formulaTable == nil {return false}
      if _storage._formatTablePreBnc == nil {return false}
      if _storage._nextRowStripID == nil {return false}
      if _storage._nextColumnStripID == nil {return false}
      if _storage._rowTileTree == nil {return false}
      if _storage._columnTileTree == nil {return false}
      if let v = _storage._rowHeaders, !v.isInitialized {return false}
      if let v = _storage._columnHeaders, !v.isInitialized {return false}
      if let v = _storage._tiles, !v.isInitialized {return false}
      if let v = _storage._stringTable, !v.isInitialized {return false}
      if let v = _storage._styleTable, !v.isInitialized {return false}
      if let v = _storage._formulaTable, !v.isInitialized {return false}
      if let v = _storage._formulaErrorTable, !v.isInitialized {return false}
      if let v = _storage._formatTablePreBnc, !v.isInitialized {return false}
      if let v = _storage._multipleChoiceListFormatTable, !v.isInitialized {return false}
      if let v = _storage._mergeRegionMap, !v.isInitialized {return false}
      if let v = _storage._deprecatedCustomFormatTable, !v.isInitialized {return false}
      if let v = _storage._rowTileTree, !v.isInitialized {return false}
      if let v = _storage._columnTileTree, !v.isInitialized {return false}
      if let v = _storage._richTextTable, !v.isInitialized {return false}
      if let v = _storage._conditionalstyletable, !v.isInitialized {return false}
      if let v = _storage._commentStorageTable, !v.isInitialized {return false}
      if let v = _storage._importWarningSetTable, !v.isInitialized {return false}
      if let v = _storage._controlCellSpecTable, !v.isInitialized {return false}
      if let v = _storage._formatTable, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._rowHeaders) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._columnHeaders) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._tiles) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._stringTable) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._styleTable) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._formulaTable) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._nextRowStripID) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._nextColumnStripID) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._rowTileTree) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._columnTileTree) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._formatTablePreBnc) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._formulaErrorTable) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._mergeRegionMap) }()
        case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._storageVersionPreBnc) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._deprecatedCustomFormatTable) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._multipleChoiceListFormatTable) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._richTextTable) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._conditionalstyletable) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._commentStorageTable) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._importWarningSetTable) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._controlCellSpecTable) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._formatTable) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._rowHeaders {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._columnHeaders {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._tiles {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._stringTable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._styleTable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._formulaTable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._nextRowStripID {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._nextColumnStripID {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._rowTileTree {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._columnTileTree {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._formatTablePreBnc {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._formulaErrorTable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._mergeRegionMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._storageVersionPreBnc {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._deprecatedCustomFormatTable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._multipleChoiceListFormatTable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._richTextTable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._conditionalstyletable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._commentStorageTable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._importWarningSetTable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._controlCellSpecTable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._formatTable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_DataStore, rhs: TST_DataStore) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rowHeaders != rhs_storage._rowHeaders {return false}
        if _storage._columnHeaders != rhs_storage._columnHeaders {return false}
        if _storage._tiles != rhs_storage._tiles {return false}
        if _storage._stringTable != rhs_storage._stringTable {return false}
        if _storage._styleTable != rhs_storage._styleTable {return false}
        if _storage._formulaTable != rhs_storage._formulaTable {return false}
        if _storage._formulaErrorTable != rhs_storage._formulaErrorTable {return false}
        if _storage._formatTablePreBnc != rhs_storage._formatTablePreBnc {return false}
        if _storage._multipleChoiceListFormatTable != rhs_storage._multipleChoiceListFormatTable {return false}
        if _storage._mergeRegionMap != rhs_storage._mergeRegionMap {return false}
        if _storage._deprecatedCustomFormatTable != rhs_storage._deprecatedCustomFormatTable {return false}
        if _storage._nextRowStripID != rhs_storage._nextRowStripID {return false}
        if _storage._nextColumnStripID != rhs_storage._nextColumnStripID {return false}
        if _storage._rowTileTree != rhs_storage._rowTileTree {return false}
        if _storage._columnTileTree != rhs_storage._columnTileTree {return false}
        if _storage._storageVersionPreBnc != rhs_storage._storageVersionPreBnc {return false}
        if _storage._richTextTable != rhs_storage._richTextTable {return false}
        if _storage._conditionalstyletable != rhs_storage._conditionalstyletable {return false}
        if _storage._commentStorageTable != rhs_storage._commentStorageTable {return false}
        if _storage._importWarningSetTable != rhs_storage._importWarningSetTable {return false}
        if _storage._controlCellSpecTable != rhs_storage._controlCellSpecTable {return false}
        if _storage._formatTable != rhs_storage._formatTable {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableInfoArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TableInfoArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}tableModel\0\u{3}editing_state\0\u{3}summary_model\0\u{3}category_order\0\u{3}view_column_row_uids\0\u{3}group_by_uuid\0\u{3}hidden_states_uuid\0\u{3}formula_coord_space_in_pre40\0\u{3}formula_coord_space\0\u{4}\u{3}pasteboard_coord_mapper\0\u{3}layout_engine\0\u{3}pivot_data_model\0\u{3}is_a_pivot_table\0\u{3}pivot_order\0")

  fileprivate class _StorageClass {
    var _super: TSD_DrawableArchive? = nil
    var _tableModel: TSP_Reference? = nil
    var _editingState: TSP_Reference? = nil
    var _summaryModel: TSP_Reference? = nil
    var _categoryOrder: TSP_Reference? = nil
    var _viewColumnRowUids: TSP_Reference? = nil
    var _groupByUuid: TSP_UUID? = nil
    var _hiddenStatesUuid: TSP_UUID? = nil
    var _formulaCoordSpaceInPre40: UInt32? = nil
    var _formulaCoordSpace: UInt32? = nil
    var _pasteboardCoordMapper: TSCE_CoordMapperArchive? = nil
    var _layoutEngine: TST_LayoutEngineArchive? = nil
    var _pivotDataModel: TSP_Reference? = nil
    var _isAPivotTable: Bool? = nil
    var _pivotOrder: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _tableModel = source._tableModel
      _editingState = source._editingState
      _summaryModel = source._summaryModel
      _categoryOrder = source._categoryOrder
      _viewColumnRowUids = source._viewColumnRowUids
      _groupByUuid = source._groupByUuid
      _hiddenStatesUuid = source._hiddenStatesUuid
      _formulaCoordSpaceInPre40 = source._formulaCoordSpaceInPre40
      _formulaCoordSpace = source._formulaCoordSpace
      _pasteboardCoordMapper = source._pasteboardCoordMapper
      _layoutEngine = source._layoutEngine
      _pivotDataModel = source._pivotDataModel
      _isAPivotTable = source._isAPivotTable
      _pivotOrder = source._pivotOrder
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._tableModel == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._tableModel, !v.isInitialized {return false}
      if let v = _storage._editingState, !v.isInitialized {return false}
      if let v = _storage._summaryModel, !v.isInitialized {return false}
      if let v = _storage._categoryOrder, !v.isInitialized {return false}
      if let v = _storage._viewColumnRowUids, !v.isInitialized {return false}
      if let v = _storage._groupByUuid, !v.isInitialized {return false}
      if let v = _storage._hiddenStatesUuid, !v.isInitialized {return false}
      if let v = _storage._pasteboardCoordMapper, !v.isInitialized {return false}
      if let v = _storage._pivotDataModel, !v.isInitialized {return false}
      if let v = _storage._pivotOrder, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._tableModel) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._editingState) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._summaryModel) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._categoryOrder) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._viewColumnRowUids) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._groupByUuid) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._hiddenStatesUuid) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._formulaCoordSpaceInPre40) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._formulaCoordSpace) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._pasteboardCoordMapper) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._layoutEngine) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._pivotDataModel) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._isAPivotTable) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._pivotOrder) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._tableModel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._editingState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._summaryModel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._categoryOrder {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._viewColumnRowUids {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._groupByUuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._hiddenStatesUuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._formulaCoordSpaceInPre40 {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._formulaCoordSpace {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._pasteboardCoordMapper {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._layoutEngine {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._pivotDataModel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._isAPivotTable {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._pivotOrder {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableInfoArchive, rhs: TST_TableInfoArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._tableModel != rhs_storage._tableModel {return false}
        if _storage._editingState != rhs_storage._editingState {return false}
        if _storage._summaryModel != rhs_storage._summaryModel {return false}
        if _storage._categoryOrder != rhs_storage._categoryOrder {return false}
        if _storage._viewColumnRowUids != rhs_storage._viewColumnRowUids {return false}
        if _storage._groupByUuid != rhs_storage._groupByUuid {return false}
        if _storage._hiddenStatesUuid != rhs_storage._hiddenStatesUuid {return false}
        if _storage._formulaCoordSpaceInPre40 != rhs_storage._formulaCoordSpaceInPre40 {return false}
        if _storage._formulaCoordSpace != rhs_storage._formulaCoordSpace {return false}
        if _storage._pasteboardCoordMapper != rhs_storage._pasteboardCoordMapper {return false}
        if _storage._layoutEngine != rhs_storage._layoutEngine {return false}
        if _storage._pivotDataModel != rhs_storage._pivotDataModel {return false}
        if _storage._isAPivotTable != rhs_storage._isAPivotTable {return false}
        if _storage._pivotOrder != rhs_storage._pivotOrder {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CategoryInfoArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CategoryInfoArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}tableModel\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._tableModel == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._tableModel, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tableModel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tableModel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CategoryInfoArchive, rhs: TST_CategoryInfoArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._tableModel != rhs._tableModel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_WPTableInfoArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WPTableInfoArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}storage\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._storage, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._storage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._storage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_WPTableInfoArchive, rhs: TST_WPTableInfoArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._storage != rhs._storage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableStyleNetworkArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TableStyleNetworkArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}body_text_style\0\u{3}header_row_text_style\0\u{3}header_column_text_style\0\u{3}footer_row_text_style\0\u{3}body_cell_style\0\u{3}header_row_style\0\u{3}header_column_style\0\u{3}footer_row_style\0\u{3}table_style\0\u{3}table_name_style\0\u{3}table_name_shape_style\0\u{3}preset_id\0\u{3}category_level_1_text_style\0\u{3}category_level_2_text_style\0\u{3}category_level_3_text_style\0\u{3}category_level_4_text_style\0\u{3}category_level_5_text_style\0\u{3}category_level_1_style\0\u{3}category_level_2_style\0\u{3}category_level_3_style\0\u{3}category_level_4_style\0\u{3}category_level_5_style\0\u{3}label_level_1_text_style\0\u{3}label_level_2_text_style\0\u{3}label_level_3_text_style\0\u{3}label_level_4_text_style\0\u{3}label_level_5_text_style\0\u{3}label_level_1_style\0\u{3}label_level_2_style\0\u{3}label_level_3_style\0\u{3}label_level_4_style\0\u{3}label_level_5_style\0\u{3}pivot_body_summary_row_style\0\u{3}pivot_body_summary_column_style\0\u{3}pivot_header_column_summary_style\0")

  fileprivate class _StorageClass {
    var _bodyTextStyle: TSP_Reference? = nil
    var _headerRowTextStyle: TSP_Reference? = nil
    var _headerColumnTextStyle: TSP_Reference? = nil
    var _footerRowTextStyle: TSP_Reference? = nil
    var _bodyCellStyle: TSP_Reference? = nil
    var _headerRowStyle: TSP_Reference? = nil
    var _headerColumnStyle: TSP_Reference? = nil
    var _footerRowStyle: TSP_Reference? = nil
    var _tableStyle: TSP_Reference? = nil
    var _tableNameStyle: TSP_Reference? = nil
    var _tableNameShapeStyle: TSP_Reference? = nil
    var _presetID: UInt32? = nil
    var _categoryLevel1TextStyle: TSP_Reference? = nil
    var _categoryLevel2TextStyle: TSP_Reference? = nil
    var _categoryLevel3TextStyle: TSP_Reference? = nil
    var _categoryLevel4TextStyle: TSP_Reference? = nil
    var _categoryLevel5TextStyle: TSP_Reference? = nil
    var _categoryLevel1Style: TSP_Reference? = nil
    var _categoryLevel2Style: TSP_Reference? = nil
    var _categoryLevel3Style: TSP_Reference? = nil
    var _categoryLevel4Style: TSP_Reference? = nil
    var _categoryLevel5Style: TSP_Reference? = nil
    var _labelLevel1TextStyle: TSP_Reference? = nil
    var _labelLevel2TextStyle: TSP_Reference? = nil
    var _labelLevel3TextStyle: TSP_Reference? = nil
    var _labelLevel4TextStyle: TSP_Reference? = nil
    var _labelLevel5TextStyle: TSP_Reference? = nil
    var _labelLevel1Style: TSP_Reference? = nil
    var _labelLevel2Style: TSP_Reference? = nil
    var _labelLevel3Style: TSP_Reference? = nil
    var _labelLevel4Style: TSP_Reference? = nil
    var _labelLevel5Style: TSP_Reference? = nil
    var _pivotBodySummaryRowStyle: TSP_Reference? = nil
    var _pivotBodySummaryColumnStyle: TSP_Reference? = nil
    var _pivotHeaderColumnSummaryStyle: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _bodyTextStyle = source._bodyTextStyle
      _headerRowTextStyle = source._headerRowTextStyle
      _headerColumnTextStyle = source._headerColumnTextStyle
      _footerRowTextStyle = source._footerRowTextStyle
      _bodyCellStyle = source._bodyCellStyle
      _headerRowStyle = source._headerRowStyle
      _headerColumnStyle = source._headerColumnStyle
      _footerRowStyle = source._footerRowStyle
      _tableStyle = source._tableStyle
      _tableNameStyle = source._tableNameStyle
      _tableNameShapeStyle = source._tableNameShapeStyle
      _presetID = source._presetID
      _categoryLevel1TextStyle = source._categoryLevel1TextStyle
      _categoryLevel2TextStyle = source._categoryLevel2TextStyle
      _categoryLevel3TextStyle = source._categoryLevel3TextStyle
      _categoryLevel4TextStyle = source._categoryLevel4TextStyle
      _categoryLevel5TextStyle = source._categoryLevel5TextStyle
      _categoryLevel1Style = source._categoryLevel1Style
      _categoryLevel2Style = source._categoryLevel2Style
      _categoryLevel3Style = source._categoryLevel3Style
      _categoryLevel4Style = source._categoryLevel4Style
      _categoryLevel5Style = source._categoryLevel5Style
      _labelLevel1TextStyle = source._labelLevel1TextStyle
      _labelLevel2TextStyle = source._labelLevel2TextStyle
      _labelLevel3TextStyle = source._labelLevel3TextStyle
      _labelLevel4TextStyle = source._labelLevel4TextStyle
      _labelLevel5TextStyle = source._labelLevel5TextStyle
      _labelLevel1Style = source._labelLevel1Style
      _labelLevel2Style = source._labelLevel2Style
      _labelLevel3Style = source._labelLevel3Style
      _labelLevel4Style = source._labelLevel4Style
      _labelLevel5Style = source._labelLevel5Style
      _pivotBodySummaryRowStyle = source._pivotBodySummaryRowStyle
      _pivotBodySummaryColumnStyle = source._pivotBodySummaryColumnStyle
      _pivotHeaderColumnSummaryStyle = source._pivotHeaderColumnSummaryStyle
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._bodyTextStyle == nil {return false}
      if _storage._headerRowTextStyle == nil {return false}
      if _storage._headerColumnTextStyle == nil {return false}
      if _storage._footerRowTextStyle == nil {return false}
      if _storage._bodyCellStyle == nil {return false}
      if _storage._headerRowStyle == nil {return false}
      if _storage._headerColumnStyle == nil {return false}
      if _storage._footerRowStyle == nil {return false}
      if _storage._tableStyle == nil {return false}
      if let v = _storage._bodyTextStyle, !v.isInitialized {return false}
      if let v = _storage._headerRowTextStyle, !v.isInitialized {return false}
      if let v = _storage._headerColumnTextStyle, !v.isInitialized {return false}
      if let v = _storage._footerRowTextStyle, !v.isInitialized {return false}
      if let v = _storage._bodyCellStyle, !v.isInitialized {return false}
      if let v = _storage._headerRowStyle, !v.isInitialized {return false}
      if let v = _storage._headerColumnStyle, !v.isInitialized {return false}
      if let v = _storage._footerRowStyle, !v.isInitialized {return false}
      if let v = _storage._tableStyle, !v.isInitialized {return false}
      if let v = _storage._tableNameStyle, !v.isInitialized {return false}
      if let v = _storage._tableNameShapeStyle, !v.isInitialized {return false}
      if let v = _storage._categoryLevel1TextStyle, !v.isInitialized {return false}
      if let v = _storage._categoryLevel2TextStyle, !v.isInitialized {return false}
      if let v = _storage._categoryLevel3TextStyle, !v.isInitialized {return false}
      if let v = _storage._categoryLevel4TextStyle, !v.isInitialized {return false}
      if let v = _storage._categoryLevel5TextStyle, !v.isInitialized {return false}
      if let v = _storage._categoryLevel1Style, !v.isInitialized {return false}
      if let v = _storage._categoryLevel2Style, !v.isInitialized {return false}
      if let v = _storage._categoryLevel3Style, !v.isInitialized {return false}
      if let v = _storage._categoryLevel4Style, !v.isInitialized {return false}
      if let v = _storage._categoryLevel5Style, !v.isInitialized {return false}
      if let v = _storage._labelLevel1TextStyle, !v.isInitialized {return false}
      if let v = _storage._labelLevel2TextStyle, !v.isInitialized {return false}
      if let v = _storage._labelLevel3TextStyle, !v.isInitialized {return false}
      if let v = _storage._labelLevel4TextStyle, !v.isInitialized {return false}
      if let v = _storage._labelLevel5TextStyle, !v.isInitialized {return false}
      if let v = _storage._labelLevel1Style, !v.isInitialized {return false}
      if let v = _storage._labelLevel2Style, !v.isInitialized {return false}
      if let v = _storage._labelLevel3Style, !v.isInitialized {return false}
      if let v = _storage._labelLevel4Style, !v.isInitialized {return false}
      if let v = _storage._labelLevel5Style, !v.isInitialized {return false}
      if let v = _storage._pivotBodySummaryRowStyle, !v.isInitialized {return false}
      if let v = _storage._pivotBodySummaryColumnStyle, !v.isInitialized {return false}
      if let v = _storage._pivotHeaderColumnSummaryStyle, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._bodyTextStyle) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._headerRowTextStyle) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._headerColumnTextStyle) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._footerRowTextStyle) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._bodyCellStyle) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._headerRowStyle) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._headerColumnStyle) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._footerRowStyle) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._tableStyle) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._tableNameStyle) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._tableNameShapeStyle) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._presetID) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._categoryLevel1TextStyle) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._categoryLevel2TextStyle) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._categoryLevel3TextStyle) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._categoryLevel4TextStyle) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._categoryLevel5TextStyle) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._categoryLevel1Style) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._categoryLevel2Style) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._categoryLevel3Style) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._categoryLevel4Style) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._categoryLevel5Style) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._labelLevel1TextStyle) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._labelLevel2TextStyle) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._labelLevel3TextStyle) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._labelLevel4TextStyle) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._labelLevel5TextStyle) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._labelLevel1Style) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._labelLevel2Style) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._labelLevel3Style) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._labelLevel4Style) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._labelLevel5Style) }()
        case 33: try { try decoder.decodeSingularMessageField(value: &_storage._pivotBodySummaryRowStyle) }()
        case 34: try { try decoder.decodeSingularMessageField(value: &_storage._pivotBodySummaryColumnStyle) }()
        case 35: try { try decoder.decodeSingularMessageField(value: &_storage._pivotHeaderColumnSummaryStyle) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._bodyTextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._headerRowTextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._headerColumnTextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._footerRowTextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._bodyCellStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._headerRowStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._headerColumnStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._footerRowStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._tableStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._tableNameStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._tableNameShapeStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._presetID {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._categoryLevel1TextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._categoryLevel2TextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._categoryLevel3TextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._categoryLevel4TextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._categoryLevel5TextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._categoryLevel1Style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._categoryLevel2Style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._categoryLevel3Style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._categoryLevel4Style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._categoryLevel5Style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._labelLevel1TextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._labelLevel2TextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._labelLevel3TextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._labelLevel4TextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._labelLevel5TextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      } }()
      try { if let v = _storage._labelLevel1Style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._labelLevel2Style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._labelLevel3Style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._labelLevel4Style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._labelLevel5Style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._pivotBodySummaryRowStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      } }()
      try { if let v = _storage._pivotBodySummaryColumnStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      } }()
      try { if let v = _storage._pivotHeaderColumnSummaryStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableStyleNetworkArchive, rhs: TST_TableStyleNetworkArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._bodyTextStyle != rhs_storage._bodyTextStyle {return false}
        if _storage._headerRowTextStyle != rhs_storage._headerRowTextStyle {return false}
        if _storage._headerColumnTextStyle != rhs_storage._headerColumnTextStyle {return false}
        if _storage._footerRowTextStyle != rhs_storage._footerRowTextStyle {return false}
        if _storage._bodyCellStyle != rhs_storage._bodyCellStyle {return false}
        if _storage._headerRowStyle != rhs_storage._headerRowStyle {return false}
        if _storage._headerColumnStyle != rhs_storage._headerColumnStyle {return false}
        if _storage._footerRowStyle != rhs_storage._footerRowStyle {return false}
        if _storage._tableStyle != rhs_storage._tableStyle {return false}
        if _storage._tableNameStyle != rhs_storage._tableNameStyle {return false}
        if _storage._tableNameShapeStyle != rhs_storage._tableNameShapeStyle {return false}
        if _storage._presetID != rhs_storage._presetID {return false}
        if _storage._categoryLevel1TextStyle != rhs_storage._categoryLevel1TextStyle {return false}
        if _storage._categoryLevel2TextStyle != rhs_storage._categoryLevel2TextStyle {return false}
        if _storage._categoryLevel3TextStyle != rhs_storage._categoryLevel3TextStyle {return false}
        if _storage._categoryLevel4TextStyle != rhs_storage._categoryLevel4TextStyle {return false}
        if _storage._categoryLevel5TextStyle != rhs_storage._categoryLevel5TextStyle {return false}
        if _storage._categoryLevel1Style != rhs_storage._categoryLevel1Style {return false}
        if _storage._categoryLevel2Style != rhs_storage._categoryLevel2Style {return false}
        if _storage._categoryLevel3Style != rhs_storage._categoryLevel3Style {return false}
        if _storage._categoryLevel4Style != rhs_storage._categoryLevel4Style {return false}
        if _storage._categoryLevel5Style != rhs_storage._categoryLevel5Style {return false}
        if _storage._labelLevel1TextStyle != rhs_storage._labelLevel1TextStyle {return false}
        if _storage._labelLevel2TextStyle != rhs_storage._labelLevel2TextStyle {return false}
        if _storage._labelLevel3TextStyle != rhs_storage._labelLevel3TextStyle {return false}
        if _storage._labelLevel4TextStyle != rhs_storage._labelLevel4TextStyle {return false}
        if _storage._labelLevel5TextStyle != rhs_storage._labelLevel5TextStyle {return false}
        if _storage._labelLevel1Style != rhs_storage._labelLevel1Style {return false}
        if _storage._labelLevel2Style != rhs_storage._labelLevel2Style {return false}
        if _storage._labelLevel3Style != rhs_storage._labelLevel3Style {return false}
        if _storage._labelLevel4Style != rhs_storage._labelLevel4Style {return false}
        if _storage._labelLevel5Style != rhs_storage._labelLevel5Style {return false}
        if _storage._pivotBodySummaryRowStyle != rhs_storage._pivotBodySummaryRowStyle {return false}
        if _storage._pivotBodySummaryColumnStyle != rhs_storage._pivotBodySummaryColumnStyle {return false}
        if _storage._pivotHeaderColumnSummaryStyle != rhs_storage._pivotHeaderColumnSummaryStyle {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableGroupSortOrderUIDArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TableGroupSortOrderUIDArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_sort_rules\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.groupSortRules) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groupSortRules) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupSortRules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupSortRules, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableGroupSortOrderUIDArchive, rhs: TST_TableGroupSortOrderUIDArchive) -> Bool {
    if lhs.groupSortRules != rhs.groupSortRules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableGroupSortOrderUIDArchive.GroupSortRuleUIDArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_TableGroupSortOrderUIDArchive.protoMessageName + ".GroupSortRuleUIDArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}grouping_column_uid\0\u{3}column_uid\0\u{1}direction\0")

  public var isInitialized: Bool {
    if let v = self._groupingColumnUid, !v.isInitialized {return false}
    if let v = self._columnUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groupingColumnUid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._columnUid) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._direction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groupingColumnUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._columnUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._direction {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableGroupSortOrderUIDArchive.GroupSortRuleUIDArchive, rhs: TST_TableGroupSortOrderUIDArchive.GroupSortRuleUIDArchive) -> Bool {
    if lhs._groupingColumnUid != rhs._groupingColumnUid {return false}
    if lhs._columnUid != rhs._columnUid {return false}
    if lhs._direction != rhs._direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableGroupSortOrderUIDArchive.GroupSortRuleUIDArchive.Direction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ascending\0\u{1}descending\0")
}

extension TST_TableSortOrderArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TableSortOrderArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}rules\0")

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rules) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rules) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.rules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rules, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableSortOrderArchive, rhs: TST_TableSortOrderArchive) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.rules != rhs.rules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableSortOrderArchive.SortType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0entire_table\0\u{1}row_range\0")
}

extension TST_TableSortOrderArchive.SortRuleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_TableSortOrderArchive.protoMessageName + ".SortRuleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}index\0\u{1}direction\0")

  public var isInitialized: Bool {
    if self._index == nil {return false}
    if self._direction == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._index) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._direction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._index {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._direction {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableSortOrderArchive.SortRuleArchive, rhs: TST_TableSortOrderArchive.SortRuleArchive) -> Bool {
    if lhs._index != rhs._index {return false}
    if lhs._direction != rhs._direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableSortOrderArchive.SortRuleArchive.Direction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ascending\0\u{1}descending\0")
}

extension TST_TableSortOrderUIDArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TableSortOrderUIDArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}rules\0")

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rules) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rules) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.rules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rules, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableSortOrderUIDArchive, rhs: TST_TableSortOrderUIDArchive) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.rules != rhs.rules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableSortOrderUIDArchive.SortType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0entire_table\0\u{1}row_range\0")
}

extension TST_TableSortOrderUIDArchive.SortRuleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_TableSortOrderUIDArchive.protoMessageName + ".SortRuleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}column_uid\0\u{1}direction\0")

  public var isInitialized: Bool {
    if self._columnUid == nil {return false}
    if self._direction == nil {return false}
    if let v = self._columnUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._columnUid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._direction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._columnUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._direction {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableSortOrderUIDArchive.SortRuleArchive, rhs: TST_TableSortOrderUIDArchive.SortRuleArchive) -> Bool {
    if lhs._columnUid != rhs._columnUid {return false}
    if lhs._direction != rhs._direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableSortOrderUIDArchive.SortRuleArchive.Direction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ascending\0\u{1}descending\0")
}

extension TST_SortRuleReferenceTrackerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SortRuleReferenceTrackerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}reference_tracker\0")

  public var isInitialized: Bool {
    if self._referenceTracker == nil {return false}
    if let v = self._referenceTracker, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._referenceTracker) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._referenceTracker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_SortRuleReferenceTrackerArchive, rhs: TST_SortRuleReferenceTrackerArchive) -> Bool {
    if lhs._referenceTracker != rhs._referenceTracker {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CellRegion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellRegion"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cell_ranges\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.cellRanges) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cellRanges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cellRanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cellRanges, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CellRegion, rhs: TST_CellRegion) -> Bool {
    if lhs.cellRanges != rhs.cellRanges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CellUIDRegionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellUIDRegionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cell_uid_ranges\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.cellUidRanges) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cellUidRanges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cellUidRanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cellUidRanges, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CellUIDRegionArchive, rhs: TST_CellUIDRegionArchive) -> Bool {
    if lhs.cellUidRanges != rhs.cellUidRanges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_StructuredTextImportRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StructuredTextImportRecord"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}import_settings\0\u{3}import_source\0\u{3}import_date\0\u{3}source_data\0\u{3}source_encoding\0\u{1}confidence\0\u{3}imported_region\0\u{3}source_row_count\0\u{3}source_column_count\0")

  fileprivate class _StorageClass {
    var _importSettings: TSK_StructuredTextImportSettings? = nil
    var _importSource: String? = nil
    var _importDate: Double? = nil
    var _sourceData: Data? = nil
    var _sourceEncoding: UInt64? = nil
    var _confidence: Float? = nil
    var _importedRegion: TST_CellRegion? = nil
    var _sourceRowCount: UInt64? = nil
    var _sourceColumnCount: UInt64? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _importSettings = source._importSettings
      _importSource = source._importSource
      _importDate = source._importDate
      _sourceData = source._sourceData
      _sourceEncoding = source._sourceEncoding
      _confidence = source._confidence
      _importedRegion = source._importedRegion
      _sourceRowCount = source._sourceRowCount
      _sourceColumnCount = source._sourceColumnCount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._importSettings == nil {return false}
      if let v = _storage._importSettings, !v.isInitialized {return false}
      if let v = _storage._importedRegion, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._importSettings) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._importSource) }()
        case 3: try { try decoder.decodeSingularDoubleField(value: &_storage._importDate) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._sourceData) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._sourceEncoding) }()
        case 6: try { try decoder.decodeSingularFloatField(value: &_storage._confidence) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._importedRegion) }()
        case 8: try { try decoder.decodeSingularUInt64Field(value: &_storage._sourceRowCount) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._sourceColumnCount) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._importSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._importSource {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._importDate {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._sourceData {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._sourceEncoding {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._confidence {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._importedRegion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._sourceRowCount {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._sourceColumnCount {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_StructuredTextImportRecord, rhs: TST_StructuredTextImportRecord) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._importSettings != rhs_storage._importSettings {return false}
        if _storage._importSource != rhs_storage._importSource {return false}
        if _storage._importDate != rhs_storage._importDate {return false}
        if _storage._sourceData != rhs_storage._sourceData {return false}
        if _storage._sourceEncoding != rhs_storage._sourceEncoding {return false}
        if _storage._confidence != rhs_storage._confidence {return false}
        if _storage._importedRegion != rhs_storage._importedRegion {return false}
        if _storage._sourceRowCount != rhs_storage._sourceRowCount {return false}
        if _storage._sourceColumnCount != rhs_storage._sourceColumnCount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableModelArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TableModelArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}table_id\0\u{4}\u{2}table_style\0\u{3}base_data_store\0\u{1}provider\0\u{3}number_of_rows\0\u{3}number_of_columns\0\u{3}table_name\0\u{3}number_of_header_rows\0\u{3}number_of_header_columns\0\u{3}number_of_footer_rows\0\u{3}header_rows_frozen\0\u{3}header_columns_frozen\0\u{3}number_of_hidden_rows\0\u{3}number_of_hidden_columns\0\u{3}default_row_height\0\u{3}default_column_width\0\u{3}body_cell_style\0\u{3}header_row_style\0\u{3}header_column_style\0\u{3}footer_row_style\0\u{3}table_name_enabled\0\u{3}origin_offset\0\u{3}body_text_style\0\u{3}header_row_text_style\0\u{3}header_column_text_style\0\u{3}footer_row_text_style\0\u{3}preset_index\0\u{3}repeating_header_rows_enabled\0\u{3}table_name_style\0\u{3}style_apply_clears_all\0\u{3}repeating_header_columns_enabled\0\u{3}table_name_height\0\u{3}hidden_state_formula_owner_for_columns\0\u{3}hidden_state_formula_owner_for_rows\0\u{3}table_name_shape_style\0\u{3}table_name_border_enabled\0\u{3}row_filter_set_pre_pivot\0\u{3}conditional_style_formula_owner_id\0\u{3}number_of_filtered_rows\0\u{3}number_of_user_hidden_rows\0\u{3}number_of_user_hidden_columns\0\u{3}from_table_id\0\u{3}sort_order\0\u{3}sort_rule_reference_tracker\0\u{3}base_column_row_uids\0\u{3}merge_owner\0\u{3}table_style_preset\0\u{3}stroke_sidecar\0\u{3}was_cut\0\u{3}preset_needs_strong_ownership\0\u{3}text_import_record\0\u{4}\u{8}category_level_1_style\0\u{3}category_level_2_style\0\u{3}category_level_3_style\0\u{3}category_level_4_style\0\u{3}category_level_5_style\0\u{3}category_level_1_text_style\0\u{3}category_level_2_text_style\0\u{3}category_level_3_text_style\0\u{3}category_level_4_text_style\0\u{3}category_level_5_text_style\0\u{3}hidden_states_owner\0\u{3}label_level_1_style\0\u{3}label_level_2_style\0\u{3}label_level_3_style\0\u{3}label_level_4_style\0\u{3}label_level_5_style\0\u{3}label_level_1_text_style\0\u{3}label_level_2_text_style\0\u{3}label_level_3_text_style\0\u{3}label_level_4_text_style\0\u{3}label_level_5_text_style\0\u{3}category_owner_deprecated\0\u{3}pencil_annotation_owner\0\u{3}from_group_by_uid\0\u{3}haunted_owner\0\u{3}pivot_owner\0\u{3}category_owner\0\u{3}pivot_body_summary_row_style\0\u{3}pivot_body_summary_column_style\0\u{3}pivot_header_column_summary_style\0\u{3}pivot_value_types_by_col\0\u{3}pivot_date_grouping_columns\0\u{3}pivot_date_grouping_types\0\u{3}spill_owner\0")

  fileprivate class _StorageClass {
    var _tableID: String? = nil
    var _fromTableID: String? = nil
    var _wasCut: Bool? = nil
    var _tableStyle: TSP_Reference? = nil
    var _bodyTextStyle: TSP_Reference? = nil
    var _headerRowTextStyle: TSP_Reference? = nil
    var _headerColumnTextStyle: TSP_Reference? = nil
    var _footerRowTextStyle: TSP_Reference? = nil
    var _bodyCellStyle: TSP_Reference? = nil
    var _headerRowStyle: TSP_Reference? = nil
    var _headerColumnStyle: TSP_Reference? = nil
    var _footerRowStyle: TSP_Reference? = nil
    var _tableNameStyle: TSP_Reference? = nil
    var _tableNameShapeStyle: TSP_Reference? = nil
    var _tableStylePreset: TSP_Reference? = nil
    var _presetIndex: UInt32? = nil
    var _baseDataStore: TST_DataStore? = nil
    var _provider: TSP_Reference? = nil
    var _numberOfRows: UInt32? = nil
    var _numberOfColumns: UInt32? = nil
    var _tableName: String? = nil
    var _tableNameEnabled: Bool? = nil
    var _tableNameHeight: Double? = nil
    var _tableNameBorderEnabled: Bool? = nil
    var _numberOfHeaderRows: UInt32? = nil
    var _numberOfHeaderColumns: UInt32? = nil
    var _numberOfFooterRows: UInt32? = nil
    var _headerRowsFrozen: Bool? = nil
    var _headerColumnsFrozen: Bool? = nil
    var _numberOfHiddenRows: UInt32? = nil
    var _numberOfHiddenColumns: UInt32? = nil
    var _numberOfUserHiddenRows: UInt32? = nil
    var _numberOfUserHiddenColumns: UInt32? = nil
    var _numberOfFilteredRows: UInt32? = nil
    var _defaultRowHeight: Double? = nil
    var _defaultColumnWidth: Double? = nil
    var _originOffset: TST_CellID? = nil
    var _repeatingHeaderRowsEnabled: Bool? = nil
    var _styleApplyClearsAll: Bool? = nil
    var _repeatingHeaderColumnsEnabled: Bool? = nil
    var _hiddenStateFormulaOwnerForColumns: TSP_Reference? = nil
    var _hiddenStateFormulaOwnerForRows: TSP_Reference? = nil
    var _rowFilterSetPrePivot: TSP_Reference? = nil
    var _conditionalStyleFormulaOwnerID: TSP_CFUUIDArchive? = nil
    var _sortOrder: TST_TableSortOrderArchive? = nil
    var _sortRuleReferenceTracker: TST_SortRuleReferenceTrackerArchive? = nil
    var _baseColumnRowUids: TSP_Reference? = nil
    var _mergeOwner: TST_MergeOwnerArchive? = nil
    var _strokeSidecar: TSP_Reference? = nil
    var _presetNeedsStrongOwnership: Bool? = nil
    var _textImportRecord: TST_StructuredTextImportRecord? = nil
    var _categoryLevel1Style: TSP_Reference? = nil
    var _categoryLevel2Style: TSP_Reference? = nil
    var _categoryLevel3Style: TSP_Reference? = nil
    var _categoryLevel4Style: TSP_Reference? = nil
    var _categoryLevel5Style: TSP_Reference? = nil
    var _categoryLevel1TextStyle: TSP_Reference? = nil
    var _categoryLevel2TextStyle: TSP_Reference? = nil
    var _categoryLevel3TextStyle: TSP_Reference? = nil
    var _categoryLevel4TextStyle: TSP_Reference? = nil
    var _categoryLevel5TextStyle: TSP_Reference? = nil
    var _hiddenStatesOwner: TST_HiddenStatesOwnerArchive? = nil
    var _labelLevel1Style: TSP_Reference? = nil
    var _labelLevel2Style: TSP_Reference? = nil
    var _labelLevel3Style: TSP_Reference? = nil
    var _labelLevel4Style: TSP_Reference? = nil
    var _labelLevel5Style: TSP_Reference? = nil
    var _labelLevel1TextStyle: TSP_Reference? = nil
    var _labelLevel2TextStyle: TSP_Reference? = nil
    var _labelLevel3TextStyle: TSP_Reference? = nil
    var _labelLevel4TextStyle: TSP_Reference? = nil
    var _labelLevel5TextStyle: TSP_Reference? = nil
    var _categoryOwnerDeprecated: TST_CategoryOwnerArchive? = nil
    var _pencilAnnotationOwner: TST_PencilAnnotationOwnerArchive? = nil
    var _fromGroupByUid: String? = nil
    var _hauntedOwner: TSCE_HauntedOwnerArchive? = nil
    var _pivotOwner: TSP_Reference? = nil
    var _categoryOwner: TSP_Reference? = nil
    var _pivotBodySummaryRowStyle: TSP_Reference? = nil
    var _pivotBodySummaryColumnStyle: TSP_Reference? = nil
    var _pivotHeaderColumnSummaryStyle: TSP_Reference? = nil
    var _pivotValueTypesByCol: [UInt32] = []
    var _pivotDateGroupingColumns: [UInt32] = []
    var _pivotDateGroupingTypes: [UInt32] = []
    var _spillOwner: TSCE_SpillOwnerArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tableID = source._tableID
      _fromTableID = source._fromTableID
      _wasCut = source._wasCut
      _tableStyle = source._tableStyle
      _bodyTextStyle = source._bodyTextStyle
      _headerRowTextStyle = source._headerRowTextStyle
      _headerColumnTextStyle = source._headerColumnTextStyle
      _footerRowTextStyle = source._footerRowTextStyle
      _bodyCellStyle = source._bodyCellStyle
      _headerRowStyle = source._headerRowStyle
      _headerColumnStyle = source._headerColumnStyle
      _footerRowStyle = source._footerRowStyle
      _tableNameStyle = source._tableNameStyle
      _tableNameShapeStyle = source._tableNameShapeStyle
      _tableStylePreset = source._tableStylePreset
      _presetIndex = source._presetIndex
      _baseDataStore = source._baseDataStore
      _provider = source._provider
      _numberOfRows = source._numberOfRows
      _numberOfColumns = source._numberOfColumns
      _tableName = source._tableName
      _tableNameEnabled = source._tableNameEnabled
      _tableNameHeight = source._tableNameHeight
      _tableNameBorderEnabled = source._tableNameBorderEnabled
      _numberOfHeaderRows = source._numberOfHeaderRows
      _numberOfHeaderColumns = source._numberOfHeaderColumns
      _numberOfFooterRows = source._numberOfFooterRows
      _headerRowsFrozen = source._headerRowsFrozen
      _headerColumnsFrozen = source._headerColumnsFrozen
      _numberOfHiddenRows = source._numberOfHiddenRows
      _numberOfHiddenColumns = source._numberOfHiddenColumns
      _numberOfUserHiddenRows = source._numberOfUserHiddenRows
      _numberOfUserHiddenColumns = source._numberOfUserHiddenColumns
      _numberOfFilteredRows = source._numberOfFilteredRows
      _defaultRowHeight = source._defaultRowHeight
      _defaultColumnWidth = source._defaultColumnWidth
      _originOffset = source._originOffset
      _repeatingHeaderRowsEnabled = source._repeatingHeaderRowsEnabled
      _styleApplyClearsAll = source._styleApplyClearsAll
      _repeatingHeaderColumnsEnabled = source._repeatingHeaderColumnsEnabled
      _hiddenStateFormulaOwnerForColumns = source._hiddenStateFormulaOwnerForColumns
      _hiddenStateFormulaOwnerForRows = source._hiddenStateFormulaOwnerForRows
      _rowFilterSetPrePivot = source._rowFilterSetPrePivot
      _conditionalStyleFormulaOwnerID = source._conditionalStyleFormulaOwnerID
      _sortOrder = source._sortOrder
      _sortRuleReferenceTracker = source._sortRuleReferenceTracker
      _baseColumnRowUids = source._baseColumnRowUids
      _mergeOwner = source._mergeOwner
      _strokeSidecar = source._strokeSidecar
      _presetNeedsStrongOwnership = source._presetNeedsStrongOwnership
      _textImportRecord = source._textImportRecord
      _categoryLevel1Style = source._categoryLevel1Style
      _categoryLevel2Style = source._categoryLevel2Style
      _categoryLevel3Style = source._categoryLevel3Style
      _categoryLevel4Style = source._categoryLevel4Style
      _categoryLevel5Style = source._categoryLevel5Style
      _categoryLevel1TextStyle = source._categoryLevel1TextStyle
      _categoryLevel2TextStyle = source._categoryLevel2TextStyle
      _categoryLevel3TextStyle = source._categoryLevel3TextStyle
      _categoryLevel4TextStyle = source._categoryLevel4TextStyle
      _categoryLevel5TextStyle = source._categoryLevel5TextStyle
      _hiddenStatesOwner = source._hiddenStatesOwner
      _labelLevel1Style = source._labelLevel1Style
      _labelLevel2Style = source._labelLevel2Style
      _labelLevel3Style = source._labelLevel3Style
      _labelLevel4Style = source._labelLevel4Style
      _labelLevel5Style = source._labelLevel5Style
      _labelLevel1TextStyle = source._labelLevel1TextStyle
      _labelLevel2TextStyle = source._labelLevel2TextStyle
      _labelLevel3TextStyle = source._labelLevel3TextStyle
      _labelLevel4TextStyle = source._labelLevel4TextStyle
      _labelLevel5TextStyle = source._labelLevel5TextStyle
      _categoryOwnerDeprecated = source._categoryOwnerDeprecated
      _pencilAnnotationOwner = source._pencilAnnotationOwner
      _fromGroupByUid = source._fromGroupByUid
      _hauntedOwner = source._hauntedOwner
      _pivotOwner = source._pivotOwner
      _categoryOwner = source._categoryOwner
      _pivotBodySummaryRowStyle = source._pivotBodySummaryRowStyle
      _pivotBodySummaryColumnStyle = source._pivotBodySummaryColumnStyle
      _pivotHeaderColumnSummaryStyle = source._pivotHeaderColumnSummaryStyle
      _pivotValueTypesByCol = source._pivotValueTypesByCol
      _pivotDateGroupingColumns = source._pivotDateGroupingColumns
      _pivotDateGroupingTypes = source._pivotDateGroupingTypes
      _spillOwner = source._spillOwner
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._tableID == nil {return false}
      if _storage._tableStyle == nil {return false}
      if _storage._bodyTextStyle == nil {return false}
      if _storage._headerRowTextStyle == nil {return false}
      if _storage._headerColumnTextStyle == nil {return false}
      if _storage._footerRowTextStyle == nil {return false}
      if _storage._bodyCellStyle == nil {return false}
      if _storage._headerRowStyle == nil {return false}
      if _storage._headerColumnStyle == nil {return false}
      if _storage._footerRowStyle == nil {return false}
      if _storage._baseDataStore == nil {return false}
      if _storage._numberOfRows == nil {return false}
      if _storage._numberOfColumns == nil {return false}
      if _storage._tableName == nil {return false}
      if _storage._defaultRowHeight == nil {return false}
      if _storage._defaultColumnWidth == nil {return false}
      if let v = _storage._tableStyle, !v.isInitialized {return false}
      if let v = _storage._bodyTextStyle, !v.isInitialized {return false}
      if let v = _storage._headerRowTextStyle, !v.isInitialized {return false}
      if let v = _storage._headerColumnTextStyle, !v.isInitialized {return false}
      if let v = _storage._footerRowTextStyle, !v.isInitialized {return false}
      if let v = _storage._bodyCellStyle, !v.isInitialized {return false}
      if let v = _storage._headerRowStyle, !v.isInitialized {return false}
      if let v = _storage._headerColumnStyle, !v.isInitialized {return false}
      if let v = _storage._footerRowStyle, !v.isInitialized {return false}
      if let v = _storage._tableNameStyle, !v.isInitialized {return false}
      if let v = _storage._tableNameShapeStyle, !v.isInitialized {return false}
      if let v = _storage._tableStylePreset, !v.isInitialized {return false}
      if let v = _storage._baseDataStore, !v.isInitialized {return false}
      if let v = _storage._provider, !v.isInitialized {return false}
      if let v = _storage._originOffset, !v.isInitialized {return false}
      if let v = _storage._hiddenStateFormulaOwnerForColumns, !v.isInitialized {return false}
      if let v = _storage._hiddenStateFormulaOwnerForRows, !v.isInitialized {return false}
      if let v = _storage._rowFilterSetPrePivot, !v.isInitialized {return false}
      if let v = _storage._sortOrder, !v.isInitialized {return false}
      if let v = _storage._sortRuleReferenceTracker, !v.isInitialized {return false}
      if let v = _storage._baseColumnRowUids, !v.isInitialized {return false}
      if let v = _storage._mergeOwner, !v.isInitialized {return false}
      if let v = _storage._strokeSidecar, !v.isInitialized {return false}
      if let v = _storage._textImportRecord, !v.isInitialized {return false}
      if let v = _storage._categoryLevel1Style, !v.isInitialized {return false}
      if let v = _storage._categoryLevel2Style, !v.isInitialized {return false}
      if let v = _storage._categoryLevel3Style, !v.isInitialized {return false}
      if let v = _storage._categoryLevel4Style, !v.isInitialized {return false}
      if let v = _storage._categoryLevel5Style, !v.isInitialized {return false}
      if let v = _storage._categoryLevel1TextStyle, !v.isInitialized {return false}
      if let v = _storage._categoryLevel2TextStyle, !v.isInitialized {return false}
      if let v = _storage._categoryLevel3TextStyle, !v.isInitialized {return false}
      if let v = _storage._categoryLevel4TextStyle, !v.isInitialized {return false}
      if let v = _storage._categoryLevel5TextStyle, !v.isInitialized {return false}
      if let v = _storage._hiddenStatesOwner, !v.isInitialized {return false}
      if let v = _storage._labelLevel1Style, !v.isInitialized {return false}
      if let v = _storage._labelLevel2Style, !v.isInitialized {return false}
      if let v = _storage._labelLevel3Style, !v.isInitialized {return false}
      if let v = _storage._labelLevel4Style, !v.isInitialized {return false}
      if let v = _storage._labelLevel5Style, !v.isInitialized {return false}
      if let v = _storage._labelLevel1TextStyle, !v.isInitialized {return false}
      if let v = _storage._labelLevel2TextStyle, !v.isInitialized {return false}
      if let v = _storage._labelLevel3TextStyle, !v.isInitialized {return false}
      if let v = _storage._labelLevel4TextStyle, !v.isInitialized {return false}
      if let v = _storage._labelLevel5TextStyle, !v.isInitialized {return false}
      if let v = _storage._categoryOwnerDeprecated, !v.isInitialized {return false}
      if let v = _storage._pencilAnnotationOwner, !v.isInitialized {return false}
      if let v = _storage._hauntedOwner, !v.isInitialized {return false}
      if let v = _storage._pivotOwner, !v.isInitialized {return false}
      if let v = _storage._categoryOwner, !v.isInitialized {return false}
      if let v = _storage._pivotBodySummaryRowStyle, !v.isInitialized {return false}
      if let v = _storage._pivotBodySummaryColumnStyle, !v.isInitialized {return false}
      if let v = _storage._pivotHeaderColumnSummaryStyle, !v.isInitialized {return false}
      if let v = _storage._spillOwner, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._tableID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._tableStyle) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._baseDataStore) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._provider) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._numberOfRows) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._numberOfColumns) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._tableName) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._numberOfHeaderRows) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._numberOfHeaderColumns) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._numberOfFooterRows) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._headerRowsFrozen) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._headerColumnsFrozen) }()
        case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._numberOfHiddenRows) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._numberOfHiddenColumns) }()
        case 16: try { try decoder.decodeSingularDoubleField(value: &_storage._defaultRowHeight) }()
        case 17: try { try decoder.decodeSingularDoubleField(value: &_storage._defaultColumnWidth) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._bodyCellStyle) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._headerRowStyle) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._headerColumnStyle) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._footerRowStyle) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._tableNameEnabled) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._originOffset) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._bodyTextStyle) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._headerRowTextStyle) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._headerColumnTextStyle) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._footerRowTextStyle) }()
        case 28: try { try decoder.decodeSingularUInt32Field(value: &_storage._presetIndex) }()
        case 29: try { try decoder.decodeSingularBoolField(value: &_storage._repeatingHeaderRowsEnabled) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._tableNameStyle) }()
        case 31: try { try decoder.decodeSingularBoolField(value: &_storage._styleApplyClearsAll) }()
        case 32: try { try decoder.decodeSingularBoolField(value: &_storage._repeatingHeaderColumnsEnabled) }()
        case 33: try { try decoder.decodeSingularDoubleField(value: &_storage._tableNameHeight) }()
        case 34: try { try decoder.decodeSingularMessageField(value: &_storage._hiddenStateFormulaOwnerForColumns) }()
        case 35: try { try decoder.decodeSingularMessageField(value: &_storage._hiddenStateFormulaOwnerForRows) }()
        case 36: try { try decoder.decodeSingularMessageField(value: &_storage._tableNameShapeStyle) }()
        case 37: try { try decoder.decodeSingularBoolField(value: &_storage._tableNameBorderEnabled) }()
        case 38: try { try decoder.decodeSingularMessageField(value: &_storage._rowFilterSetPrePivot) }()
        case 39: try { try decoder.decodeSingularMessageField(value: &_storage._conditionalStyleFormulaOwnerID) }()
        case 40: try { try decoder.decodeSingularUInt32Field(value: &_storage._numberOfFilteredRows) }()
        case 41: try { try decoder.decodeSingularUInt32Field(value: &_storage._numberOfUserHiddenRows) }()
        case 42: try { try decoder.decodeSingularUInt32Field(value: &_storage._numberOfUserHiddenColumns) }()
        case 43: try { try decoder.decodeSingularStringField(value: &_storage._fromTableID) }()
        case 44: try { try decoder.decodeSingularMessageField(value: &_storage._sortOrder) }()
        case 45: try { try decoder.decodeSingularMessageField(value: &_storage._sortRuleReferenceTracker) }()
        case 46: try { try decoder.decodeSingularMessageField(value: &_storage._baseColumnRowUids) }()
        case 47: try { try decoder.decodeSingularMessageField(value: &_storage._mergeOwner) }()
        case 48: try { try decoder.decodeSingularMessageField(value: &_storage._tableStylePreset) }()
        case 49: try { try decoder.decodeSingularMessageField(value: &_storage._strokeSidecar) }()
        case 50: try { try decoder.decodeSingularBoolField(value: &_storage._wasCut) }()
        case 51: try { try decoder.decodeSingularBoolField(value: &_storage._presetNeedsStrongOwnership) }()
        case 52: try { try decoder.decodeSingularMessageField(value: &_storage._textImportRecord) }()
        case 60: try { try decoder.decodeSingularMessageField(value: &_storage._categoryLevel1Style) }()
        case 61: try { try decoder.decodeSingularMessageField(value: &_storage._categoryLevel2Style) }()
        case 62: try { try decoder.decodeSingularMessageField(value: &_storage._categoryLevel3Style) }()
        case 63: try { try decoder.decodeSingularMessageField(value: &_storage._categoryLevel4Style) }()
        case 64: try { try decoder.decodeSingularMessageField(value: &_storage._categoryLevel5Style) }()
        case 65: try { try decoder.decodeSingularMessageField(value: &_storage._categoryLevel1TextStyle) }()
        case 66: try { try decoder.decodeSingularMessageField(value: &_storage._categoryLevel2TextStyle) }()
        case 67: try { try decoder.decodeSingularMessageField(value: &_storage._categoryLevel3TextStyle) }()
        case 68: try { try decoder.decodeSingularMessageField(value: &_storage._categoryLevel4TextStyle) }()
        case 69: try { try decoder.decodeSingularMessageField(value: &_storage._categoryLevel5TextStyle) }()
        case 70: try { try decoder.decodeSingularMessageField(value: &_storage._hiddenStatesOwner) }()
        case 71: try { try decoder.decodeSingularMessageField(value: &_storage._labelLevel1Style) }()
        case 72: try { try decoder.decodeSingularMessageField(value: &_storage._labelLevel2Style) }()
        case 73: try { try decoder.decodeSingularMessageField(value: &_storage._labelLevel3Style) }()
        case 74: try { try decoder.decodeSingularMessageField(value: &_storage._labelLevel4Style) }()
        case 75: try { try decoder.decodeSingularMessageField(value: &_storage._labelLevel5Style) }()
        case 76: try { try decoder.decodeSingularMessageField(value: &_storage._labelLevel1TextStyle) }()
        case 77: try { try decoder.decodeSingularMessageField(value: &_storage._labelLevel2TextStyle) }()
        case 78: try { try decoder.decodeSingularMessageField(value: &_storage._labelLevel3TextStyle) }()
        case 79: try { try decoder.decodeSingularMessageField(value: &_storage._labelLevel4TextStyle) }()
        case 80: try { try decoder.decodeSingularMessageField(value: &_storage._labelLevel5TextStyle) }()
        case 81: try { try decoder.decodeSingularMessageField(value: &_storage._categoryOwnerDeprecated) }()
        case 82: try { try decoder.decodeSingularMessageField(value: &_storage._pencilAnnotationOwner) }()
        case 83: try { try decoder.decodeSingularStringField(value: &_storage._fromGroupByUid) }()
        case 84: try { try decoder.decodeSingularMessageField(value: &_storage._hauntedOwner) }()
        case 85: try { try decoder.decodeSingularMessageField(value: &_storage._pivotOwner) }()
        case 86: try { try decoder.decodeSingularMessageField(value: &_storage._categoryOwner) }()
        case 87: try { try decoder.decodeSingularMessageField(value: &_storage._pivotBodySummaryRowStyle) }()
        case 88: try { try decoder.decodeSingularMessageField(value: &_storage._pivotBodySummaryColumnStyle) }()
        case 89: try { try decoder.decodeSingularMessageField(value: &_storage._pivotHeaderColumnSummaryStyle) }()
        case 90: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._pivotValueTypesByCol) }()
        case 91: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._pivotDateGroupingColumns) }()
        case 92: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._pivotDateGroupingTypes) }()
        case 93: try { try decoder.decodeSingularMessageField(value: &_storage._spillOwner) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._tableID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._tableStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._baseDataStore {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._provider {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._numberOfRows {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._numberOfColumns {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._tableName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._numberOfHeaderRows {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._numberOfHeaderColumns {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._numberOfFooterRows {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._headerRowsFrozen {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._headerColumnsFrozen {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._numberOfHiddenRows {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._numberOfHiddenColumns {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._defaultRowHeight {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._defaultColumnWidth {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._bodyCellStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._headerRowStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._headerColumnStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._footerRowStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._tableNameEnabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._originOffset {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._bodyTextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._headerRowTextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._headerColumnTextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._footerRowTextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      } }()
      try { if let v = _storage._presetIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._repeatingHeaderRowsEnabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._tableNameStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._styleApplyClearsAll {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._repeatingHeaderColumnsEnabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._tableNameHeight {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 33)
      } }()
      try { if let v = _storage._hiddenStateFormulaOwnerForColumns {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      } }()
      try { if let v = _storage._hiddenStateFormulaOwnerForRows {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      } }()
      try { if let v = _storage._tableNameShapeStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      } }()
      try { if let v = _storage._tableNameBorderEnabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 37)
      } }()
      try { if let v = _storage._rowFilterSetPrePivot {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      } }()
      try { if let v = _storage._conditionalStyleFormulaOwnerID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      } }()
      try { if let v = _storage._numberOfFilteredRows {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 40)
      } }()
      try { if let v = _storage._numberOfUserHiddenRows {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 41)
      } }()
      try { if let v = _storage._numberOfUserHiddenColumns {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 42)
      } }()
      try { if let v = _storage._fromTableID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 43)
      } }()
      try { if let v = _storage._sortOrder {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      } }()
      try { if let v = _storage._sortRuleReferenceTracker {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      } }()
      try { if let v = _storage._baseColumnRowUids {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      } }()
      try { if let v = _storage._mergeOwner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
      } }()
      try { if let v = _storage._tableStylePreset {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
      } }()
      try { if let v = _storage._strokeSidecar {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
      } }()
      try { if let v = _storage._wasCut {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 50)
      } }()
      try { if let v = _storage._presetNeedsStrongOwnership {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 51)
      } }()
      try { if let v = _storage._textImportRecord {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      } }()
      try { if let v = _storage._categoryLevel1Style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
      } }()
      try { if let v = _storage._categoryLevel2Style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      } }()
      try { if let v = _storage._categoryLevel3Style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
      } }()
      try { if let v = _storage._categoryLevel4Style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 63)
      } }()
      try { if let v = _storage._categoryLevel5Style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
      } }()
      try { if let v = _storage._categoryLevel1TextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 65)
      } }()
      try { if let v = _storage._categoryLevel2TextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 66)
      } }()
      try { if let v = _storage._categoryLevel3TextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 67)
      } }()
      try { if let v = _storage._categoryLevel4TextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 68)
      } }()
      try { if let v = _storage._categoryLevel5TextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 69)
      } }()
      try { if let v = _storage._hiddenStatesOwner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
      } }()
      try { if let v = _storage._labelLevel1Style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
      } }()
      try { if let v = _storage._labelLevel2Style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 72)
      } }()
      try { if let v = _storage._labelLevel3Style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 73)
      } }()
      try { if let v = _storage._labelLevel4Style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 74)
      } }()
      try { if let v = _storage._labelLevel5Style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 75)
      } }()
      try { if let v = _storage._labelLevel1TextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 76)
      } }()
      try { if let v = _storage._labelLevel2TextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 77)
      } }()
      try { if let v = _storage._labelLevel3TextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 78)
      } }()
      try { if let v = _storage._labelLevel4TextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 79)
      } }()
      try { if let v = _storage._labelLevel5TextStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 80)
      } }()
      try { if let v = _storage._categoryOwnerDeprecated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 81)
      } }()
      try { if let v = _storage._pencilAnnotationOwner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 82)
      } }()
      try { if let v = _storage._fromGroupByUid {
        try visitor.visitSingularStringField(value: v, fieldNumber: 83)
      } }()
      try { if let v = _storage._hauntedOwner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 84)
      } }()
      try { if let v = _storage._pivotOwner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 85)
      } }()
      try { if let v = _storage._categoryOwner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 86)
      } }()
      try { if let v = _storage._pivotBodySummaryRowStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 87)
      } }()
      try { if let v = _storage._pivotBodySummaryColumnStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 88)
      } }()
      try { if let v = _storage._pivotHeaderColumnSummaryStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 89)
      } }()
      if !_storage._pivotValueTypesByCol.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._pivotValueTypesByCol, fieldNumber: 90)
      }
      if !_storage._pivotDateGroupingColumns.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._pivotDateGroupingColumns, fieldNumber: 91)
      }
      if !_storage._pivotDateGroupingTypes.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._pivotDateGroupingTypes, fieldNumber: 92)
      }
      try { if let v = _storage._spillOwner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 93)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableModelArchive, rhs: TST_TableModelArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tableID != rhs_storage._tableID {return false}
        if _storage._fromTableID != rhs_storage._fromTableID {return false}
        if _storage._wasCut != rhs_storage._wasCut {return false}
        if _storage._tableStyle != rhs_storage._tableStyle {return false}
        if _storage._bodyTextStyle != rhs_storage._bodyTextStyle {return false}
        if _storage._headerRowTextStyle != rhs_storage._headerRowTextStyle {return false}
        if _storage._headerColumnTextStyle != rhs_storage._headerColumnTextStyle {return false}
        if _storage._footerRowTextStyle != rhs_storage._footerRowTextStyle {return false}
        if _storage._bodyCellStyle != rhs_storage._bodyCellStyle {return false}
        if _storage._headerRowStyle != rhs_storage._headerRowStyle {return false}
        if _storage._headerColumnStyle != rhs_storage._headerColumnStyle {return false}
        if _storage._footerRowStyle != rhs_storage._footerRowStyle {return false}
        if _storage._tableNameStyle != rhs_storage._tableNameStyle {return false}
        if _storage._tableNameShapeStyle != rhs_storage._tableNameShapeStyle {return false}
        if _storage._tableStylePreset != rhs_storage._tableStylePreset {return false}
        if _storage._presetIndex != rhs_storage._presetIndex {return false}
        if _storage._baseDataStore != rhs_storage._baseDataStore {return false}
        if _storage._provider != rhs_storage._provider {return false}
        if _storage._numberOfRows != rhs_storage._numberOfRows {return false}
        if _storage._numberOfColumns != rhs_storage._numberOfColumns {return false}
        if _storage._tableName != rhs_storage._tableName {return false}
        if _storage._tableNameEnabled != rhs_storage._tableNameEnabled {return false}
        if _storage._tableNameHeight != rhs_storage._tableNameHeight {return false}
        if _storage._tableNameBorderEnabled != rhs_storage._tableNameBorderEnabled {return false}
        if _storage._numberOfHeaderRows != rhs_storage._numberOfHeaderRows {return false}
        if _storage._numberOfHeaderColumns != rhs_storage._numberOfHeaderColumns {return false}
        if _storage._numberOfFooterRows != rhs_storage._numberOfFooterRows {return false}
        if _storage._headerRowsFrozen != rhs_storage._headerRowsFrozen {return false}
        if _storage._headerColumnsFrozen != rhs_storage._headerColumnsFrozen {return false}
        if _storage._numberOfHiddenRows != rhs_storage._numberOfHiddenRows {return false}
        if _storage._numberOfHiddenColumns != rhs_storage._numberOfHiddenColumns {return false}
        if _storage._numberOfUserHiddenRows != rhs_storage._numberOfUserHiddenRows {return false}
        if _storage._numberOfUserHiddenColumns != rhs_storage._numberOfUserHiddenColumns {return false}
        if _storage._numberOfFilteredRows != rhs_storage._numberOfFilteredRows {return false}
        if _storage._defaultRowHeight != rhs_storage._defaultRowHeight {return false}
        if _storage._defaultColumnWidth != rhs_storage._defaultColumnWidth {return false}
        if _storage._originOffset != rhs_storage._originOffset {return false}
        if _storage._repeatingHeaderRowsEnabled != rhs_storage._repeatingHeaderRowsEnabled {return false}
        if _storage._styleApplyClearsAll != rhs_storage._styleApplyClearsAll {return false}
        if _storage._repeatingHeaderColumnsEnabled != rhs_storage._repeatingHeaderColumnsEnabled {return false}
        if _storage._hiddenStateFormulaOwnerForColumns != rhs_storage._hiddenStateFormulaOwnerForColumns {return false}
        if _storage._hiddenStateFormulaOwnerForRows != rhs_storage._hiddenStateFormulaOwnerForRows {return false}
        if _storage._rowFilterSetPrePivot != rhs_storage._rowFilterSetPrePivot {return false}
        if _storage._conditionalStyleFormulaOwnerID != rhs_storage._conditionalStyleFormulaOwnerID {return false}
        if _storage._sortOrder != rhs_storage._sortOrder {return false}
        if _storage._sortRuleReferenceTracker != rhs_storage._sortRuleReferenceTracker {return false}
        if _storage._baseColumnRowUids != rhs_storage._baseColumnRowUids {return false}
        if _storage._mergeOwner != rhs_storage._mergeOwner {return false}
        if _storage._strokeSidecar != rhs_storage._strokeSidecar {return false}
        if _storage._presetNeedsStrongOwnership != rhs_storage._presetNeedsStrongOwnership {return false}
        if _storage._textImportRecord != rhs_storage._textImportRecord {return false}
        if _storage._categoryLevel1Style != rhs_storage._categoryLevel1Style {return false}
        if _storage._categoryLevel2Style != rhs_storage._categoryLevel2Style {return false}
        if _storage._categoryLevel3Style != rhs_storage._categoryLevel3Style {return false}
        if _storage._categoryLevel4Style != rhs_storage._categoryLevel4Style {return false}
        if _storage._categoryLevel5Style != rhs_storage._categoryLevel5Style {return false}
        if _storage._categoryLevel1TextStyle != rhs_storage._categoryLevel1TextStyle {return false}
        if _storage._categoryLevel2TextStyle != rhs_storage._categoryLevel2TextStyle {return false}
        if _storage._categoryLevel3TextStyle != rhs_storage._categoryLevel3TextStyle {return false}
        if _storage._categoryLevel4TextStyle != rhs_storage._categoryLevel4TextStyle {return false}
        if _storage._categoryLevel5TextStyle != rhs_storage._categoryLevel5TextStyle {return false}
        if _storage._hiddenStatesOwner != rhs_storage._hiddenStatesOwner {return false}
        if _storage._labelLevel1Style != rhs_storage._labelLevel1Style {return false}
        if _storage._labelLevel2Style != rhs_storage._labelLevel2Style {return false}
        if _storage._labelLevel3Style != rhs_storage._labelLevel3Style {return false}
        if _storage._labelLevel4Style != rhs_storage._labelLevel4Style {return false}
        if _storage._labelLevel5Style != rhs_storage._labelLevel5Style {return false}
        if _storage._labelLevel1TextStyle != rhs_storage._labelLevel1TextStyle {return false}
        if _storage._labelLevel2TextStyle != rhs_storage._labelLevel2TextStyle {return false}
        if _storage._labelLevel3TextStyle != rhs_storage._labelLevel3TextStyle {return false}
        if _storage._labelLevel4TextStyle != rhs_storage._labelLevel4TextStyle {return false}
        if _storage._labelLevel5TextStyle != rhs_storage._labelLevel5TextStyle {return false}
        if _storage._categoryOwnerDeprecated != rhs_storage._categoryOwnerDeprecated {return false}
        if _storage._pencilAnnotationOwner != rhs_storage._pencilAnnotationOwner {return false}
        if _storage._fromGroupByUid != rhs_storage._fromGroupByUid {return false}
        if _storage._hauntedOwner != rhs_storage._hauntedOwner {return false}
        if _storage._pivotOwner != rhs_storage._pivotOwner {return false}
        if _storage._categoryOwner != rhs_storage._categoryOwner {return false}
        if _storage._pivotBodySummaryRowStyle != rhs_storage._pivotBodySummaryRowStyle {return false}
        if _storage._pivotBodySummaryColumnStyle != rhs_storage._pivotBodySummaryColumnStyle {return false}
        if _storage._pivotHeaderColumnSummaryStyle != rhs_storage._pivotHeaderColumnSummaryStyle {return false}
        if _storage._pivotValueTypesByCol != rhs_storage._pivotValueTypesByCol {return false}
        if _storage._pivotDateGroupingColumns != rhs_storage._pivotDateGroupingColumns {return false}
        if _storage._pivotDateGroupingTypes != rhs_storage._pivotDateGroupingTypes {return false}
        if _storage._spillOwner != rhs_storage._spillOwner {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_SummaryModelArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SummaryModelArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}table_info\0\u{3}data_store\0\u{3}column_row_uids\0\u{3}aggregate_formula_owner_uuid\0\u{3}summary_cell_vendor\0\u{4}\u{5}category_column_width\0\u{3}summary_row_level_1_height\0\u{3}summary_row_level_2_height\0\u{3}summary_row_level_3_height\0\u{3}summary_row_level_4_height\0\u{3}summary_row_level_5_height\0\u{3}summary_label_row_level_1_height\0\u{3}summary_label_row_level_2_height\0\u{3}summary_label_row_level_3_height\0\u{3}summary_label_row_level_4_height\0\u{3}summary_label_row_level_5_height\0\u{3}label_row_visibility_1\0\u{3}label_row_visibility_2\0\u{3}label_row_visibility_3\0\u{3}label_row_visibility_4\0\u{3}label_row_visibility_5\0\u{3}summary_row_height_list\0\u{3}label_row_height_list\0\u{3}label_row_visibility_list\0\u{3}group_sort_order\0")

  fileprivate class _StorageClass {
    var _tableInfo: TSP_Reference? = nil
    var _dataStore: TST_DataStore? = nil
    var _columnRowUids: TSP_Reference? = nil
    var _aggregateFormulaOwnerUuid: TSP_UUID? = nil
    var _summaryCellVendor: TSP_Reference? = nil
    var _categoryColumnWidth: Double? = nil
    var _summaryRowLevel1Height: Double? = nil
    var _summaryRowLevel2Height: Double? = nil
    var _summaryRowLevel3Height: Double? = nil
    var _summaryRowLevel4Height: Double? = nil
    var _summaryRowLevel5Height: Double? = nil
    var _summaryLabelRowLevel1Height: Double? = nil
    var _summaryLabelRowLevel2Height: Double? = nil
    var _summaryLabelRowLevel3Height: Double? = nil
    var _summaryLabelRowLevel4Height: Double? = nil
    var _summaryLabelRowLevel5Height: Double? = nil
    var _labelRowVisibility1: UInt32? = nil
    var _labelRowVisibility2: UInt32? = nil
    var _labelRowVisibility3: UInt32? = nil
    var _labelRowVisibility4: UInt32? = nil
    var _labelRowVisibility5: UInt32? = nil
    var _summaryRowHeightList: [Double] = []
    var _labelRowHeightList: [Double] = []
    var _labelRowVisibilityList: [UInt32] = []
    var _groupSortOrder: TST_TableGroupSortOrderUIDArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tableInfo = source._tableInfo
      _dataStore = source._dataStore
      _columnRowUids = source._columnRowUids
      _aggregateFormulaOwnerUuid = source._aggregateFormulaOwnerUuid
      _summaryCellVendor = source._summaryCellVendor
      _categoryColumnWidth = source._categoryColumnWidth
      _summaryRowLevel1Height = source._summaryRowLevel1Height
      _summaryRowLevel2Height = source._summaryRowLevel2Height
      _summaryRowLevel3Height = source._summaryRowLevel3Height
      _summaryRowLevel4Height = source._summaryRowLevel4Height
      _summaryRowLevel5Height = source._summaryRowLevel5Height
      _summaryLabelRowLevel1Height = source._summaryLabelRowLevel1Height
      _summaryLabelRowLevel2Height = source._summaryLabelRowLevel2Height
      _summaryLabelRowLevel3Height = source._summaryLabelRowLevel3Height
      _summaryLabelRowLevel4Height = source._summaryLabelRowLevel4Height
      _summaryLabelRowLevel5Height = source._summaryLabelRowLevel5Height
      _labelRowVisibility1 = source._labelRowVisibility1
      _labelRowVisibility2 = source._labelRowVisibility2
      _labelRowVisibility3 = source._labelRowVisibility3
      _labelRowVisibility4 = source._labelRowVisibility4
      _labelRowVisibility5 = source._labelRowVisibility5
      _summaryRowHeightList = source._summaryRowHeightList
      _labelRowHeightList = source._labelRowHeightList
      _labelRowVisibilityList = source._labelRowVisibilityList
      _groupSortOrder = source._groupSortOrder
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._tableInfo == nil {return false}
      if let v = _storage._tableInfo, !v.isInitialized {return false}
      if let v = _storage._dataStore, !v.isInitialized {return false}
      if let v = _storage._columnRowUids, !v.isInitialized {return false}
      if let v = _storage._aggregateFormulaOwnerUuid, !v.isInitialized {return false}
      if let v = _storage._summaryCellVendor, !v.isInitialized {return false}
      if let v = _storage._groupSortOrder, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._tableInfo) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._dataStore) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._columnRowUids) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._aggregateFormulaOwnerUuid) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._summaryCellVendor) }()
        case 10: try { try decoder.decodeSingularDoubleField(value: &_storage._categoryColumnWidth) }()
        case 11: try { try decoder.decodeSingularDoubleField(value: &_storage._summaryRowLevel1Height) }()
        case 12: try { try decoder.decodeSingularDoubleField(value: &_storage._summaryRowLevel2Height) }()
        case 13: try { try decoder.decodeSingularDoubleField(value: &_storage._summaryRowLevel3Height) }()
        case 14: try { try decoder.decodeSingularDoubleField(value: &_storage._summaryRowLevel4Height) }()
        case 15: try { try decoder.decodeSingularDoubleField(value: &_storage._summaryRowLevel5Height) }()
        case 16: try { try decoder.decodeSingularDoubleField(value: &_storage._summaryLabelRowLevel1Height) }()
        case 17: try { try decoder.decodeSingularDoubleField(value: &_storage._summaryLabelRowLevel2Height) }()
        case 18: try { try decoder.decodeSingularDoubleField(value: &_storage._summaryLabelRowLevel3Height) }()
        case 19: try { try decoder.decodeSingularDoubleField(value: &_storage._summaryLabelRowLevel4Height) }()
        case 20: try { try decoder.decodeSingularDoubleField(value: &_storage._summaryLabelRowLevel5Height) }()
        case 21: try { try decoder.decodeSingularUInt32Field(value: &_storage._labelRowVisibility1) }()
        case 22: try { try decoder.decodeSingularUInt32Field(value: &_storage._labelRowVisibility2) }()
        case 23: try { try decoder.decodeSingularUInt32Field(value: &_storage._labelRowVisibility3) }()
        case 24: try { try decoder.decodeSingularUInt32Field(value: &_storage._labelRowVisibility4) }()
        case 25: try { try decoder.decodeSingularUInt32Field(value: &_storage._labelRowVisibility5) }()
        case 26: try { try decoder.decodeRepeatedDoubleField(value: &_storage._summaryRowHeightList) }()
        case 27: try { try decoder.decodeRepeatedDoubleField(value: &_storage._labelRowHeightList) }()
        case 28: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._labelRowVisibilityList) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._groupSortOrder) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._tableInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._dataStore {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._columnRowUids {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._aggregateFormulaOwnerUuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._summaryCellVendor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._categoryColumnWidth {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._summaryRowLevel1Height {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._summaryRowLevel2Height {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._summaryRowLevel3Height {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._summaryRowLevel4Height {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._summaryRowLevel5Height {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._summaryLabelRowLevel1Height {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._summaryLabelRowLevel2Height {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._summaryLabelRowLevel3Height {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._summaryLabelRowLevel4Height {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._summaryLabelRowLevel5Height {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._labelRowVisibility1 {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._labelRowVisibility2 {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._labelRowVisibility3 {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._labelRowVisibility4 {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._labelRowVisibility5 {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 25)
      } }()
      if !_storage._summaryRowHeightList.isEmpty {
        try visitor.visitRepeatedDoubleField(value: _storage._summaryRowHeightList, fieldNumber: 26)
      }
      if !_storage._labelRowHeightList.isEmpty {
        try visitor.visitRepeatedDoubleField(value: _storage._labelRowHeightList, fieldNumber: 27)
      }
      if !_storage._labelRowVisibilityList.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._labelRowVisibilityList, fieldNumber: 28)
      }
      try { if let v = _storage._groupSortOrder {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_SummaryModelArchive, rhs: TST_SummaryModelArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tableInfo != rhs_storage._tableInfo {return false}
        if _storage._dataStore != rhs_storage._dataStore {return false}
        if _storage._columnRowUids != rhs_storage._columnRowUids {return false}
        if _storage._aggregateFormulaOwnerUuid != rhs_storage._aggregateFormulaOwnerUuid {return false}
        if _storage._summaryCellVendor != rhs_storage._summaryCellVendor {return false}
        if _storage._categoryColumnWidth != rhs_storage._categoryColumnWidth {return false}
        if _storage._summaryRowLevel1Height != rhs_storage._summaryRowLevel1Height {return false}
        if _storage._summaryRowLevel2Height != rhs_storage._summaryRowLevel2Height {return false}
        if _storage._summaryRowLevel3Height != rhs_storage._summaryRowLevel3Height {return false}
        if _storage._summaryRowLevel4Height != rhs_storage._summaryRowLevel4Height {return false}
        if _storage._summaryRowLevel5Height != rhs_storage._summaryRowLevel5Height {return false}
        if _storage._summaryLabelRowLevel1Height != rhs_storage._summaryLabelRowLevel1Height {return false}
        if _storage._summaryLabelRowLevel2Height != rhs_storage._summaryLabelRowLevel2Height {return false}
        if _storage._summaryLabelRowLevel3Height != rhs_storage._summaryLabelRowLevel3Height {return false}
        if _storage._summaryLabelRowLevel4Height != rhs_storage._summaryLabelRowLevel4Height {return false}
        if _storage._summaryLabelRowLevel5Height != rhs_storage._summaryLabelRowLevel5Height {return false}
        if _storage._labelRowVisibility1 != rhs_storage._labelRowVisibility1 {return false}
        if _storage._labelRowVisibility2 != rhs_storage._labelRowVisibility2 {return false}
        if _storage._labelRowVisibility3 != rhs_storage._labelRowVisibility3 {return false}
        if _storage._labelRowVisibility4 != rhs_storage._labelRowVisibility4 {return false}
        if _storage._labelRowVisibility5 != rhs_storage._labelRowVisibility5 {return false}
        if _storage._summaryRowHeightList != rhs_storage._summaryRowHeightList {return false}
        if _storage._labelRowHeightList != rhs_storage._labelRowHeightList {return false}
        if _storage._labelRowVisibilityList != rhs_storage._labelRowVisibilityList {return false}
        if _storage._groupSortOrder != rhs_storage._groupSortOrder {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_SummaryModelGroupByChangeStateArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SummaryModelGroupByChangeStateArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cell_map\0\u{3}summary_row_height_list\0\u{3}label_row_height_list\0\u{3}label_row_visibility_list\0")

  public var isInitialized: Bool {
    if let v = self._cellMap, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cellMap) }()
      case 2: try { try decoder.decodeRepeatedDoubleField(value: &self.summaryRowHeightList) }()
      case 3: try { try decoder.decodeRepeatedDoubleField(value: &self.labelRowHeightList) }()
      case 4: try { try decoder.decodeRepeatedUInt32Field(value: &self.labelRowVisibilityList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cellMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.summaryRowHeightList.isEmpty {
      try visitor.visitRepeatedDoubleField(value: self.summaryRowHeightList, fieldNumber: 2)
    }
    if !self.labelRowHeightList.isEmpty {
      try visitor.visitRepeatedDoubleField(value: self.labelRowHeightList, fieldNumber: 3)
    }
    if !self.labelRowVisibilityList.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.labelRowVisibilityList, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_SummaryModelGroupByChangeStateArchive, rhs: TST_SummaryModelGroupByChangeStateArchive) -> Bool {
    if lhs._cellMap != rhs._cellMap {return false}
    if lhs.summaryRowHeightList != rhs.summaryRowHeightList {return false}
    if lhs.labelRowHeightList != rhs.labelRowHeightList {return false}
    if lhs.labelRowVisibilityList != rhs.labelRowVisibilityList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ColumnRowUIDMapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ColumnRowUIDMapArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}sorted_column_uids\0\u{3}column_index_for_uid\0\u{3}column_uid_for_index\0\u{3}sorted_row_uids\0\u{3}row_index_for_uid\0\u{3}row_uid_for_index\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.sortedColumnUids) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.sortedRowUids) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sortedColumnUids) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.columnIndexForUid) }()
      case 3: try { try decoder.decodeRepeatedUInt32Field(value: &self.columnUidForIndex) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.sortedRowUids) }()
      case 5: try { try decoder.decodeRepeatedUInt32Field(value: &self.rowIndexForUid) }()
      case 6: try { try decoder.decodeRepeatedUInt32Field(value: &self.rowUidForIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sortedColumnUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sortedColumnUids, fieldNumber: 1)
    }
    if !self.columnIndexForUid.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.columnIndexForUid, fieldNumber: 2)
    }
    if !self.columnUidForIndex.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.columnUidForIndex, fieldNumber: 3)
    }
    if !self.sortedRowUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sortedRowUids, fieldNumber: 4)
    }
    if !self.rowIndexForUid.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.rowIndexForUid, fieldNumber: 5)
    }
    if !self.rowUidForIndex.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.rowUidForIndex, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ColumnRowUIDMapArchive, rhs: TST_ColumnRowUIDMapArchive) -> Bool {
    if lhs.sortedColumnUids != rhs.sortedColumnUids {return false}
    if lhs.columnIndexForUid != rhs.columnIndexForUid {return false}
    if lhs.columnUidForIndex != rhs.columnUidForIndex {return false}
    if lhs.sortedRowUids != rhs.sortedRowUids {return false}
    if lhs.rowIndexForUid != rhs.rowIndexForUid {return false}
    if lhs.rowUidForIndex != rhs.rowUidForIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_StrokeLayerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StrokeLayerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}row_column_index\0\u{3}stroke_runs\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.strokeRuns) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._rowColumnIndex) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.strokeRuns) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rowColumnIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.strokeRuns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.strokeRuns, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_StrokeLayerArchive, rhs: TST_StrokeLayerArchive) -> Bool {
    if lhs._rowColumnIndex != rhs._rowColumnIndex {return false}
    if lhs.strokeRuns != rhs.strokeRuns {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_StrokeLayerArchive.StrokeRunArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_StrokeLayerArchive.protoMessageName + ".StrokeRunArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}origin\0\u{1}length\0\u{1}stroke\0\u{1}order\0")

  public var isInitialized: Bool {
    if let v = self._stroke, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._origin) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._length) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._stroke) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._order) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._origin {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._length {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._stroke {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._order {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_StrokeLayerArchive.StrokeRunArchive, rhs: TST_StrokeLayerArchive.StrokeRunArchive) -> Bool {
    if lhs._origin != rhs._origin {return false}
    if lhs._length != rhs._length {return false}
    if lhs._stroke != rhs._stroke {return false}
    if lhs._order != rhs._order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_StrokeSidecarArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StrokeSidecarArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}max_order\0\u{3}column_count\0\u{3}row_count\0\u{3}left_column_stroke_layers\0\u{3}right_column_stroke_layers\0\u{3}top_row_stroke_layers\0\u{3}bottom_row_stroke_layers\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.leftColumnStrokeLayers) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rightColumnStrokeLayers) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.topRowStrokeLayers) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.bottomRowStrokeLayers) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._maxOrder) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._columnCount) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._rowCount) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.leftColumnStrokeLayers) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.rightColumnStrokeLayers) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.topRowStrokeLayers) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.bottomRowStrokeLayers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._maxOrder {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._columnCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._rowCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    if !self.leftColumnStrokeLayers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.leftColumnStrokeLayers, fieldNumber: 4)
    }
    if !self.rightColumnStrokeLayers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rightColumnStrokeLayers, fieldNumber: 5)
    }
    if !self.topRowStrokeLayers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topRowStrokeLayers, fieldNumber: 6)
    }
    if !self.bottomRowStrokeLayers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bottomRowStrokeLayers, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_StrokeSidecarArchive, rhs: TST_StrokeSidecarArchive) -> Bool {
    if lhs._maxOrder != rhs._maxOrder {return false}
    if lhs._columnCount != rhs._columnCount {return false}
    if lhs._rowCount != rhs._rowCount {return false}
    if lhs.leftColumnStrokeLayers != rhs.leftColumnStrokeLayers {return false}
    if lhs.rightColumnStrokeLayers != rhs.rightColumnStrokeLayers {return false}
    if lhs.topRowStrokeLayers != rhs.topRowStrokeLayers {return false}
    if lhs.bottomRowStrokeLayers != rhs.bottomRowStrokeLayers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_DurationWrapperArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DurationWrapperArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_DurationWrapperArchive, rhs: TST_DurationWrapperArchive) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_Cell: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Cell"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}valueType\0\u{3}cell_style\0\u{3}text_style\0\u{1}numberValue\0\u{1}stringValue\0\u{1}boolValue\0\u{4}\u{2}current_format\0\u{1}formulaError\0\u{3}number_format\0\u{3}currency_format\0\u{3}duration_format\0\u{3}date_format\0\u{4}\u{2}custom_format\0\u{3}base_format\0\u{4}\u{2}explicit_format_flags\0\u{1}richText\0\u{3}conditional_style\0\u{4}\u{2}comment_storage\0\u{3}conditional_style_applied_rule\0\u{3}import_warning_set\0\u{3}custom_format_object\0\u{3}cell_border\0\u{3}cell_spec\0\u{3}cell_format_kind\0\u{3}text_format\0\u{3}boolean_format\0\u{3}decimal_value_low\0\u{3}decimal_value_high\0")

  fileprivate class _StorageClass {
    var _valueType: TST_CellValueType? = nil
    var _cellStyle: TSP_Reference? = nil
    var _textStyle: TSP_Reference? = nil
    var _numberValue: Double? = nil
    var _stringValue: String? = nil
    var _boolValue: Bool? = nil
    var _currentFormat: TSK_FormatStructArchive? = nil
    var _formulaError: TSP_Reference? = nil
    var _numberFormat: TSK_FormatStructArchive? = nil
    var _currencyFormat: TSK_FormatStructArchive? = nil
    var _durationFormat: TSK_FormatStructArchive? = nil
    var _dateFormat: TSK_FormatStructArchive? = nil
    var _customFormat: TSK_FormatStructArchive? = nil
    var _baseFormat: TSK_FormatStructArchive? = nil
    var _explicitFormatFlags: UInt32? = nil
    var _richText: TSP_Reference? = nil
    var _conditionalStyle: TSP_Reference? = nil
    var _commentStorage: TSP_Reference? = nil
    var _conditionalStyleAppliedRule: UInt32? = nil
    var _importWarningSet: TST_ImportWarningSetArchive? = nil
    var _customFormatObject: TSK_CustomFormatArchive? = nil
    var _cellBorder: TST_CellBorderArchive? = nil
    var _cellSpec: TST_CellSpecArchive? = nil
    var _cellFormatKind: UInt32? = nil
    var _textFormat: TSK_FormatStructArchive? = nil
    var _booleanFormat: TSK_FormatStructArchive? = nil
    var _decimalValueLow: UInt64? = nil
    var _decimalValueHigh: UInt64? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _valueType = source._valueType
      _cellStyle = source._cellStyle
      _textStyle = source._textStyle
      _numberValue = source._numberValue
      _stringValue = source._stringValue
      _boolValue = source._boolValue
      _currentFormat = source._currentFormat
      _formulaError = source._formulaError
      _numberFormat = source._numberFormat
      _currencyFormat = source._currencyFormat
      _durationFormat = source._durationFormat
      _dateFormat = source._dateFormat
      _customFormat = source._customFormat
      _baseFormat = source._baseFormat
      _explicitFormatFlags = source._explicitFormatFlags
      _richText = source._richText
      _conditionalStyle = source._conditionalStyle
      _commentStorage = source._commentStorage
      _conditionalStyleAppliedRule = source._conditionalStyleAppliedRule
      _importWarningSet = source._importWarningSet
      _customFormatObject = source._customFormatObject
      _cellBorder = source._cellBorder
      _cellSpec = source._cellSpec
      _cellFormatKind = source._cellFormatKind
      _textFormat = source._textFormat
      _booleanFormat = source._booleanFormat
      _decimalValueLow = source._decimalValueLow
      _decimalValueHigh = source._decimalValueHigh
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._valueType == nil {return false}
      if let v = _storage._cellStyle, !v.isInitialized {return false}
      if let v = _storage._textStyle, !v.isInitialized {return false}
      if let v = _storage._currentFormat, !v.isInitialized {return false}
      if let v = _storage._formulaError, !v.isInitialized {return false}
      if let v = _storage._numberFormat, !v.isInitialized {return false}
      if let v = _storage._currencyFormat, !v.isInitialized {return false}
      if let v = _storage._durationFormat, !v.isInitialized {return false}
      if let v = _storage._dateFormat, !v.isInitialized {return false}
      if let v = _storage._customFormat, !v.isInitialized {return false}
      if let v = _storage._baseFormat, !v.isInitialized {return false}
      if let v = _storage._richText, !v.isInitialized {return false}
      if let v = _storage._conditionalStyle, !v.isInitialized {return false}
      if let v = _storage._commentStorage, !v.isInitialized {return false}
      if let v = _storage._importWarningSet, !v.isInitialized {return false}
      if let v = _storage._customFormatObject, !v.isInitialized {return false}
      if let v = _storage._cellBorder, !v.isInitialized {return false}
      if let v = _storage._cellSpec, !v.isInitialized {return false}
      if let v = _storage._textFormat, !v.isInitialized {return false}
      if let v = _storage._booleanFormat, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._valueType) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._cellStyle) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._textStyle) }()
        case 5: try { try decoder.decodeSingularDoubleField(value: &_storage._numberValue) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._stringValue) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._boolValue) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._currentFormat) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._formulaError) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._numberFormat) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._currencyFormat) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._durationFormat) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._dateFormat) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._customFormat) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._baseFormat) }()
        case 19: try { try decoder.decodeSingularUInt32Field(value: &_storage._explicitFormatFlags) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._richText) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._conditionalStyle) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._commentStorage) }()
        case 24: try { try decoder.decodeSingularUInt32Field(value: &_storage._conditionalStyleAppliedRule) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._importWarningSet) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._customFormatObject) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._cellBorder) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._cellSpec) }()
        case 29: try { try decoder.decodeSingularUInt32Field(value: &_storage._cellFormatKind) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._textFormat) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._booleanFormat) }()
        case 32: try { try decoder.decodeSingularUInt64Field(value: &_storage._decimalValueLow) }()
        case 33: try { try decoder.decodeSingularUInt64Field(value: &_storage._decimalValueHigh) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._valueType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._cellStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._textStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._numberValue {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._stringValue {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._boolValue {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._currentFormat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._formulaError {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._numberFormat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._currencyFormat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._durationFormat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._dateFormat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._customFormat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._baseFormat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._explicitFormatFlags {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._richText {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._conditionalStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._commentStorage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._conditionalStyleAppliedRule {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._importWarningSet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._customFormatObject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._cellBorder {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      } }()
      try { if let v = _storage._cellSpec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._cellFormatKind {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._textFormat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._booleanFormat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._decimalValueLow {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._decimalValueHigh {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 33)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_Cell, rhs: TST_Cell) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._valueType != rhs_storage._valueType {return false}
        if _storage._cellStyle != rhs_storage._cellStyle {return false}
        if _storage._textStyle != rhs_storage._textStyle {return false}
        if _storage._numberValue != rhs_storage._numberValue {return false}
        if _storage._stringValue != rhs_storage._stringValue {return false}
        if _storage._boolValue != rhs_storage._boolValue {return false}
        if _storage._currentFormat != rhs_storage._currentFormat {return false}
        if _storage._formulaError != rhs_storage._formulaError {return false}
        if _storage._numberFormat != rhs_storage._numberFormat {return false}
        if _storage._currencyFormat != rhs_storage._currencyFormat {return false}
        if _storage._durationFormat != rhs_storage._durationFormat {return false}
        if _storage._dateFormat != rhs_storage._dateFormat {return false}
        if _storage._customFormat != rhs_storage._customFormat {return false}
        if _storage._baseFormat != rhs_storage._baseFormat {return false}
        if _storage._explicitFormatFlags != rhs_storage._explicitFormatFlags {return false}
        if _storage._richText != rhs_storage._richText {return false}
        if _storage._conditionalStyle != rhs_storage._conditionalStyle {return false}
        if _storage._commentStorage != rhs_storage._commentStorage {return false}
        if _storage._conditionalStyleAppliedRule != rhs_storage._conditionalStyleAppliedRule {return false}
        if _storage._importWarningSet != rhs_storage._importWarningSet {return false}
        if _storage._customFormatObject != rhs_storage._customFormatObject {return false}
        if _storage._cellBorder != rhs_storage._cellBorder {return false}
        if _storage._cellSpec != rhs_storage._cellSpec {return false}
        if _storage._cellFormatKind != rhs_storage._cellFormatKind {return false}
        if _storage._textFormat != rhs_storage._textFormat {return false}
        if _storage._booleanFormat != rhs_storage._booleanFormat {return false}
        if _storage._decimalValueLow != rhs_storage._decimalValueLow {return false}
        if _storage._decimalValueHigh != rhs_storage._decimalValueHigh {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_MergeRegionMapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MergeRegionMapArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cell_range\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.cellRange) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cellRange) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cellRange.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cellRange, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_MergeRegionMapArchive, rhs: TST_MergeRegionMapArchive) -> Bool {
    if lhs.cellRange != rhs.cellRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CellMapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellMapArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{2}cell_tiles\0\u{3}uid_based\0\u{4}\u{2}cell_uid_list\0\u{4}\u{2}merge_uid_ranges\0\u{4}\u{2}unmerge_uid_ranges\0\u{3}may_modify_formulas_in_cells\0\u{3}may_modify_values_referenced_by_formulas\0\u{3}should_reset_spill_formulas\0\u{3}merge_actions\0\u{3}expanded_cell_ids\0")

  fileprivate class _StorageClass {
    var _cellTiles: [TSP_Reference] = []
    var _uidBased: Bool? = nil
    var _expandedCellIds: [TSCE_CellCoordinateArchive] = []
    var _cellUidList: TST_CellUIDListArchive? = nil
    var _mergeUidRanges: [TSP_UUIDRectArchive] = []
    var _unmergeUidRanges: [TSP_UUIDRectArchive] = []
    var _mergeActions: [TST_MergeOperationArchive] = []
    var _mayModifyFormulasInCells: Bool? = nil
    var _mayModifyValuesReferencedByFormulas: Bool? = nil
    var _shouldResetSpillFormulas: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _cellTiles = source._cellTiles
      _uidBased = source._uidBased
      _expandedCellIds = source._expandedCellIds
      _cellUidList = source._cellUidList
      _mergeUidRanges = source._mergeUidRanges
      _unmergeUidRanges = source._unmergeUidRanges
      _mergeActions = source._mergeActions
      _mayModifyFormulasInCells = source._mayModifyFormulasInCells
      _mayModifyValuesReferencedByFormulas = source._mayModifyValuesReferencedByFormulas
      _shouldResetSpillFormulas = source._shouldResetSpillFormulas
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._uidBased == nil {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._cellTiles) {return false}
      if let v = _storage._cellUidList, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._mergeUidRanges) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._unmergeUidRanges) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._mergeActions) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._cellTiles) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._uidBased) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._cellUidList) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._mergeUidRanges) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._unmergeUidRanges) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._mayModifyFormulasInCells) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._mayModifyValuesReferencedByFormulas) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._shouldResetSpillFormulas) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._mergeActions) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._expandedCellIds) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._cellTiles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._cellTiles, fieldNumber: 2)
      }
      try { if let v = _storage._uidBased {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._cellUidList {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._mergeUidRanges.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._mergeUidRanges, fieldNumber: 7)
      }
      if !_storage._unmergeUidRanges.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._unmergeUidRanges, fieldNumber: 9)
      }
      try { if let v = _storage._mayModifyFormulasInCells {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._mayModifyValuesReferencedByFormulas {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._shouldResetSpillFormulas {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      } }()
      if !_storage._mergeActions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._mergeActions, fieldNumber: 13)
      }
      if !_storage._expandedCellIds.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._expandedCellIds, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CellMapArchive, rhs: TST_CellMapArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._cellTiles != rhs_storage._cellTiles {return false}
        if _storage._uidBased != rhs_storage._uidBased {return false}
        if _storage._expandedCellIds != rhs_storage._expandedCellIds {return false}
        if _storage._cellUidList != rhs_storage._cellUidList {return false}
        if _storage._mergeUidRanges != rhs_storage._mergeUidRanges {return false}
        if _storage._unmergeUidRanges != rhs_storage._unmergeUidRanges {return false}
        if _storage._mergeActions != rhs_storage._mergeActions {return false}
        if _storage._mayModifyFormulasInCells != rhs_storage._mayModifyFormulasInCells {return false}
        if _storage._mayModifyValuesReferencedByFormulas != rhs_storage._mayModifyValuesReferencedByFormulas {return false}
        if _storage._shouldResetSpillFormulas != rhs_storage._shouldResetSpillFormulas {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CellListArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellListArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}cells\0\u{3}trailing_empty_cell_count\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.cells) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cells) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._trailingEmptyCellCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cells.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cells, fieldNumber: 1)
    }
    try { if let v = self._trailingEmptyCellCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CellListArchive, rhs: TST_CellListArchive) -> Bool {
    if lhs.cells != rhs.cells {return false}
    if lhs._trailingEmptyCellCount != rhs._trailingEmptyCellCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CellListArchive.OptionalCell: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_CellListArchive.protoMessageName + ".OptionalCell"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}cell\0")

  public var isInitialized: Bool {
    if let v = self._cell, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cell) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cell {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CellListArchive.OptionalCell, rhs: TST_CellListArchive.OptionalCell) -> Bool {
    if lhs._cell != rhs._cell {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ConcurrentCellMapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConcurrentCellMapArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cell_lists\0\u{3}uid_based\0\u{3}merge_actions\0\u{3}may_modify_formulas_in_cells\0\u{3}may_modify_values_referenced_by_formulas\0\u{3}affects_cell_borders\0\u{3}skip_dirtying_ranges\0\u{3}should_reset_spill_formulas\0")

  public var isInitialized: Bool {
    if self._uidBased == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.cellLists) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.mergeActions) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cellLists) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._uidBased) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mergeActions) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._mayModifyFormulasInCells) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._mayModifyValuesReferencedByFormulas) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._affectsCellBorders) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._skipDirtyingRanges) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._shouldResetSpillFormulas) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cellLists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cellLists, fieldNumber: 1)
    }
    try { if let v = self._uidBased {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    if !self.mergeActions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mergeActions, fieldNumber: 3)
    }
    try { if let v = self._mayModifyFormulasInCells {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._mayModifyValuesReferencedByFormulas {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._affectsCellBorders {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._skipDirtyingRanges {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._shouldResetSpillFormulas {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ConcurrentCellMapArchive, rhs: TST_ConcurrentCellMapArchive) -> Bool {
    if lhs.cellLists != rhs.cellLists {return false}
    if lhs._uidBased != rhs._uidBased {return false}
    if lhs.mergeActions != rhs.mergeActions {return false}
    if lhs._mayModifyFormulasInCells != rhs._mayModifyFormulasInCells {return false}
    if lhs._mayModifyValuesReferencedByFormulas != rhs._mayModifyValuesReferencedByFormulas {return false}
    if lhs._affectsCellBorders != rhs._affectsCellBorders {return false}
    if lhs._skipDirtyingRanges != rhs._skipDirtyingRanges {return false}
    if lhs._shouldResetSpillFormulas != rhs._shouldResetSpillFormulas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ConcurrentCellListArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConcurrentCellListArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}cells\0\u{3}cell_uid_range\0\u{3}cell_range\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.cells) {return false}
    if let v = self._cellUidRange, !v.isInitialized {return false}
    if let v = self._cellRange, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cells) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cellUidRange) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cellRange) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cells.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cells, fieldNumber: 1)
    }
    try { if let v = self._cellUidRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cellRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ConcurrentCellListArchive, rhs: TST_ConcurrentCellListArchive) -> Bool {
    if lhs.cells != rhs.cells {return false}
    if lhs._cellUidRange != rhs._cellUidRange {return false}
    if lhs._cellRange != rhs._cellRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ConcurrentCellListArchive.OptionalCell: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_ConcurrentCellListArchive.protoMessageName + ".OptionalCell"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}cell\0")

  public var isInitialized: Bool {
    if let v = self._cell, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cell) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cell {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ConcurrentCellListArchive.OptionalCell, rhs: TST_ConcurrentCellListArchive.OptionalCell) -> Bool {
    if lhs._cell != rhs._cell {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CellFormatAndValueArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellFormatAndValueArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}valueType\0\u{1}numberValue\0\u{1}stringValue\0\u{1}boolValue\0\u{1}richTextStorage\0\u{3}use_all_spare_formats\0\u{3}explicit_flags\0\u{3}cell_format_kind\0\u{4}\u{2}number_format\0\u{3}currency_format\0\u{3}date_format\0\u{3}duration_format\0\u{3}text_format\0\u{3}boolean_format\0\u{3}formatted_value\0\u{3}formatted_rich_text_value\0\u{3}apply_spare_format_only\0\u{3}spare_format_type\0\u{3}decimal_low\0\u{3}decimal_high\0\u{3}suppress_apply_value\0")

  fileprivate class _StorageClass {
    var _valueType: TST_CellValueType? = nil
    var _numberValue: Double? = nil
    var _stringValue: String? = nil
    var _boolValue: Bool? = nil
    var _richTextStorage: TSP_Reference? = nil
    var _useAllSpareFormats: Bool? = nil
    var _explicitFlags: UInt32? = nil
    var _cellFormatKind: UInt32? = nil
    var _numberFormat: TSK_FormatStructArchive? = nil
    var _currencyFormat: TSK_FormatStructArchive? = nil
    var _dateFormat: TSK_FormatStructArchive? = nil
    var _durationFormat: TSK_FormatStructArchive? = nil
    var _textFormat: TSK_FormatStructArchive? = nil
    var _booleanFormat: TSK_FormatStructArchive? = nil
    var _formattedValue: String? = nil
    var _formattedRichTextValue: TSP_Reference? = nil
    var _applySpareFormatOnly: Bool? = nil
    var _spareFormatType: Bool? = nil
    var _decimalLow: UInt64? = nil
    var _decimalHigh: UInt64? = nil
    var _suppressApplyValue: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _valueType = source._valueType
      _numberValue = source._numberValue
      _stringValue = source._stringValue
      _boolValue = source._boolValue
      _richTextStorage = source._richTextStorage
      _useAllSpareFormats = source._useAllSpareFormats
      _explicitFlags = source._explicitFlags
      _cellFormatKind = source._cellFormatKind
      _numberFormat = source._numberFormat
      _currencyFormat = source._currencyFormat
      _dateFormat = source._dateFormat
      _durationFormat = source._durationFormat
      _textFormat = source._textFormat
      _booleanFormat = source._booleanFormat
      _formattedValue = source._formattedValue
      _formattedRichTextValue = source._formattedRichTextValue
      _applySpareFormatOnly = source._applySpareFormatOnly
      _spareFormatType = source._spareFormatType
      _decimalLow = source._decimalLow
      _decimalHigh = source._decimalHigh
      _suppressApplyValue = source._suppressApplyValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._valueType == nil {return false}
      if _storage._useAllSpareFormats == nil {return false}
      if _storage._explicitFlags == nil {return false}
      if _storage._cellFormatKind == nil {return false}
      if _storage._applySpareFormatOnly == nil {return false}
      if _storage._spareFormatType == nil {return false}
      if let v = _storage._richTextStorage, !v.isInitialized {return false}
      if let v = _storage._numberFormat, !v.isInitialized {return false}
      if let v = _storage._currencyFormat, !v.isInitialized {return false}
      if let v = _storage._dateFormat, !v.isInitialized {return false}
      if let v = _storage._durationFormat, !v.isInitialized {return false}
      if let v = _storage._textFormat, !v.isInitialized {return false}
      if let v = _storage._booleanFormat, !v.isInitialized {return false}
      if let v = _storage._formattedRichTextValue, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._valueType) }()
        case 2: try { try decoder.decodeSingularDoubleField(value: &_storage._numberValue) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._stringValue) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._boolValue) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._richTextStorage) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._useAllSpareFormats) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._explicitFlags) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._cellFormatKind) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._numberFormat) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._currencyFormat) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._dateFormat) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._durationFormat) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._textFormat) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._booleanFormat) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._formattedValue) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._formattedRichTextValue) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._applySpareFormatOnly) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._spareFormatType) }()
        case 20: try { try decoder.decodeSingularUInt64Field(value: &_storage._decimalLow) }()
        case 21: try { try decoder.decodeSingularUInt64Field(value: &_storage._decimalHigh) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._suppressApplyValue) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._valueType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._numberValue {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._stringValue {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._boolValue {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._richTextStorage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._useAllSpareFormats {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._explicitFlags {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._cellFormatKind {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._numberFormat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._currencyFormat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._dateFormat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._durationFormat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._textFormat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._booleanFormat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._formattedValue {
        try visitor.visitSingularStringField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._formattedRichTextValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._applySpareFormatOnly {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._spareFormatType {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._decimalLow {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._decimalHigh {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._suppressApplyValue {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 22)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CellFormatAndValueArchive, rhs: TST_CellFormatAndValueArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._valueType != rhs_storage._valueType {return false}
        if _storage._numberValue != rhs_storage._numberValue {return false}
        if _storage._stringValue != rhs_storage._stringValue {return false}
        if _storage._boolValue != rhs_storage._boolValue {return false}
        if _storage._richTextStorage != rhs_storage._richTextStorage {return false}
        if _storage._useAllSpareFormats != rhs_storage._useAllSpareFormats {return false}
        if _storage._explicitFlags != rhs_storage._explicitFlags {return false}
        if _storage._cellFormatKind != rhs_storage._cellFormatKind {return false}
        if _storage._numberFormat != rhs_storage._numberFormat {return false}
        if _storage._currencyFormat != rhs_storage._currencyFormat {return false}
        if _storage._dateFormat != rhs_storage._dateFormat {return false}
        if _storage._durationFormat != rhs_storage._durationFormat {return false}
        if _storage._textFormat != rhs_storage._textFormat {return false}
        if _storage._booleanFormat != rhs_storage._booleanFormat {return false}
        if _storage._formattedValue != rhs_storage._formattedValue {return false}
        if _storage._formattedRichTextValue != rhs_storage._formattedRichTextValue {return false}
        if _storage._applySpareFormatOnly != rhs_storage._applySpareFormatOnly {return false}
        if _storage._spareFormatType != rhs_storage._spareFormatType {return false}
        if _storage._decimalLow != rhs_storage._decimalLow {return false}
        if _storage._decimalHigh != rhs_storage._decimalHigh {return false}
        if _storage._suppressApplyValue != rhs_storage._suppressApplyValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CellSpecArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellSpecArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}interaction_type\0\u{1}formula\0\u{3}range_control_min\0\u{3}range_control_max\0\u{3}range_control_inc\0\u{3}chooser_control_popup_model\0\u{3}chooser_control_start_w_first\0\u{3}category_summary_should_display_label\0")

  fileprivate class _StorageClass {
    var _interactionType: UInt32? = nil
    var _formula: TSCE_FormulaArchive? = nil
    var _rangeControlMin: Double? = nil
    var _rangeControlMax: Double? = nil
    var _rangeControlInc: Double? = nil
    var _chooserControlPopupModel: TSP_Reference? = nil
    var _chooserControlStartWFirst: Bool? = nil
    var _categorySummaryShouldDisplayLabel: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _interactionType = source._interactionType
      _formula = source._formula
      _rangeControlMin = source._rangeControlMin
      _rangeControlMax = source._rangeControlMax
      _rangeControlInc = source._rangeControlInc
      _chooserControlPopupModel = source._chooserControlPopupModel
      _chooserControlStartWFirst = source._chooserControlStartWFirst
      _categorySummaryShouldDisplayLabel = source._categorySummaryShouldDisplayLabel
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._interactionType == nil {return false}
      if let v = _storage._formula, !v.isInitialized {return false}
      if let v = _storage._chooserControlPopupModel, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._interactionType) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._formula) }()
        case 3: try { try decoder.decodeSingularDoubleField(value: &_storage._rangeControlMin) }()
        case 4: try { try decoder.decodeSingularDoubleField(value: &_storage._rangeControlMax) }()
        case 5: try { try decoder.decodeSingularDoubleField(value: &_storage._rangeControlInc) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._chooserControlPopupModel) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._chooserControlStartWFirst) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._categorySummaryShouldDisplayLabel) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._interactionType {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._formula {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._rangeControlMin {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._rangeControlMax {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._rangeControlInc {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._chooserControlPopupModel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._chooserControlStartWFirst {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._categorySummaryShouldDisplayLabel {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CellSpecArchive, rhs: TST_CellSpecArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._interactionType != rhs_storage._interactionType {return false}
        if _storage._formula != rhs_storage._formula {return false}
        if _storage._rangeControlMin != rhs_storage._rangeControlMin {return false}
        if _storage._rangeControlMax != rhs_storage._rangeControlMax {return false}
        if _storage._rangeControlInc != rhs_storage._rangeControlInc {return false}
        if _storage._chooserControlPopupModel != rhs_storage._chooserControlPopupModel {return false}
        if _storage._chooserControlStartWFirst != rhs_storage._chooserControlStartWFirst {return false}
        if _storage._categorySummaryShouldDisplayLabel != rhs_storage._categorySummaryShouldDisplayLabel {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommentStorageWrapperArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommentStorageWrapperArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}comment_storage\0")

  public var isInitialized: Bool {
    if let v = self._commentStorage, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commentStorage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commentStorage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommentStorageWrapperArchive, rhs: TST_CommentStorageWrapperArchive) -> Bool {
    if lhs._commentStorage != rhs._commentStorage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CellDiffArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellDiffArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}property_map_to_set\0\u{3}property_map_to_reset\0")

  public var isInitialized: Bool {
    if self._propertyMapToSet == nil {return false}
    if self._propertyMapToReset == nil {return false}
    if let v = self._propertyMapToSet, !v.isInitialized {return false}
    if let v = self._propertyMapToReset, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._propertyMapToSet) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._propertyMapToReset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._propertyMapToSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._propertyMapToReset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CellDiffArchive, rhs: TST_CellDiffArchive) -> Bool {
    if lhs._propertyMapToSet != rhs._propertyMapToSet {return false}
    if lhs._propertyMapToReset != rhs._propertyMapToReset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CellDiffArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellDiffArray"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}large_array\0")

  public var isInitialized: Bool {
    if let v = self._largeArray, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._largeArray) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._largeArray {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CellDiffArray, rhs: TST_CellDiffArray) -> Bool {
    if lhs._largeArray != rhs._largeArray {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CellDiffArraySegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellDiffArraySegment"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}large_array_segment\0\u{1}elements\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.elements) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._largeArraySegment) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._largeArraySegment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CellDiffArraySegment, rhs: TST_CellDiffArraySegment) -> Bool {
    if lhs._largeArraySegment != rhs._largeArraySegment {return false}
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CellDiffMapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellDiffMapArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}uid_based\0\u{3}expanded_cell_ids\0\u{3}cell_uids\0\u{3}cell_diff_array\0")

  public var isInitialized: Bool {
    if self._uidBased == nil {return false}
    if self._cellUids == nil {return false}
    if let v = self._cellUids, !v.isInitialized {return false}
    if let v = self._cellDiffArray, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._uidBased) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.expandedCellIds) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cellUids) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._cellDiffArray) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uidBased {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    if !self.expandedCellIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.expandedCellIds, fieldNumber: 2)
    }
    try { if let v = self._cellUids {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._cellDiffArray {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CellDiffMapArchive, rhs: TST_CellDiffMapArchive) -> Bool {
    if lhs._uidBased != rhs._uidBased {return false}
    if lhs.expandedCellIds != rhs.expandedCellIds {return false}
    if lhs._cellUids != rhs._cellUids {return false}
    if lhs._cellDiffArray != rhs._cellDiffArray {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_HierarchicalCellDiffMapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HierarchicalCellDiffMapArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}num_row_rules\0\u{3}num_column_rules\0\u{3}row_header_uids\0\u{3}column_header_uids\0\u{3}aggregate_rule_uids\0\u{3}active_flattening_dimension\0\u{3}row_value_uids\0\u{3}row_level_preorder\0\u{3}column_value_uids\0\u{3}column_level_preorder\0\u{3}cell_diff_storage\0\u{3}row_sizes\0\u{3}column_sizes\0")

  public var isInitialized: Bool {
    if self._numRowRules == nil {return false}
    if self._numColumnRules == nil {return false}
    if self._activeFlatteningDimension == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rowHeaderUids) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.columnHeaderUids) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.aggregateRuleUids) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rowValueUids) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.columnValueUids) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.cellDiffStorage) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._numRowRules) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._numColumnRules) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.rowHeaderUids) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.columnHeaderUids) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.aggregateRuleUids) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._activeFlatteningDimension) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.rowValueUids) }()
      case 8: try { try decoder.decodeRepeatedUInt32Field(value: &self.rowLevelPreorder) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.columnValueUids) }()
      case 10: try { try decoder.decodeRepeatedUInt32Field(value: &self.columnLevelPreorder) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.cellDiffStorage) }()
      case 12: try { try decoder.decodeRepeatedDoubleField(value: &self.rowSizes) }()
      case 13: try { try decoder.decodeRepeatedDoubleField(value: &self.columnSizes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._numRowRules {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._numColumnRules {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    if !self.rowHeaderUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rowHeaderUids, fieldNumber: 3)
    }
    if !self.columnHeaderUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.columnHeaderUids, fieldNumber: 4)
    }
    if !self.aggregateRuleUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aggregateRuleUids, fieldNumber: 5)
    }
    try { if let v = self._activeFlatteningDimension {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    if !self.rowValueUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rowValueUids, fieldNumber: 7)
    }
    if !self.rowLevelPreorder.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.rowLevelPreorder, fieldNumber: 8)
    }
    if !self.columnValueUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.columnValueUids, fieldNumber: 9)
    }
    if !self.columnLevelPreorder.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.columnLevelPreorder, fieldNumber: 10)
    }
    if !self.cellDiffStorage.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cellDiffStorage, fieldNumber: 11)
    }
    if !self.rowSizes.isEmpty {
      try visitor.visitRepeatedDoubleField(value: self.rowSizes, fieldNumber: 12)
    }
    if !self.columnSizes.isEmpty {
      try visitor.visitRepeatedDoubleField(value: self.columnSizes, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_HierarchicalCellDiffMapArchive, rhs: TST_HierarchicalCellDiffMapArchive) -> Bool {
    if lhs._numRowRules != rhs._numRowRules {return false}
    if lhs._numColumnRules != rhs._numColumnRules {return false}
    if lhs.rowHeaderUids != rhs.rowHeaderUids {return false}
    if lhs.columnHeaderUids != rhs.columnHeaderUids {return false}
    if lhs.aggregateRuleUids != rhs.aggregateRuleUids {return false}
    if lhs._activeFlatteningDimension != rhs._activeFlatteningDimension {return false}
    if lhs.rowValueUids != rhs.rowValueUids {return false}
    if lhs.rowLevelPreorder != rhs.rowLevelPreorder {return false}
    if lhs.columnValueUids != rhs.columnValueUids {return false}
    if lhs.columnLevelPreorder != rhs.columnLevelPreorder {return false}
    if lhs.cellDiffStorage != rhs.cellDiffStorage {return false}
    if lhs.rowSizes != rhs.rowSizes {return false}
    if lhs.columnSizes != rhs.columnSizes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_HierarchicalCellDiffMapArchive.BoxedRow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_HierarchicalCellDiffMapArchive.protoMessageName + ".BoxedRow"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}column_index_set\0\u{3}cell_diff_list\0")

  public var isInitialized: Bool {
    if self._columnIndexSet == nil {return false}
    if let v = self._columnIndexSet, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.cellDiffList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._columnIndexSet) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.cellDiffList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._columnIndexSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.cellDiffList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cellDiffList, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_HierarchicalCellDiffMapArchive.BoxedRow, rhs: TST_HierarchicalCellDiffMapArchive.BoxedRow) -> Bool {
    if lhs._columnIndexSet != rhs._columnIndexSet {return false}
    if lhs.cellDiffList != rhs.cellDiffList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_DoubleStyleMapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DoubleStyleMapArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}capacity\0\u{1}count\0\u{3}cell_map_entry\0")

  public var isInitialized: Bool {
    if self._capacity == nil {return false}
    if self._count == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.cellMapEntry) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._capacity) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._count) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.cellMapEntry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._capacity {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._count {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    if !self.cellMapEntry.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cellMapEntry, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_DoubleStyleMapArchive, rhs: TST_DoubleStyleMapArchive) -> Bool {
    if lhs._capacity != rhs._capacity {return false}
    if lhs._count != rhs._count {return false}
    if lhs.cellMapEntry != rhs.cellMapEntry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_DoubleStyleMapArchive.DoubleStyleMapEntryArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_DoubleStyleMapArchive.protoMessageName + ".DoubleStyleMapEntryArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cell_id\0\u{3}old_style\0\u{3}new_style\0")

  public var isInitialized: Bool {
    if self._cellID == nil {return false}
    if self._oldStyle == nil {return false}
    if self._newStyle == nil {return false}
    if let v = self._cellID, !v.isInitialized {return false}
    if let v = self._oldStyle, !v.isInitialized {return false}
    if let v = self._newStyle, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cellID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._oldStyle) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newStyle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cellID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oldStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_DoubleStyleMapArchive.DoubleStyleMapEntryArchive, rhs: TST_DoubleStyleMapArchive.DoubleStyleMapEntryArchive) -> Bool {
    if lhs._cellID != rhs._cellID {return false}
    if lhs._oldStyle != rhs._oldStyle {return false}
    if lhs._newStyle != rhs._newStyle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_StyleTableMapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StyleTableMapArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}capacity\0\u{1}count\0\u{3}map_entry\0")

  public var isInitialized: Bool {
    if self._capacity == nil {return false}
    if self._count == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.mapEntry) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._capacity) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._count) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mapEntry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._capacity {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._count {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    if !self.mapEntry.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mapEntry, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_StyleTableMapArchive, rhs: TST_StyleTableMapArchive) -> Bool {
    if lhs._capacity != rhs._capacity {return false}
    if lhs._count != rhs._count {return false}
    if lhs.mapEntry != rhs.mapEntry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_StyleTableMapArchive.StyleTableMapEntryArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_StyleTableMapArchive.protoMessageName + ".StyleTableMapEntryArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{3}old_style\0\u{3}new_style\0")

  public var isInitialized: Bool {
    if self._key == nil {return false}
    if self._oldStyle == nil {return false}
    if self._newStyle == nil {return false}
    if let v = self._oldStyle, !v.isInitialized {return false}
    if let v = self._newStyle, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._oldStyle) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newStyle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oldStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_StyleTableMapArchive.StyleTableMapEntryArchive, rhs: TST_StyleTableMapArchive.StyleTableMapEntryArchive) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._oldStyle != rhs._oldStyle {return false}
    if lhs._newStyle != rhs._newStyle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_SelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}tableModel\0\u{4}\u{3}selection_type\0\u{3}anchor_cell\0\u{3}cell_ranges\0\u{3}base_ranges\0\u{3}cursor_cell\0\u{3}table_info\0\u{3}cell_uid_region\0\u{3}base_uid_region\0\u{3}anchor_cell_uid\0\u{3}cursor_cell_uid\0")

  fileprivate class _StorageClass {
    var _tableModel: TSP_Reference? = nil
    var _selectionType: TST_SelectionTypeArchive? = nil
    var _anchorCell: TST_CellID? = nil
    var _cellRanges: [TST_CellRange] = []
    var _baseRanges: [TST_CellRange] = []
    var _cursorCell: TST_CellID? = nil
    var _tableInfo: TSP_Reference? = nil
    var _cellUidRegion: TST_CellUIDRegionArchive? = nil
    var _baseUidRegion: TST_CellUIDRegionArchive? = nil
    var _anchorCellUid: TSP_UUIDCoordArchive? = nil
    var _cursorCellUid: TSP_UUIDCoordArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tableModel = source._tableModel
      _selectionType = source._selectionType
      _anchorCell = source._anchorCell
      _cellRanges = source._cellRanges
      _baseRanges = source._baseRanges
      _cursorCell = source._cursorCell
      _tableInfo = source._tableInfo
      _cellUidRegion = source._cellUidRegion
      _baseUidRegion = source._baseUidRegion
      _anchorCellUid = source._anchorCellUid
      _cursorCellUid = source._cursorCellUid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._selectionType == nil {return false}
      if let v = _storage._tableModel, !v.isInitialized {return false}
      if let v = _storage._anchorCell, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._cellRanges) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._baseRanges) {return false}
      if let v = _storage._cursorCell, !v.isInitialized {return false}
      if let v = _storage._tableInfo, !v.isInitialized {return false}
      if let v = _storage._cellUidRegion, !v.isInitialized {return false}
      if let v = _storage._baseUidRegion, !v.isInitialized {return false}
      if let v = _storage._anchorCellUid, !v.isInitialized {return false}
      if let v = _storage._cursorCellUid, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._tableModel) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._selectionType) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._anchorCell) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._cellRanges) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._baseRanges) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._cursorCell) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._tableInfo) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._cellUidRegion) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._baseUidRegion) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._anchorCellUid) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._cursorCellUid) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._tableModel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._selectionType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._anchorCell {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._cellRanges.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._cellRanges, fieldNumber: 6)
      }
      if !_storage._baseRanges.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._baseRanges, fieldNumber: 7)
      }
      try { if let v = _storage._cursorCell {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._tableInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._cellUidRegion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._baseUidRegion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._anchorCellUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._cursorCellUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_SelectionArchive, rhs: TST_SelectionArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tableModel != rhs_storage._tableModel {return false}
        if _storage._selectionType != rhs_storage._selectionType {return false}
        if _storage._anchorCell != rhs_storage._anchorCell {return false}
        if _storage._cellRanges != rhs_storage._cellRanges {return false}
        if _storage._baseRanges != rhs_storage._baseRanges {return false}
        if _storage._cursorCell != rhs_storage._cursorCell {return false}
        if _storage._tableInfo != rhs_storage._tableInfo {return false}
        if _storage._cellUidRegion != rhs_storage._cellUidRegion {return false}
        if _storage._baseUidRegion != rhs_storage._baseUidRegion {return false}
        if _storage._anchorCellUid != rhs_storage._anchorCellUid {return false}
        if _storage._cursorCellUid != rhs_storage._cursorCellUid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_DeathhawkRdar39989167CellSelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeathhawkRdar39989167CellSelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}table_info\0\u{3}selection_type\0\u{3}cell_uid_region\0\u{3}base_uid_region\0\u{3}anchor_cell_uid\0\u{3}cursor_cell_uid\0")

  public var isInitialized: Bool {
    if let v = self._tableInfo, !v.isInitialized {return false}
    if let v = self._cellUidRegion, !v.isInitialized {return false}
    if let v = self._baseUidRegion, !v.isInitialized {return false}
    if let v = self._anchorCellUid, !v.isInitialized {return false}
    if let v = self._cursorCellUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tableInfo) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._selectionType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cellUidRegion) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._baseUidRegion) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._anchorCellUid) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._cursorCellUid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tableInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._selectionType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cellUidRegion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._baseUidRegion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._anchorCellUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._cursorCellUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_DeathhawkRdar39989167CellSelectionArchive, rhs: TST_DeathhawkRdar39989167CellSelectionArchive) -> Bool {
    if lhs._tableInfo != rhs._tableInfo {return false}
    if lhs._selectionType != rhs._selectionType {return false}
    if lhs._cellUidRegion != rhs._cellUidRegion {return false}
    if lhs._baseUidRegion != rhs._baseUidRegion {return false}
    if lhs._anchorCellUid != rhs._anchorCellUid {return false}
    if lhs._cursorCellUid != rhs._cursorCellUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_StrokeSelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StrokeSelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}mask\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._mask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mask {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_StrokeSelectionArchive, rhs: TST_StrokeSelectionArchive) -> Bool {
    if lhs._mask != rhs._mask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ControlCellSelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ControlCellSelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ControlCellSelectionArchive, rhs: TST_ControlCellSelectionArchive) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_StockCellSelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StockCellSelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_StockCellSelectionArchive, rhs: TST_StockCellSelectionArchive) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableNameSelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TableNameSelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableNameSelectionArchive, rhs: TST_TableNameSelectionArchive) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_AutofillSelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AutofillSelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}source_cell_range\0\u{3}target_cell_range\0")

  public var isInitialized: Bool {
    if let v = self._sourceCellRange, !v.isInitialized {return false}
    if let v = self._targetCellRange, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sourceCellRange) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._targetCellRange) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sourceCellRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._targetCellRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_AutofillSelectionArchive, rhs: TST_AutofillSelectionArchive) -> Bool {
    if lhs._sourceCellRange != rhs._sourceCellRange {return false}
    if lhs._targetCellRange != rhs._targetCellRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_FilterRulePrePivotArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FilterRulePrePivotArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}predicate\0\u{1}disabled\0")

  public var isInitialized: Bool {
    if self._predicate == nil {return false}
    if let v = self._predicate, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._predicate) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._disabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._predicate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._disabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_FilterRulePrePivotArchive, rhs: TST_FilterRulePrePivotArchive) -> Bool {
    if lhs._predicate != rhs._predicate {return false}
    if lhs._disabled != rhs._disabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_FilterRuleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FilterRuleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}predicate\0")

  public var isInitialized: Bool {
    if self._predicate == nil {return false}
    if let v = self._predicate, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._predicate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._predicate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_FilterRuleArchive, rhs: TST_FilterRuleArchive) -> Bool {
    if lhs._predicate != rhs._predicate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TableStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{9}override_count\0\u{3}table_properties\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._tableProperties, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._overrideCount) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._tableProperties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._overrideCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._tableProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableStyleArchive, rhs: TST_TableStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._overrideCount != rhs._overrideCount {return false}
    if lhs._tableProperties != rhs._tableProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CellStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{9}override_count\0\u{3}cell_properties\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._cellProperties, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._overrideCount) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._cellProperties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._overrideCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._cellProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CellStyleArchive, rhs: TST_CellStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._overrideCount != rhs._overrideCount {return false}
    if lhs._cellProperties != rhs._cellProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_FormulaPredArgDataArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormulaPredArgDataArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}double_value\0\u{3}decimal_low\0\u{3}decimal_high\0\u{3}string_value\0\u{3}date_value\0\u{3}duration_timeinterval\0\u{3}duration_units\0\u{3}boolean_value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._doubleValue) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._decimalLow) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._decimalHigh) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._stringValue) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self._dateValue) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self._durationTimeinterval) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self._durationUnits) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._booleanValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._doubleValue {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._decimalLow {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._decimalHigh {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._stringValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._dateValue {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._durationTimeinterval {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._durationUnits {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._booleanValue {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_FormulaPredArgDataArchive, rhs: TST_FormulaPredArgDataArchive) -> Bool {
    if lhs._doubleValue != rhs._doubleValue {return false}
    if lhs._decimalLow != rhs._decimalLow {return false}
    if lhs._decimalHigh != rhs._decimalHigh {return false}
    if lhs._stringValue != rhs._stringValue {return false}
    if lhs._dateValue != rhs._dateValue {return false}
    if lhs._durationTimeinterval != rhs._durationTimeinterval {return false}
    if lhs._durationUnits != rhs._durationUnits {return false}
    if lhs._booleanValue != rhs._booleanValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_FormulaPredArgArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormulaPredArgArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}arg_type\0\u{3}arg_value\0\u{3}base_cell_ref\0\u{3}relative_cell_ref\0\u{3}category_ref\0\u{3}uid_tract_list\0\u{3}host_cell_coord\0\u{3}preserve_row\0\u{3}preserve_column\0\u{3}list_entries\0\u{3}view_tract_ref\0")

  fileprivate class _StorageClass {
    var _argType: Int32? = nil
    var _argValue: TST_FormulaPredArgDataArchive? = nil
    var _baseCellRef: TSCE_CellReferenceArchive? = nil
    var _relativeCellRef: TSCE_RelativeCellRefArchive? = nil
    var _categoryRef: TSCE_CategoryReferenceArchive? = nil
    var _uidTractList: TSCE_ASTNodeArrayArchive.ASTUidTractList? = nil
    var _hostCellCoord: TSCE_CellCoordinateArchive? = nil
    var _preserveRow: Bool? = nil
    var _preserveColumn: Bool? = nil
    var _listEntries: [TST_FormulaPredArgDataArchive] = []
    var _viewTractRef: TSCE_ViewTractRefArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _argType = source._argType
      _argValue = source._argValue
      _baseCellRef = source._baseCellRef
      _relativeCellRef = source._relativeCellRef
      _categoryRef = source._categoryRef
      _uidTractList = source._uidTractList
      _hostCellCoord = source._hostCellCoord
      _preserveRow = source._preserveRow
      _preserveColumn = source._preserveColumn
      _listEntries = source._listEntries
      _viewTractRef = source._viewTractRef
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._argType == nil {return false}
      if let v = _storage._baseCellRef, !v.isInitialized {return false}
      if let v = _storage._relativeCellRef, !v.isInitialized {return false}
      if let v = _storage._categoryRef, !v.isInitialized {return false}
      if let v = _storage._uidTractList, !v.isInitialized {return false}
      if let v = _storage._viewTractRef, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._argType) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._argValue) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._baseCellRef) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._relativeCellRef) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._categoryRef) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._uidTractList) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._hostCellCoord) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._preserveRow) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._preserveColumn) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._listEntries) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._viewTractRef) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._argType {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._argValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._baseCellRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._relativeCellRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._categoryRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._uidTractList {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._hostCellCoord {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._preserveRow {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._preserveColumn {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
      if !_storage._listEntries.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._listEntries, fieldNumber: 10)
      }
      try { if let v = _storage._viewTractRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_FormulaPredArgArchive, rhs: TST_FormulaPredArgArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._argType != rhs_storage._argType {return false}
        if _storage._argValue != rhs_storage._argValue {return false}
        if _storage._baseCellRef != rhs_storage._baseCellRef {return false}
        if _storage._relativeCellRef != rhs_storage._relativeCellRef {return false}
        if _storage._categoryRef != rhs_storage._categoryRef {return false}
        if _storage._uidTractList != rhs_storage._uidTractList {return false}
        if _storage._hostCellCoord != rhs_storage._hostCellCoord {return false}
        if _storage._preserveRow != rhs_storage._preserveRow {return false}
        if _storage._preserveColumn != rhs_storage._preserveColumn {return false}
        if _storage._listEntries != rhs_storage._listEntries {return false}
        if _storage._viewTractRef != rhs_storage._viewTractRef {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_FormulaPredicatePrePivotArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormulaPredicatePrePivotArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}formula\0\u{3}predicate_type\0\u{1}qualifier1\0\u{1}qualifier2\0\u{3}param_index1\0\u{3}param_index2\0\u{3}param_index0\0")

  fileprivate class _StorageClass {
    var _formula: TSCE_FormulaArchive? = nil
    var _predicateType: Int32? = nil
    var _qualifier1: Int32? = nil
    var _qualifier2: Int32? = nil
    var _paramIndex1: Int32? = nil
    var _paramIndex2: Int32? = nil
    var _paramIndex0: Int32? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _formula = source._formula
      _predicateType = source._predicateType
      _qualifier1 = source._qualifier1
      _qualifier2 = source._qualifier2
      _paramIndex1 = source._paramIndex1
      _paramIndex2 = source._paramIndex2
      _paramIndex0 = source._paramIndex0
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._formula == nil {return false}
      if _storage._predicateType == nil {return false}
      if _storage._qualifier1 == nil {return false}
      if _storage._qualifier2 == nil {return false}
      if _storage._paramIndex1 == nil {return false}
      if _storage._paramIndex2 == nil {return false}
      if _storage._paramIndex0 == nil {return false}
      if let v = _storage._formula, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._formula) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._predicateType) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._qualifier1) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._qualifier2) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._paramIndex1) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._paramIndex2) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._paramIndex0) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._formula {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._predicateType {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._qualifier1 {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._qualifier2 {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._paramIndex1 {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._paramIndex2 {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._paramIndex0 {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_FormulaPredicatePrePivotArchive, rhs: TST_FormulaPredicatePrePivotArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._formula != rhs_storage._formula {return false}
        if _storage._predicateType != rhs_storage._predicateType {return false}
        if _storage._qualifier1 != rhs_storage._qualifier1 {return false}
        if _storage._qualifier2 != rhs_storage._qualifier2 {return false}
        if _storage._paramIndex1 != rhs_storage._paramIndex1 {return false}
        if _storage._paramIndex2 != rhs_storage._paramIndex2 {return false}
        if _storage._paramIndex0 != rhs_storage._paramIndex0 {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_FormulaPredicateArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormulaPredicateArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}predicate_type\0\u{1}qualifier1\0\u{1}qualifier2\0\u{3}param_value0\0\u{3}param_value1\0\u{3}param_value2\0\u{1}formula\0\u{3}for_conditional_style\0\u{3}host_table_uid\0\u{3}host_column_uid\0\u{3}host_row_uid\0")

  fileprivate class _StorageClass {
    var _predicateType: Int32? = nil
    var _qualifier1: Int32? = nil
    var _qualifier2: Int32? = nil
    var _paramValue0: TST_FormulaPredArgArchive? = nil
    var _paramValue1: TST_FormulaPredArgArchive? = nil
    var _paramValue2: TST_FormulaPredArgArchive? = nil
    var _formula: TSCE_FormulaArchive? = nil
    var _forConditionalStyle: Bool? = nil
    var _hostTableUid: TSP_UUID? = nil
    var _hostColumnUid: TSP_UUID? = nil
    var _hostRowUid: TSP_UUID? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _predicateType = source._predicateType
      _qualifier1 = source._qualifier1
      _qualifier2 = source._qualifier2
      _paramValue0 = source._paramValue0
      _paramValue1 = source._paramValue1
      _paramValue2 = source._paramValue2
      _formula = source._formula
      _forConditionalStyle = source._forConditionalStyle
      _hostTableUid = source._hostTableUid
      _hostColumnUid = source._hostColumnUid
      _hostRowUid = source._hostRowUid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._predicateType == nil {return false}
      if _storage._qualifier1 == nil {return false}
      if _storage._qualifier2 == nil {return false}
      if let v = _storage._paramValue0, !v.isInitialized {return false}
      if let v = _storage._paramValue1, !v.isInitialized {return false}
      if let v = _storage._paramValue2, !v.isInitialized {return false}
      if let v = _storage._formula, !v.isInitialized {return false}
      if let v = _storage._hostTableUid, !v.isInitialized {return false}
      if let v = _storage._hostColumnUid, !v.isInitialized {return false}
      if let v = _storage._hostRowUid, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._predicateType) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._qualifier1) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._qualifier2) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._paramValue0) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._paramValue1) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._paramValue2) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._formula) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._forConditionalStyle) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._hostTableUid) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._hostColumnUid) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._hostRowUid) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._predicateType {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._qualifier1 {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._qualifier2 {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._paramValue0 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._paramValue1 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._paramValue2 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._formula {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._forConditionalStyle {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._hostTableUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._hostColumnUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._hostRowUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_FormulaPredicateArchive, rhs: TST_FormulaPredicateArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._predicateType != rhs_storage._predicateType {return false}
        if _storage._qualifier1 != rhs_storage._qualifier1 {return false}
        if _storage._qualifier2 != rhs_storage._qualifier2 {return false}
        if _storage._paramValue0 != rhs_storage._paramValue0 {return false}
        if _storage._paramValue1 != rhs_storage._paramValue1 {return false}
        if _storage._paramValue2 != rhs_storage._paramValue2 {return false}
        if _storage._formula != rhs_storage._formula {return false}
        if _storage._forConditionalStyle != rhs_storage._forConditionalStyle {return false}
        if _storage._hostTableUid != rhs_storage._hostTableUid {return false}
        if _storage._hostColumnUid != rhs_storage._hostColumnUid {return false}
        if _storage._hostRowUid != rhs_storage._hostRowUid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ConditionalStyleSetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConditionalStyleSetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ruleCount\0\u{3}rules_prepivot\0\u{1}rules\0")

  public var isInitialized: Bool {
    if self._ruleCount == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rulesPrepivot) {return false}
    if let v = self._rules, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._ruleCount) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rulesPrepivot) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._rules) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ruleCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.rulesPrepivot.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rulesPrepivot, fieldNumber: 2)
    }
    try { if let v = self._rules {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ConditionalStyleSetArchive, rhs: TST_ConditionalStyleSetArchive) -> Bool {
    if lhs._ruleCount != rhs._ruleCount {return false}
    if lhs.rulesPrepivot != rhs.rulesPrepivot {return false}
    if lhs._rules != rhs._rules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ConditionalStyleSetArchive.ConditionalStyleRulePrePivot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_ConditionalStyleSetArchive.protoMessageName + ".ConditionalStyleRulePrePivot"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}predicate\0\u{3}cell_style\0\u{3}text_style\0")

  public var isInitialized: Bool {
    if self._predicate == nil {return false}
    if self._cellStyle == nil {return false}
    if self._textStyle == nil {return false}
    if let v = self._predicate, !v.isInitialized {return false}
    if let v = self._cellStyle, !v.isInitialized {return false}
    if let v = self._textStyle, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._predicate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cellStyle) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._textStyle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._predicate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cellStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._textStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ConditionalStyleSetArchive.ConditionalStyleRulePrePivot, rhs: TST_ConditionalStyleSetArchive.ConditionalStyleRulePrePivot) -> Bool {
    if lhs._predicate != rhs._predicate {return false}
    if lhs._cellStyle != rhs._cellStyle {return false}
    if lhs._textStyle != rhs._textStyle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ConditionalStyleSetArchive.ConditionalStyleRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_ConditionalStyleSetArchive.protoMessageName + ".ConditionalStyleRule"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}predicate\0\u{3}cell_style\0\u{3}text_style\0")

  public var isInitialized: Bool {
    if self._cellStyle == nil {return false}
    if self._textStyle == nil {return false}
    if let v = self._predicate, !v.isInitialized {return false}
    if let v = self._cellStyle, !v.isInitialized {return false}
    if let v = self._textStyle, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._predicate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cellStyle) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._textStyle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._predicate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cellStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._textStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ConditionalStyleSetArchive.ConditionalStyleRule, rhs: TST_ConditionalStyleSetArchive.ConditionalStyleRule) -> Bool {
    if lhs._predicate != rhs._predicate {return false}
    if lhs._cellStyle != rhs._cellStyle {return false}
    if lhs._textStyle != rhs._textStyle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ConditionalStyleSetArchive.ConditionalStyleRules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_ConditionalStyleSetArchive.protoMessageName + ".ConditionalStyleRules"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rule\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.rule) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rule) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rule.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rule, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ConditionalStyleSetArchive.ConditionalStyleRules, rhs: TST_ConditionalStyleSetArchive.ConditionalStyleRules) -> Bool {
    if lhs.rule != rhs.rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_FilterSetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FilterSetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{3}is_enabled\0\u{3}filter_rules_prepivot\0\u{3}needs_formula_rewrite_for_import\0\u{3}filter_offsets\0\u{3}filter_enabled\0\u{3}filter_rules\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.filterRulesPrepivot) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.filterRules) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isEnabled) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.filterRulesPrepivot) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._needsFormulaRewriteForImport) }()
      case 5: try { try decoder.decodeRepeatedUInt32Field(value: &self.filterOffsets) }()
      case 6: try { try decoder.decodeRepeatedBoolField(value: &self.filterEnabled) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.filterRules) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._isEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    if !self.filterRulesPrepivot.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filterRulesPrepivot, fieldNumber: 3)
    }
    try { if let v = self._needsFormulaRewriteForImport {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    if !self.filterOffsets.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.filterOffsets, fieldNumber: 5)
    }
    if !self.filterEnabled.isEmpty {
      try visitor.visitRepeatedBoolField(value: self.filterEnabled, fieldNumber: 6)
    }
    if !self.filterRules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filterRules, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_FilterSetArchive, rhs: TST_FilterSetArchive) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._isEnabled != rhs._isEnabled {return false}
    if lhs.filterRulesPrepivot != rhs.filterRulesPrepivot {return false}
    if lhs._needsFormulaRewriteForImport != rhs._needsFormulaRewriteForImport {return false}
    if lhs.filterOffsets != rhs.filterOffsets {return false}
    if lhs.filterEnabled != rhs.filterEnabled {return false}
    if lhs.filterRules != rhs.filterRules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_FilterSetArchive.FilterSetType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0FilterSetArchiveTypeAll\0\u{1}FilterSetArchiveTypeAny\0")
}

extension TST_UniqueIndexArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UniqueIndexArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}column_uid\0\u{3}unique_entries\0")

  public var isInitialized: Bool {
    if self._columnUid == nil {return false}
    if let v = self._columnUid, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.uniqueEntries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._columnUid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.uniqueEntries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._columnUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.uniqueEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uniqueEntries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_UniqueIndexArchive, rhs: TST_UniqueIndexArchive) -> Bool {
    if lhs._columnUid != rhs._columnUid {return false}
    if lhs.uniqueEntries != rhs.uniqueEntries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_UniqueIndexArchive.UniqueIndexEntryArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_UniqueIndexArchive.protoMessageName + ".UniqueIndexEntryArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}string_value\0\u{3}row_uids\0")

  public var isInitialized: Bool {
    if self._stringValue == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rowUids) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._stringValue) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rowUids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stringValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.rowUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rowUids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_UniqueIndexArchive.UniqueIndexEntryArchive, rhs: TST_UniqueIndexArchive.UniqueIndexEntryArchive) -> Bool {
    if lhs._stringValue != rhs._stringValue {return false}
    if lhs.rowUids != rhs.rowUids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_HiddenStateExtentArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HiddenStateExtentArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}hidden_state_extent_uid\0\u{3}base_hidden_states\0\u{3}row_or_column_direction\0\u{4}\u{2}threshold_value\0\u{3}needs_to_update_filter_set_for_import\0\u{3}collapsed_group_uids\0\u{3}filter_set\0\u{3}summary_pivot_hidden_indexes\0\u{3}summary_filtered_indexes\0\u{3}unique_indexes\0\u{3}summary_hidden_states\0")

  public var isInitialized: Bool {
    if self._hiddenStateExtentUid == nil {return false}
    if self._rowOrColumnDirection == nil {return false}
    if let v = self._hiddenStateExtentUid, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.baseHiddenStates) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.thresholdValue) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.collapsedGroupUids) {return false}
    if let v = self._filterSet, !v.isInitialized {return false}
    if let v = self._summaryPivotHiddenIndexes, !v.isInitialized {return false}
    if let v = self._summaryFilteredIndexes, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.uniqueIndexes) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.summaryHiddenStates) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._hiddenStateExtentUid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.baseHiddenStates) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._rowOrColumnDirection) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.thresholdValue) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._needsToUpdateFilterSetForImport) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.collapsedGroupUids) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._filterSet) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._summaryPivotHiddenIndexes) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._summaryFilteredIndexes) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.uniqueIndexes) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.summaryHiddenStates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hiddenStateExtentUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.baseHiddenStates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.baseHiddenStates, fieldNumber: 2)
    }
    try { if let v = self._rowOrColumnDirection {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    if !self.thresholdValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.thresholdValue, fieldNumber: 5)
    }
    try { if let v = self._needsToUpdateFilterSetForImport {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    if !self.collapsedGroupUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.collapsedGroupUids, fieldNumber: 7)
    }
    try { if let v = self._filterSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._summaryPivotHiddenIndexes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._summaryFilteredIndexes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    if !self.uniqueIndexes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uniqueIndexes, fieldNumber: 11)
    }
    if !self.summaryHiddenStates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.summaryHiddenStates, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_HiddenStateExtentArchive, rhs: TST_HiddenStateExtentArchive) -> Bool {
    if lhs._hiddenStateExtentUid != rhs._hiddenStateExtentUid {return false}
    if lhs.baseHiddenStates != rhs.baseHiddenStates {return false}
    if lhs._rowOrColumnDirection != rhs._rowOrColumnDirection {return false}
    if lhs.thresholdValue != rhs.thresholdValue {return false}
    if lhs._needsToUpdateFilterSetForImport != rhs._needsToUpdateFilterSetForImport {return false}
    if lhs.collapsedGroupUids != rhs.collapsedGroupUids {return false}
    if lhs._filterSet != rhs._filterSet {return false}
    if lhs._summaryPivotHiddenIndexes != rhs._summaryPivotHiddenIndexes {return false}
    if lhs._summaryFilteredIndexes != rhs._summaryFilteredIndexes {return false}
    if lhs.uniqueIndexes != rhs.uniqueIndexes {return false}
    if lhs.summaryHiddenStates != rhs.summaryHiddenStates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_HiddenStateExtentArchive.RowOrColumnDirection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ColumnDirection\0\u{1}RowDirection\0")
}

extension TST_HiddenStateExtentArchive.RowOrColumnState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_HiddenStateExtentArchive.protoMessageName + ".RowOrColumnState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}row_or_column_uid\0\u{3}user_hidden\0\u{1}filtered\0\u{3}pivot_hidden\0")

  public var isInitialized: Bool {
    if self._rowOrColumnUid == nil {return false}
    if let v = self._rowOrColumnUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rowOrColumnUid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._userHidden) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._filtered) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._pivotHidden) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rowOrColumnUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._userHidden {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._filtered {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pivotHidden {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_HiddenStateExtentArchive.RowOrColumnState, rhs: TST_HiddenStateExtentArchive.RowOrColumnState) -> Bool {
    if lhs._rowOrColumnUid != rhs._rowOrColumnUid {return false}
    if lhs._userHidden != rhs._userHidden {return false}
    if lhs._filtered != rhs._filtered {return false}
    if lhs._pivotHidden != rhs._pivotHidden {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_HiddenStatesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HiddenStatesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}hidden_states_uid\0\u{3}column_hidden_state_extent\0\u{3}row_hidden_state_extent\0")

  fileprivate class _StorageClass {
    var _hiddenStatesUid: TSP_UUID? = nil
    var _columnHiddenStateExtent: TST_HiddenStateExtentArchive? = nil
    var _rowHiddenStateExtent: TST_HiddenStateExtentArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hiddenStatesUid = source._hiddenStatesUid
      _columnHiddenStateExtent = source._columnHiddenStateExtent
      _rowHiddenStateExtent = source._rowHiddenStateExtent
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._hiddenStatesUid == nil {return false}
      if _storage._columnHiddenStateExtent == nil {return false}
      if _storage._rowHiddenStateExtent == nil {return false}
      if let v = _storage._hiddenStatesUid, !v.isInitialized {return false}
      if let v = _storage._columnHiddenStateExtent, !v.isInitialized {return false}
      if let v = _storage._rowHiddenStateExtent, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._hiddenStatesUid) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._columnHiddenStateExtent) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._rowHiddenStateExtent) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._hiddenStatesUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._columnHiddenStateExtent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._rowHiddenStateExtent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_HiddenStatesArchive, rhs: TST_HiddenStatesArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hiddenStatesUid != rhs_storage._hiddenStatesUid {return false}
        if _storage._columnHiddenStateExtent != rhs_storage._columnHiddenStateExtent {return false}
        if _storage._rowHiddenStateExtent != rhs_storage._rowHiddenStateExtent {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_HiddenStatesOwnerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HiddenStatesOwnerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}owner_uid\0\u{3}hidden_states\0")

  public var isInitialized: Bool {
    if self._ownerUid == nil {return false}
    if let v = self._ownerUid, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.hiddenStates) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ownerUid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.hiddenStates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownerUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.hiddenStates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hiddenStates, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_HiddenStatesOwnerArchive, rhs: TST_HiddenStatesOwnerArchive) -> Bool {
    if lhs._ownerUid != rhs._ownerUid {return false}
    if lhs.hiddenStates != rhs.hiddenStates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ExpandCollapseStateArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExpandCollapseStateArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}uids_collapsed\0\u{3}uids_expanded\0\u{1}dimension\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.uidsCollapsed) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.uidsExpanded) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.uidsCollapsed) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.uidsExpanded) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._dimension) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uidsCollapsed.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uidsCollapsed, fieldNumber: 1)
    }
    if !self.uidsExpanded.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uidsExpanded, fieldNumber: 2)
    }
    try { if let v = self._dimension {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ExpandCollapseStateArchive, rhs: TST_ExpandCollapseStateArchive) -> Bool {
    if lhs.uidsCollapsed != rhs.uidsCollapsed {return false}
    if lhs.uidsExpanded != rhs.uidsExpanded {return false}
    if lhs._dimension != rhs._dimension {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TokenAttachmentArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenAttachmentArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}expressionNode\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._expressionNode, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expressionNode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._expressionNode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TokenAttachmentArchive, rhs: TST_TokenAttachmentArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._expressionNode != rhs._expressionNode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ExpressionNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExpressionNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}children\0\u{3}first_index\0\u{3}last_index\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.children) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.children) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._firstIndex) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._lastIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.children.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.children, fieldNumber: 1)
    }
    try { if let v = self._firstIndex {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lastIndex {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ExpressionNodeArchive, rhs: TST_ExpressionNodeArchive) -> Bool {
    if lhs.children != rhs.children {return false}
    if lhs._firstIndex != rhs._firstIndex {return false}
    if lhs._lastIndex != rhs._lastIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_BooleanNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BooleanNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}value\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._value == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_BooleanNodeArchive, rhs: TST_BooleanNodeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_NumberNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NumberNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}number\0\u{3}decimal_low\0\u{3}decimal_high\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._number) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._decimalLow) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._decimalHigh) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._number {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._decimalLow {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._decimalHigh {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_NumberNodeArchive, rhs: TST_NumberNodeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._number != rhs._number {return false}
    if lhs._decimalLow != rhs._decimalLow {return false}
    if lhs._decimalHigh != rhs._decimalHigh {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_StringNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StringNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}value\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._value == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_StringNodeArchive, rhs: TST_StringNodeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_IdentifierNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IdentifierNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}identifier\0\u{1}symbol\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._identifier) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._symbol) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._identifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._symbol {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_IdentifierNodeArchive, rhs: TST_IdentifierNodeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._identifier != rhs._identifier {return false}
    if lhs._symbol != rhs._symbol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ArrayNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ArrayNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}columns\0\u{1}rows\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._columns) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._rows) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._columns {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._rows {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ArrayNodeArchive, rhs: TST_ArrayNodeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._columns != rhs._columns {return false}
    if lhs._rows != rhs._rows {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ListNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ListNodeArchive, rhs: TST_ListNodeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_OperatorNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OperatorNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}operatorChar\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._operatorChar == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._operatorChar) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._operatorChar {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_OperatorNodeArchive, rhs: TST_OperatorNodeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._operatorChar != rhs._operatorChar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_PostfixOperatorNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PostfixOperatorNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_PostfixOperatorNodeArchive, rhs: TST_PostfixOperatorNodeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_PrefixOperatorNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PrefixOperatorNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_PrefixOperatorNodeArchive, rhs: TST_PrefixOperatorNodeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_FunctionNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FunctionNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}functionIndex\0\u{1}invalidFunctionName\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._functionIndex == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._functionIndex) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._invalidFunctionName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._functionIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._invalidFunctionName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_FunctionNodeArchive, rhs: TST_FunctionNodeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._functionIndex != rhs._functionIndex {return false}
    if lhs._invalidFunctionName != rhs._invalidFunctionName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_FunctionEndNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FunctionEndNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_FunctionEndNodeArchive, rhs: TST_FunctionEndNodeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_DateNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DateNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}value\0\u{1}format\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._value == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._format) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._format {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_DateNodeArchive, rhs: TST_DateNodeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._value != rhs._value {return false}
    if lhs._format != rhs._format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ReferenceNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReferenceNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}rangeReference\0\u{3}preserve_flags\0\u{1}hostTableID\0\u{3}table_uid\0\u{3}range_top_left\0\u{3}range_bottom_right\0\u{3}category_ref\0\u{3}uid_range_rect\0\u{3}host_cell_ref\0\u{3}spill_range_op_suffix\0")

  fileprivate class _StorageClass {
    var _super: TST_ExpressionNodeArchive? = nil
    var _rangeReference: TSCE_RangeReferenceArchive? = nil
    var _preserveFlags: UInt32? = nil
    var _hostTableID: String? = nil
    var _hostCellRef: TSCE_CellReferenceArchive? = nil
    var _tableUid: TSP_UUID? = nil
    var _rangeTopLeft: TSP_UUIDCoordArchive? = nil
    var _rangeBottomRight: TSP_UUIDCoordArchive? = nil
    var _categoryRef: TSCE_CategoryReferenceArchive? = nil
    var _uidRangeRect: TSP_UUIDRectArchive? = nil
    var _spillRangeOpSuffix: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _rangeReference = source._rangeReference
      _preserveFlags = source._preserveFlags
      _hostTableID = source._hostTableID
      _hostCellRef = source._hostCellRef
      _tableUid = source._tableUid
      _rangeTopLeft = source._rangeTopLeft
      _rangeBottomRight = source._rangeBottomRight
      _categoryRef = source._categoryRef
      _uidRangeRect = source._uidRangeRect
      _spillRangeOpSuffix = source._spillRangeOpSuffix
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._preserveFlags == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._rangeReference, !v.isInitialized {return false}
      if let v = _storage._hostCellRef, !v.isInitialized {return false}
      if let v = _storage._tableUid, !v.isInitialized {return false}
      if let v = _storage._rangeTopLeft, !v.isInitialized {return false}
      if let v = _storage._rangeBottomRight, !v.isInitialized {return false}
      if let v = _storage._categoryRef, !v.isInitialized {return false}
      if let v = _storage._uidRangeRect, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._rangeReference) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._preserveFlags) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._hostTableID) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._tableUid) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._rangeTopLeft) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._rangeBottomRight) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._categoryRef) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._uidRangeRect) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._hostCellRef) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._spillRangeOpSuffix) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._rangeReference {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._preserveFlags {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._hostTableID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._tableUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._rangeTopLeft {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._rangeBottomRight {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._categoryRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._uidRangeRect {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._hostCellRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._spillRangeOpSuffix {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ReferenceNodeArchive, rhs: TST_ReferenceNodeArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._rangeReference != rhs_storage._rangeReference {return false}
        if _storage._preserveFlags != rhs_storage._preserveFlags {return false}
        if _storage._hostTableID != rhs_storage._hostTableID {return false}
        if _storage._hostCellRef != rhs_storage._hostCellRef {return false}
        if _storage._tableUid != rhs_storage._tableUid {return false}
        if _storage._rangeTopLeft != rhs_storage._rangeTopLeft {return false}
        if _storage._rangeBottomRight != rhs_storage._rangeBottomRight {return false}
        if _storage._categoryRef != rhs_storage._categoryRef {return false}
        if _storage._uidRangeRect != rhs_storage._uidRangeRect {return false}
        if _storage._spillRangeOpSuffix != rhs_storage._spillRangeOpSuffix {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_DurationNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DurationNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}timeinterval\0\u{1}smallest\0\u{1}largest\0\u{1}style\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._timeinterval == nil {return false}
    if self._smallest == nil {return false}
    if self._largest == nil {return false}
    if self._style == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._timeinterval) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._smallest) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._largest) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._style) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._timeinterval {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._smallest {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._largest {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._style {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_DurationNodeArchive, rhs: TST_DurationNodeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._timeinterval != rhs._timeinterval {return false}
    if lhs._smallest != rhs._smallest {return false}
    if lhs._largest != rhs._largest {return false}
    if lhs._style != rhs._style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ArgumentPlaceholderNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ArgumentPlaceholderNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}functionIndex\0\u{1}argumentIndex\0\u{1}mode\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._functionIndex) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._argumentIndex) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._mode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._functionIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._argumentIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._mode {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ArgumentPlaceholderNodeArchive, rhs: TST_ArgumentPlaceholderNodeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._functionIndex != rhs._functionIndex {return false}
    if lhs._argumentIndex != rhs._argumentIndex {return false}
    if lhs._mode != rhs._mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_EmptyExpressionNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EmptyExpressionNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_EmptyExpressionNodeArchive, rhs: TST_EmptyExpressionNodeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_VariableNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VariableNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}identifier\0\u{1}symbol\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._symbol == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._identifier) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._symbol) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._identifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._symbol {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_VariableNodeArchive, rhs: TST_VariableNodeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._identifier != rhs._identifier {return false}
    if lhs._symbol != rhs._symbol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_SpillOriginRefNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpillOriginRefNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}spill_origin_coord\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._spillOriginCoord == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spillOriginCoord) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spillOriginCoord {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_SpillOriginRefNodeArchive, rhs: TST_SpillOriginRefNodeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._spillOriginCoord != rhs._spillOriginCoord {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_LayoutHintArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LayoutHintArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}isValid\0\u{1}cellRange\0\u{1}hintID\0\u{1}maximumSize\0\u{1}partitionPosition\0\u{1}horizontal\0\u{1}effectiveSize\0\u{1}partitioningPass\0")

  fileprivate class _StorageClass {
    var _isValid: Bool? = nil
    var _cellRange: TST_CellRange? = nil
    var _hintID: TST_CellID? = nil
    var _maximumSize: TSP_Size? = nil
    var _partitionPosition: UInt32? = nil
    var _horizontal: Bool? = nil
    var _effectiveSize: TSP_Size? = nil
    var _partitioningPass: UInt32? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _isValid = source._isValid
      _cellRange = source._cellRange
      _hintID = source._hintID
      _maximumSize = source._maximumSize
      _partitionPosition = source._partitionPosition
      _horizontal = source._horizontal
      _effectiveSize = source._effectiveSize
      _partitioningPass = source._partitioningPass
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._isValid == nil {return false}
      if _storage._maximumSize == nil {return false}
      if _storage._partitionPosition == nil {return false}
      if _storage._horizontal == nil {return false}
      if let v = _storage._cellRange, !v.isInitialized {return false}
      if let v = _storage._hintID, !v.isInitialized {return false}
      if let v = _storage._maximumSize, !v.isInitialized {return false}
      if let v = _storage._effectiveSize, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._isValid) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._cellRange) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._hintID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._maximumSize) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._partitionPosition) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._horizontal) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._effectiveSize) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._partitioningPass) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._isValid {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._cellRange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._hintID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._maximumSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._partitionPosition {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._horizontal {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._effectiveSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._partitioningPass {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_LayoutHintArchive, rhs: TST_LayoutHintArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._isValid != rhs_storage._isValid {return false}
        if _storage._cellRange != rhs_storage._cellRange {return false}
        if _storage._hintID != rhs_storage._hintID {return false}
        if _storage._maximumSize != rhs_storage._maximumSize {return false}
        if _storage._partitionPosition != rhs_storage._partitionPosition {return false}
        if _storage._horizontal != rhs_storage._horizontal {return false}
        if _storage._effectiveSize != rhs_storage._effectiveSize {return false}
        if _storage._partitioningPass != rhs_storage._partitioningPass {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CompletionTokenAttachmentArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompletionTokenAttachmentArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}completionText\0\u{1}caretPosition\0\u{1}prefixStart\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._completionText) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._caretPosition) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._prefixStart) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._completionText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._caretPosition {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._prefixStart {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CompletionTokenAttachmentArchive, rhs: TST_CompletionTokenAttachmentArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._completionText != rhs._completionText {return false}
    if lhs._caretPosition != rhs._caretPosition {return false}
    if lhs._prefixStart != rhs._prefixStart {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_HiddenStateFormulaOwnerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HiddenStateFormulaOwnerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}owner_id\0\u{3}threshold_value\0\u{3}needs_to_update_filter_set_for_import\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.thresholdValue) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ownerID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.thresholdValue) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._needsToUpdateFilterSetForImport) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.thresholdValue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.thresholdValue, fieldNumber: 2)
    }
    try { if let v = self._needsToUpdateFilterSetForImport {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_HiddenStateFormulaOwnerArchive, rhs: TST_HiddenStateFormulaOwnerArchive) -> Bool {
    if lhs._ownerID != rhs._ownerID {return false}
    if lhs.thresholdValue != rhs.thresholdValue {return false}
    if lhs._needsToUpdateFilterSetForImport != rhs._needsToUpdateFilterSetForImport {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_FormulaStoreArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormulaStoreArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{2}next_formula_index\0\u{1}formulas\0")

  public var isInitialized: Bool {
    if self._nextFormulaIndex == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.formulas) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._nextFormulaIndex) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.formulas) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nextFormulaIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    if !self.formulas.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.formulas, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_FormulaStoreArchive, rhs: TST_FormulaStoreArchive) -> Bool {
    if lhs._nextFormulaIndex != rhs._nextFormulaIndex {return false}
    if lhs.formulas != rhs.formulas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_FormulaStoreArchive.FormulaStorePair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_FormulaStoreArchive.protoMessageName + ".FormulaStorePair"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}formula_index\0\u{1}formula\0")

  fileprivate class _StorageClass {
    var _formulaIndex: UInt32? = nil
    var _formula: TSCE_FormulaArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _formulaIndex = source._formulaIndex
      _formula = source._formula
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._formulaIndex == nil {return false}
      if _storage._formula == nil {return false}
      if let v = _storage._formula, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._formulaIndex) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._formula) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._formulaIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._formula {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_FormulaStoreArchive.FormulaStorePair, rhs: TST_FormulaStoreArchive.FormulaStorePair) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._formulaIndex != rhs_storage._formulaIndex {return false}
        if _storage._formula != rhs_storage._formula {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_MergeOperationArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MergeOperationArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}merge_type\0\u{3}merge_ranges\0\u{3}merge_formulas\0\u{3}merge_formula_indexes\0")

  public var isInitialized: Bool {
    if self._mergeType == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.mergeRanges) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.mergeFormulas) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._mergeType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.mergeRanges) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mergeFormulas) }()
      case 4: try { try decoder.decodeRepeatedUInt32Field(value: &self.mergeFormulaIndexes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mergeType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.mergeRanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mergeRanges, fieldNumber: 2)
    }
    if !self.mergeFormulas.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mergeFormulas, fieldNumber: 3)
    }
    if !self.mergeFormulaIndexes.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.mergeFormulaIndexes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_MergeOperationArchive, rhs: TST_MergeOperationArchive) -> Bool {
    if lhs._mergeType != rhs._mergeType {return false}
    if lhs.mergeRanges != rhs.mergeRanges {return false}
    if lhs.mergeFormulas != rhs.mergeFormulas {return false}
    if lhs.mergeFormulaIndexes != rhs.mergeFormulaIndexes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_MergeOwnerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MergeOwnerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}owner_id\0\u{3}formula_store\0")

  public var isInitialized: Bool {
    if self._ownerID == nil {return false}
    if let v = self._formulaStore, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ownerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._formulaStore) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._formulaStore {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_MergeOwnerArchive, rhs: TST_MergeOwnerArchive) -> Bool {
    if lhs._ownerID != rhs._ownerID {return false}
    if lhs._formulaStore != rhs._formulaStore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_PencilAnnotationArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PencilAnnotationArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}table_info\0\u{3}pencil_annotation_storage\0")

  public var isInitialized: Bool {
    if let v = self._tableInfo, !v.isInitialized {return false}
    if let v = self._pencilAnnotationStorage, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tableInfo) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pencilAnnotationStorage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tableInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pencilAnnotationStorage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_PencilAnnotationArchive, rhs: TST_PencilAnnotationArchive) -> Bool {
    if lhs._tableInfo != rhs._tableInfo {return false}
    if lhs._pencilAnnotationStorage != rhs._pencilAnnotationStorage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_PencilAnnotationOwnerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PencilAnnotationOwnerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}owner_id\0\u{3}formula_store\0\u{1}annotations\0")

  public var isInitialized: Bool {
    if self._ownerID == nil {return false}
    if let v = self._formulaStore, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.annotations) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ownerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._formulaStore) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.annotations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._formulaStore {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.annotations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotations, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_PencilAnnotationOwnerArchive, rhs: TST_PencilAnnotationOwnerArchive) -> Bool {
    if lhs._ownerID != rhs._ownerID {return false}
    if lhs._formulaStore != rhs._formulaStore {return false}
    if lhs.annotations != rhs.annotations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_AccumulatorArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccumulatorArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}bool_count\0\u{3}number_count\0\u{3}date_count\0\u{3}duration_count\0\u{3}string_count\0\u{3}min_value\0\u{3}max_value\0\u{3}number_total_value\0\u{3}first_date_seen\0\u{3}total_secs_since_ref_date\0\u{3}secs_to_add\0\u{3}bool_true_count\0\u{3}error_count\0\u{3}is_circular_ref\0\u{3}product_value\0\u{3}no_content_count\0")

  public var isInitialized: Bool {
    if self._minValue == nil {return false}
    if self._maxValue == nil {return false}
    if self._numberTotalValue == nil {return false}
    if let v = self._minValue, !v.isInitialized {return false}
    if let v = self._maxValue, !v.isInitialized {return false}
    if let v = self._numberTotalValue, !v.isInitialized {return false}
    if let v = self._firstDateSeen, !v.isInitialized {return false}
    if let v = self._productValue, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._boolCount) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._numberCount) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._dateCount) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._durationCount) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._stringCount) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._minValue) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._maxValue) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._numberTotalValue) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._firstDateSeen) }()
      case 10: try { try decoder.decodeSingularDoubleField(value: &self._totalSecsSinceRefDate) }()
      case 11: try { try decoder.decodeSingularDoubleField(value: &self._secsToAdd) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self._boolTrueCount) }()
      case 13: try { try decoder.decodeSingularUInt32Field(value: &self._errorCount) }()
      case 14: try { try decoder.decodeSingularBoolField(value: &self._isCircularRef) }()
      case 15: try { try decoder.decodeSingularMessageField(value: &self._productValue) }()
      case 16: try { try decoder.decodeSingularUInt32Field(value: &self._noContentCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._boolCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._numberCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._dateCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._durationCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._stringCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._minValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._maxValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._numberTotalValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._firstDateSeen {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._totalSecsSinceRefDate {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._secsToAdd {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._boolTrueCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._errorCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._isCircularRef {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
    } }()
    try { if let v = self._productValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    } }()
    try { if let v = self._noContentCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 16)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_AccumulatorArchive, rhs: TST_AccumulatorArchive) -> Bool {
    if lhs._boolCount != rhs._boolCount {return false}
    if lhs._numberCount != rhs._numberCount {return false}
    if lhs._dateCount != rhs._dateCount {return false}
    if lhs._durationCount != rhs._durationCount {return false}
    if lhs._stringCount != rhs._stringCount {return false}
    if lhs._minValue != rhs._minValue {return false}
    if lhs._maxValue != rhs._maxValue {return false}
    if lhs._numberTotalValue != rhs._numberTotalValue {return false}
    if lhs._firstDateSeen != rhs._firstDateSeen {return false}
    if lhs._totalSecsSinceRefDate != rhs._totalSecsSinceRefDate {return false}
    if lhs._secsToAdd != rhs._secsToAdd {return false}
    if lhs._boolTrueCount != rhs._boolTrueCount {return false}
    if lhs._errorCount != rhs._errorCount {return false}
    if lhs._isCircularRef != rhs._isCircularRef {return false}
    if lhs._productValue != rhs._productValue {return false}
    if lhs._noContentCount != rhs._noContentCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_GroupColumnArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupColumnArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}column_uid\0\u{3}grouping_type\0\u{3}grouping_functor\0\u{3}grouping_column_uid\0")

  public var isInitialized: Bool {
    if self._columnUid == nil {return false}
    if self._groupingType == nil {return false}
    if let v = self._columnUid, !v.isInitialized {return false}
    if let v = self._groupingFunctor, !v.isInitialized {return false}
    if let v = self._groupingColumnUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._columnUid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._groupingType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._groupingFunctor) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._groupingColumnUid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._columnUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._groupingType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._groupingFunctor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._groupingColumnUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_GroupColumnArchive, rhs: TST_GroupColumnArchive) -> Bool {
    if lhs._columnUid != rhs._columnUid {return false}
    if lhs._groupingType != rhs._groupingType {return false}
    if lhs._groupingFunctor != rhs._groupingFunctor {return false}
    if lhs._groupingColumnUid != rhs._groupingColumnUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_GroupColumnListArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupColumnListArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_column\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.groupColumn) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groupColumn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupColumn.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupColumn, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_GroupColumnListArchive, rhs: TST_GroupColumnListArchive) -> Bool {
    if lhs.groupColumn != rhs.groupColumn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ColumnAggregateArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ColumnAggregateArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}column_uid\0\u{1}level\0\u{3}agg_type\0\u{3}show_as_type\0\u{3}column_aggregate_uid\0\u{3}running_total_group_column_uid\0")

  public var isInitialized: Bool {
    if self._columnUid == nil {return false}
    if self._level == nil {return false}
    if self._aggType == nil {return false}
    if let v = self._columnUid, !v.isInitialized {return false}
    if let v = self._columnAggregateUid, !v.isInitialized {return false}
    if let v = self._runningTotalGroupColumnUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._columnUid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._level) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._aggType) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._showAsType) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._columnAggregateUid) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._runningTotalGroupColumnUid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._columnUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._level {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._aggType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._showAsType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._columnAggregateUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._runningTotalGroupColumnUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ColumnAggregateArchive, rhs: TST_ColumnAggregateArchive) -> Bool {
    if lhs._columnUid != rhs._columnUid {return false}
    if lhs._level != rhs._level {return false}
    if lhs._aggType != rhs._aggType {return false}
    if lhs._showAsType != rhs._showAsType {return false}
    if lhs._columnAggregateUid != rhs._columnAggregateUid {return false}
    if lhs._runningTotalGroupColumnUid != rhs._runningTotalGroupColumnUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ColumnAggregateListArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ColumnAggregateListArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}aggregates\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.aggregates) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.aggregates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.aggregates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aggregates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ColumnAggregateListArchive, rhs: TST_ColumnAggregateListArchive) -> Bool {
    if lhs.aggregates != rhs.aggregates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_GroupByArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupByArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_by_uid\0\u{3}group_column\0\u{3}group_node_root\0\u{1}aggregator\0\u{3}column_agg_type\0\u{3}is_enabled\0\u{3}indirect_agg_type_change_formula\0\u{3}grouping_columns_formula\0\u{3}aggs_in_group_root_formula\0\u{3}grouping_column_headers_formula\0\u{3}column_order_changed_formula\0\u{3}row_order_changed_formula\0\u{3}row_order_changed_ignoring_recalc_formula\0\u{3}owner_index\0\u{3}row_uid_lookup\0\u{3}hidden_states_changed_formula\0\u{3}aggregator_ref\0\u{3}group_node_root_ref\0")

  fileprivate class _StorageClass {
    var _groupByUid: TSP_UUID? = nil
    var _groupColumn: [TST_GroupColumnArchive] = []
    var _groupNodeRoot: TST_GroupByArchive.GroupNodeArchive? = nil
    var _aggregator: [TST_GroupByArchive.AggregatorArchive] = []
    var _columnAggType: [TST_ColumnAggregateArchive] = []
    var _isEnabled: Bool? = nil
    var _indirectAggTypeChangeFormula: TSCE_CellCoordinateArchive? = nil
    var _groupingColumnsFormula: TSCE_CellCoordinateArchive? = nil
    var _aggsInGroupRootFormula: TSCE_CellCoordinateArchive? = nil
    var _groupingColumnHeadersFormula: TSCE_CellCoordinateArchive? = nil
    var _columnOrderChangedFormula: TSCE_CellCoordinateArchive? = nil
    var _rowOrderChangedFormula: TSCE_CellCoordinateArchive? = nil
    var _rowOrderChangedIgnoringRecalcFormula: TSCE_CellCoordinateArchive? = nil
    var _ownerIndex: Int32? = nil
    var _rowUidLookup: TSCE_UidLookupListArchive? = nil
    var _hiddenStatesChangedFormula: TSCE_CellCoordinateArchive? = nil
    var _aggregatorRef: [TSP_Reference] = []
    var _groupNodeRootRef: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _groupByUid = source._groupByUid
      _groupColumn = source._groupColumn
      _groupNodeRoot = source._groupNodeRoot
      _aggregator = source._aggregator
      _columnAggType = source._columnAggType
      _isEnabled = source._isEnabled
      _indirectAggTypeChangeFormula = source._indirectAggTypeChangeFormula
      _groupingColumnsFormula = source._groupingColumnsFormula
      _aggsInGroupRootFormula = source._aggsInGroupRootFormula
      _groupingColumnHeadersFormula = source._groupingColumnHeadersFormula
      _columnOrderChangedFormula = source._columnOrderChangedFormula
      _rowOrderChangedFormula = source._rowOrderChangedFormula
      _rowOrderChangedIgnoringRecalcFormula = source._rowOrderChangedIgnoringRecalcFormula
      _ownerIndex = source._ownerIndex
      _rowUidLookup = source._rowUidLookup
      _hiddenStatesChangedFormula = source._hiddenStatesChangedFormula
      _aggregatorRef = source._aggregatorRef
      _groupNodeRootRef = source._groupNodeRootRef
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._groupByUid == nil {return false}
      if _storage._isEnabled == nil {return false}
      if let v = _storage._groupByUid, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._groupColumn) {return false}
      if let v = _storage._groupNodeRoot, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._aggregator) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._columnAggType) {return false}
      if let v = _storage._rowUidLookup, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._aggregatorRef) {return false}
      if let v = _storage._groupNodeRootRef, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._groupByUid) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._groupColumn) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._groupNodeRoot) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._aggregator) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._columnAggType) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._isEnabled) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._indirectAggTypeChangeFormula) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._groupingColumnsFormula) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._aggsInGroupRootFormula) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._groupingColumnHeadersFormula) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._columnOrderChangedFormula) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._rowOrderChangedFormula) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._rowOrderChangedIgnoringRecalcFormula) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._ownerIndex) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._rowUidLookup) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._hiddenStatesChangedFormula) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._aggregatorRef) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._groupNodeRootRef) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._groupByUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._groupColumn.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._groupColumn, fieldNumber: 2)
      }
      try { if let v = _storage._groupNodeRoot {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._aggregator.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._aggregator, fieldNumber: 4)
      }
      if !_storage._columnAggType.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._columnAggType, fieldNumber: 5)
      }
      try { if let v = _storage._isEnabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._indirectAggTypeChangeFormula {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._groupingColumnsFormula {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._aggsInGroupRootFormula {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._groupingColumnHeadersFormula {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._columnOrderChangedFormula {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._rowOrderChangedFormula {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._rowOrderChangedIgnoringRecalcFormula {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._ownerIndex {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._rowUidLookup {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._hiddenStatesChangedFormula {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if !_storage._aggregatorRef.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._aggregatorRef, fieldNumber: 17)
      }
      try { if let v = _storage._groupNodeRootRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_GroupByArchive, rhs: TST_GroupByArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._groupByUid != rhs_storage._groupByUid {return false}
        if _storage._groupColumn != rhs_storage._groupColumn {return false}
        if _storage._groupNodeRoot != rhs_storage._groupNodeRoot {return false}
        if _storage._aggregator != rhs_storage._aggregator {return false}
        if _storage._columnAggType != rhs_storage._columnAggType {return false}
        if _storage._isEnabled != rhs_storage._isEnabled {return false}
        if _storage._indirectAggTypeChangeFormula != rhs_storage._indirectAggTypeChangeFormula {return false}
        if _storage._groupingColumnsFormula != rhs_storage._groupingColumnsFormula {return false}
        if _storage._aggsInGroupRootFormula != rhs_storage._aggsInGroupRootFormula {return false}
        if _storage._groupingColumnHeadersFormula != rhs_storage._groupingColumnHeadersFormula {return false}
        if _storage._columnOrderChangedFormula != rhs_storage._columnOrderChangedFormula {return false}
        if _storage._rowOrderChangedFormula != rhs_storage._rowOrderChangedFormula {return false}
        if _storage._rowOrderChangedIgnoringRecalcFormula != rhs_storage._rowOrderChangedIgnoringRecalcFormula {return false}
        if _storage._ownerIndex != rhs_storage._ownerIndex {return false}
        if _storage._rowUidLookup != rhs_storage._rowUidLookup {return false}
        if _storage._hiddenStatesChangedFormula != rhs_storage._hiddenStatesChangedFormula {return false}
        if _storage._aggregatorRef != rhs_storage._aggregatorRef {return false}
        if _storage._groupNodeRootRef != rhs_storage._groupNodeRootRef {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_GroupByArchive.AggNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_GroupByArchive.protoMessageName + ".AggNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}formula_coord\0\u{1}accum\0\u{1}child\0")

  fileprivate class _StorageClass {
    var _formulaCoord: TSCE_CellCoordinateArchive? = nil
    var _accum: TST_AccumulatorArchive? = nil
    var _child: [TST_GroupByArchive.AggNodeArchive] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _formulaCoord = source._formulaCoord
      _accum = source._accum
      _child = source._child
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._formulaCoord == nil {return false}
      if let v = _storage._accum, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._child) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._formulaCoord) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._accum) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._child) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._formulaCoord {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._accum {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._child.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._child, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_GroupByArchive.AggNodeArchive, rhs: TST_GroupByArchive.AggNodeArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._formulaCoord != rhs_storage._formulaCoord {return false}
        if _storage._accum != rhs_storage._accum {return false}
        if _storage._child != rhs_storage._child {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_GroupByArchive.AggregatorArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_GroupByArchive.protoMessageName + ".AggregatorArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}column_uid\0\u{3}agg_node\0")

  public var isInitialized: Bool {
    if self._columnUid == nil {return false}
    if let v = self._columnUid, !v.isInitialized {return false}
    if let v = self._aggNode, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._columnUid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._aggNode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._columnUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._aggNode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_GroupByArchive.AggregatorArchive, rhs: TST_GroupByArchive.AggregatorArchive) -> Bool {
    if lhs._columnUid != rhs._columnUid {return false}
    if lhs._aggNode != rhs._aggNode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_GroupByArchive.GroupNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_GroupByArchive.protoMessageName + ".GroupNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_uid\0\u{2}\u{2}child\0\u{3}row_uid\0\u{3}agg_formula_coords\0\u{3}format_manager\0\u{3}group_cell_value\0\u{3}row_indexes\0\u{3}row_lookup_uids\0\u{3}child_ref\0")

  public var isInitialized: Bool {
    if self._groupUid == nil {return false}
    if let v = self._groupUid, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.child) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rowUid) {return false}
    if let v = self._formatManager, !v.isInitialized {return false}
    if let v = self._groupCellValue, !v.isInitialized {return false}
    if let v = self._rowIndexes, !v.isInitialized {return false}
    if let v = self._rowLookupUids, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.childRef) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groupUid) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.child) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.rowUid) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.aggFormulaCoords) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._formatManager) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._groupCellValue) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._rowIndexes) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._rowLookupUids) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.childRef) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groupUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.child.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.child, fieldNumber: 3)
    }
    if !self.rowUid.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rowUid, fieldNumber: 4)
    }
    if !self.aggFormulaCoords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aggFormulaCoords, fieldNumber: 5)
    }
    try { if let v = self._formatManager {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._groupCellValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._rowIndexes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._rowLookupUids {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.childRef.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.childRef, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_GroupByArchive.GroupNodeArchive, rhs: TST_GroupByArchive.GroupNodeArchive) -> Bool {
    if lhs._groupUid != rhs._groupUid {return false}
    if lhs.child != rhs.child {return false}
    if lhs.rowUid != rhs.rowUid {return false}
    if lhs.aggFormulaCoords != rhs.aggFormulaCoords {return false}
    if lhs._formatManager != rhs._formatManager {return false}
    if lhs._groupCellValue != rhs._groupCellValue {return false}
    if lhs._rowIndexes != rhs._rowIndexes {return false}
    if lhs._rowLookupUids != rhs._rowLookupUids {return false}
    if lhs.childRef != rhs.childRef {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_GroupByArchive.GroupNodeArchive.FormatManagerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_GroupByArchive.GroupNodeArchive.protoMessageName + ".FormatManagerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cell_value\0\u{1}formats\0\u{3}row_sets\0\u{3}row_uid_lookup_sets\0")

  public var isInitialized: Bool {
    if let v = self._cellValue, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.formats) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rowSets) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rowUidLookupSets) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cellValue) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.formats) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.rowSets) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.rowUidLookupSets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cellValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.formats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.formats, fieldNumber: 2)
    }
    if !self.rowSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rowSets, fieldNumber: 3)
    }
    if !self.rowUidLookupSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rowUidLookupSets, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_GroupByArchive.GroupNodeArchive.FormatManagerArchive, rhs: TST_GroupByArchive.GroupNodeArchive.FormatManagerArchive) -> Bool {
    if lhs._cellValue != rhs._cellValue {return false}
    if lhs.formats != rhs.formats {return false}
    if lhs.rowSets != rhs.rowSets {return false}
    if lhs.rowUidLookupSets != rhs.rowUidLookupSets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_GroupByArchive.GroupNodeArchive.FormatManagerArchive.RowSetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_GroupByArchive.GroupNodeArchive.FormatManagerArchive.protoMessageName + ".RowSetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}row_uids\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.rowUids) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rowUids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rowUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rowUids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_GroupByArchive.GroupNodeArchive.FormatManagerArchive.RowSetArchive, rhs: TST_GroupByArchive.GroupNodeArchive.FormatManagerArchive.RowSetArchive) -> Bool {
    if lhs.rowUids != rhs.rowUids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CategoryOwnerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CategoryOwnerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}owner_uid\0\u{3}group_by\0")

  public var isInitialized: Bool {
    if self._ownerUid == nil {return false}
    if let v = self._ownerUid, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.groupBy) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ownerUid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.groupBy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownerUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.groupBy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupBy, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CategoryOwnerArchive, rhs: TST_CategoryOwnerArchive) -> Bool {
    if lhs._ownerUid != rhs._ownerUid {return false}
    if lhs.groupBy != rhs.groupBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CategoryOwnerRefArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CategoryOwnerRefArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_by\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.groupBy) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groupBy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupBy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupBy, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CategoryOwnerRefArchive, rhs: TST_CategoryOwnerRefArchive) -> Bool {
    if lhs.groupBy != rhs.groupBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_PivotGroupingColumnOptionsMapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PivotGroupingColumnOptionsMapArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uids\0\u{1}flags\0\u{4}\u{2}aggregate_rule_uids\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.uids) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.aggregateRuleUids) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.uids) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.flags) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.aggregateRuleUids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uids, fieldNumber: 1)
    }
    if !self.flags.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.flags, fieldNumber: 2)
    }
    if !self.aggregateRuleUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aggregateRuleUids, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_PivotGroupingColumnOptionsMapArchive, rhs: TST_PivotGroupingColumnOptionsMapArchive) -> Bool {
    if lhs.uids != rhs.uids {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs.aggregateRuleUids != rhs.aggregateRuleUids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_PivotOwnerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PivotOwnerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{2}pivot_owner_uid\0\u{3}grouping_columns_for_rows\0\u{3}grouping_columns_for_columns\0\u{3}aggregate_columns\0\u{3}flattening_dimension\0\u{3}is_empty_pivot\0\u{3}source_table_uid\0\u{3}refresh_timestamp\0\u{3}grpg_col_options_map\0\u{3}hide_grand_total_rows\0\u{3}source_table_name\0\u{3}hide_grand_total_columns\0\u{4}\u{4}formula_store\0\u{3}refresh_uid\0\u{3}row_column_rule_change_uid\0\u{3}aggregate_rule_change_uid\0")

  fileprivate class _StorageClass {
    var _pivotOwnerUid: TSP_UUID? = nil
    var _groupingColumnsForRows: TST_GroupColumnListArchive? = nil
    var _groupingColumnsForColumns: TST_GroupColumnListArchive? = nil
    var _aggregateColumns: TST_ColumnAggregateListArchive? = nil
    var _flatteningDimension: Int32? = nil
    var _isEmptyPivot: Bool? = nil
    var _sourceTableUid: TSP_UUID? = nil
    var _refreshTimestamp: Double? = nil
    var _grpgColOptionsMap: TSP_Reference? = nil
    var _hideGrandTotalRows: Bool? = nil
    var _sourceTableName: String? = nil
    var _hideGrandTotalColumns: Bool? = nil
    var _formulaStore: TST_FormulaStoreArchive? = nil
    var _refreshUid: TSP_UUID? = nil
    var _rowColumnRuleChangeUid: TSP_UUID? = nil
    var _aggregateRuleChangeUid: TSP_UUID? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _pivotOwnerUid = source._pivotOwnerUid
      _groupingColumnsForRows = source._groupingColumnsForRows
      _groupingColumnsForColumns = source._groupingColumnsForColumns
      _aggregateColumns = source._aggregateColumns
      _flatteningDimension = source._flatteningDimension
      _isEmptyPivot = source._isEmptyPivot
      _sourceTableUid = source._sourceTableUid
      _refreshTimestamp = source._refreshTimestamp
      _grpgColOptionsMap = source._grpgColOptionsMap
      _hideGrandTotalRows = source._hideGrandTotalRows
      _sourceTableName = source._sourceTableName
      _hideGrandTotalColumns = source._hideGrandTotalColumns
      _formulaStore = source._formulaStore
      _refreshUid = source._refreshUid
      _rowColumnRuleChangeUid = source._rowColumnRuleChangeUid
      _aggregateRuleChangeUid = source._aggregateRuleChangeUid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._pivotOwnerUid, !v.isInitialized {return false}
      if let v = _storage._groupingColumnsForRows, !v.isInitialized {return false}
      if let v = _storage._groupingColumnsForColumns, !v.isInitialized {return false}
      if let v = _storage._aggregateColumns, !v.isInitialized {return false}
      if let v = _storage._sourceTableUid, !v.isInitialized {return false}
      if let v = _storage._grpgColOptionsMap, !v.isInitialized {return false}
      if let v = _storage._formulaStore, !v.isInitialized {return false}
      if let v = _storage._refreshUid, !v.isInitialized {return false}
      if let v = _storage._rowColumnRuleChangeUid, !v.isInitialized {return false}
      if let v = _storage._aggregateRuleChangeUid, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._pivotOwnerUid) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._groupingColumnsForRows) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._groupingColumnsForColumns) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._aggregateColumns) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._flatteningDimension) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._isEmptyPivot) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._sourceTableUid) }()
        case 9: try { try decoder.decodeSingularDoubleField(value: &_storage._refreshTimestamp) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._grpgColOptionsMap) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._hideGrandTotalRows) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._sourceTableName) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._hideGrandTotalColumns) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._formulaStore) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._refreshUid) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._rowColumnRuleChangeUid) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._aggregateRuleChangeUid) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._pivotOwnerUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._groupingColumnsForRows {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._groupingColumnsForColumns {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._aggregateColumns {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._flatteningDimension {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._isEmptyPivot {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._sourceTableUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._refreshTimestamp {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._grpgColOptionsMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._hideGrandTotalRows {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._sourceTableName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._hideGrandTotalColumns {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._formulaStore {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._refreshUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._rowColumnRuleChangeUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._aggregateRuleChangeUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_PivotOwnerArchive, rhs: TST_PivotOwnerArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pivotOwnerUid != rhs_storage._pivotOwnerUid {return false}
        if _storage._groupingColumnsForRows != rhs_storage._groupingColumnsForRows {return false}
        if _storage._groupingColumnsForColumns != rhs_storage._groupingColumnsForColumns {return false}
        if _storage._aggregateColumns != rhs_storage._aggregateColumns {return false}
        if _storage._flatteningDimension != rhs_storage._flatteningDimension {return false}
        if _storage._isEmptyPivot != rhs_storage._isEmptyPivot {return false}
        if _storage._sourceTableUid != rhs_storage._sourceTableUid {return false}
        if _storage._refreshTimestamp != rhs_storage._refreshTimestamp {return false}
        if _storage._grpgColOptionsMap != rhs_storage._grpgColOptionsMap {return false}
        if _storage._hideGrandTotalRows != rhs_storage._hideGrandTotalRows {return false}
        if _storage._sourceTableName != rhs_storage._sourceTableName {return false}
        if _storage._hideGrandTotalColumns != rhs_storage._hideGrandTotalColumns {return false}
        if _storage._formulaStore != rhs_storage._formulaStore {return false}
        if _storage._refreshUid != rhs_storage._refreshUid {return false}
        if _storage._rowColumnRuleChangeUid != rhs_storage._rowColumnRuleChangeUid {return false}
        if _storage._aggregateRuleChangeUid != rhs_storage._aggregateRuleChangeUid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_RichTextPayloadArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RichTextPayloadArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}storage\0\u{1}range\0\u{1}cellid\0")

  public var isInitialized: Bool {
    if self._storage == nil {return false}
    if self._cellid == nil {return false}
    if let v = self._storage, !v.isInitialized {return false}
    if let v = self._range, !v.isInitialized {return false}
    if let v = self._cellid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._storage) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._range) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cellid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._storage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._range {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cellid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_RichTextPayloadArchive, rhs: TST_RichTextPayloadArchive) -> Bool {
    if lhs._storage != rhs._storage {return false}
    if lhs._range != rhs._range {return false}
    if lhs._cellid != rhs._cellid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_FormulaEqualsTokenAttachmentArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormulaEqualsTokenAttachmentArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_FormulaEqualsTokenAttachmentArchive, rhs: TST_FormulaEqualsTokenAttachmentArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CellFillStandIn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellFillStandIn"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}fill\0\u{3}type_is_mixed\0\u{3}color_has_been_modified\0\u{3}color_is_mixed\0\u{3}first_color_has_been_modified\0\u{3}first_color_is_mixed\0\u{3}last_color_has_been_modified\0\u{3}last_color_is_mixed\0\u{3}gradient_type_has_been_modified\0\u{3}gradient_type_is_mixed\0\u{3}gradient_angle_has_been_modified\0\u{3}gradient_angle_is_mixed\0\u{3}image_data_has_been_modified\0\u{3}image_data_is_mixed\0\u{3}tint_color_has_been_modified\0\u{3}tint_color_is_mixed\0\u{3}scale_has_been_modified\0\u{3}scale_is_mixed\0\u{3}technique_has_been_modified\0\u{3}technique_is_mixed\0")

  fileprivate class _StorageClass {
    var _fill: TSD_FillArchive? = nil
    var _typeIsMixed: Bool? = nil
    var _colorHasBeenModified: Bool? = nil
    var _colorIsMixed: Bool? = nil
    var _firstColorHasBeenModified: Bool? = nil
    var _firstColorIsMixed: Bool? = nil
    var _lastColorHasBeenModified: Bool? = nil
    var _lastColorIsMixed: Bool? = nil
    var _gradientTypeHasBeenModified: Bool? = nil
    var _gradientTypeIsMixed: Bool? = nil
    var _gradientAngleHasBeenModified: Bool? = nil
    var _gradientAngleIsMixed: Bool? = nil
    var _imageDataHasBeenModified: Bool? = nil
    var _imageDataIsMixed: Bool? = nil
    var _tintColorHasBeenModified: Bool? = nil
    var _tintColorIsMixed: Bool? = nil
    var _scaleHasBeenModified: Bool? = nil
    var _scaleIsMixed: Bool? = nil
    var _techniqueHasBeenModified: Bool? = nil
    var _techniqueIsMixed: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _fill = source._fill
      _typeIsMixed = source._typeIsMixed
      _colorHasBeenModified = source._colorHasBeenModified
      _colorIsMixed = source._colorIsMixed
      _firstColorHasBeenModified = source._firstColorHasBeenModified
      _firstColorIsMixed = source._firstColorIsMixed
      _lastColorHasBeenModified = source._lastColorHasBeenModified
      _lastColorIsMixed = source._lastColorIsMixed
      _gradientTypeHasBeenModified = source._gradientTypeHasBeenModified
      _gradientTypeIsMixed = source._gradientTypeIsMixed
      _gradientAngleHasBeenModified = source._gradientAngleHasBeenModified
      _gradientAngleIsMixed = source._gradientAngleIsMixed
      _imageDataHasBeenModified = source._imageDataHasBeenModified
      _imageDataIsMixed = source._imageDataIsMixed
      _tintColorHasBeenModified = source._tintColorHasBeenModified
      _tintColorIsMixed = source._tintColorIsMixed
      _scaleHasBeenModified = source._scaleHasBeenModified
      _scaleIsMixed = source._scaleIsMixed
      _techniqueHasBeenModified = source._techniqueHasBeenModified
      _techniqueIsMixed = source._techniqueIsMixed
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._fill == nil {return false}
      if let v = _storage._fill, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._fill) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._typeIsMixed) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._colorHasBeenModified) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._colorIsMixed) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._firstColorHasBeenModified) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._firstColorIsMixed) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._lastColorHasBeenModified) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._lastColorIsMixed) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._gradientTypeHasBeenModified) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._gradientTypeIsMixed) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._gradientAngleHasBeenModified) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._gradientAngleIsMixed) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._imageDataHasBeenModified) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._imageDataIsMixed) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._tintColorHasBeenModified) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._tintColorIsMixed) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._scaleHasBeenModified) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._scaleIsMixed) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._techniqueHasBeenModified) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._techniqueIsMixed) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._fill {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._typeIsMixed {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._colorHasBeenModified {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._colorIsMixed {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._firstColorHasBeenModified {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._firstColorIsMixed {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._lastColorHasBeenModified {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._lastColorIsMixed {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._gradientTypeHasBeenModified {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._gradientTypeIsMixed {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._gradientAngleHasBeenModified {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._gradientAngleIsMixed {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._imageDataHasBeenModified {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._imageDataIsMixed {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._tintColorHasBeenModified {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._tintColorIsMixed {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._scaleHasBeenModified {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._scaleIsMixed {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._techniqueHasBeenModified {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._techniqueIsMixed {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CellFillStandIn, rhs: TST_CellFillStandIn) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._fill != rhs_storage._fill {return false}
        if _storage._typeIsMixed != rhs_storage._typeIsMixed {return false}
        if _storage._colorHasBeenModified != rhs_storage._colorHasBeenModified {return false}
        if _storage._colorIsMixed != rhs_storage._colorIsMixed {return false}
        if _storage._firstColorHasBeenModified != rhs_storage._firstColorHasBeenModified {return false}
        if _storage._firstColorIsMixed != rhs_storage._firstColorIsMixed {return false}
        if _storage._lastColorHasBeenModified != rhs_storage._lastColorHasBeenModified {return false}
        if _storage._lastColorIsMixed != rhs_storage._lastColorIsMixed {return false}
        if _storage._gradientTypeHasBeenModified != rhs_storage._gradientTypeHasBeenModified {return false}
        if _storage._gradientTypeIsMixed != rhs_storage._gradientTypeIsMixed {return false}
        if _storage._gradientAngleHasBeenModified != rhs_storage._gradientAngleHasBeenModified {return false}
        if _storage._gradientAngleIsMixed != rhs_storage._gradientAngleIsMixed {return false}
        if _storage._imageDataHasBeenModified != rhs_storage._imageDataHasBeenModified {return false}
        if _storage._imageDataIsMixed != rhs_storage._imageDataIsMixed {return false}
        if _storage._tintColorHasBeenModified != rhs_storage._tintColorHasBeenModified {return false}
        if _storage._tintColorIsMixed != rhs_storage._tintColorIsMixed {return false}
        if _storage._scaleHasBeenModified != rhs_storage._scaleHasBeenModified {return false}
        if _storage._scaleIsMixed != rhs_storage._scaleIsMixed {return false}
        if _storage._techniqueHasBeenModified != rhs_storage._techniqueHasBeenModified {return false}
        if _storage._techniqueIsMixed != rhs_storage._techniqueIsMixed {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_FormulaSelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormulaSelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}activeTokenCharIndex\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._activeTokenCharIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._activeTokenCharIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_FormulaSelectionArchive, rhs: TST_FormulaSelectionArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._activeTokenCharIndex != rhs._activeTokenCharIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CellBorderArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellBorderArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}top_stroke\0\u{3}top_stroke_order\0\u{3}right_stroke\0\u{3}right_stroke_order\0\u{3}bottom_stroke\0\u{3}bottom_stroke_order\0\u{3}left_stroke\0\u{3}left_stroke_order\0")

  public var isInitialized: Bool {
    if let v = self._topStroke, !v.isInitialized {return false}
    if let v = self._rightStroke, !v.isInitialized {return false}
    if let v = self._bottomStroke, !v.isInitialized {return false}
    if let v = self._leftStroke, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._topStroke) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._topStrokeOrder) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._rightStroke) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._rightStrokeOrder) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._bottomStroke) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._bottomStrokeOrder) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._leftStroke) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self._leftStrokeOrder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._topStroke {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._topStrokeOrder {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._rightStroke {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._rightStrokeOrder {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._bottomStroke {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._bottomStrokeOrder {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._leftStroke {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._leftStrokeOrder {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CellBorderArchive, rhs: TST_CellBorderArchive) -> Bool {
    if lhs._topStroke != rhs._topStroke {return false}
    if lhs._topStrokeOrder != rhs._topStrokeOrder {return false}
    if lhs._rightStroke != rhs._rightStroke {return false}
    if lhs._rightStrokeOrder != rhs._rightStrokeOrder {return false}
    if lhs._bottomStroke != rhs._bottomStroke {return false}
    if lhs._bottomStrokeOrder != rhs._bottomStrokeOrder {return false}
    if lhs._leftStroke != rhs._leftStroke {return false}
    if lhs._leftStrokeOrder != rhs._leftStrokeOrder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_DefaultCellStylesContainerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DefaultCellStylesContainerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}table_style_network\0\u{3}row_uids\0\u{3}column_uids\0\u{3}row_types\0\u{3}column_types\0\u{3}is_a_pivot_table\0")

  public var isInitialized: Bool {
    if self._tableStyleNetwork == nil {return false}
    if let v = self._tableStyleNetwork, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rowUids) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.columnUids) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tableStyleNetwork) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rowUids) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.columnUids) }()
      case 4: try { try decoder.decodeRepeatedUInt32Field(value: &self.rowTypes) }()
      case 5: try { try decoder.decodeRepeatedUInt32Field(value: &self.columnTypes) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._isAPivotTable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tableStyleNetwork {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.rowUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rowUids, fieldNumber: 2)
    }
    if !self.columnUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.columnUids, fieldNumber: 3)
    }
    if !self.rowTypes.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.rowTypes, fieldNumber: 4)
    }
    if !self.columnTypes.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.columnTypes, fieldNumber: 5)
    }
    try { if let v = self._isAPivotTable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_DefaultCellStylesContainerArchive, rhs: TST_DefaultCellStylesContainerArchive) -> Bool {
    if lhs._tableStyleNetwork != rhs._tableStyleNetwork {return false}
    if lhs.rowUids != rhs.rowUids {return false}
    if lhs.columnUids != rhs.columnUids {return false}
    if lhs.rowTypes != rhs.rowTypes {return false}
    if lhs.columnTypes != rhs.columnTypes {return false}
    if lhs._isAPivotTable != rhs._isAPivotTable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_MultiTableRemapperArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MultiTableRemapperArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}mapping_purpose\0\u{3}should_steal_references\0\u{3}can_reuse_table_names\0\u{3}owner_uid_mapper\0\u{3}backing_tables_for_charts\0\u{3}cross_document_paste\0\u{3}nested_inner_mapper\0")

  public var isInitialized: Bool {
    if self._mappingPurpose == nil {return false}
    if self._shouldStealReferences == nil {return false}
    if self._canReuseTableNames == nil {return false}
    if self._backingTablesForCharts == nil {return false}
    if self._crossDocumentPaste == nil {return false}
    if self._nestedInnerMapper == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.ownerUidMapper) {return false}
    if let v = self._backingTablesForCharts, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._mappingPurpose) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._shouldStealReferences) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._canReuseTableNames) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.ownerUidMapper) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._backingTablesForCharts) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._crossDocumentPaste) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._nestedInnerMapper) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mappingPurpose {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._shouldStealReferences {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._canReuseTableNames {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    if !self.ownerUidMapper.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ownerUidMapper, fieldNumber: 4)
    }
    try { if let v = self._backingTablesForCharts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._crossDocumentPaste {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._nestedInnerMapper {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_MultiTableRemapperArchive, rhs: TST_MultiTableRemapperArchive) -> Bool {
    if lhs._mappingPurpose != rhs._mappingPurpose {return false}
    if lhs._shouldStealReferences != rhs._shouldStealReferences {return false}
    if lhs._canReuseTableNames != rhs._canReuseTableNames {return false}
    if lhs.ownerUidMapper != rhs.ownerUidMapper {return false}
    if lhs._backingTablesForCharts != rhs._backingTablesForCharts {return false}
    if lhs._crossDocumentPaste != rhs._crossDocumentPaste {return false}
    if lhs._nestedInnerMapper != rhs._nestedInnerMapper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_MultiTableRemapperArchive.Purpose: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DEFAULT\0\u{1}GROUPING\0\u{1}PAGES_SECTION_DUPLICATION_NONCOLLAB\0")
}

extension TST_ChangePropagationMapWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangePropagationMapWrapper"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}replacement_behavior\0\u{3}style_replace_prototypes\0\u{3}style_replace_replacements\0\u{3}style_modify_styles\0\u{3}style_modify_old_prop_maps\0\u{3}style_modify_new_prop_maps\0\u{3}style_delete_prototypes\0\u{3}style_delete_replacements\0\u{3}table_preset_replace_prototype\0\u{3}table_preset_replace_replacement\0\u{3}table_preset_delete_prototype\0\u{3}table_preset_delete_replacement\0")

  fileprivate class _StorageClass {
    var _replacementBehavior: Int32? = nil
    var _styleReplacePrototypes: [TSP_Reference] = []
    var _styleReplaceReplacements: [TSP_Reference] = []
    var _styleModifyStyles: [TSP_Reference] = []
    var _styleModifyOldPropMaps: [TSP_Reference] = []
    var _styleModifyNewPropMaps: [TSP_Reference] = []
    var _styleDeletePrototypes: [TSP_Reference] = []
    var _styleDeleteReplacements: [TSP_Reference] = []
    var _tablePresetReplacePrototype: TSP_Reference? = nil
    var _tablePresetReplaceReplacement: TSP_Reference? = nil
    var _tablePresetDeletePrototype: TSP_Reference? = nil
    var _tablePresetDeleteReplacement: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _replacementBehavior = source._replacementBehavior
      _styleReplacePrototypes = source._styleReplacePrototypes
      _styleReplaceReplacements = source._styleReplaceReplacements
      _styleModifyStyles = source._styleModifyStyles
      _styleModifyOldPropMaps = source._styleModifyOldPropMaps
      _styleModifyNewPropMaps = source._styleModifyNewPropMaps
      _styleDeletePrototypes = source._styleDeletePrototypes
      _styleDeleteReplacements = source._styleDeleteReplacements
      _tablePresetReplacePrototype = source._tablePresetReplacePrototype
      _tablePresetReplaceReplacement = source._tablePresetReplaceReplacement
      _tablePresetDeletePrototype = source._tablePresetDeletePrototype
      _tablePresetDeleteReplacement = source._tablePresetDeleteReplacement
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._replacementBehavior == nil {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._styleReplacePrototypes) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._styleReplaceReplacements) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._styleModifyStyles) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._styleModifyOldPropMaps) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._styleModifyNewPropMaps) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._styleDeletePrototypes) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._styleDeleteReplacements) {return false}
      if let v = _storage._tablePresetReplacePrototype, !v.isInitialized {return false}
      if let v = _storage._tablePresetReplaceReplacement, !v.isInitialized {return false}
      if let v = _storage._tablePresetDeletePrototype, !v.isInitialized {return false}
      if let v = _storage._tablePresetDeleteReplacement, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._replacementBehavior) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._styleReplacePrototypes) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._styleReplaceReplacements) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._styleModifyStyles) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._styleModifyOldPropMaps) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._styleModifyNewPropMaps) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._styleDeletePrototypes) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._styleDeleteReplacements) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._tablePresetReplacePrototype) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._tablePresetReplaceReplacement) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._tablePresetDeletePrototype) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._tablePresetDeleteReplacement) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._replacementBehavior {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      } }()
      if !_storage._styleReplacePrototypes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._styleReplacePrototypes, fieldNumber: 2)
      }
      if !_storage._styleReplaceReplacements.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._styleReplaceReplacements, fieldNumber: 3)
      }
      if !_storage._styleModifyStyles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._styleModifyStyles, fieldNumber: 4)
      }
      if !_storage._styleModifyOldPropMaps.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._styleModifyOldPropMaps, fieldNumber: 5)
      }
      if !_storage._styleModifyNewPropMaps.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._styleModifyNewPropMaps, fieldNumber: 6)
      }
      if !_storage._styleDeletePrototypes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._styleDeletePrototypes, fieldNumber: 7)
      }
      if !_storage._styleDeleteReplacements.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._styleDeleteReplacements, fieldNumber: 8)
      }
      try { if let v = _storage._tablePresetReplacePrototype {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._tablePresetReplaceReplacement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._tablePresetDeletePrototype {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._tablePresetDeleteReplacement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ChangePropagationMapWrapper, rhs: TST_ChangePropagationMapWrapper) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._replacementBehavior != rhs_storage._replacementBehavior {return false}
        if _storage._styleReplacePrototypes != rhs_storage._styleReplacePrototypes {return false}
        if _storage._styleReplaceReplacements != rhs_storage._styleReplaceReplacements {return false}
        if _storage._styleModifyStyles != rhs_storage._styleModifyStyles {return false}
        if _storage._styleModifyOldPropMaps != rhs_storage._styleModifyOldPropMaps {return false}
        if _storage._styleModifyNewPropMaps != rhs_storage._styleModifyNewPropMaps {return false}
        if _storage._styleDeletePrototypes != rhs_storage._styleDeletePrototypes {return false}
        if _storage._styleDeleteReplacements != rhs_storage._styleDeleteReplacements {return false}
        if _storage._tablePresetReplacePrototype != rhs_storage._tablePresetReplacePrototype {return false}
        if _storage._tablePresetReplaceReplacement != rhs_storage._tablePresetReplaceReplacement {return false}
        if _storage._tablePresetDeletePrototype != rhs_storage._tablePresetDeletePrototype {return false}
        if _storage._tablePresetDeleteReplacement != rhs_storage._tablePresetDeleteReplacement {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_SummaryCellVendorArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SummaryCellVendorArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}table_info\0\u{1}entries\0")

  public var isInitialized: Bool {
    if self._tableInfo == nil {return false}
    if let v = self._tableInfo, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.entries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tableInfo) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tableInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_SummaryCellVendorArchive, rhs: TST_SummaryCellVendorArchive) -> Bool {
    if lhs._tableInfo != rhs._tableInfo {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_SummaryCellVendorArchive.SummaryCellEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_SummaryCellVendorArchive.protoMessageName + ".SummaryCellEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}wildcardUID\0\u{1}columnUID\0\u{1}cell\0")

  public var isInitialized: Bool {
    if self._wildcardUid == nil {return false}
    if self._columnUid == nil {return false}
    if self._cell == nil {return false}
    if let v = self._wildcardUid, !v.isInitialized {return false}
    if let v = self._columnUid, !v.isInitialized {return false}
    if let v = self._cell, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._wildcardUid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._columnUid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cell) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._wildcardUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._columnUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cell {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_SummaryCellVendorArchive.SummaryCellEntry, rhs: TST_SummaryCellVendorArchive.SummaryCellEntry) -> Bool {
    if lhs._wildcardUid != rhs._wildcardUid {return false}
    if lhs._columnUid != rhs._columnUid {return false}
    if lhs._cell != rhs._cell {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CategoryOrderArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CategoryOrderArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}table_info\0\u{3}uid_map\0")

  public var isInitialized: Bool {
    if self._tableInfo == nil {return false}
    if self._uidMap == nil {return false}
    if let v = self._tableInfo, !v.isInitialized {return false}
    if let v = self._uidMap, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tableInfo) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._uidMap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tableInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._uidMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CategoryOrderArchive, rhs: TST_CategoryOrderArchive) -> Bool {
    if lhs._tableInfo != rhs._tableInfo {return false}
    if lhs._uidMap != rhs._uidMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_PivotOrderArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PivotOrderArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}uid_map\0")

  public var isInitialized: Bool {
    if let v = self._uidMap, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uidMap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uidMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_PivotOrderArchive, rhs: TST_PivotOrderArchive) -> Bool {
    if lhs._uidMap != rhs._uidMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_HeaderNameMgrTileArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeaderNameMgrTileArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}first_fragment\0\u{3}last_fragment\0\u{3}name_frag_entries\0")

  public var isInitialized: Bool {
    if self._firstFragment == nil {return false}
    if self._lastFragment == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.nameFragEntries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._firstFragment) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._lastFragment) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.nameFragEntries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._firstFragment {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lastFragment {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.nameFragEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nameFragEntries, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_HeaderNameMgrTileArchive, rhs: TST_HeaderNameMgrTileArchive) -> Bool {
    if lhs._firstFragment != rhs._firstFragment {return false}
    if lhs._lastFragment != rhs._lastFragment {return false}
    if lhs.nameFragEntries != rhs.nameFragEntries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_HeaderNameMgrTileArchive.NameFragmentArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_HeaderNameMgrTileArchive.protoMessageName + ".NameFragmentArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}name_fragment\0\u{3}name_precedent\0\u{3}uses_of_name_fragment\0")

  public var isInitialized: Bool {
    if self._nameFragment == nil {return false}
    if self._namePrecedent == nil {return false}
    if let v = self._usesOfNameFragment, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._nameFragment) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._namePrecedent) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usesOfNameFragment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nameFragment {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._namePrecedent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._usesOfNameFragment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_HeaderNameMgrTileArchive.NameFragmentArchive, rhs: TST_HeaderNameMgrTileArchive.NameFragmentArchive) -> Bool {
    if lhs._nameFragment != rhs._nameFragment {return false}
    if lhs._namePrecedent != rhs._namePrecedent {return false}
    if lhs._usesOfNameFragment != rhs._usesOfNameFragment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_HeaderNameMgrArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeaderNameMgrArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}owner_uid\0\u{3}nrm_owner_uid\0\u{3}per_tables\0\u{3}name_frag_tiles\0")

  public var isInitialized: Bool {
    if self._ownerUid == nil {return false}
    if let v = self._ownerUid, !v.isInitialized {return false}
    if let v = self._nrmOwnerUid, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.perTables) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.nameFragTiles) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ownerUid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._nrmOwnerUid) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.perTables) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.nameFragTiles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownerUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nrmOwnerUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.perTables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.perTables, fieldNumber: 3)
    }
    if !self.nameFragTiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nameFragTiles, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_HeaderNameMgrArchive, rhs: TST_HeaderNameMgrArchive) -> Bool {
    if lhs._ownerUid != rhs._ownerUid {return false}
    if lhs._nrmOwnerUid != rhs._nrmOwnerUid {return false}
    if lhs.perTables != rhs.perTables {return false}
    if lhs.nameFragTiles != rhs.nameFragTiles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_HeaderNameMgrArchive.PerTableArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_HeaderNameMgrArchive.protoMessageName + ".PerTableArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}table_uid\0\u{3}per_table_precedent\0\u{3}is_deleted\0\u{4}\u{2}header_row_uids\0\u{3}header_column_uids\0\u{3}update_header_row_uids\0\u{3}update_header_column_uids\0")

  public var isInitialized: Bool {
    if self._tableUid == nil {return false}
    if self._perTablePrecedent == nil {return false}
    if let v = self._tableUid, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.headerRowUids) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.headerColumnUids) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.updateHeaderRowUids) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.updateHeaderColumnUids) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tableUid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._perTablePrecedent) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._isDeleted) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.headerRowUids) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.headerColumnUids) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.updateHeaderRowUids) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.updateHeaderColumnUids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tableUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._perTablePrecedent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._isDeleted {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    if !self.headerRowUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headerRowUids, fieldNumber: 5)
    }
    if !self.headerColumnUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headerColumnUids, fieldNumber: 6)
    }
    if !self.updateHeaderRowUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updateHeaderRowUids, fieldNumber: 7)
    }
    if !self.updateHeaderColumnUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updateHeaderColumnUids, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_HeaderNameMgrArchive.PerTableArchive, rhs: TST_HeaderNameMgrArchive.PerTableArchive) -> Bool {
    if lhs._tableUid != rhs._tableUid {return false}
    if lhs._perTablePrecedent != rhs._perTablePrecedent {return false}
    if lhs._isDeleted != rhs._isDeleted {return false}
    if lhs.headerRowUids != rhs.headerRowUids {return false}
    if lhs.headerColumnUids != rhs.headerColumnUids {return false}
    if lhs.updateHeaderRowUids != rhs.updateHeaderRowUids {return false}
    if lhs.updateHeaderColumnUids != rhs.updateHeaderColumnUids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_WidthHeightCacheFittingEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WidthHeightCacheFittingEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}fitting_index\0\u{3}fitting_size\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._fittingIndex) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._fittingSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fittingIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fittingSize {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_WidthHeightCacheFittingEntry, rhs: TST_WidthHeightCacheFittingEntry) -> Bool {
    if lhs._fittingIndex != rhs._fittingIndex {return false}
    if lhs._fittingSize != rhs._fittingSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_WidthHeightCache: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WidthHeightCache"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}rows_fitting_entries\0\u{4}\u{2}columns_count\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rowsFittingEntries) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._columnsCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.rowsFittingEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rowsFittingEntries, fieldNumber: 1)
    }
    try { if let v = self._columnsCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_WidthHeightCache, rhs: TST_WidthHeightCache) -> Bool {
    if lhs.rowsFittingEntries != rhs.rowsFittingEntries {return false}
    if lhs._columnsCount != rhs._columnsCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_LayoutEngineArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LayoutEngineArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}width_height_cache\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._widthHeightCache) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._widthHeightCache {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_LayoutEngineArchive, rhs: TST_LayoutEngineArchive) -> Bool {
    if lhs._widthHeightCache != rhs._widthHeightCache {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CollaboratorTableCursorSubselectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CollaboratorTableCursorSubselectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cell_uid_list\0\u{4}\u{2}selection_type\0\u{3}row_column_uid_list\0")

  public var isInitialized: Bool {
    if let v = self._cellUidList, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rowColumnUidList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cellUidList) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._selectionType) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.rowColumnUidList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cellUidList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._selectionType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    if !self.rowColumnUidList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rowColumnUidList, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CollaboratorTableCursorSubselectionArchive, rhs: TST_CollaboratorTableCursorSubselectionArchive) -> Bool {
    if lhs._cellUidList != rhs._cellUidList {return false}
    if lhs._selectionType != rhs._selectionType {return false}
    if lhs.rowColumnUidList != rhs.rowColumnUidList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
