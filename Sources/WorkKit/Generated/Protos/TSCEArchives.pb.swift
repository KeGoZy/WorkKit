// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TSCEArchives.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct TSCE_CellReferenceArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var column: UInt32 {
    get {return _column ?? 0}
    set {_column = newValue}
  }
  /// Returns true if `column` has been explicitly set.
  var hasColumn: Bool {return self._column != nil}
  /// Clears the value of `column`. Subsequent reads from it will return its default value.
  mutating func clearColumn() {self._column = nil}

  var row: UInt32 {
    get {return _row ?? 0}
    set {_row = newValue}
  }
  /// Returns true if `row` has been explicitly set.
  var hasRow: Bool {return self._row != nil}
  /// Clears the value of `row`. Subsequent reads from it will return its default value.
  mutating func clearRow() {self._row = nil}

  var tableID: TSP_CFUUIDArchive {
    get {return _tableID ?? TSP_CFUUIDArchive()}
    set {_tableID = newValue}
  }
  /// Returns true if `tableID` has been explicitly set.
  var hasTableID: Bool {return self._tableID != nil}
  /// Clears the value of `tableID`. Subsequent reads from it will return its default value.
  mutating func clearTableID() {self._tableID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _column: UInt32? = nil
  fileprivate var _row: UInt32? = nil
  fileprivate var _tableID: TSP_CFUUIDArchive? = nil
}

struct TSCE_InternalCellReferenceArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var coordinate: TSCE_CellCoordinateArchive {
    get {return _coordinate ?? TSCE_CellCoordinateArchive()}
    set {_coordinate = newValue}
  }
  /// Returns true if `coordinate` has been explicitly set.
  var hasCoordinate: Bool {return self._coordinate != nil}
  /// Clears the value of `coordinate`. Subsequent reads from it will return its default value.
  mutating func clearCoordinate() {self._coordinate = nil}

  var ownerID: UInt32 {
    get {return _ownerID ?? 0}
    set {_ownerID = newValue}
  }
  /// Returns true if `ownerID` has been explicitly set.
  var hasOwnerID: Bool {return self._ownerID != nil}
  /// Clears the value of `ownerID`. Subsequent reads from it will return its default value.
  mutating func clearOwnerID() {self._ownerID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _coordinate: TSCE_CellCoordinateArchive? = nil
  fileprivate var _ownerID: UInt32? = nil
}

struct TSCE_RelativeCellRefArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var relativeRowOffset: Int32 {
    get {return _relativeRowOffset ?? 0}
    set {_relativeRowOffset = newValue}
  }
  /// Returns true if `relativeRowOffset` has been explicitly set.
  var hasRelativeRowOffset: Bool {return self._relativeRowOffset != nil}
  /// Clears the value of `relativeRowOffset`. Subsequent reads from it will return its default value.
  mutating func clearRelativeRowOffset() {self._relativeRowOffset = nil}

  var relativeColumnOffset: Int32 {
    get {return _relativeColumnOffset ?? 0}
    set {_relativeColumnOffset = newValue}
  }
  /// Returns true if `relativeColumnOffset` has been explicitly set.
  var hasRelativeColumnOffset: Bool {return self._relativeColumnOffset != nil}
  /// Clears the value of `relativeColumnOffset`. Subsequent reads from it will return its default value.
  mutating func clearRelativeColumnOffset() {self._relativeColumnOffset = nil}

  var tableUid: TSP_UUID {
    get {return _tableUid ?? TSP_UUID()}
    set {_tableUid = newValue}
  }
  /// Returns true if `tableUid` has been explicitly set.
  var hasTableUid: Bool {return self._tableUid != nil}
  /// Clears the value of `tableUid`. Subsequent reads from it will return its default value.
  mutating func clearTableUid() {self._tableUid = nil}

  var preserveColumn: Bool {
    get {return _preserveColumn ?? false}
    set {_preserveColumn = newValue}
  }
  /// Returns true if `preserveColumn` has been explicitly set.
  var hasPreserveColumn: Bool {return self._preserveColumn != nil}
  /// Clears the value of `preserveColumn`. Subsequent reads from it will return its default value.
  mutating func clearPreserveColumn() {self._preserveColumn = nil}

  var preserveRow: Bool {
    get {return _preserveRow ?? false}
    set {_preserveRow = newValue}
  }
  /// Returns true if `preserveRow` has been explicitly set.
  var hasPreserveRow: Bool {return self._preserveRow != nil}
  /// Clears the value of `preserveRow`. Subsequent reads from it will return its default value.
  mutating func clearPreserveRow() {self._preserveRow = nil}

  var isSpanningColumn: Bool {
    get {return _isSpanningColumn ?? false}
    set {_isSpanningColumn = newValue}
  }
  /// Returns true if `isSpanningColumn` has been explicitly set.
  var hasIsSpanningColumn: Bool {return self._isSpanningColumn != nil}
  /// Clears the value of `isSpanningColumn`. Subsequent reads from it will return its default value.
  mutating func clearIsSpanningColumn() {self._isSpanningColumn = nil}

  var isSpanningRow: Bool {
    get {return _isSpanningRow ?? false}
    set {_isSpanningRow = newValue}
  }
  /// Returns true if `isSpanningRow` has been explicitly set.
  var hasIsSpanningRow: Bool {return self._isSpanningRow != nil}
  /// Clears the value of `isSpanningRow`. Subsequent reads from it will return its default value.
  mutating func clearIsSpanningRow() {self._isSpanningRow = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _relativeRowOffset: Int32? = nil
  fileprivate var _relativeColumnOffset: Int32? = nil
  fileprivate var _tableUid: TSP_UUID? = nil
  fileprivate var _preserveColumn: Bool? = nil
  fileprivate var _preserveRow: Bool? = nil
  fileprivate var _isSpanningColumn: Bool? = nil
  fileprivate var _isSpanningRow: Bool? = nil
}

struct TSCE_RangeReferenceArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tableID: TSP_CFUUIDArchive {
    get {return _tableID ?? TSP_CFUUIDArchive()}
    set {_tableID = newValue}
  }
  /// Returns true if `tableID` has been explicitly set.
  var hasTableID: Bool {return self._tableID != nil}
  /// Clears the value of `tableID`. Subsequent reads from it will return its default value.
  mutating func clearTableID() {self._tableID = nil}

  var topLeftColumn: UInt32 {
    get {return _topLeftColumn ?? 0}
    set {_topLeftColumn = newValue}
  }
  /// Returns true if `topLeftColumn` has been explicitly set.
  var hasTopLeftColumn: Bool {return self._topLeftColumn != nil}
  /// Clears the value of `topLeftColumn`. Subsequent reads from it will return its default value.
  mutating func clearTopLeftColumn() {self._topLeftColumn = nil}

  var topLeftRow: UInt32 {
    get {return _topLeftRow ?? 0}
    set {_topLeftRow = newValue}
  }
  /// Returns true if `topLeftRow` has been explicitly set.
  var hasTopLeftRow: Bool {return self._topLeftRow != nil}
  /// Clears the value of `topLeftRow`. Subsequent reads from it will return its default value.
  mutating func clearTopLeftRow() {self._topLeftRow = nil}

  var bottomRightColumn: UInt32 {
    get {return _bottomRightColumn ?? 0}
    set {_bottomRightColumn = newValue}
  }
  /// Returns true if `bottomRightColumn` has been explicitly set.
  var hasBottomRightColumn: Bool {return self._bottomRightColumn != nil}
  /// Clears the value of `bottomRightColumn`. Subsequent reads from it will return its default value.
  mutating func clearBottomRightColumn() {self._bottomRightColumn = nil}

  var bottomRightRow: UInt32 {
    get {return _bottomRightRow ?? 0}
    set {_bottomRightRow = newValue}
  }
  /// Returns true if `bottomRightRow` has been explicitly set.
  var hasBottomRightRow: Bool {return self._bottomRightRow != nil}
  /// Clears the value of `bottomRightRow`. Subsequent reads from it will return its default value.
  mutating func clearBottomRightRow() {self._bottomRightRow = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tableID: TSP_CFUUIDArchive? = nil
  fileprivate var _topLeftColumn: UInt32? = nil
  fileprivate var _topLeftRow: UInt32? = nil
  fileprivate var _bottomRightColumn: UInt32? = nil
  fileprivate var _bottomRightRow: UInt32? = nil
}

struct TSCE_InternalRangeReferenceArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerID: UInt32 {
    get {return _ownerID ?? 0}
    set {_ownerID = newValue}
  }
  /// Returns true if `ownerID` has been explicitly set.
  var hasOwnerID: Bool {return self._ownerID != nil}
  /// Clears the value of `ownerID`. Subsequent reads from it will return its default value.
  mutating func clearOwnerID() {self._ownerID = nil}

  var range: TSCE_RangeCoordinateArchive {
    get {return _range ?? TSCE_RangeCoordinateArchive()}
    set {_range = newValue}
  }
  /// Returns true if `range` has been explicitly set.
  var hasRange: Bool {return self._range != nil}
  /// Clears the value of `range`. Subsequent reads from it will return its default value.
  mutating func clearRange() {self._range = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ownerID: UInt32? = nil
  fileprivate var _range: TSCE_RangeCoordinateArchive? = nil
}

struct TSCE_IndexSetArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [TSCE_IndexSetArchive.IndexSetEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct IndexSetEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rangeBegin: Int32 {
      get {return _rangeBegin ?? 0}
      set {_rangeBegin = newValue}
    }
    /// Returns true if `rangeBegin` has been explicitly set.
    var hasRangeBegin: Bool {return self._rangeBegin != nil}
    /// Clears the value of `rangeBegin`. Subsequent reads from it will return its default value.
    mutating func clearRangeBegin() {self._rangeBegin = nil}

    var rangeEnd: Int32 {
      get {return _rangeEnd ?? 0}
      set {_rangeEnd = newValue}
    }
    /// Returns true if `rangeEnd` has been explicitly set.
    var hasRangeEnd: Bool {return self._rangeEnd != nil}
    /// Clears the value of `rangeEnd`. Subsequent reads from it will return its default value.
    mutating func clearRangeEnd() {self._rangeEnd = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _rangeBegin: Int32? = nil
    fileprivate var _rangeEnd: Int32? = nil
  }

  init() {}
}

struct TSCE_CellCoordSetArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var columnEntries: [TSCE_CellCoordSetArchive.ColumnEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ColumnEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var column: UInt32 {
      get {return _column ?? 0}
      set {_column = newValue}
    }
    /// Returns true if `column` has been explicitly set.
    var hasColumn: Bool {return self._column != nil}
    /// Clears the value of `column`. Subsequent reads from it will return its default value.
    mutating func clearColumn() {self._column = nil}

    var rowSet: TSCE_IndexSetArchive {
      get {return _rowSet ?? TSCE_IndexSetArchive()}
      set {_rowSet = newValue}
    }
    /// Returns true if `rowSet` has been explicitly set.
    var hasRowSet: Bool {return self._rowSet != nil}
    /// Clears the value of `rowSet`. Subsequent reads from it will return its default value.
    mutating func clearRowSet() {self._rowSet = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _column: UInt32? = nil
    fileprivate var _rowSet: TSCE_IndexSetArchive? = nil
  }

  init() {}
}

struct TSCE_InternalCellRefSetArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerEntries: [TSCE_InternalCellRefSetArchive.OwnerEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct OwnerEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ownerID: UInt32 {
      get {return _ownerID ?? 0}
      set {_ownerID = newValue}
    }
    /// Returns true if `ownerID` has been explicitly set.
    var hasOwnerID: Bool {return self._ownerID != nil}
    /// Clears the value of `ownerID`. Subsequent reads from it will return its default value.
    mutating func clearOwnerID() {self._ownerID = nil}

    var coordSet: TSCE_CellCoordSetArchive {
      get {return _coordSet ?? TSCE_CellCoordSetArchive()}
      set {_coordSet = newValue}
    }
    /// Returns true if `coordSet` has been explicitly set.
    var hasCoordSet: Bool {return self._coordSet != nil}
    /// Clears the value of `coordSet`. Subsequent reads from it will return its default value.
    mutating func clearCoordSet() {self._coordSet = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _ownerID: UInt32? = nil
    fileprivate var _coordSet: TSCE_CellCoordSetArchive? = nil
  }

  init() {}
}

struct TSCE_ColumnRowSize: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var numColumns: UInt32 {
    get {return _numColumns ?? 1}
    set {_numColumns = newValue}
  }
  /// Returns true if `numColumns` has been explicitly set.
  var hasNumColumns: Bool {return self._numColumns != nil}
  /// Clears the value of `numColumns`. Subsequent reads from it will return its default value.
  mutating func clearNumColumns() {self._numColumns = nil}

  var numRows: UInt32 {
    get {return _numRows ?? 1}
    set {_numRows = newValue}
  }
  /// Returns true if `numRows` has been explicitly set.
  var hasNumRows: Bool {return self._numRows != nil}
  /// Clears the value of `numRows`. Subsequent reads from it will return its default value.
  mutating func clearNumRows() {self._numRows = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _numColumns: UInt32? = nil
  fileprivate var _numRows: UInt32? = nil
}

struct TSCE_CellRectArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var origin: TSCE_CellCoordinateArchive {
    get {return _origin ?? TSCE_CellCoordinateArchive()}
    set {_origin = newValue}
  }
  /// Returns true if `origin` has been explicitly set.
  var hasOrigin: Bool {return self._origin != nil}
  /// Clears the value of `origin`. Subsequent reads from it will return its default value.
  mutating func clearOrigin() {self._origin = nil}

  var size: TSCE_ColumnRowSize {
    get {return _size ?? TSCE_ColumnRowSize()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _origin: TSCE_CellCoordinateArchive? = nil
  fileprivate var _size: TSCE_ColumnRowSize? = nil
}

struct TSCE_CellRefSetArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerEntries: [TSCE_CellRefSetArchive.OwnerEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct OwnerEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ownerUid: TSP_UUID {
      get {return _ownerUid ?? TSP_UUID()}
      set {_ownerUid = newValue}
    }
    /// Returns true if `ownerUid` has been explicitly set.
    var hasOwnerUid: Bool {return self._ownerUid != nil}
    /// Clears the value of `ownerUid`. Subsequent reads from it will return its default value.
    mutating func clearOwnerUid() {self._ownerUid = nil}

    var coordSet: TSCE_CellCoordSetArchive {
      get {return _coordSet ?? TSCE_CellCoordSetArchive()}
      set {_coordSet = newValue}
    }
    /// Returns true if `coordSet` has been explicitly set.
    var hasCoordSet: Bool {return self._coordSet != nil}
    /// Clears the value of `coordSet`. Subsequent reads from it will return its default value.
    mutating func clearCoordSet() {self._coordSet = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _ownerUid: TSP_UUID? = nil
    fileprivate var _coordSet: TSCE_CellCoordSetArchive? = nil
  }

  init() {}
}

struct TSCE_UidCoordSetArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var columnEntries: [TSCE_UidCoordSetArchive.ColumnEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ColumnEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var column: TSP_UUID {
      get {return _column ?? TSP_UUID()}
      set {_column = newValue}
    }
    /// Returns true if `column` has been explicitly set.
    var hasColumn: Bool {return self._column != nil}
    /// Clears the value of `column`. Subsequent reads from it will return its default value.
    mutating func clearColumn() {self._column = nil}

    var rowSet: [TSP_UUID] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _column: TSP_UUID? = nil
  }

  init() {}
}

struct TSCE_UidCellRefSetArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerEntries: [TSCE_UidCellRefSetArchive.OwnerEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct OwnerEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ownerUid: TSP_UUID {
      get {return _ownerUid ?? TSP_UUID()}
      set {_ownerUid = newValue}
    }
    /// Returns true if `ownerUid` has been explicitly set.
    var hasOwnerUid: Bool {return self._ownerUid != nil}
    /// Clears the value of `ownerUid`. Subsequent reads from it will return its default value.
    mutating func clearOwnerUid() {self._ownerUid = nil}

    var coordSet: TSCE_UidCoordSetArchive {
      get {return _coordSet ?? TSCE_UidCoordSetArchive()}
      set {_coordSet = newValue}
    }
    /// Returns true if `coordSet` has been explicitly set.
    var hasCoordSet: Bool {return self._coordSet != nil}
    /// Clears the value of `coordSet`. Subsequent reads from it will return its default value.
    mutating func clearCoordSet() {self._coordSet = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _ownerUid: TSP_UUID? = nil
    fileprivate var _coordSet: TSCE_UidCoordSetArchive? = nil
  }

  init() {}
}

struct TSCE_ReferencesToDirtyArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var toDirtyOwnerIds: TSCE_IndexSetArchive {
    get {return _toDirtyOwnerIds ?? TSCE_IndexSetArchive()}
    set {_toDirtyOwnerIds = newValue}
  }
  /// Returns true if `toDirtyOwnerIds` has been explicitly set.
  var hasToDirtyOwnerIds: Bool {return self._toDirtyOwnerIds != nil}
  /// Clears the value of `toDirtyOwnerIds`. Subsequent reads from it will return its default value.
  mutating func clearToDirtyOwnerIds() {self._toDirtyOwnerIds = nil}

  var toDirtyCells: TSCE_InternalCellRefSetArchive {
    get {return _toDirtyCells ?? TSCE_InternalCellRefSetArchive()}
    set {_toDirtyCells = newValue}
  }
  /// Returns true if `toDirtyCells` has been explicitly set.
  var hasToDirtyCells: Bool {return self._toDirtyCells != nil}
  /// Clears the value of `toDirtyCells`. Subsequent reads from it will return its default value.
  mutating func clearToDirtyCells() {self._toDirtyCells = nil}

  var toDirtyCellsAdditional: TSCE_InternalCellRefSetArchive {
    get {return _toDirtyCellsAdditional ?? TSCE_InternalCellRefSetArchive()}
    set {_toDirtyCellsAdditional = newValue}
  }
  /// Returns true if `toDirtyCellsAdditional` has been explicitly set.
  var hasToDirtyCellsAdditional: Bool {return self._toDirtyCellsAdditional != nil}
  /// Clears the value of `toDirtyCellsAdditional`. Subsequent reads from it will return its default value.
  mutating func clearToDirtyCellsAdditional() {self._toDirtyCellsAdditional = nil}

  var toDirtyRangeRefs: [TSCE_InternalRangeReferenceArchive] = []

  var calcInProgressCells: TSCE_InternalCellRefSetArchive {
    get {return _calcInProgressCells ?? TSCE_InternalCellRefSetArchive()}
    set {_calcInProgressCells = newValue}
  }
  /// Returns true if `calcInProgressCells` has been explicitly set.
  var hasCalcInProgressCells: Bool {return self._calcInProgressCells != nil}
  /// Clears the value of `calcInProgressCells`. Subsequent reads from it will return its default value.
  mutating func clearCalcInProgressCells() {self._calcInProgressCells = nil}

  var toUpdatePrecedentsCells: TSCE_InternalCellRefSetArchive {
    get {return _toUpdatePrecedentsCells ?? TSCE_InternalCellRefSetArchive()}
    set {_toUpdatePrecedentsCells = newValue}
  }
  /// Returns true if `toUpdatePrecedentsCells` has been explicitly set.
  var hasToUpdatePrecedentsCells: Bool {return self._toUpdatePrecedentsCells != nil}
  /// Clears the value of `toUpdatePrecedentsCells`. Subsequent reads from it will return its default value.
  mutating func clearToUpdatePrecedentsCells() {self._toUpdatePrecedentsCells = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _toDirtyOwnerIds: TSCE_IndexSetArchive? = nil
  fileprivate var _toDirtyCells: TSCE_InternalCellRefSetArchive? = nil
  fileprivate var _toDirtyCellsAdditional: TSCE_InternalCellRefSetArchive? = nil
  fileprivate var _calcInProgressCells: TSCE_InternalCellRefSetArchive? = nil
  fileprivate var _toUpdatePrecedentsCells: TSCE_InternalCellRefSetArchive? = nil
}

struct TSCE_CoordMapperArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tableUid: TSP_UUID {
    get {return _tableUid ?? TSP_UUID()}
    set {_tableUid = newValue}
  }
  /// Returns true if `tableUid` has been explicitly set.
  var hasTableUid: Bool {return self._tableUid != nil}
  /// Clears the value of `tableUid`. Subsequent reads from it will return its default value.
  mutating func clearTableUid() {self._tableUid = nil}

  var summaryRowsSet: TSCE_IndexSetArchive {
    get {return _summaryRowsSet ?? TSCE_IndexSetArchive()}
    set {_summaryRowsSet = newValue}
  }
  /// Returns true if `summaryRowsSet` has been explicitly set.
  var hasSummaryRowsSet: Bool {return self._summaryRowsSet != nil}
  /// Clears the value of `summaryRowsSet`. Subsequent reads from it will return its default value.
  mutating func clearSummaryRowsSet() {self._summaryRowsSet = nil}

  var summaryColumnsSet: TSCE_IndexSetArchive {
    get {return _summaryColumnsSet ?? TSCE_IndexSetArchive()}
    set {_summaryColumnsSet = newValue}
  }
  /// Returns true if `summaryColumnsSet` has been explicitly set.
  var hasSummaryColumnsSet: Bool {return self._summaryColumnsSet != nil}
  /// Clears the value of `summaryColumnsSet`. Subsequent reads from it will return its default value.
  mutating func clearSummaryColumnsSet() {self._summaryColumnsSet = nil}

  var labelRowsSet: TSCE_IndexSetArchive {
    get {return _labelRowsSet ?? TSCE_IndexSetArchive()}
    set {_labelRowsSet = newValue}
  }
  /// Returns true if `labelRowsSet` has been explicitly set.
  var hasLabelRowsSet: Bool {return self._labelRowsSet != nil}
  /// Clears the value of `labelRowsSet`. Subsequent reads from it will return its default value.
  mutating func clearLabelRowsSet() {self._labelRowsSet = nil}

  var baseToViewRowMap: [TSCE_CoordMapperArchive.BaseToViewEntry] = []

  var baseToViewColumnMap: [TSCE_CoordMapperArchive.BaseToViewEntry] = []

  var summaryToViewRowMap: [TSCE_CoordMapperArchive.SummaryToViewEntry] = []

  var summaryToViewColumnMap: [TSCE_CoordMapperArchive.SummaryToViewEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct BaseToViewEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var baseColumnOrRow: UInt32 {
      get {return _baseColumnOrRow ?? 0}
      set {_baseColumnOrRow = newValue}
    }
    /// Returns true if `baseColumnOrRow` has been explicitly set.
    var hasBaseColumnOrRow: Bool {return self._baseColumnOrRow != nil}
    /// Clears the value of `baseColumnOrRow`. Subsequent reads from it will return its default value.
    mutating func clearBaseColumnOrRow() {self._baseColumnOrRow = nil}

    var viewColumnOrRow: UInt32 {
      get {return _viewColumnOrRow ?? 0}
      set {_viewColumnOrRow = newValue}
    }
    /// Returns true if `viewColumnOrRow` has been explicitly set.
    var hasViewColumnOrRow: Bool {return self._viewColumnOrRow != nil}
    /// Clears the value of `viewColumnOrRow`. Subsequent reads from it will return its default value.
    mutating func clearViewColumnOrRow() {self._viewColumnOrRow = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _baseColumnOrRow: UInt32? = nil
    fileprivate var _viewColumnOrRow: UInt32? = nil
  }

  struct SummaryToViewEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var summaryColumnOrRow: UInt32 {
      get {return _summaryColumnOrRow ?? 0}
      set {_summaryColumnOrRow = newValue}
    }
    /// Returns true if `summaryColumnOrRow` has been explicitly set.
    var hasSummaryColumnOrRow: Bool {return self._summaryColumnOrRow != nil}
    /// Clears the value of `summaryColumnOrRow`. Subsequent reads from it will return its default value.
    mutating func clearSummaryColumnOrRow() {self._summaryColumnOrRow = nil}

    var viewColumnOrRow: UInt32 {
      get {return _viewColumnOrRow ?? 0}
      set {_viewColumnOrRow = newValue}
    }
    /// Returns true if `viewColumnOrRow` has been explicitly set.
    var hasViewColumnOrRow: Bool {return self._viewColumnOrRow != nil}
    /// Clears the value of `viewColumnOrRow`. Subsequent reads from it will return its default value.
    mutating func clearViewColumnOrRow() {self._viewColumnOrRow = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _summaryColumnOrRow: UInt32? = nil
    fileprivate var _viewColumnOrRow: UInt32? = nil
  }

  init() {}

  fileprivate var _tableUid: TSP_UUID? = nil
  fileprivate var _summaryRowsSet: TSCE_IndexSetArchive? = nil
  fileprivate var _summaryColumnsSet: TSCE_IndexSetArchive? = nil
  fileprivate var _labelRowsSet: TSCE_IndexSetArchive? = nil
}

struct TSCE_ReferenceArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var referenceType: TSCE_ReferenceArchive.ReferenceType {
    get {return _storage._referenceType ?? .cellReference}
    set {_uniqueStorage()._referenceType = newValue}
  }
  /// Returns true if `referenceType` has been explicitly set.
  var hasReferenceType: Bool {return _storage._referenceType != nil}
  /// Clears the value of `referenceType`. Subsequent reads from it will return its default value.
  mutating func clearReferenceType() {_uniqueStorage()._referenceType = nil}

  var cellReference: TSCE_CellReferenceArchive {
    get {return _storage._cellReference ?? TSCE_CellReferenceArchive()}
    set {_uniqueStorage()._cellReference = newValue}
  }
  /// Returns true if `cellReference` has been explicitly set.
  var hasCellReference: Bool {return _storage._cellReference != nil}
  /// Clears the value of `cellReference`. Subsequent reads from it will return its default value.
  mutating func clearCellReference() {_uniqueStorage()._cellReference = nil}

  var rangeReference: TSCE_RangeReferenceArchive {
    get {return _storage._rangeReference ?? TSCE_RangeReferenceArchive()}
    set {_uniqueStorage()._rangeReference = newValue}
  }
  /// Returns true if `rangeReference` has been explicitly set.
  var hasRangeReference: Bool {return _storage._rangeReference != nil}
  /// Clears the value of `rangeReference`. Subsequent reads from it will return its default value.
  mutating func clearRangeReference() {_uniqueStorage()._rangeReference = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ReferenceType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case cellReference = 1
    case rangeReference = 2
    case nameDependency = 3

    init() {
      self = .cellReference
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSCE_EdgeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var column: UInt32 {
    get {return _column ?? 0}
    set {_column = newValue}
  }
  /// Returns true if `column` has been explicitly set.
  var hasColumn: Bool {return self._column != nil}
  /// Clears the value of `column`. Subsequent reads from it will return its default value.
  mutating func clearColumn() {self._column = nil}

  var row: UInt32 {
    get {return _row ?? 0}
    set {_row = newValue}
  }
  /// Returns true if `row` has been explicitly set.
  var hasRow: Bool {return self._row != nil}
  /// Clears the value of `row`. Subsequent reads from it will return its default value.
  mutating func clearRow() {self._row = nil}

  var isPrecedent: Bool {
    get {return _isPrecedent ?? false}
    set {_isPrecedent = newValue}
  }
  /// Returns true if `isPrecedent` has been explicitly set.
  var hasIsPrecedent: Bool {return self._isPrecedent != nil}
  /// Clears the value of `isPrecedent`. Subsequent reads from it will return its default value.
  mutating func clearIsPrecedent() {self._isPrecedent = nil}

  var ownerID: TSP_CFUUIDArchive {
    get {return _ownerID ?? TSP_CFUUIDArchive()}
    set {_ownerID = newValue}
  }
  /// Returns true if `ownerID` has been explicitly set.
  var hasOwnerID: Bool {return self._ownerID != nil}
  /// Clears the value of `ownerID`. Subsequent reads from it will return its default value.
  mutating func clearOwnerID() {self._ownerID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _column: UInt32? = nil
  fileprivate var _row: UInt32? = nil
  fileprivate var _isPrecedent: Bool? = nil
  fileprivate var _ownerID: TSP_CFUUIDArchive? = nil
}

struct TSCE_EdgesArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var packedEdgeWithoutOwner: [UInt32] = []

  var packedEdgeWithOwner: [UInt32] = []

  var ownerIDForEdge: [TSP_CFUUIDArchive] = []

  var internalOwnerIDForEdge: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSCE_ExpandedEdgesArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var edgeWithoutOwnerRows: [UInt32] = []

  var edgeWithoutOwnerColumns: [UInt32] = []

  var edgeWithOwnerRows: [UInt32] = []

  var edgeWithOwnerColumns: [UInt32] = []

  var internalOwnerIDForEdge: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSCE_CellRecordArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var column: UInt32 {
    get {return _column ?? 0}
    set {_column = newValue}
  }
  /// Returns true if `column` has been explicitly set.
  var hasColumn: Bool {return self._column != nil}
  /// Clears the value of `column`. Subsequent reads from it will return its default value.
  mutating func clearColumn() {self._column = nil}

  var row: UInt32 {
    get {return _row ?? 0}
    set {_row = newValue}
  }
  /// Returns true if `row` has been explicitly set.
  var hasRow: Bool {return self._row != nil}
  /// Clears the value of `row`. Subsequent reads from it will return its default value.
  mutating func clearRow() {self._row = nil}

  var dirtySelfPlusPrecedentsCount: UInt64 {
    get {return _dirtySelfPlusPrecedentsCount ?? 0}
    set {_dirtySelfPlusPrecedentsCount = newValue}
  }
  /// Returns true if `dirtySelfPlusPrecedentsCount` has been explicitly set.
  var hasDirtySelfPlusPrecedentsCount: Bool {return self._dirtySelfPlusPrecedentsCount != nil}
  /// Clears the value of `dirtySelfPlusPrecedentsCount`. Subsequent reads from it will return its default value.
  mutating func clearDirtySelfPlusPrecedentsCount() {self._dirtySelfPlusPrecedentsCount = nil}

  var isInACycle: Bool {
    get {return _isInACycle ?? false}
    set {_isInACycle = newValue}
  }
  /// Returns true if `isInACycle` has been explicitly set.
  var hasIsInACycle: Bool {return self._isInACycle != nil}
  /// Clears the value of `isInACycle`. Subsequent reads from it will return its default value.
  mutating func clearIsInACycle() {self._isInACycle = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var edge: [TSCE_EdgeArchive] = []

  var containsAFormula: Bool {
    get {return _containsAFormula ?? true}
    set {_containsAFormula = newValue}
  }
  /// Returns true if `containsAFormula` has been explicitly set.
  var hasContainsAFormula: Bool {return self._containsAFormula != nil}
  /// Clears the value of `containsAFormula`. Subsequent reads from it will return its default value.
  mutating func clearContainsAFormula() {self._containsAFormula = nil}

  var hasCalculatedPrecedents_p: Bool {
    get {return _hasCalculatedPrecedents_p ?? false}
    set {_hasCalculatedPrecedents_p = newValue}
  }
  /// Returns true if `hasCalculatedPrecedents_p` has been explicitly set.
  var hasHasCalculatedPrecedents_p: Bool {return self._hasCalculatedPrecedents_p != nil}
  /// Clears the value of `hasCalculatedPrecedents_p`. Subsequent reads from it will return its default value.
  mutating func clearHasCalculatedPrecedents_p() {self._hasCalculatedPrecedents_p = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var calculatePrecedentsOnNextRecalc: Bool {
    get {return _calculatePrecedentsOnNextRecalc ?? false}
    set {_calculatePrecedentsOnNextRecalc = newValue}
  }
  /// Returns true if `calculatePrecedentsOnNextRecalc` has been explicitly set.
  var hasCalculatePrecedentsOnNextRecalc: Bool {return self._calculatePrecedentsOnNextRecalc != nil}
  /// Clears the value of `calculatePrecedentsOnNextRecalc`. Subsequent reads from it will return its default value.
  mutating func clearCalculatePrecedentsOnNextRecalc() {self._calculatePrecedentsOnNextRecalc = nil}

  var translateForExcelImportOnNextRecalc: Bool {
    get {return _translateForExcelImportOnNextRecalc ?? false}
    set {_translateForExcelImportOnNextRecalc = newValue}
  }
  /// Returns true if `translateForExcelImportOnNextRecalc` has been explicitly set.
  var hasTranslateForExcelImportOnNextRecalc: Bool {return self._translateForExcelImportOnNextRecalc != nil}
  /// Clears the value of `translateForExcelImportOnNextRecalc`. Subsequent reads from it will return its default value.
  mutating func clearTranslateForExcelImportOnNextRecalc() {self._translateForExcelImportOnNextRecalc = nil}

  var edges: TSCE_EdgesArchive {
    get {return _edges ?? TSCE_EdgesArchive()}
    set {_edges = newValue}
  }
  /// Returns true if `edges` has been explicitly set.
  var hasEdges: Bool {return self._edges != nil}
  /// Clears the value of `edges`. Subsequent reads from it will return its default value.
  mutating func clearEdges() {self._edges = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _column: UInt32? = nil
  fileprivate var _row: UInt32? = nil
  fileprivate var _dirtySelfPlusPrecedentsCount: UInt64? = nil
  fileprivate var _isInACycle: Bool? = nil
  fileprivate var _containsAFormula: Bool? = nil
  fileprivate var _hasCalculatedPrecedents_p: Bool? = nil
  fileprivate var _calculatePrecedentsOnNextRecalc: Bool? = nil
  fileprivate var _translateForExcelImportOnNextRecalc: Bool? = nil
  fileprivate var _edges: TSCE_EdgesArchive? = nil
}

struct TSCE_CellDependenciesArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cellRecord: [TSCE_CellRecordArchive] = []

  var numDirtyCells: UInt32 {
    get {return _numDirtyCells ?? 0}
    set {_numDirtyCells = newValue}
  }
  /// Returns true if `numDirtyCells` has been explicitly set.
  var hasNumDirtyCells: Bool {return self._numDirtyCells != nil}
  /// Clears the value of `numDirtyCells`. Subsequent reads from it will return its default value.
  mutating func clearNumDirtyCells() {self._numDirtyCells = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _numDirtyCells: UInt32? = nil
}

struct TSCE_CellRecordExpandedArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var column: UInt32 {
    get {return _column ?? 0}
    set {_column = newValue}
  }
  /// Returns true if `column` has been explicitly set.
  var hasColumn: Bool {return self._column != nil}
  /// Clears the value of `column`. Subsequent reads from it will return its default value.
  mutating func clearColumn() {self._column = nil}

  var row: UInt32 {
    get {return _row ?? 0}
    set {_row = newValue}
  }
  /// Returns true if `row` has been explicitly set.
  var hasRow: Bool {return self._row != nil}
  /// Clears the value of `row`. Subsequent reads from it will return its default value.
  mutating func clearRow() {self._row = nil}

  var dirtySelfPlusPrecedentsCount: UInt64 {
    get {return _dirtySelfPlusPrecedentsCount ?? 0}
    set {_dirtySelfPlusPrecedentsCount = newValue}
  }
  /// Returns true if `dirtySelfPlusPrecedentsCount` has been explicitly set.
  var hasDirtySelfPlusPrecedentsCount: Bool {return self._dirtySelfPlusPrecedentsCount != nil}
  /// Clears the value of `dirtySelfPlusPrecedentsCount`. Subsequent reads from it will return its default value.
  mutating func clearDirtySelfPlusPrecedentsCount() {self._dirtySelfPlusPrecedentsCount = nil}

  var isInACycle: Bool {
    get {return _isInACycle ?? false}
    set {_isInACycle = newValue}
  }
  /// Returns true if `isInACycle` has been explicitly set.
  var hasIsInACycle: Bool {return self._isInACycle != nil}
  /// Clears the value of `isInACycle`. Subsequent reads from it will return its default value.
  mutating func clearIsInACycle() {self._isInACycle = nil}

  var hasCalculatedPrecedents_p: Bool {
    get {return _hasCalculatedPrecedents_p ?? false}
    set {_hasCalculatedPrecedents_p = newValue}
  }
  /// Returns true if `hasCalculatedPrecedents_p` has been explicitly set.
  var hasHasCalculatedPrecedents_p: Bool {return self._hasCalculatedPrecedents_p != nil}
  /// Clears the value of `hasCalculatedPrecedents_p`. Subsequent reads from it will return its default value.
  mutating func clearHasCalculatedPrecedents_p() {self._hasCalculatedPrecedents_p = nil}

  var expandedEdges: TSCE_ExpandedEdgesArchive {
    get {return _expandedEdges ?? TSCE_ExpandedEdgesArchive()}
    set {_expandedEdges = newValue}
  }
  /// Returns true if `expandedEdges` has been explicitly set.
  var hasExpandedEdges: Bool {return self._expandedEdges != nil}
  /// Clears the value of `expandedEdges`. Subsequent reads from it will return its default value.
  mutating func clearExpandedEdges() {self._expandedEdges = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _column: UInt32? = nil
  fileprivate var _row: UInt32? = nil
  fileprivate var _dirtySelfPlusPrecedentsCount: UInt64? = nil
  fileprivate var _isInACycle: Bool? = nil
  fileprivate var _hasCalculatedPrecedents_p: Bool? = nil
  fileprivate var _expandedEdges: TSCE_ExpandedEdgesArchive? = nil
}

struct TSCE_CellDependenciesExpandedArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cellRecord: [TSCE_CellRecordExpandedArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSCE_CellRecordTileArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var internalOwnerID: UInt32 {
    get {return _internalOwnerID ?? 0}
    set {_internalOwnerID = newValue}
  }
  /// Returns true if `internalOwnerID` has been explicitly set.
  var hasInternalOwnerID: Bool {return self._internalOwnerID != nil}
  /// Clears the value of `internalOwnerID`. Subsequent reads from it will return its default value.
  mutating func clearInternalOwnerID() {self._internalOwnerID = nil}

  var tileColumnBegin: UInt32 {
    get {return _tileColumnBegin ?? 0}
    set {_tileColumnBegin = newValue}
  }
  /// Returns true if `tileColumnBegin` has been explicitly set.
  var hasTileColumnBegin: Bool {return self._tileColumnBegin != nil}
  /// Clears the value of `tileColumnBegin`. Subsequent reads from it will return its default value.
  mutating func clearTileColumnBegin() {self._tileColumnBegin = nil}

  var tileRowBegin: UInt32 {
    get {return _tileRowBegin ?? 0}
    set {_tileRowBegin = newValue}
  }
  /// Returns true if `tileRowBegin` has been explicitly set.
  var hasTileRowBegin: Bool {return self._tileRowBegin != nil}
  /// Clears the value of `tileRowBegin`. Subsequent reads from it will return its default value.
  mutating func clearTileRowBegin() {self._tileRowBegin = nil}

  var cellRecords: [TSCE_CellRecordExpandedArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _internalOwnerID: UInt32? = nil
  fileprivate var _tileColumnBegin: UInt32? = nil
  fileprivate var _tileRowBegin: UInt32? = nil
}

struct TSCE_CellDependenciesTiledArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cellRecordTiles: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSCE_VolatileDependenciesArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var volatileTimeCellColumn: [UInt32] {
    get {return _storage._volatileTimeCellColumn}
    set {_uniqueStorage()._volatileTimeCellColumn = newValue}
  }

  var volatileTimeCellRow: [UInt32] {
    get {return _storage._volatileTimeCellRow}
    set {_uniqueStorage()._volatileTimeCellRow = newValue}
  }

  var volatileRandomCellColumn: [UInt32] {
    get {return _storage._volatileRandomCellColumn}
    set {_uniqueStorage()._volatileRandomCellColumn = newValue}
  }

  var volatileRandomCellRow: [UInt32] {
    get {return _storage._volatileRandomCellRow}
    set {_uniqueStorage()._volatileRandomCellRow = newValue}
  }

  var volatileLocaleCellColumn: [UInt32] {
    get {return _storage._volatileLocaleCellColumn}
    set {_uniqueStorage()._volatileLocaleCellColumn = newValue}
  }

  var volatileLocaleCellRow: [UInt32] {
    get {return _storage._volatileLocaleCellRow}
    set {_uniqueStorage()._volatileLocaleCellRow = newValue}
  }

  var volatileLocationCellColumn: [UInt32] {
    get {return _storage._volatileLocationCellColumn}
    set {_uniqueStorage()._volatileLocationCellColumn = newValue}
  }

  var volatileLocationCellRow: [UInt32] {
    get {return _storage._volatileLocationCellRow}
    set {_uniqueStorage()._volatileLocationCellRow = newValue}
  }

  var volatileCompassCellColumn: [UInt32] {
    get {return _storage._volatileCompassCellColumn}
    set {_uniqueStorage()._volatileCompassCellColumn = newValue}
  }

  var volatileCompassCellRow: [UInt32] {
    get {return _storage._volatileCompassCellRow}
    set {_uniqueStorage()._volatileCompassCellRow = newValue}
  }

  var volatileRemoteDataCellColumn: [UInt32] {
    get {return _storage._volatileRemoteDataCellColumn}
    set {_uniqueStorage()._volatileRemoteDataCellColumn = newValue}
  }

  var volatileRemoteDataCellRow: [UInt32] {
    get {return _storage._volatileRemoteDataCellRow}
    set {_uniqueStorage()._volatileRemoteDataCellRow = newValue}
  }

  var volatileSheetTableNameCellColumn: [UInt32] {
    get {return _storage._volatileSheetTableNameCellColumn}
    set {_uniqueStorage()._volatileSheetTableNameCellColumn = newValue}
  }

  var volatileSheetTableNameCellRow: [UInt32] {
    get {return _storage._volatileSheetTableNameCellRow}
    set {_uniqueStorage()._volatileSheetTableNameCellRow = newValue}
  }

  var calculatedDependencyCellColumn: [UInt32] {
    get {return _storage._calculatedDependencyCellColumn}
    set {_uniqueStorage()._calculatedDependencyCellColumn = newValue}
  }

  var calculatedDependencyCellRow: [UInt32] {
    get {return _storage._calculatedDependencyCellRow}
    set {_uniqueStorage()._calculatedDependencyCellRow = newValue}
  }

  var volatileGeometryCellReference: [TSCE_CellReferenceArchive] {
    get {return _storage._volatileGeometryCellReference}
    set {_uniqueStorage()._volatileGeometryCellReference = newValue}
  }

  var volatileGeometryCell: [TSCE_CellCoordinateArchive] {
    get {return _storage._volatileGeometryCell}
    set {_uniqueStorage()._volatileGeometryCell = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSCE_VolatileDependenciesExpandedArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var volatileTimeCells: TSCE_CellCoordSetArchive {
    get {return _volatileTimeCells ?? TSCE_CellCoordSetArchive()}
    set {_volatileTimeCells = newValue}
  }
  /// Returns true if `volatileTimeCells` has been explicitly set.
  var hasVolatileTimeCells: Bool {return self._volatileTimeCells != nil}
  /// Clears the value of `volatileTimeCells`. Subsequent reads from it will return its default value.
  mutating func clearVolatileTimeCells() {self._volatileTimeCells = nil}

  var volatileRandomCells: TSCE_CellCoordSetArchive {
    get {return _volatileRandomCells ?? TSCE_CellCoordSetArchive()}
    set {_volatileRandomCells = newValue}
  }
  /// Returns true if `volatileRandomCells` has been explicitly set.
  var hasVolatileRandomCells: Bool {return self._volatileRandomCells != nil}
  /// Clears the value of `volatileRandomCells`. Subsequent reads from it will return its default value.
  mutating func clearVolatileRandomCells() {self._volatileRandomCells = nil}

  var volatileLocaleCells: TSCE_CellCoordSetArchive {
    get {return _volatileLocaleCells ?? TSCE_CellCoordSetArchive()}
    set {_volatileLocaleCells = newValue}
  }
  /// Returns true if `volatileLocaleCells` has been explicitly set.
  var hasVolatileLocaleCells: Bool {return self._volatileLocaleCells != nil}
  /// Clears the value of `volatileLocaleCells`. Subsequent reads from it will return its default value.
  mutating func clearVolatileLocaleCells() {self._volatileLocaleCells = nil}

  var volatileSheetTableNameCells: TSCE_CellCoordSetArchive {
    get {return _volatileSheetTableNameCells ?? TSCE_CellCoordSetArchive()}
    set {_volatileSheetTableNameCells = newValue}
  }
  /// Returns true if `volatileSheetTableNameCells` has been explicitly set.
  var hasVolatileSheetTableNameCells: Bool {return self._volatileSheetTableNameCells != nil}
  /// Clears the value of `volatileSheetTableNameCells`. Subsequent reads from it will return its default value.
  mutating func clearVolatileSheetTableNameCells() {self._volatileSheetTableNameCells = nil}

  var volatileRemoteDataCells: TSCE_CellCoordSetArchive {
    get {return _volatileRemoteDataCells ?? TSCE_CellCoordSetArchive()}
    set {_volatileRemoteDataCells = newValue}
  }
  /// Returns true if `volatileRemoteDataCells` has been explicitly set.
  var hasVolatileRemoteDataCells: Bool {return self._volatileRemoteDataCells != nil}
  /// Clears the value of `volatileRemoteDataCells`. Subsequent reads from it will return its default value.
  mutating func clearVolatileRemoteDataCells() {self._volatileRemoteDataCells = nil}

  var volatileGeometryCellRefs: TSCE_InternalCellRefSetArchive {
    get {return _volatileGeometryCellRefs ?? TSCE_InternalCellRefSetArchive()}
    set {_volatileGeometryCellRefs = newValue}
  }
  /// Returns true if `volatileGeometryCellRefs` has been explicitly set.
  var hasVolatileGeometryCellRefs: Bool {return self._volatileGeometryCellRefs != nil}
  /// Clears the value of `volatileGeometryCellRefs`. Subsequent reads from it will return its default value.
  mutating func clearVolatileGeometryCellRefs() {self._volatileGeometryCellRefs = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _volatileTimeCells: TSCE_CellCoordSetArchive? = nil
  fileprivate var _volatileRandomCells: TSCE_CellCoordSetArchive? = nil
  fileprivate var _volatileLocaleCells: TSCE_CellCoordSetArchive? = nil
  fileprivate var _volatileSheetTableNameCells: TSCE_CellCoordSetArchive? = nil
  fileprivate var _volatileRemoteDataCells: TSCE_CellCoordSetArchive? = nil
  fileprivate var _volatileGeometryCellRefs: TSCE_InternalCellRefSetArchive? = nil
}

struct TSCE_RTreeInternalNodeContentsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var min: [UInt32] = []

  var max: [UInt32] = []

  var child: TSCE_RTreeNodeArchive {
    get {return _child ?? TSCE_RTreeNodeArchive()}
    set {_child = newValue}
  }
  /// Returns true if `child` has been explicitly set.
  var hasChild: Bool {return self._child != nil}
  /// Clears the value of `child`. Subsequent reads from it will return its default value.
  mutating func clearChild() {self._child = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _child: TSCE_RTreeNodeArchive? = nil
}

struct TSCE_RTreeLeafNodeContentsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var min: [UInt32] = []

  var max: [UInt32] = []

  var cellReference: TSCE_CellReferenceArchive {
    get {return _cellReference ?? TSCE_CellReferenceArchive()}
    set {_cellReference = newValue}
  }
  /// Returns true if `cellReference` has been explicitly set.
  var hasCellReference: Bool {return self._cellReference != nil}
  /// Clears the value of `cellReference`. Subsequent reads from it will return its default value.
  mutating func clearCellReference() {self._cellReference = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cellReference: TSCE_CellReferenceArchive? = nil
}

struct TSCE_RTreeNodeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var level: UInt32 {
    get {return _level ?? 0}
    set {_level = newValue}
  }
  /// Returns true if `level` has been explicitly set.
  var hasLevel: Bool {return self._level != nil}
  /// Clears the value of `level`. Subsequent reads from it will return its default value.
  mutating func clearLevel() {self._level = nil}

  var count: UInt32 {
    get {return _count ?? 0}
    set {_count = newValue}
  }
  /// Returns true if `count` has been explicitly set.
  var hasCount: Bool {return self._count != nil}
  /// Clears the value of `count`. Subsequent reads from it will return its default value.
  mutating func clearCount() {self._count = nil}

  var internalNodeContents: [TSCE_RTreeInternalNodeContentsArchive] = []

  var leafNodeContents: [TSCE_RTreeLeafNodeContentsArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _level: UInt32? = nil
  fileprivate var _count: UInt32? = nil
}

struct TSCE_RTreeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dataFileID: UInt32 {
    get {return _dataFileID ?? 0}
    set {_dataFileID = newValue}
  }
  /// Returns true if `dataFileID` has been explicitly set.
  var hasDataFileID: Bool {return self._dataFileID != nil}
  /// Clears the value of `dataFileID`. Subsequent reads from it will return its default value.
  mutating func clearDataFileID() {self._dataFileID = nil}

  var dataSize: UInt32 {
    get {return _dataSize ?? 0}
    set {_dataSize = newValue}
  }
  /// Returns true if `dataSize` has been explicitly set.
  var hasDataSize: Bool {return self._dataSize != nil}
  /// Clears the value of `dataSize`. Subsequent reads from it will return its default value.
  mutating func clearDataSize() {self._dataSize = nil}

  var dataNumDims: UInt32 {
    get {return _dataNumDims ?? 0}
    set {_dataNumDims = newValue}
  }
  /// Returns true if `dataNumDims` has been explicitly set.
  var hasDataNumDims: Bool {return self._dataNumDims != nil}
  /// Clears the value of `dataNumDims`. Subsequent reads from it will return its default value.
  mutating func clearDataNumDims() {self._dataNumDims = nil}

  var dataElemSize: UInt32 {
    get {return _dataElemSize ?? 0}
    set {_dataElemSize = newValue}
  }
  /// Returns true if `dataElemSize` has been explicitly set.
  var hasDataElemSize: Bool {return self._dataElemSize != nil}
  /// Clears the value of `dataElemSize`. Subsequent reads from it will return its default value.
  mutating func clearDataElemSize() {self._dataElemSize = nil}

  var dataElemRealSize: UInt32 {
    get {return _dataElemRealSize ?? 0}
    set {_dataElemRealSize = newValue}
  }
  /// Returns true if `dataElemRealSize` has been explicitly set.
  var hasDataElemRealSize: Bool {return self._dataElemRealSize != nil}
  /// Clears the value of `dataElemRealSize`. Subsequent reads from it will return its default value.
  mutating func clearDataElemRealSize() {self._dataElemRealSize = nil}

  var dataMaxNodes: UInt32 {
    get {return _dataMaxNodes ?? 0}
    set {_dataMaxNodes = newValue}
  }
  /// Returns true if `dataMaxNodes` has been explicitly set.
  var hasDataMaxNodes: Bool {return self._dataMaxNodes != nil}
  /// Clears the value of `dataMaxNodes`. Subsequent reads from it will return its default value.
  mutating func clearDataMaxNodes() {self._dataMaxNodes = nil}

  var dataMinNodes: UInt32 {
    get {return _dataMinNodes ?? 0}
    set {_dataMinNodes = newValue}
  }
  /// Returns true if `dataMinNodes` has been explicitly set.
  var hasDataMinNodes: Bool {return self._dataMinNodes != nil}
  /// Clears the value of `dataMinNodes`. Subsequent reads from it will return its default value.
  mutating func clearDataMinNodes() {self._dataMinNodes = nil}

  var root: TSCE_RTreeNodeArchive {
    get {return _root ?? TSCE_RTreeNodeArchive()}
    set {_root = newValue}
  }
  /// Returns true if `root` has been explicitly set.
  var hasRoot: Bool {return self._root != nil}
  /// Clears the value of `root`. Subsequent reads from it will return its default value.
  mutating func clearRoot() {self._root = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _dataFileID: UInt32? = nil
  fileprivate var _dataSize: UInt32? = nil
  fileprivate var _dataNumDims: UInt32? = nil
  fileprivate var _dataElemSize: UInt32? = nil
  fileprivate var _dataElemRealSize: UInt32? = nil
  fileprivate var _dataMaxNodes: UInt32? = nil
  fileprivate var _dataMinNodes: UInt32? = nil
  fileprivate var _root: TSCE_RTreeNodeArchive? = nil
}

struct TSCE_RangeBackDependencyArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cellCoordRow: UInt32 {
    get {return _cellCoordRow ?? 0}
    set {_cellCoordRow = newValue}
  }
  /// Returns true if `cellCoordRow` has been explicitly set.
  var hasCellCoordRow: Bool {return self._cellCoordRow != nil}
  /// Clears the value of `cellCoordRow`. Subsequent reads from it will return its default value.
  mutating func clearCellCoordRow() {self._cellCoordRow = nil}

  var cellCoordColumn: UInt32 {
    get {return _cellCoordColumn ?? 0}
    set {_cellCoordColumn = newValue}
  }
  /// Returns true if `cellCoordColumn` has been explicitly set.
  var hasCellCoordColumn: Bool {return self._cellCoordColumn != nil}
  /// Clears the value of `cellCoordColumn`. Subsequent reads from it will return its default value.
  mutating func clearCellCoordColumn() {self._cellCoordColumn = nil}

  var rangeReference: TSCE_RangeReferenceArchive {
    get {return _rangeReference ?? TSCE_RangeReferenceArchive()}
    set {_rangeReference = newValue}
  }
  /// Returns true if `rangeReference` has been explicitly set.
  var hasRangeReference: Bool {return self._rangeReference != nil}
  /// Clears the value of `rangeReference`. Subsequent reads from it will return its default value.
  mutating func clearRangeReference() {self._rangeReference = nil}

  var internalRangeReference: TSCE_InternalRangeReferenceArchive {
    get {return _internalRangeReference ?? TSCE_InternalRangeReferenceArchive()}
    set {_internalRangeReference = newValue}
  }
  /// Returns true if `internalRangeReference` has been explicitly set.
  var hasInternalRangeReference: Bool {return self._internalRangeReference != nil}
  /// Clears the value of `internalRangeReference`. Subsequent reads from it will return its default value.
  mutating func clearInternalRangeReference() {self._internalRangeReference = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cellCoordRow: UInt32? = nil
  fileprivate var _cellCoordColumn: UInt32? = nil
  fileprivate var _rangeReference: TSCE_RangeReferenceArchive? = nil
  fileprivate var _internalRangeReference: TSCE_InternalRangeReferenceArchive? = nil
}

struct TSCE_RangeDependenciesArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var backDependency: [TSCE_RangeBackDependencyArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSCE_RangePrecedentsTileArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var toOwnerID: UInt32 {
    get {return _toOwnerID ?? 0}
    set {_toOwnerID = newValue}
  }
  /// Returns true if `toOwnerID` has been explicitly set.
  var hasToOwnerID: Bool {return self._toOwnerID != nil}
  /// Clears the value of `toOwnerID`. Subsequent reads from it will return its default value.
  mutating func clearToOwnerID() {self._toOwnerID = nil}

  var fromToRange: [TSCE_RangePrecedentsTileArchive.FromToRangeArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct FromToRangeArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fromCoord: TSCE_CellCoordinateArchive {
      get {return _fromCoord ?? TSCE_CellCoordinateArchive()}
      set {_fromCoord = newValue}
    }
    /// Returns true if `fromCoord` has been explicitly set.
    var hasFromCoord: Bool {return self._fromCoord != nil}
    /// Clears the value of `fromCoord`. Subsequent reads from it will return its default value.
    mutating func clearFromCoord() {self._fromCoord = nil}

    var refersToRect: TSCE_CellRectArchive {
      get {return _refersToRect ?? TSCE_CellRectArchive()}
      set {_refersToRect = newValue}
    }
    /// Returns true if `refersToRect` has been explicitly set.
    var hasRefersToRect: Bool {return self._refersToRect != nil}
    /// Clears the value of `refersToRect`. Subsequent reads from it will return its default value.
    mutating func clearRefersToRect() {self._refersToRect = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _fromCoord: TSCE_CellCoordinateArchive? = nil
    fileprivate var _refersToRect: TSCE_CellRectArchive? = nil
  }

  init() {}

  fileprivate var _toOwnerID: UInt32? = nil
}

struct TSCE_RangeDependenciesTiledArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rangePrecedentsTile: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSCE_SpanningDependenciesArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var column: [UInt32] = []

  var rangeContext: [TSCE_SpanningDependenciesArchive.RangeContext] = []

  var cell: [TSCE_CellReferenceArchive] = []

  var totalRangeForDeletedTable: TSCE_RangeCoordinateArchive {
    get {return _totalRangeForDeletedTable ?? TSCE_RangeCoordinateArchive()}
    set {_totalRangeForDeletedTable = newValue}
  }
  /// Returns true if `totalRangeForDeletedTable` has been explicitly set.
  var hasTotalRangeForDeletedTable: Bool {return self._totalRangeForDeletedTable != nil}
  /// Clears the value of `totalRangeForDeletedTable`. Subsequent reads from it will return its default value.
  mutating func clearTotalRangeForDeletedTable() {self._totalRangeForDeletedTable = nil}

  var bodyRangeForDeletedTable: TSCE_RangeCoordinateArchive {
    get {return _bodyRangeForDeletedTable ?? TSCE_RangeCoordinateArchive()}
    set {_bodyRangeForDeletedTable = newValue}
  }
  /// Returns true if `bodyRangeForDeletedTable` has been explicitly set.
  var hasBodyRangeForDeletedTable: Bool {return self._bodyRangeForDeletedTable != nil}
  /// Clears the value of `bodyRangeForDeletedTable`. Subsequent reads from it will return its default value.
  mutating func clearBodyRangeForDeletedTable() {self._bodyRangeForDeletedTable = nil}

  var referringColumnToLocalCells: [TSCE_SpanningDependenciesArchive.ReferringColumnToLocalCells] = []

  var referringColumnToRemoteCells: [TSCE_SpanningDependenciesArchive.ReferringColumnToRemoteCells] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum RangeContext: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case `default` = 0
    case includeHeaders = 1

    init() {
      self = .default
    }

  }

  struct ReferringColumnToLocalCells: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var column: UInt32 {
      get {return _column ?? 0}
      set {_column = newValue}
    }
    /// Returns true if `column` has been explicitly set.
    var hasColumn: Bool {return self._column != nil}
    /// Clears the value of `column`. Subsequent reads from it will return its default value.
    mutating func clearColumn() {self._column = nil}

    var rangeContext: TSCE_SpanningDependenciesArchive.RangeContext {
      get {return _rangeContext ?? .default}
      set {_rangeContext = newValue}
    }
    /// Returns true if `rangeContext` has been explicitly set.
    var hasRangeContext: Bool {return self._rangeContext != nil}
    /// Clears the value of `rangeContext`. Subsequent reads from it will return its default value.
    mutating func clearRangeContext() {self._rangeContext = nil}

    var cellCoordinate: [TSCE_CellCoordinateArchive] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _column: UInt32? = nil
    fileprivate var _rangeContext: TSCE_SpanningDependenciesArchive.RangeContext? = nil
  }

  struct ReferringColumnToRemoteCells: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var column: UInt32 {
      get {return _column ?? 0}
      set {_column = newValue}
    }
    /// Returns true if `column` has been explicitly set.
    var hasColumn: Bool {return self._column != nil}
    /// Clears the value of `column`. Subsequent reads from it will return its default value.
    mutating func clearColumn() {self._column = nil}

    var rangeContext: TSCE_SpanningDependenciesArchive.RangeContext {
      get {return _rangeContext ?? .default}
      set {_rangeContext = newValue}
    }
    /// Returns true if `rangeContext` has been explicitly set.
    var hasRangeContext: Bool {return self._rangeContext != nil}
    /// Clears the value of `rangeContext`. Subsequent reads from it will return its default value.
    mutating func clearRangeContext() {self._rangeContext = nil}

    var internalCellReference: [TSCE_InternalCellReferenceArchive] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _column: UInt32? = nil
    fileprivate var _rangeContext: TSCE_SpanningDependenciesArchive.RangeContext? = nil
  }

  init() {}

  fileprivate var _totalRangeForDeletedTable: TSCE_RangeCoordinateArchive? = nil
  fileprivate var _bodyRangeForDeletedTable: TSCE_RangeCoordinateArchive? = nil
}

struct TSCE_SpanningDependenciesExpandedArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var coordRefersToSpans: [TSCE_SpanningDependenciesExpandedArchive.CellCoordRefersToExtents] = []

  var totalRangeForTable: TSCE_RangeCoordinateArchive {
    get {return _totalRangeForTable ?? TSCE_RangeCoordinateArchive()}
    set {_totalRangeForTable = newValue}
  }
  /// Returns true if `totalRangeForTable` has been explicitly set.
  var hasTotalRangeForTable: Bool {return self._totalRangeForTable != nil}
  /// Clears the value of `totalRangeForTable`. Subsequent reads from it will return its default value.
  mutating func clearTotalRangeForTable() {self._totalRangeForTable = nil}

  var bodyRangeForTable: TSCE_RangeCoordinateArchive {
    get {return _bodyRangeForTable ?? TSCE_RangeCoordinateArchive()}
    set {_bodyRangeForTable = newValue}
  }
  /// Returns true if `bodyRangeForTable` has been explicitly set.
  var hasBodyRangeForTable: Bool {return self._bodyRangeForTable != nil}
  /// Clears the value of `bodyRangeForTable`. Subsequent reads from it will return its default value.
  mutating func clearBodyRangeForTable() {self._bodyRangeForTable = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum RangeContext: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case `default` = 0
    case includeHeaders = 1

    init() {
      self = .default
    }

  }

  struct ExtentRange: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var extentBegin: UInt32 {
      get {return _extentBegin ?? 0}
      set {_extentBegin = newValue}
    }
    /// Returns true if `extentBegin` has been explicitly set.
    var hasExtentBegin: Bool {return self._extentBegin != nil}
    /// Clears the value of `extentBegin`. Subsequent reads from it will return its default value.
    mutating func clearExtentBegin() {self._extentBegin = nil}

    var extentEnd: UInt32 {
      get {return _extentEnd ?? 0}
      set {_extentEnd = newValue}
    }
    /// Returns true if `extentEnd` has been explicitly set.
    var hasExtentEnd: Bool {return self._extentEnd != nil}
    /// Clears the value of `extentEnd`. Subsequent reads from it will return its default value.
    mutating func clearExtentEnd() {self._extentEnd = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _extentBegin: UInt32? = nil
    fileprivate var _extentEnd: UInt32? = nil
  }

  struct ExtentRangeWithTableWithContext: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ownerID: UInt32 {
      get {return _ownerID ?? 0}
      set {_ownerID = newValue}
    }
    /// Returns true if `ownerID` has been explicitly set.
    var hasOwnerID: Bool {return self._ownerID != nil}
    /// Clears the value of `ownerID`. Subsequent reads from it will return its default value.
    mutating func clearOwnerID() {self._ownerID = nil}

    var rangeContext: TSCE_SpanningDependenciesExpandedArchive.RangeContext {
      get {return _rangeContext ?? .default}
      set {_rangeContext = newValue}
    }
    /// Returns true if `rangeContext` has been explicitly set.
    var hasRangeContext: Bool {return self._rangeContext != nil}
    /// Clears the value of `rangeContext`. Subsequent reads from it will return its default value.
    mutating func clearRangeContext() {self._rangeContext = nil}

    var ranges: [TSCE_SpanningDependenciesExpandedArchive.ExtentRange] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _ownerID: UInt32? = nil
    fileprivate var _rangeContext: TSCE_SpanningDependenciesExpandedArchive.RangeContext? = nil
  }

  struct CellCoordRefersToExtents: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var coordinate: TSCE_CellCoordinateArchive {
      get {return _coordinate ?? TSCE_CellCoordinateArchive()}
      set {_coordinate = newValue}
    }
    /// Returns true if `coordinate` has been explicitly set.
    var hasCoordinate: Bool {return self._coordinate != nil}
    /// Clears the value of `coordinate`. Subsequent reads from it will return its default value.
    mutating func clearCoordinate() {self._coordinate = nil}

    var rangesByTableContext: [TSCE_SpanningDependenciesExpandedArchive.ExtentRangeWithTableWithContext] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _coordinate: TSCE_CellCoordinateArchive? = nil
  }

  init() {}

  fileprivate var _totalRangeForTable: TSCE_RangeCoordinateArchive? = nil
  fileprivate var _bodyRangeForTable: TSCE_RangeCoordinateArchive? = nil
}

struct TSCE_WholeOwnerDependenciesArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dependentCell: [TSCE_InternalCellReferenceArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSCE_WholeOwnerDependenciesExpandedArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dependentCells: TSCE_InternalCellRefSetArchive {
    get {return _dependentCells ?? TSCE_InternalCellRefSetArchive()}
    set {_dependentCells = newValue}
  }
  /// Returns true if `dependentCells` has been explicitly set.
  var hasDependentCells: Bool {return self._dependentCells != nil}
  /// Clears the value of `dependentCells`. Subsequent reads from it will return its default value.
  mutating func clearDependentCells() {self._dependentCells = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _dependentCells: TSCE_InternalCellRefSetArchive? = nil
}

struct TSCE_ErrorArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorTypeCode: UInt32 {
    get {return _errorTypeCode ?? 0}
    set {_errorTypeCode = newValue}
  }
  /// Returns true if `errorTypeCode` has been explicitly set.
  var hasErrorTypeCode: Bool {return self._errorTypeCode != nil}
  /// Clears the value of `errorTypeCode`. Subsequent reads from it will return its default value.
  mutating func clearErrorTypeCode() {self._errorTypeCode = nil}

  var errorInfoDictionary: [TSCE_ErrorArchive.ErrorDictionaryEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ErrorDictionaryEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var errorKey: String {
      get {return _errorKey ?? String()}
      set {_errorKey = newValue}
    }
    /// Returns true if `errorKey` has been explicitly set.
    var hasErrorKey: Bool {return self._errorKey != nil}
    /// Clears the value of `errorKey`. Subsequent reads from it will return its default value.
    mutating func clearErrorKey() {self._errorKey = nil}

    var valueForKeyString: String {
      get {return _valueForKeyString ?? String()}
      set {_valueForKeyString = newValue}
    }
    /// Returns true if `valueForKeyString` has been explicitly set.
    var hasValueForKeyString: Bool {return self._valueForKeyString != nil}
    /// Clears the value of `valueForKeyString`. Subsequent reads from it will return its default value.
    mutating func clearValueForKeyString() {self._valueForKeyString = nil}

    var valueForKeyNumber: Double {
      get {return _valueForKeyNumber ?? 0}
      set {_valueForKeyNumber = newValue}
    }
    /// Returns true if `valueForKeyNumber` has been explicitly set.
    var hasValueForKeyNumber: Bool {return self._valueForKeyNumber != nil}
    /// Clears the value of `valueForKeyNumber`. Subsequent reads from it will return its default value.
    mutating func clearValueForKeyNumber() {self._valueForKeyNumber = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _errorKey: String? = nil
    fileprivate var _valueForKeyString: String? = nil
    fileprivate var _valueForKeyNumber: Double? = nil
  }

  init() {}

  fileprivate var _errorTypeCode: UInt32? = nil
}

struct TSCE_WarningArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var warningType: UInt32 {
    get {return _warningType ?? 0}
    set {_warningType = newValue}
  }
  /// Returns true if `warningType` has been explicitly set.
  var hasWarningType: Bool {return self._warningType != nil}
  /// Clears the value of `warningType`. Subsequent reads from it will return its default value.
  mutating func clearWarningType() {self._warningType = nil}

  var warningInfoDictionary: [TSCE_WarningArchive.WarningDictionaryEntry] = []

  var rangeRef: TSCE_RangeReferenceArchive {
    get {return _rangeRef ?? TSCE_RangeReferenceArchive()}
    set {_rangeRef = newValue}
  }
  /// Returns true if `rangeRef` has been explicitly set.
  var hasRangeRef: Bool {return self._rangeRef != nil}
  /// Clears the value of `rangeRef`. Subsequent reads from it will return its default value.
  mutating func clearRangeRef() {self._rangeRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct WarningDictionaryEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var warningKey: String {
      get {return _warningKey ?? String()}
      set {_warningKey = newValue}
    }
    /// Returns true if `warningKey` has been explicitly set.
    var hasWarningKey: Bool {return self._warningKey != nil}
    /// Clears the value of `warningKey`. Subsequent reads from it will return its default value.
    mutating func clearWarningKey() {self._warningKey = nil}

    var valueForKeyString: String {
      get {return _valueForKeyString ?? String()}
      set {_valueForKeyString = newValue}
    }
    /// Returns true if `valueForKeyString` has been explicitly set.
    var hasValueForKeyString: Bool {return self._valueForKeyString != nil}
    /// Clears the value of `valueForKeyString`. Subsequent reads from it will return its default value.
    mutating func clearValueForKeyString() {self._valueForKeyString = nil}

    var valueForKeyNumber: Double {
      get {return _valueForKeyNumber ?? 0}
      set {_valueForKeyNumber = newValue}
    }
    /// Returns true if `valueForKeyNumber` has been explicitly set.
    var hasValueForKeyNumber: Bool {return self._valueForKeyNumber != nil}
    /// Clears the value of `valueForKeyNumber`. Subsequent reads from it will return its default value.
    mutating func clearValueForKeyNumber() {self._valueForKeyNumber = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _warningKey: String? = nil
    fileprivate var _valueForKeyString: String? = nil
    fileprivate var _valueForKeyNumber: Double? = nil
  }

  init() {}

  fileprivate var _warningType: UInt32? = nil
  fileprivate var _rangeRef: TSCE_RangeReferenceArchive? = nil
}

struct TSCE_CellErrorsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errors: [TSCE_CellErrorsArchive.ErrorForCell] = []

  var enhancedErrors: [TSCE_CellErrorsArchive.EnhancedErrorForCell] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ErrorFlavor: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case none = 0
    case error = 1
    case refError = 2
    case circularRefError = 3
    case unsupportedFunctionError = 4

    init() {
      self = .none
    }

  }

  struct ErrorForCell: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var coordinate: TSCE_CellCoordinateArchive {
      get {return _coordinate ?? TSCE_CellCoordinateArchive()}
      set {_coordinate = newValue}
    }
    /// Returns true if `coordinate` has been explicitly set.
    var hasCoordinate: Bool {return self._coordinate != nil}
    /// Clears the value of `coordinate`. Subsequent reads from it will return its default value.
    mutating func clearCoordinate() {self._coordinate = nil}

    var errorFlavor: TSCE_CellErrorsArchive.ErrorFlavor {
      get {return _errorFlavor ?? .none}
      set {_errorFlavor = newValue}
    }
    /// Returns true if `errorFlavor` has been explicitly set.
    var hasErrorFlavor: Bool {return self._errorFlavor != nil}
    /// Clears the value of `errorFlavor`. Subsequent reads from it will return its default value.
    mutating func clearErrorFlavor() {self._errorFlavor = nil}

    var errDueToCell: TSCE_InternalCellReferenceArchive {
      get {return _errDueToCell ?? TSCE_InternalCellReferenceArchive()}
      set {_errDueToCell = newValue}
    }
    /// Returns true if `errDueToCell` has been explicitly set.
    var hasErrDueToCell: Bool {return self._errDueToCell != nil}
    /// Clears the value of `errDueToCell`. Subsequent reads from it will return its default value.
    mutating func clearErrDueToCell() {self._errDueToCell = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _coordinate: TSCE_CellCoordinateArchive? = nil
    fileprivate var _errorFlavor: TSCE_CellErrorsArchive.ErrorFlavor? = nil
    fileprivate var _errDueToCell: TSCE_InternalCellReferenceArchive? = nil
  }

  struct EnhancedErrorForCell: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var coordinate: TSCE_CellCoordinateArchive {
      get {return _coordinate ?? TSCE_CellCoordinateArchive()}
      set {_coordinate = newValue}
    }
    /// Returns true if `coordinate` has been explicitly set.
    var hasCoordinate: Bool {return self._coordinate != nil}
    /// Clears the value of `coordinate`. Subsequent reads from it will return its default value.
    mutating func clearCoordinate() {self._coordinate = nil}

    var error: TSCE_ErrorArchive {
      get {return _error ?? TSCE_ErrorArchive()}
      set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    mutating func clearError() {self._error = nil}

    var errDueToCell: TSCE_InternalCellReferenceArchive {
      get {return _errDueToCell ?? TSCE_InternalCellReferenceArchive()}
      set {_errDueToCell = newValue}
    }
    /// Returns true if `errDueToCell` has been explicitly set.
    var hasErrDueToCell: Bool {return self._errDueToCell != nil}
    /// Clears the value of `errDueToCell`. Subsequent reads from it will return its default value.
    mutating func clearErrDueToCell() {self._errDueToCell = nil}

    var sortedWarnings: [TSCE_WarningArchive] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _coordinate: TSCE_CellCoordinateArchive? = nil
    fileprivate var _error: TSCE_ErrorArchive? = nil
    fileprivate var _errDueToCell: TSCE_InternalCellReferenceArchive? = nil
  }

  init() {}
}

struct TSCE_CellSpillSizesArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var spills: [TSCE_CellSpillSizesArchive.SpillForCell] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct SpillForCell: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var coordinate: TSCE_CellCoordinateArchive {
      get {return _coordinate ?? TSCE_CellCoordinateArchive()}
      set {_coordinate = newValue}
    }
    /// Returns true if `coordinate` has been explicitly set.
    var hasCoordinate: Bool {return self._coordinate != nil}
    /// Clears the value of `coordinate`. Subsequent reads from it will return its default value.
    mutating func clearCoordinate() {self._coordinate = nil}

    var spillSize: TSCE_ColumnRowSize {
      get {return _spillSize ?? TSCE_ColumnRowSize()}
      set {_spillSize = newValue}
    }
    /// Returns true if `spillSize` has been explicitly set.
    var hasSpillSize: Bool {return self._spillSize != nil}
    /// Clears the value of `spillSize`. Subsequent reads from it will return its default value.
    mutating func clearSpillSize() {self._spillSize = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _coordinate: TSCE_CellCoordinateArchive? = nil
    fileprivate var _spillSize: TSCE_ColumnRowSize? = nil
  }

  init() {}
}

struct TSCE_UuidReferencesArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tableRefs: [TSCE_UuidReferencesArchive.TableRef] = []

  var tableUuidRefs: [TSCE_UuidReferencesArchive.TableWithUuidRef] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct TableRef: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ownerUuid: TSP_UUID {
      get {return _ownerUuid ?? TSP_UUID()}
      set {_ownerUuid = newValue}
    }
    /// Returns true if `ownerUuid` has been explicitly set.
    var hasOwnerUuid: Bool {return self._ownerUuid != nil}
    /// Clears the value of `ownerUuid`. Subsequent reads from it will return its default value.
    mutating func clearOwnerUuid() {self._ownerUuid = nil}

    var coordSet: TSCE_CellCoordSetArchive {
      get {return _coordSet ?? TSCE_CellCoordSetArchive()}
      set {_coordSet = newValue}
    }
    /// Returns true if `coordSet` has been explicitly set.
    var hasCoordSet: Bool {return self._coordSet != nil}
    /// Clears the value of `coordSet`. Subsequent reads from it will return its default value.
    mutating func clearCoordSet() {self._coordSet = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _ownerUuid: TSP_UUID? = nil
    fileprivate var _coordSet: TSCE_CellCoordSetArchive? = nil
  }

  struct UuidRef: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uuid: TSP_UUID {
      get {return _uuid ?? TSP_UUID()}
      set {_uuid = newValue}
    }
    /// Returns true if `uuid` has been explicitly set.
    var hasUuid: Bool {return self._uuid != nil}
    /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
    mutating func clearUuid() {self._uuid = nil}

    var coordSet: TSCE_CellCoordSetArchive {
      get {return _coordSet ?? TSCE_CellCoordSetArchive()}
      set {_coordSet = newValue}
    }
    /// Returns true if `coordSet` has been explicitly set.
    var hasCoordSet: Bool {return self._coordSet != nil}
    /// Clears the value of `coordSet`. Subsequent reads from it will return its default value.
    mutating func clearCoordSet() {self._coordSet = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _uuid: TSP_UUID? = nil
    fileprivate var _coordSet: TSCE_CellCoordSetArchive? = nil
  }

  struct TableWithUuidRef: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ownerUuid: TSP_UUID {
      get {return _ownerUuid ?? TSP_UUID()}
      set {_ownerUuid = newValue}
    }
    /// Returns true if `ownerUuid` has been explicitly set.
    var hasOwnerUuid: Bool {return self._ownerUuid != nil}
    /// Clears the value of `ownerUuid`. Subsequent reads from it will return its default value.
    mutating func clearOwnerUuid() {self._ownerUuid = nil}

    var uuidRefs: [TSCE_UuidReferencesArchive.UuidRef] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _ownerUuid: TSP_UUID? = nil
  }

  init() {}
}

struct TSCE_FormulaOwnerDependenciesArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var formulaOwnerUid: TSP_UUID {
    get {return _storage._formulaOwnerUid ?? TSP_UUID()}
    set {_uniqueStorage()._formulaOwnerUid = newValue}
  }
  /// Returns true if `formulaOwnerUid` has been explicitly set.
  var hasFormulaOwnerUid: Bool {return _storage._formulaOwnerUid != nil}
  /// Clears the value of `formulaOwnerUid`. Subsequent reads from it will return its default value.
  mutating func clearFormulaOwnerUid() {_uniqueStorage()._formulaOwnerUid = nil}

  var internalFormulaOwnerID: UInt32 {
    get {return _storage._internalFormulaOwnerID ?? 0}
    set {_uniqueStorage()._internalFormulaOwnerID = newValue}
  }
  /// Returns true if `internalFormulaOwnerID` has been explicitly set.
  var hasInternalFormulaOwnerID: Bool {return _storage._internalFormulaOwnerID != nil}
  /// Clears the value of `internalFormulaOwnerID`. Subsequent reads from it will return its default value.
  mutating func clearInternalFormulaOwnerID() {_uniqueStorage()._internalFormulaOwnerID = nil}

  var ownerKind: UInt32 {
    get {return _storage._ownerKind ?? 0}
    set {_uniqueStorage()._ownerKind = newValue}
  }
  /// Returns true if `ownerKind` has been explicitly set.
  var hasOwnerKind: Bool {return _storage._ownerKind != nil}
  /// Clears the value of `ownerKind`. Subsequent reads from it will return its default value.
  mutating func clearOwnerKind() {_uniqueStorage()._ownerKind = nil}

  var cellDependencies: TSCE_CellDependenciesExpandedArchive {
    get {return _storage._cellDependencies ?? TSCE_CellDependenciesExpandedArchive()}
    set {_uniqueStorage()._cellDependencies = newValue}
  }
  /// Returns true if `cellDependencies` has been explicitly set.
  var hasCellDependencies: Bool {return _storage._cellDependencies != nil}
  /// Clears the value of `cellDependencies`. Subsequent reads from it will return its default value.
  mutating func clearCellDependencies() {_uniqueStorage()._cellDependencies = nil}

  var rangeDependencies: TSCE_RangeDependenciesArchive {
    get {return _storage._rangeDependencies ?? TSCE_RangeDependenciesArchive()}
    set {_uniqueStorage()._rangeDependencies = newValue}
  }
  /// Returns true if `rangeDependencies` has been explicitly set.
  var hasRangeDependencies: Bool {return _storage._rangeDependencies != nil}
  /// Clears the value of `rangeDependencies`. Subsequent reads from it will return its default value.
  mutating func clearRangeDependencies() {_uniqueStorage()._rangeDependencies = nil}

  var volatileDependencies: TSCE_VolatileDependenciesExpandedArchive {
    get {return _storage._volatileDependencies ?? TSCE_VolatileDependenciesExpandedArchive()}
    set {_uniqueStorage()._volatileDependencies = newValue}
  }
  /// Returns true if `volatileDependencies` has been explicitly set.
  var hasVolatileDependencies: Bool {return _storage._volatileDependencies != nil}
  /// Clears the value of `volatileDependencies`. Subsequent reads from it will return its default value.
  mutating func clearVolatileDependencies() {_uniqueStorage()._volatileDependencies = nil}

  var spanningColumnDependencies: TSCE_SpanningDependenciesExpandedArchive {
    get {return _storage._spanningColumnDependencies ?? TSCE_SpanningDependenciesExpandedArchive()}
    set {_uniqueStorage()._spanningColumnDependencies = newValue}
  }
  /// Returns true if `spanningColumnDependencies` has been explicitly set.
  var hasSpanningColumnDependencies: Bool {return _storage._spanningColumnDependencies != nil}
  /// Clears the value of `spanningColumnDependencies`. Subsequent reads from it will return its default value.
  mutating func clearSpanningColumnDependencies() {_uniqueStorage()._spanningColumnDependencies = nil}

  var spanningRowDependencies: TSCE_SpanningDependenciesExpandedArchive {
    get {return _storage._spanningRowDependencies ?? TSCE_SpanningDependenciesExpandedArchive()}
    set {_uniqueStorage()._spanningRowDependencies = newValue}
  }
  /// Returns true if `spanningRowDependencies` has been explicitly set.
  var hasSpanningRowDependencies: Bool {return _storage._spanningRowDependencies != nil}
  /// Clears the value of `spanningRowDependencies`. Subsequent reads from it will return its default value.
  mutating func clearSpanningRowDependencies() {_uniqueStorage()._spanningRowDependencies = nil}

  var wholeOwnerDependencies: TSCE_WholeOwnerDependenciesExpandedArchive {
    get {return _storage._wholeOwnerDependencies ?? TSCE_WholeOwnerDependenciesExpandedArchive()}
    set {_uniqueStorage()._wholeOwnerDependencies = newValue}
  }
  /// Returns true if `wholeOwnerDependencies` has been explicitly set.
  var hasWholeOwnerDependencies: Bool {return _storage._wholeOwnerDependencies != nil}
  /// Clears the value of `wholeOwnerDependencies`. Subsequent reads from it will return its default value.
  mutating func clearWholeOwnerDependencies() {_uniqueStorage()._wholeOwnerDependencies = nil}

  var cellErrors: TSCE_CellErrorsArchive {
    get {return _storage._cellErrors ?? TSCE_CellErrorsArchive()}
    set {_uniqueStorage()._cellErrors = newValue}
  }
  /// Returns true if `cellErrors` has been explicitly set.
  var hasCellErrors: Bool {return _storage._cellErrors != nil}
  /// Clears the value of `cellErrors`. Subsequent reads from it will return its default value.
  mutating func clearCellErrors() {_uniqueStorage()._cellErrors = nil}

  var formulaOwner: TSP_Reference {
    get {return _storage._formulaOwner ?? TSP_Reference()}
    set {_uniqueStorage()._formulaOwner = newValue}
  }
  /// Returns true if `formulaOwner` has been explicitly set.
  var hasFormulaOwner: Bool {return _storage._formulaOwner != nil}
  /// Clears the value of `formulaOwner`. Subsequent reads from it will return its default value.
  mutating func clearFormulaOwner() {_uniqueStorage()._formulaOwner = nil}

  var baseOwnerUid: TSP_UUID {
    get {return _storage._baseOwnerUid ?? TSP_UUID()}
    set {_uniqueStorage()._baseOwnerUid = newValue}
  }
  /// Returns true if `baseOwnerUid` has been explicitly set.
  var hasBaseOwnerUid: Bool {return _storage._baseOwnerUid != nil}
  /// Clears the value of `baseOwnerUid`. Subsequent reads from it will return its default value.
  mutating func clearBaseOwnerUid() {_uniqueStorage()._baseOwnerUid = nil}

  var tiledCellDependencies: TSCE_CellDependenciesTiledArchive {
    get {return _storage._tiledCellDependencies ?? TSCE_CellDependenciesTiledArchive()}
    set {_uniqueStorage()._tiledCellDependencies = newValue}
  }
  /// Returns true if `tiledCellDependencies` has been explicitly set.
  var hasTiledCellDependencies: Bool {return _storage._tiledCellDependencies != nil}
  /// Clears the value of `tiledCellDependencies`. Subsequent reads from it will return its default value.
  mutating func clearTiledCellDependencies() {_uniqueStorage()._tiledCellDependencies = nil}

  var uuidReferences: TSCE_UuidReferencesArchive {
    get {return _storage._uuidReferences ?? TSCE_UuidReferencesArchive()}
    set {_uniqueStorage()._uuidReferences = newValue}
  }
  /// Returns true if `uuidReferences` has been explicitly set.
  var hasUuidReferences: Bool {return _storage._uuidReferences != nil}
  /// Clears the value of `uuidReferences`. Subsequent reads from it will return its default value.
  mutating func clearUuidReferences() {_uniqueStorage()._uuidReferences = nil}

  var tiledRangeDependencies: TSCE_RangeDependenciesTiledArchive {
    get {return _storage._tiledRangeDependencies ?? TSCE_RangeDependenciesTiledArchive()}
    set {_uniqueStorage()._tiledRangeDependencies = newValue}
  }
  /// Returns true if `tiledRangeDependencies` has been explicitly set.
  var hasTiledRangeDependencies: Bool {return _storage._tiledRangeDependencies != nil}
  /// Clears the value of `tiledRangeDependencies`. Subsequent reads from it will return its default value.
  mutating func clearTiledRangeDependencies() {_uniqueStorage()._tiledRangeDependencies = nil}

  var spillRangeSizes: TSCE_CellSpillSizesArchive {
    get {return _storage._spillRangeSizes ?? TSCE_CellSpillSizesArchive()}
    set {_uniqueStorage()._spillRangeSizes = newValue}
  }
  /// Returns true if `spillRangeSizes` has been explicitly set.
  var hasSpillRangeSizes: Bool {return _storage._spillRangeSizes != nil}
  /// Clears the value of `spillRangeSizes`. Subsequent reads from it will return its default value.
  mutating func clearSpillRangeSizes() {_uniqueStorage()._spillRangeSizes = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSCE_FormulaOwnerInfoArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var formulaOwnerID: TSP_CFUUIDArchive {
    get {return _storage._formulaOwnerID ?? TSP_CFUUIDArchive()}
    set {_uniqueStorage()._formulaOwnerID = newValue}
  }
  /// Returns true if `formulaOwnerID` has been explicitly set.
  var hasFormulaOwnerID: Bool {return _storage._formulaOwnerID != nil}
  /// Clears the value of `formulaOwnerID`. Subsequent reads from it will return its default value.
  mutating func clearFormulaOwnerID() {_uniqueStorage()._formulaOwnerID = nil}

  var cellDependencies: TSCE_CellDependenciesArchive {
    get {return _storage._cellDependencies ?? TSCE_CellDependenciesArchive()}
    set {_uniqueStorage()._cellDependencies = newValue}
  }
  /// Returns true if `cellDependencies` has been explicitly set.
  var hasCellDependencies: Bool {return _storage._cellDependencies != nil}
  /// Clears the value of `cellDependencies`. Subsequent reads from it will return its default value.
  mutating func clearCellDependencies() {_uniqueStorage()._cellDependencies = nil}

  var rangeDependencies: TSCE_RangeDependenciesArchive {
    get {return _storage._rangeDependencies ?? TSCE_RangeDependenciesArchive()}
    set {_uniqueStorage()._rangeDependencies = newValue}
  }
  /// Returns true if `rangeDependencies` has been explicitly set.
  var hasRangeDependencies: Bool {return _storage._rangeDependencies != nil}
  /// Clears the value of `rangeDependencies`. Subsequent reads from it will return its default value.
  mutating func clearRangeDependencies() {_uniqueStorage()._rangeDependencies = nil}

  var volatileDependencies: TSCE_VolatileDependenciesArchive {
    get {return _storage._volatileDependencies ?? TSCE_VolatileDependenciesArchive()}
    set {_uniqueStorage()._volatileDependencies = newValue}
  }
  /// Returns true if `volatileDependencies` has been explicitly set.
  var hasVolatileDependencies: Bool {return _storage._volatileDependencies != nil}
  /// Clears the value of `volatileDependencies`. Subsequent reads from it will return its default value.
  mutating func clearVolatileDependencies() {_uniqueStorage()._volatileDependencies = nil}

  var spanningColumnDependencies: TSCE_SpanningDependenciesArchive {
    get {return _storage._spanningColumnDependencies ?? TSCE_SpanningDependenciesArchive()}
    set {_uniqueStorage()._spanningColumnDependencies = newValue}
  }
  /// Returns true if `spanningColumnDependencies` has been explicitly set.
  var hasSpanningColumnDependencies: Bool {return _storage._spanningColumnDependencies != nil}
  /// Clears the value of `spanningColumnDependencies`. Subsequent reads from it will return its default value.
  mutating func clearSpanningColumnDependencies() {_uniqueStorage()._spanningColumnDependencies = nil}

  var spanningRowDependencies: TSCE_SpanningDependenciesArchive {
    get {return _storage._spanningRowDependencies ?? TSCE_SpanningDependenciesArchive()}
    set {_uniqueStorage()._spanningRowDependencies = newValue}
  }
  /// Returns true if `spanningRowDependencies` has been explicitly set.
  var hasSpanningRowDependencies: Bool {return _storage._spanningRowDependencies != nil}
  /// Clears the value of `spanningRowDependencies`. Subsequent reads from it will return its default value.
  mutating func clearSpanningRowDependencies() {_uniqueStorage()._spanningRowDependencies = nil}

  var wholeOwnerDependencies: TSCE_WholeOwnerDependenciesArchive {
    get {return _storage._wholeOwnerDependencies ?? TSCE_WholeOwnerDependenciesArchive()}
    set {_uniqueStorage()._wholeOwnerDependencies = newValue}
  }
  /// Returns true if `wholeOwnerDependencies` has been explicitly set.
  var hasWholeOwnerDependencies: Bool {return _storage._wholeOwnerDependencies != nil}
  /// Clears the value of `wholeOwnerDependencies`. Subsequent reads from it will return its default value.
  mutating func clearWholeOwnerDependencies() {_uniqueStorage()._wholeOwnerDependencies = nil}

  var cellErrors: TSCE_CellErrorsArchive {
    get {return _storage._cellErrors ?? TSCE_CellErrorsArchive()}
    set {_uniqueStorage()._cellErrors = newValue}
  }
  /// Returns true if `cellErrors` has been explicitly set.
  var hasCellErrors: Bool {return _storage._cellErrors != nil}
  /// Clears the value of `cellErrors`. Subsequent reads from it will return its default value.
  mutating func clearCellErrors() {_uniqueStorage()._cellErrors = nil}

  var formulaOwner: TSP_Reference {
    get {return _storage._formulaOwner ?? TSP_Reference()}
    set {_uniqueStorage()._formulaOwner = newValue}
  }
  /// Returns true if `formulaOwner` has been explicitly set.
  var hasFormulaOwner: Bool {return _storage._formulaOwner != nil}
  /// Clears the value of `formulaOwner`. Subsequent reads from it will return its default value.
  mutating func clearFormulaOwner() {_uniqueStorage()._formulaOwner = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSCE_SubFormulaOwnerIDArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseOwnerUid: TSP_UUID {
    get {return _baseOwnerUid ?? TSP_UUID()}
    set {_baseOwnerUid = newValue}
  }
  /// Returns true if `baseOwnerUid` has been explicitly set.
  var hasBaseOwnerUid: Bool {return self._baseOwnerUid != nil}
  /// Clears the value of `baseOwnerUid`. Subsequent reads from it will return its default value.
  mutating func clearBaseOwnerUid() {self._baseOwnerUid = nil}

  var ownerKind: UInt32 {
    get {return _ownerKind ?? 0}
    set {_ownerKind = newValue}
  }
  /// Returns true if `ownerKind` has been explicitly set.
  var hasOwnerKind: Bool {return self._ownerKind != nil}
  /// Clears the value of `ownerKind`. Subsequent reads from it will return its default value.
  mutating func clearOwnerKind() {self._ownerKind = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baseOwnerUid: TSP_UUID? = nil
  fileprivate var _ownerKind: UInt32? = nil
}

struct TSCE_OwnerIDMapArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mapEntry: [TSCE_OwnerIDMapArchive.OwnerIDMapArchiveEntry] = []

  var unregisteredInternalOwnerID: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct OwnerIDMapArchiveEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var internalOwnerID: UInt32 {
      get {return _internalOwnerID ?? 0}
      set {_internalOwnerID = newValue}
    }
    /// Returns true if `internalOwnerID` has been explicitly set.
    var hasInternalOwnerID: Bool {return self._internalOwnerID != nil}
    /// Clears the value of `internalOwnerID`. Subsequent reads from it will return its default value.
    mutating func clearInternalOwnerID() {self._internalOwnerID = nil}

    var ownerID: TSP_CFUUIDArchive {
      get {return _ownerID ?? TSP_CFUUIDArchive()}
      set {_ownerID = newValue}
    }
    /// Returns true if `ownerID` has been explicitly set.
    var hasOwnerID: Bool {return self._ownerID != nil}
    /// Clears the value of `ownerID`. Subsequent reads from it will return its default value.
    mutating func clearOwnerID() {self._ownerID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _internalOwnerID: UInt32? = nil
    fileprivate var _ownerID: TSP_CFUUIDArchive? = nil
  }

  init() {}
}

struct TSCE_UidLookupListArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuids: [TSP_UUID] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSCE_DependencyTrackerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var formulaOwnerInfo: [TSCE_FormulaOwnerInfoArchive] = []

  /// NOTE: This field was marked as deprecated in the .proto file.
  var dirtyLeaf: [TSCE_CellReferenceArchive] = []

  var ownerIDMap: TSCE_OwnerIDMapArchive {
    get {return _ownerIDMap ?? TSCE_OwnerIDMapArchive()}
    set {_ownerIDMap = newValue}
  }
  /// Returns true if `ownerIDMap` has been explicitly set.
  var hasOwnerIDMap: Bool {return self._ownerIDMap != nil}
  /// Clears the value of `ownerIDMap`. Subsequent reads from it will return its default value.
  mutating func clearOwnerIDMap() {self._ownerIDMap = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var internalDirtyLeaf: [TSCE_InternalCellReferenceArchive] = []

  var numberOfFormulas: UInt64 {
    get {return _numberOfFormulas ?? 0}
    set {_numberOfFormulas = newValue}
  }
  /// Returns true if `numberOfFormulas` has been explicitly set.
  var hasNumberOfFormulas: Bool {return self._numberOfFormulas != nil}
  /// Clears the value of `numberOfFormulas`. Subsequent reads from it will return its default value.
  mutating func clearNumberOfFormulas() {self._numberOfFormulas = nil}

  var formulaOwnerDependencies: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ownerIDMap: TSCE_OwnerIDMapArchive? = nil
  fileprivate var _numberOfFormulas: UInt64? = nil
}

struct TSCE_RemoteDataSpecifierArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var functionIndex: UInt32 {
    get {return _functionIndex ?? 0}
    set {_functionIndex = newValue}
  }
  /// Returns true if `functionIndex` has been explicitly set.
  var hasFunctionIndex: Bool {return self._functionIndex != nil}
  /// Clears the value of `functionIndex`. Subsequent reads from it will return its default value.
  mutating func clearFunctionIndex() {self._functionIndex = nil}

  var symbol: String {
    get {return _symbol ?? String()}
    set {_symbol = newValue}
  }
  /// Returns true if `symbol` has been explicitly set.
  var hasSymbol: Bool {return self._symbol != nil}
  /// Clears the value of `symbol`. Subsequent reads from it will return its default value.
  mutating func clearSymbol() {self._symbol = nil}

  var attribute: UInt32 {
    get {return _attribute ?? 0}
    set {_attribute = newValue}
  }
  /// Returns true if `attribute` has been explicitly set.
  var hasAttribute: Bool {return self._attribute != nil}
  /// Clears the value of `attribute`. Subsequent reads from it will return its default value.
  mutating func clearAttribute() {self._attribute = nil}

  var date: Double {
    get {return _date ?? 0}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {self._date = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _functionIndex: UInt32? = nil
  fileprivate var _symbol: String? = nil
  fileprivate var _attribute: UInt32? = nil
  fileprivate var _date: Double? = nil
}

struct TSCE_RemoteDataValueMapArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entry: [TSCE_RemoteDataValueMapArchive.RemoteDataMapEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct RemoteDataMapEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var specifier: TSCE_RemoteDataSpecifierArchive {
      get {return _specifier ?? TSCE_RemoteDataSpecifierArchive()}
      set {_specifier = newValue}
    }
    /// Returns true if `specifier` has been explicitly set.
    var hasSpecifier: Bool {return self._specifier != nil}
    /// Clears the value of `specifier`. Subsequent reads from it will return its default value.
    mutating func clearSpecifier() {self._specifier = nil}

    var value: TSCE_CellValueArchive {
      get {return _value ?? TSCE_CellValueArchive()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _specifier: TSCE_RemoteDataSpecifierArchive? = nil
    fileprivate var _value: TSCE_CellValueArchive? = nil
  }

  init() {}
}

struct TSCE_StockArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var symbol: String {
    get {return _symbol ?? String()}
    set {_symbol = newValue}
  }
  /// Returns true if `symbol` has been explicitly set.
  var hasSymbol: Bool {return self._symbol != nil}
  /// Clears the value of `symbol`. Subsequent reads from it will return its default value.
  mutating func clearSymbol() {self._symbol = nil}

  var date: Double {
    get {return _date ?? 0}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {self._date = nil}

  var attribute: [TSCE_StockArchive.AttributeEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct AttributeEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var attribute: UInt32 {
      get {return _attribute ?? 0}
      set {_attribute = newValue}
    }
    /// Returns true if `attribute` has been explicitly set.
    var hasAttribute: Bool {return self._attribute != nil}
    /// Clears the value of `attribute`. Subsequent reads from it will return its default value.
    mutating func clearAttribute() {self._attribute = nil}

    var value: String {
      get {return _value ?? String()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _attribute: UInt32? = nil
    fileprivate var _value: String? = nil
  }

  init() {}

  fileprivate var _symbol: String? = nil
  fileprivate var _date: Double? = nil
}

struct TSCE_RemoteDataStoreArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var valueMap: TSCE_RemoteDataValueMapArchive {
    get {return _valueMap ?? TSCE_RemoteDataValueMapArchive()}
    set {_valueMap = newValue}
  }
  /// Returns true if `valueMap` has been explicitly set.
  var hasValueMap: Bool {return self._valueMap != nil}
  /// Clears the value of `valueMap`. Subsequent reads from it will return its default value.
  mutating func clearValueMap() {self._valueMap = nil}

  var stocks: [TSCE_StockArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _valueMap: TSCE_RemoteDataValueMapArchive? = nil
}

struct TSCE_NameTrackedReferencePair: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var trackedReference: TSP_Reference {
    get {return _trackedReference ?? TSP_Reference()}
    set {_trackedReference = newValue}
  }
  /// Returns true if `trackedReference` has been explicitly set.
  var hasTrackedReference: Bool {return self._trackedReference != nil}
  /// Clears the value of `trackedReference`. Subsequent reads from it will return its default value.
  mutating func clearTrackedReference() {self._trackedReference = nil}

  var trackedReferenceID: UInt32 {
    get {return _trackedReferenceID ?? 0}
    set {_trackedReferenceID = newValue}
  }
  /// Returns true if `trackedReferenceID` has been explicitly set.
  var hasTrackedReferenceID: Bool {return self._trackedReferenceID != nil}
  /// Clears the value of `trackedReferenceID`. Subsequent reads from it will return its default value.
  mutating func clearTrackedReferenceID() {self._trackedReferenceID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _trackedReference: TSP_Reference? = nil
  fileprivate var _trackedReferenceID: UInt32? = nil
}

struct TSCE_NamesByTrackedReferenceArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tableID: TSP_CFUUIDArchive {
    get {return _tableID ?? TSP_CFUUIDArchive()}
    set {_tableID = newValue}
  }
  /// Returns true if `tableID` has been explicitly set.
  var hasTableID: Bool {return self._tableID != nil}
  /// Clears the value of `tableID`. Subsequent reads from it will return its default value.
  mutating func clearTableID() {self._tableID = nil}

  var nameTrackedReferencePair: [TSCE_NameTrackedReferencePair] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tableID: TSP_CFUUIDArchive? = nil
}

struct TSCE_NamedReferenceManagerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var referenceTracker: TSP_Reference {
    get {return _referenceTracker ?? TSP_Reference()}
    set {_referenceTracker = newValue}
  }
  /// Returns true if `referenceTracker` has been explicitly set.
  var hasReferenceTracker: Bool {return self._referenceTracker != nil}
  /// Clears the value of `referenceTracker`. Subsequent reads from it will return its default value.
  mutating func clearReferenceTracker() {self._referenceTracker = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var namesByTrackedReferenceByTable: [TSCE_NamesByTrackedReferenceArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _referenceTracker: TSP_Reference? = nil
}

struct TSCE_UuidSetStoreArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuidSet: [TSCE_UuidSetStoreArchive.UuidSet] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct UuidSet: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uuid: [TSP_UUID] = []

    var indexOfSet: UInt32 {
      get {return _indexOfSet ?? 0}
      set {_indexOfSet = newValue}
    }
    /// Returns true if `indexOfSet` has been explicitly set.
    var hasIndexOfSet: Bool {return self._indexOfSet != nil}
    /// Clears the value of `indexOfSet`. Subsequent reads from it will return its default value.
    mutating func clearIndexOfSet() {self._indexOfSet = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _indexOfSet: UInt32? = nil
  }

  init() {}
}

struct TSCE_UuidReferenceMapArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cellRefsForUuid: [TSCE_UuidReferenceMapArchive.CellRefsForUuid] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct CellRefsForUuid: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uuid: TSP_UUID {
      get {return _uuid ?? TSP_UUID()}
      set {_uuid = newValue}
    }
    /// Returns true if `uuid` has been explicitly set.
    var hasUuid: Bool {return self._uuid != nil}
    /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
    mutating func clearUuid() {self._uuid = nil}

    var cellRef: [TSCE_InternalCellReferenceArchive] = []

    var cellRefs: TSCE_InternalCellRefSetArchive {
      get {return _cellRefs ?? TSCE_InternalCellRefSetArchive()}
      set {_cellRefs = newValue}
    }
    /// Returns true if `cellRefs` has been explicitly set.
    var hasCellRefs: Bool {return self._cellRefs != nil}
    /// Clears the value of `cellRefs`. Subsequent reads from it will return its default value.
    mutating func clearCellRefs() {self._cellRefs = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _uuid: TSP_UUID? = nil
    fileprivate var _cellRefs: TSCE_InternalCellRefSetArchive? = nil
  }

  init() {}
}

struct TSCE_GroupByNodeMapArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var refsForGroupBy: [TSCE_GroupByNodeMapArchive.GroupNodesForGroupBy] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct CellRefsForGroupNode: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var groupNodeUid: TSP_UUID {
      get {return _groupNodeUid ?? TSP_UUID()}
      set {_groupNodeUid = newValue}
    }
    /// Returns true if `groupNodeUid` has been explicitly set.
    var hasGroupNodeUid: Bool {return self._groupNodeUid != nil}
    /// Clears the value of `groupNodeUid`. Subsequent reads from it will return its default value.
    mutating func clearGroupNodeUid() {self._groupNodeUid = nil}

    var cellRefs: TSCE_InternalCellRefSetArchive {
      get {return _cellRefs ?? TSCE_InternalCellRefSetArchive()}
      set {_cellRefs = newValue}
    }
    /// Returns true if `cellRefs` has been explicitly set.
    var hasCellRefs: Bool {return self._cellRefs != nil}
    /// Clears the value of `cellRefs`. Subsequent reads from it will return its default value.
    mutating func clearCellRefs() {self._cellRefs = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _groupNodeUid: TSP_UUID? = nil
    fileprivate var _cellRefs: TSCE_InternalCellRefSetArchive? = nil
  }

  struct GroupNodesForGroupBy: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var groupByUid: TSP_UUID {
      get {return _groupByUid ?? TSP_UUID()}
      set {_groupByUid = newValue}
    }
    /// Returns true if `groupByUid` has been explicitly set.
    var hasGroupByUid: Bool {return self._groupByUid != nil}
    /// Clears the value of `groupByUid`. Subsequent reads from it will return its default value.
    mutating func clearGroupByUid() {self._groupByUid = nil}

    var refsForGroupNode: [TSCE_GroupByNodeMapArchive.CellRefsForGroupNode] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _groupByUid: TSP_UUID? = nil
  }

  init() {}
}

struct TSCE_CalculationEngineArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var baseDate1904: Bool {
    get {return _storage._baseDate1904 ?? false}
    set {_uniqueStorage()._baseDate1904 = newValue}
  }
  /// Returns true if `baseDate1904` has been explicitly set.
  var hasBaseDate1904: Bool {return _storage._baseDate1904 != nil}
  /// Clears the value of `baseDate1904`. Subsequent reads from it will return its default value.
  mutating func clearBaseDate1904() {_uniqueStorage()._baseDate1904 = nil}

  var dependencyTracker: TSCE_DependencyTrackerArchive {
    get {return _storage._dependencyTracker ?? TSCE_DependencyTrackerArchive()}
    set {_uniqueStorage()._dependencyTracker = newValue}
  }
  /// Returns true if `dependencyTracker` has been explicitly set.
  var hasDependencyTracker: Bool {return _storage._dependencyTracker != nil}
  /// Clears the value of `dependencyTracker`. Subsequent reads from it will return its default value.
  mutating func clearDependencyTracker() {_uniqueStorage()._dependencyTracker = nil}

  var namedReferenceManager: TSP_Reference {
    get {return _storage._namedReferenceManager ?? TSP_Reference()}
    set {_uniqueStorage()._namedReferenceManager = newValue}
  }
  /// Returns true if `namedReferenceManager` has been explicitly set.
  var hasNamedReferenceManager: Bool {return _storage._namedReferenceManager != nil}
  /// Clears the value of `namedReferenceManager`. Subsequent reads from it will return its default value.
  mutating func clearNamedReferenceManager() {_uniqueStorage()._namedReferenceManager = nil}

  var excelImportDateMode: TSCE_CalculationEngineArchive.ExcelImportDateMode {
    get {return _storage._excelImportDateMode ?? .dateMode1900}
    set {_uniqueStorage()._excelImportDateMode = newValue}
  }
  /// Returns true if `excelImportDateMode` has been explicitly set.
  var hasExcelImportDateMode: Bool {return _storage._excelImportDateMode != nil}
  /// Clears the value of `excelImportDateMode`. Subsequent reads from it will return its default value.
  mutating func clearExcelImportDateMode() {_uniqueStorage()._excelImportDateMode = nil}

  var savedLocaleIdentifierFor42: String {
    get {return _storage._savedLocaleIdentifierFor42 ?? String()}
    set {_uniqueStorage()._savedLocaleIdentifierFor42 = newValue}
  }
  /// Returns true if `savedLocaleIdentifierFor42` has been explicitly set.
  var hasSavedLocaleIdentifierFor42: Bool {return _storage._savedLocaleIdentifierFor42 != nil}
  /// Clears the value of `savedLocaleIdentifierFor42`. Subsequent reads from it will return its default value.
  mutating func clearSavedLocaleIdentifierFor42() {_uniqueStorage()._savedLocaleIdentifierFor42 = nil}

  var documentRandomSeed: UInt64 {
    get {return _storage._documentRandomSeed ?? 0}
    set {_uniqueStorage()._documentRandomSeed = newValue}
  }
  /// Returns true if `documentRandomSeed` has been explicitly set.
  var hasDocumentRandomSeed: Bool {return _storage._documentRandomSeed != nil}
  /// Clears the value of `documentRandomSeed`. Subsequent reads from it will return its default value.
  mutating func clearDocumentRandomSeed() {_uniqueStorage()._documentRandomSeed = nil}

  var uuidReferenceMap: TSCE_UuidReferenceMapArchive {
    get {return _storage._uuidReferenceMap ?? TSCE_UuidReferenceMapArchive()}
    set {_uniqueStorage()._uuidReferenceMap = newValue}
  }
  /// Returns true if `uuidReferenceMap` has been explicitly set.
  var hasUuidReferenceMap: Bool {return _storage._uuidReferenceMap != nil}
  /// Clears the value of `uuidReferenceMap`. Subsequent reads from it will return its default value.
  mutating func clearUuidReferenceMap() {_uniqueStorage()._uuidReferenceMap = nil}

  var documentTimestamp: Double {
    get {return _storage._documentTimestamp ?? 0}
    set {_uniqueStorage()._documentTimestamp = newValue}
  }
  /// Returns true if `documentTimestamp` has been explicitly set.
  var hasDocumentTimestamp: Bool {return _storage._documentTimestamp != nil}
  /// Clears the value of `documentTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearDocumentTimestamp() {_uniqueStorage()._documentTimestamp = nil}

  var documentTimezone: String {
    get {return _storage._documentTimezone ?? String()}
    set {_uniqueStorage()._documentTimezone = newValue}
  }
  /// Returns true if `documentTimezone` has been explicitly set.
  var hasDocumentTimezone: Bool {return _storage._documentTimezone != nil}
  /// Clears the value of `documentTimezone`. Subsequent reads from it will return its default value.
  mutating func clearDocumentTimezone() {_uniqueStorage()._documentTimezone = nil}

  var tableUidHistory: TSCE_RewriteTableUIDInfoArchive {
    get {return _storage._tableUidHistory ?? TSCE_RewriteTableUIDInfoArchive()}
    set {_uniqueStorage()._tableUidHistory = newValue}
  }
  /// Returns true if `tableUidHistory` has been explicitly set.
  var hasTableUidHistory: Bool {return _storage._tableUidHistory != nil}
  /// Clears the value of `tableUidHistory`. Subsequent reads from it will return its default value.
  mutating func clearTableUidHistory() {_uniqueStorage()._tableUidHistory = nil}

  var remoteDataStore: TSP_Reference {
    get {return _storage._remoteDataStore ?? TSP_Reference()}
    set {_uniqueStorage()._remoteDataStore = newValue}
  }
  /// Returns true if `remoteDataStore` has been explicitly set.
  var hasRemoteDataStore: Bool {return _storage._remoteDataStore != nil}
  /// Clears the value of `remoteDataStore`. Subsequent reads from it will return its default value.
  mutating func clearRemoteDataStore() {_uniqueStorage()._remoteDataStore = nil}

  var groupNodeMap: TSCE_GroupByNodeMapArchive {
    get {return _storage._groupNodeMap ?? TSCE_GroupByNodeMapArchive()}
    set {_uniqueStorage()._groupNodeMap = newValue}
  }
  /// Returns true if `groupNodeMap` has been explicitly set.
  var hasGroupNodeMap: Bool {return _storage._groupNodeMap != nil}
  /// Clears the value of `groupNodeMap`. Subsequent reads from it will return its default value.
  mutating func clearGroupNodeMap() {_uniqueStorage()._groupNodeMap = nil}

  var headerNameManager: TSP_Reference {
    get {return _storage._headerNameManager ?? TSP_Reference()}
    set {_uniqueStorage()._headerNameManager = newValue}
  }
  /// Returns true if `headerNameManager` has been explicitly set.
  var hasHeaderNameManager: Bool {return _storage._headerNameManager != nil}
  /// Clears the value of `headerNameManager`. Subsequent reads from it will return its default value.
  mutating func clearHeaderNameManager() {_uniqueStorage()._headerNameManager = nil}

  var refsToDirty: TSP_Reference {
    get {return _storage._refsToDirty ?? TSP_Reference()}
    set {_uniqueStorage()._refsToDirty = newValue}
  }
  /// Returns true if `refsToDirty` has been explicitly set.
  var hasRefsToDirty: Bool {return _storage._refsToDirty != nil}
  /// Clears the value of `refsToDirty`. Subsequent reads from it will return its default value.
  mutating func clearRefsToDirty() {_uniqueStorage()._refsToDirty = nil}

  var savedLocaleIdentifier: String {
    get {return _storage._savedLocaleIdentifier ?? String()}
    set {_uniqueStorage()._savedLocaleIdentifier = newValue}
  }
  /// Returns true if `savedLocaleIdentifier` has been explicitly set.
  var hasSavedLocaleIdentifier: Bool {return _storage._savedLocaleIdentifier != nil}
  /// Clears the value of `savedLocaleIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearSavedLocaleIdentifier() {_uniqueStorage()._savedLocaleIdentifier = nil}

  var beginTrackingNamesLegacyNrm: [TSP_UUID] {
    get {return _storage._beginTrackingNamesLegacyNrm}
    set {_uniqueStorage()._beginTrackingNamesLegacyNrm = newValue}
  }

  var endTrackingNamesLegacyNrm: [TSP_UUID] {
    get {return _storage._endTrackingNamesLegacyNrm}
    set {_uniqueStorage()._endTrackingNamesLegacyNrm = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ExcelImportDateMode: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case dateMode1900 = 1
    case dateMode1900Legacy = 2
    case dateMode1904Legacy = 3

    init() {
      self = .dateMode1900
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSCE_PreserveColumnRowFlagsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var beginRowIsAbsolute: Bool {
    get {return _beginRowIsAbsolute ?? false}
    set {_beginRowIsAbsolute = newValue}
  }
  /// Returns true if `beginRowIsAbsolute` has been explicitly set.
  var hasBeginRowIsAbsolute: Bool {return self._beginRowIsAbsolute != nil}
  /// Clears the value of `beginRowIsAbsolute`. Subsequent reads from it will return its default value.
  mutating func clearBeginRowIsAbsolute() {self._beginRowIsAbsolute = nil}

  var beginColumnIsAbsolute: Bool {
    get {return _beginColumnIsAbsolute ?? false}
    set {_beginColumnIsAbsolute = newValue}
  }
  /// Returns true if `beginColumnIsAbsolute` has been explicitly set.
  var hasBeginColumnIsAbsolute: Bool {return self._beginColumnIsAbsolute != nil}
  /// Clears the value of `beginColumnIsAbsolute`. Subsequent reads from it will return its default value.
  mutating func clearBeginColumnIsAbsolute() {self._beginColumnIsAbsolute = nil}

  var endRowIsAbsolute: Bool {
    get {return _endRowIsAbsolute ?? false}
    set {_endRowIsAbsolute = newValue}
  }
  /// Returns true if `endRowIsAbsolute` has been explicitly set.
  var hasEndRowIsAbsolute: Bool {return self._endRowIsAbsolute != nil}
  /// Clears the value of `endRowIsAbsolute`. Subsequent reads from it will return its default value.
  mutating func clearEndRowIsAbsolute() {self._endRowIsAbsolute = nil}

  var endColumnIsAbsolute: Bool {
    get {return _endColumnIsAbsolute ?? false}
    set {_endColumnIsAbsolute = newValue}
  }
  /// Returns true if `endColumnIsAbsolute` has been explicitly set.
  var hasEndColumnIsAbsolute: Bool {return self._endColumnIsAbsolute != nil}
  /// Clears the value of `endColumnIsAbsolute`. Subsequent reads from it will return its default value.
  mutating func clearEndColumnIsAbsolute() {self._endColumnIsAbsolute = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _beginRowIsAbsolute: Bool? = nil
  fileprivate var _beginColumnIsAbsolute: Bool? = nil
  fileprivate var _endRowIsAbsolute: Bool? = nil
  fileprivate var _endColumnIsAbsolute: Bool? = nil
}

struct TSCE_CategoryReferenceArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groupByUid: TSP_UUID {
    get {return _storage._groupByUid ?? TSP_UUID()}
    set {_uniqueStorage()._groupByUid = newValue}
  }
  /// Returns true if `groupByUid` has been explicitly set.
  var hasGroupByUid: Bool {return _storage._groupByUid != nil}
  /// Clears the value of `groupByUid`. Subsequent reads from it will return its default value.
  mutating func clearGroupByUid() {_uniqueStorage()._groupByUid = nil}

  var columnUid: TSP_UUID {
    get {return _storage._columnUid ?? TSP_UUID()}
    set {_uniqueStorage()._columnUid = newValue}
  }
  /// Returns true if `columnUid` has been explicitly set.
  var hasColumnUid: Bool {return _storage._columnUid != nil}
  /// Clears the value of `columnUid`. Subsequent reads from it will return its default value.
  mutating func clearColumnUid() {_uniqueStorage()._columnUid = nil}

  var aggregateType: UInt32 {
    get {return _storage._aggregateType ?? 0}
    set {_uniqueStorage()._aggregateType = newValue}
  }
  /// Returns true if `aggregateType` has been explicitly set.
  var hasAggregateType: Bool {return _storage._aggregateType != nil}
  /// Clears the value of `aggregateType`. Subsequent reads from it will return its default value.
  mutating func clearAggregateType() {_uniqueStorage()._aggregateType = nil}

  var groupLevel: Int32 {
    get {return _storage._groupLevel ?? 0}
    set {_uniqueStorage()._groupLevel = newValue}
  }
  /// Returns true if `groupLevel` has been explicitly set.
  var hasGroupLevel: Bool {return _storage._groupLevel != nil}
  /// Clears the value of `groupLevel`. Subsequent reads from it will return its default value.
  mutating func clearGroupLevel() {_uniqueStorage()._groupLevel = nil}

  var groupUids: TSCE_CategoryReferenceArchive.CatRefUidList {
    get {return _storage._groupUids ?? TSCE_CategoryReferenceArchive.CatRefUidList()}
    set {_uniqueStorage()._groupUids = newValue}
  }
  /// Returns true if `groupUids` has been explicitly set.
  var hasGroupUids: Bool {return _storage._groupUids != nil}
  /// Clears the value of `groupUids`. Subsequent reads from it will return its default value.
  mutating func clearGroupUids() {_uniqueStorage()._groupUids = nil}

  var preserveFlags: TSCE_PreserveColumnRowFlagsArchive {
    get {return _storage._preserveFlags ?? TSCE_PreserveColumnRowFlagsArchive()}
    set {_uniqueStorage()._preserveFlags = newValue}
  }
  /// Returns true if `preserveFlags` has been explicitly set.
  var hasPreserveFlags: Bool {return _storage._preserveFlags != nil}
  /// Clears the value of `preserveFlags`. Subsequent reads from it will return its default value.
  mutating func clearPreserveFlags() {_uniqueStorage()._preserveFlags = nil}

  var relativeColumn: Int32 {
    get {return _storage._relativeColumn ?? 0}
    set {_uniqueStorage()._relativeColumn = newValue}
  }
  /// Returns true if `relativeColumn` has been explicitly set.
  var hasRelativeColumn: Bool {return _storage._relativeColumn != nil}
  /// Clears the value of `relativeColumn`. Subsequent reads from it will return its default value.
  mutating func clearRelativeColumn() {_uniqueStorage()._relativeColumn = nil}

  var relativeGroupUid: TSP_UUID {
    get {return _storage._relativeGroupUid ?? TSP_UUID()}
    set {_uniqueStorage()._relativeGroupUid = newValue}
  }
  /// Returns true if `relativeGroupUid` has been explicitly set.
  var hasRelativeGroupUid: Bool {return _storage._relativeGroupUid != nil}
  /// Clears the value of `relativeGroupUid`. Subsequent reads from it will return its default value.
  mutating func clearRelativeGroupUid() {_uniqueStorage()._relativeGroupUid = nil}

  var absoluteGroupUid: TSP_UUID {
    get {return _storage._absoluteGroupUid ?? TSP_UUID()}
    set {_uniqueStorage()._absoluteGroupUid = newValue}
  }
  /// Returns true if `absoluteGroupUid` has been explicitly set.
  var hasAbsoluteGroupUid: Bool {return _storage._absoluteGroupUid != nil}
  /// Clears the value of `absoluteGroupUid`. Subsequent reads from it will return its default value.
  mutating func clearAbsoluteGroupUid() {_uniqueStorage()._absoluteGroupUid = nil}

  var optionRefersToPivotRows: Bool {
    get {return _storage._optionRefersToPivotRows ?? false}
    set {_uniqueStorage()._optionRefersToPivotRows = newValue}
  }
  /// Returns true if `optionRefersToPivotRows` has been explicitly set.
  var hasOptionRefersToPivotRows: Bool {return _storage._optionRefersToPivotRows != nil}
  /// Clears the value of `optionRefersToPivotRows`. Subsequent reads from it will return its default value.
  mutating func clearOptionRefersToPivotRows() {_uniqueStorage()._optionRefersToPivotRows = nil}

  var optionRefersToPivotColumns: Bool {
    get {return _storage._optionRefersToPivotColumns ?? false}
    set {_uniqueStorage()._optionRefersToPivotColumns = newValue}
  }
  /// Returns true if `optionRefersToPivotColumns` has been explicitly set.
  var hasOptionRefersToPivotColumns: Bool {return _storage._optionRefersToPivotColumns != nil}
  /// Clears the value of `optionRefersToPivotColumns`. Subsequent reads from it will return its default value.
  mutating func clearOptionRefersToPivotColumns() {_uniqueStorage()._optionRefersToPivotColumns = nil}

  var aggIndexLevel: UInt32 {
    get {return _storage._aggIndexLevel ?? 0}
    set {_uniqueStorage()._aggIndexLevel = newValue}
  }
  /// Returns true if `aggIndexLevel` has been explicitly set.
  var hasAggIndexLevel: Bool {return _storage._aggIndexLevel != nil}
  /// Clears the value of `aggIndexLevel`. Subsequent reads from it will return its default value.
  mutating func clearAggIndexLevel() {_uniqueStorage()._aggIndexLevel = nil}

  var optionShowAggregateName: Bool {
    get {return _storage._optionShowAggregateName ?? false}
    set {_uniqueStorage()._optionShowAggregateName = newValue}
  }
  /// Returns true if `optionShowAggregateName` has been explicitly set.
  var hasOptionShowAggregateName: Bool {return _storage._optionShowAggregateName != nil}
  /// Clears the value of `optionShowAggregateName`. Subsequent reads from it will return its default value.
  mutating func clearOptionShowAggregateName() {_uniqueStorage()._optionShowAggregateName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct CatRefUidList: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uid: [TSP_UUID] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSCE_ASTNodeArrayArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var astNode: [TSCE_ASTNodeArrayArchive.ASTNodeArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ASTNodeType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case additionNode = 1
    case subtractionNode = 2
    case multiplicationNode = 3
    case divisionNode = 4
    case powerNode = 5
    case concatenationNode = 6
    case greaterThanNode = 7
    case greaterThanOrEqualToNode = 8
    case lessThanNode = 9
    case lessThanOrEqualToNode = 10
    case equalToNode = 11
    case notEqualToNode = 12
    case negationNode = 13
    case plusSignNode = 14
    case percentNode = 15
    case functionNode = 16
    case numberNode = 17
    case booleanNode = 18
    case stringNode = 19
    case dateNode = 20
    case durationNode = 21
    case emptyArgumentNode = 22
    case tokenNode = 23
    case arrayNode = 24
    case listNode = 25
    case thunkNode = 26
    case localCellReferenceNode = 27
    case crossTableCellReferenceNode = 28
    case colonNode = 29
    case referenceErrorNode = 30
    case unknownFunctionNode = 31
    case appendWhitespaceNode = 32
    case prependWhitespaceNode = 33
    case beginThunkNode = 34
    case endThunkNode = 35
    case cellReferenceNode = 36
    case colonNodeWithUids = 45
    case referenceErrorWithUids = 46
    case uidReferenceNode = 48
    case letBindNode = 52
    case varNode = 53
    case endScopeNode = 54
    case lambdaNode = 55
    case beginLambdaThunkNode = 56
    case endLambdaThunkNode = 57
    case linkedCellRefNode = 63
    case linkedColumnRefNode = 64
    case linkedRowRefNode = 65
    case categoryRefNode = 66
    case colonTractNode = 67
    case viewTractRefNode = 68
    case intersectionNode = 69
    case spillRangeNode = 70

    init() {
      self = .additionNode
    }

  }

  enum ASTUidTractPurpose: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case uidsIncluded = 0
    case uidsPremerge = 1
    case uidsPremoveregion = 2
    case uidsExcluded = 3
    case uidsActive = 4
    case uidsPremergeTopleft = 5
    case uidsRemovedByMove = 6
    case fulltupleRowColumnHeader = 7
    case fulltupleAggregateRuleUid = 8
    case fulltupleRowColumnRuleValuePairs = 9

    init() {
      self = .uidsIncluded
    }

  }

  struct ASTLocalCellReferenceNodeArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rowHandle: UInt32 {
      get {return _rowHandle ?? 0}
      set {_rowHandle = newValue}
    }
    /// Returns true if `rowHandle` has been explicitly set.
    var hasRowHandle: Bool {return self._rowHandle != nil}
    /// Clears the value of `rowHandle`. Subsequent reads from it will return its default value.
    mutating func clearRowHandle() {self._rowHandle = nil}

    var columnHandle: UInt32 {
      get {return _columnHandle ?? 0}
      set {_columnHandle = newValue}
    }
    /// Returns true if `columnHandle` has been explicitly set.
    var hasColumnHandle: Bool {return self._columnHandle != nil}
    /// Clears the value of `columnHandle`. Subsequent reads from it will return its default value.
    mutating func clearColumnHandle() {self._columnHandle = nil}

    var rowIsSticky: UInt32 {
      get {return _rowIsSticky ?? 0}
      set {_rowIsSticky = newValue}
    }
    /// Returns true if `rowIsSticky` has been explicitly set.
    var hasRowIsSticky: Bool {return self._rowIsSticky != nil}
    /// Clears the value of `rowIsSticky`. Subsequent reads from it will return its default value.
    mutating func clearRowIsSticky() {self._rowIsSticky = nil}

    var columnIsSticky: UInt32 {
      get {return _columnIsSticky ?? 0}
      set {_columnIsSticky = newValue}
    }
    /// Returns true if `columnIsSticky` has been explicitly set.
    var hasColumnIsSticky: Bool {return self._columnIsSticky != nil}
    /// Clears the value of `columnIsSticky`. Subsequent reads from it will return its default value.
    mutating func clearColumnIsSticky() {self._columnIsSticky = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _rowHandle: UInt32? = nil
    fileprivate var _columnHandle: UInt32? = nil
    fileprivate var _rowIsSticky: UInt32? = nil
    fileprivate var _columnIsSticky: UInt32? = nil
  }

  struct ASTCrossTableCellReferenceNodeArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rowHandle: UInt32 {
      get {return _rowHandle ?? 0}
      set {_rowHandle = newValue}
    }
    /// Returns true if `rowHandle` has been explicitly set.
    var hasRowHandle: Bool {return self._rowHandle != nil}
    /// Clears the value of `rowHandle`. Subsequent reads from it will return its default value.
    mutating func clearRowHandle() {self._rowHandle = nil}

    var columnHandle: UInt32 {
      get {return _columnHandle ?? 0}
      set {_columnHandle = newValue}
    }
    /// Returns true if `columnHandle` has been explicitly set.
    var hasColumnHandle: Bool {return self._columnHandle != nil}
    /// Clears the value of `columnHandle`. Subsequent reads from it will return its default value.
    mutating func clearColumnHandle() {self._columnHandle = nil}

    var rowIsSticky: UInt32 {
      get {return _rowIsSticky ?? 0}
      set {_rowIsSticky = newValue}
    }
    /// Returns true if `rowIsSticky` has been explicitly set.
    var hasRowIsSticky: Bool {return self._rowIsSticky != nil}
    /// Clears the value of `rowIsSticky`. Subsequent reads from it will return its default value.
    mutating func clearRowIsSticky() {self._rowIsSticky = nil}

    var columnIsSticky: UInt32 {
      get {return _columnIsSticky ?? 0}
      set {_columnIsSticky = newValue}
    }
    /// Returns true if `columnIsSticky` has been explicitly set.
    var hasColumnIsSticky: Bool {return self._columnIsSticky != nil}
    /// Clears the value of `columnIsSticky`. Subsequent reads from it will return its default value.
    mutating func clearColumnIsSticky() {self._columnIsSticky = nil}

    var tableID: TSP_CFUUIDArchive {
      get {return _tableID ?? TSP_CFUUIDArchive()}
      set {_tableID = newValue}
    }
    /// Returns true if `tableID` has been explicitly set.
    var hasTableID: Bool {return self._tableID != nil}
    /// Clears the value of `tableID`. Subsequent reads from it will return its default value.
    mutating func clearTableID() {self._tableID = nil}

    var astReferenceWhitespaceAfterSheetName: String {
      get {return _astReferenceWhitespaceAfterSheetName ?? String()}
      set {_astReferenceWhitespaceAfterSheetName = newValue}
    }
    /// Returns true if `astReferenceWhitespaceAfterSheetName` has been explicitly set.
    var hasAstReferenceWhitespaceAfterSheetName: Bool {return self._astReferenceWhitespaceAfterSheetName != nil}
    /// Clears the value of `astReferenceWhitespaceAfterSheetName`. Subsequent reads from it will return its default value.
    mutating func clearAstReferenceWhitespaceAfterSheetName() {self._astReferenceWhitespaceAfterSheetName = nil}

    var astReferenceWhitespaceBeforeTableName: String {
      get {return _astReferenceWhitespaceBeforeTableName ?? String()}
      set {_astReferenceWhitespaceBeforeTableName = newValue}
    }
    /// Returns true if `astReferenceWhitespaceBeforeTableName` has been explicitly set.
    var hasAstReferenceWhitespaceBeforeTableName: Bool {return self._astReferenceWhitespaceBeforeTableName != nil}
    /// Clears the value of `astReferenceWhitespaceBeforeTableName`. Subsequent reads from it will return its default value.
    mutating func clearAstReferenceWhitespaceBeforeTableName() {self._astReferenceWhitespaceBeforeTableName = nil}

    var astReferenceWhitespaceAfterTableName: String {
      get {return _astReferenceWhitespaceAfterTableName ?? String()}
      set {_astReferenceWhitespaceAfterTableName = newValue}
    }
    /// Returns true if `astReferenceWhitespaceAfterTableName` has been explicitly set.
    var hasAstReferenceWhitespaceAfterTableName: Bool {return self._astReferenceWhitespaceAfterTableName != nil}
    /// Clears the value of `astReferenceWhitespaceAfterTableName`. Subsequent reads from it will return its default value.
    mutating func clearAstReferenceWhitespaceAfterTableName() {self._astReferenceWhitespaceAfterTableName = nil}

    var astReferenceWhitespaceBeforeCellAddress: String {
      get {return _astReferenceWhitespaceBeforeCellAddress ?? String()}
      set {_astReferenceWhitespaceBeforeCellAddress = newValue}
    }
    /// Returns true if `astReferenceWhitespaceBeforeCellAddress` has been explicitly set.
    var hasAstReferenceWhitespaceBeforeCellAddress: Bool {return self._astReferenceWhitespaceBeforeCellAddress != nil}
    /// Clears the value of `astReferenceWhitespaceBeforeCellAddress`. Subsequent reads from it will return its default value.
    mutating func clearAstReferenceWhitespaceBeforeCellAddress() {self._astReferenceWhitespaceBeforeCellAddress = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _rowHandle: UInt32? = nil
    fileprivate var _columnHandle: UInt32? = nil
    fileprivate var _rowIsSticky: UInt32? = nil
    fileprivate var _columnIsSticky: UInt32? = nil
    fileprivate var _tableID: TSP_CFUUIDArchive? = nil
    fileprivate var _astReferenceWhitespaceAfterSheetName: String? = nil
    fileprivate var _astReferenceWhitespaceBeforeTableName: String? = nil
    fileprivate var _astReferenceWhitespaceAfterTableName: String? = nil
    fileprivate var _astReferenceWhitespaceBeforeCellAddress: String? = nil
  }

  struct ASTColumnCoordinateArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var column: Int32 {
      get {return _column ?? 0}
      set {_column = newValue}
    }
    /// Returns true if `column` has been explicitly set.
    var hasColumn: Bool {return self._column != nil}
    /// Clears the value of `column`. Subsequent reads from it will return its default value.
    mutating func clearColumn() {self._column = nil}

    var absolute: Bool {
      get {return _absolute ?? false}
      set {_absolute = newValue}
    }
    /// Returns true if `absolute` has been explicitly set.
    var hasAbsolute: Bool {return self._absolute != nil}
    /// Clears the value of `absolute`. Subsequent reads from it will return its default value.
    mutating func clearAbsolute() {self._absolute = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _column: Int32? = nil
    fileprivate var _absolute: Bool? = nil
  }

  struct ASTRowCoordinateArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var row: Int32 {
      get {return _row ?? 0}
      set {_row = newValue}
    }
    /// Returns true if `row` has been explicitly set.
    var hasRow: Bool {return self._row != nil}
    /// Clears the value of `row`. Subsequent reads from it will return its default value.
    mutating func clearRow() {self._row = nil}

    var absolute: Bool {
      get {return _absolute ?? false}
      set {_absolute = newValue}
    }
    /// Returns true if `absolute` has been explicitly set.
    var hasAbsolute: Bool {return self._absolute != nil}
    /// Clears the value of `absolute`. Subsequent reads from it will return its default value.
    mutating func clearAbsolute() {self._absolute = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _row: Int32? = nil
    fileprivate var _absolute: Bool? = nil
  }

  struct ASTUidList: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uid: [TSP_UUID] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ASTUidTract: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var columnUids: TSCE_ASTNodeArrayArchive.ASTUidList {
      get {return _columnUids ?? TSCE_ASTNodeArrayArchive.ASTUidList()}
      set {_columnUids = newValue}
    }
    /// Returns true if `columnUids` has been explicitly set.
    var hasColumnUids: Bool {return self._columnUids != nil}
    /// Clears the value of `columnUids`. Subsequent reads from it will return its default value.
    mutating func clearColumnUids() {self._columnUids = nil}

    var rowUids: TSCE_ASTNodeArrayArchive.ASTUidList {
      get {return _rowUids ?? TSCE_ASTNodeArrayArchive.ASTUidList()}
      set {_rowUids = newValue}
    }
    /// Returns true if `rowUids` has been explicitly set.
    var hasRowUids: Bool {return self._rowUids != nil}
    /// Clears the value of `rowUids`. Subsequent reads from it will return its default value.
    mutating func clearRowUids() {self._rowUids = nil}

    var isRangeRef: Bool {
      get {return _isRangeRef ?? false}
      set {_isRangeRef = newValue}
    }
    /// Returns true if `isRangeRef` has been explicitly set.
    var hasIsRangeRef: Bool {return self._isRangeRef != nil}
    /// Clears the value of `isRangeRef`. Subsequent reads from it will return its default value.
    mutating func clearIsRangeRef() {self._isRangeRef = nil}

    var purpose: TSCE_ASTNodeArrayArchive.ASTUidTractPurpose {
      get {return _purpose ?? .uidsIncluded}
      set {_purpose = newValue}
    }
    /// Returns true if `purpose` has been explicitly set.
    var hasPurpose: Bool {return self._purpose != nil}
    /// Clears the value of `purpose`. Subsequent reads from it will return its default value.
    mutating func clearPurpose() {self._purpose = nil}

    var preserveRectangular: Bool {
      get {return _preserveRectangular ?? true}
      set {_preserveRectangular = newValue}
    }
    /// Returns true if `preserveRectangular` has been explicitly set.
    var hasPreserveRectangular: Bool {return self._preserveRectangular != nil}
    /// Clears the value of `preserveRectangular`. Subsequent reads from it will return its default value.
    mutating func clearPreserveRectangular() {self._preserveRectangular = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _columnUids: TSCE_ASTNodeArrayArchive.ASTUidList? = nil
    fileprivate var _rowUids: TSCE_ASTNodeArrayArchive.ASTUidList? = nil
    fileprivate var _isRangeRef: Bool? = nil
    fileprivate var _purpose: TSCE_ASTNodeArrayArchive.ASTUidTractPurpose? = nil
    fileprivate var _preserveRectangular: Bool? = nil
  }

  struct ASTStickyBits: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var beginRowIsAbsolute: Bool {
      get {return _beginRowIsAbsolute ?? false}
      set {_beginRowIsAbsolute = newValue}
    }
    /// Returns true if `beginRowIsAbsolute` has been explicitly set.
    var hasBeginRowIsAbsolute: Bool {return self._beginRowIsAbsolute != nil}
    /// Clears the value of `beginRowIsAbsolute`. Subsequent reads from it will return its default value.
    mutating func clearBeginRowIsAbsolute() {self._beginRowIsAbsolute = nil}

    var beginColumnIsAbsolute: Bool {
      get {return _beginColumnIsAbsolute ?? false}
      set {_beginColumnIsAbsolute = newValue}
    }
    /// Returns true if `beginColumnIsAbsolute` has been explicitly set.
    var hasBeginColumnIsAbsolute: Bool {return self._beginColumnIsAbsolute != nil}
    /// Clears the value of `beginColumnIsAbsolute`. Subsequent reads from it will return its default value.
    mutating func clearBeginColumnIsAbsolute() {self._beginColumnIsAbsolute = nil}

    var endRowIsAbsolute: Bool {
      get {return _endRowIsAbsolute ?? false}
      set {_endRowIsAbsolute = newValue}
    }
    /// Returns true if `endRowIsAbsolute` has been explicitly set.
    var hasEndRowIsAbsolute: Bool {return self._endRowIsAbsolute != nil}
    /// Clears the value of `endRowIsAbsolute`. Subsequent reads from it will return its default value.
    mutating func clearEndRowIsAbsolute() {self._endRowIsAbsolute = nil}

    var endColumnIsAbsolute: Bool {
      get {return _endColumnIsAbsolute ?? false}
      set {_endColumnIsAbsolute = newValue}
    }
    /// Returns true if `endColumnIsAbsolute` has been explicitly set.
    var hasEndColumnIsAbsolute: Bool {return self._endColumnIsAbsolute != nil}
    /// Clears the value of `endColumnIsAbsolute`. Subsequent reads from it will return its default value.
    mutating func clearEndColumnIsAbsolute() {self._endColumnIsAbsolute = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _beginRowIsAbsolute: Bool? = nil
    fileprivate var _beginColumnIsAbsolute: Bool? = nil
    fileprivate var _endRowIsAbsolute: Bool? = nil
    fileprivate var _endColumnIsAbsolute: Bool? = nil
  }

  struct ASTUidTractList: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var tract: [TSCE_ASTNodeArrayArchive.ASTUidTract] = []

    var stickyBits: TSCE_ASTNodeArrayArchive.ASTStickyBits {
      get {return _stickyBits ?? TSCE_ASTNodeArrayArchive.ASTStickyBits()}
      set {_stickyBits = newValue}
    }
    /// Returns true if `stickyBits` has been explicitly set.
    var hasStickyBits: Bool {return self._stickyBits != nil}
    /// Clears the value of `stickyBits`. Subsequent reads from it will return its default value.
    mutating func clearStickyBits() {self._stickyBits = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _stickyBits: TSCE_ASTNodeArrayArchive.ASTStickyBits? = nil
  }

  struct ASTUidCoordinateArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var columnUid: TSP_UUID {
      get {return _columnUid ?? TSP_UUID()}
      set {_columnUid = newValue}
    }
    /// Returns true if `columnUid` has been explicitly set.
    var hasColumnUid: Bool {return self._columnUid != nil}
    /// Clears the value of `columnUid`. Subsequent reads from it will return its default value.
    mutating func clearColumnUid() {self._columnUid = nil}

    var rowUid: TSP_UUID {
      get {return _rowUid ?? TSP_UUID()}
      set {_rowUid = newValue}
    }
    /// Returns true if `rowUid` has been explicitly set.
    var hasRowUid: Bool {return self._rowUid != nil}
    /// Clears the value of `rowUid`. Subsequent reads from it will return its default value.
    mutating func clearRowUid() {self._rowUid = nil}

    var columnAbsolute: Bool {
      get {return _columnAbsolute ?? false}
      set {_columnAbsolute = newValue}
    }
    /// Returns true if `columnAbsolute` has been explicitly set.
    var hasColumnAbsolute: Bool {return self._columnAbsolute != nil}
    /// Clears the value of `columnAbsolute`. Subsequent reads from it will return its default value.
    mutating func clearColumnAbsolute() {self._columnAbsolute = nil}

    var rowAbsolute: Bool {
      get {return _rowAbsolute ?? false}
      set {_rowAbsolute = newValue}
    }
    /// Returns true if `rowAbsolute` has been explicitly set.
    var hasRowAbsolute: Bool {return self._rowAbsolute != nil}
    /// Clears the value of `rowAbsolute`. Subsequent reads from it will return its default value.
    mutating func clearRowAbsolute() {self._rowAbsolute = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _columnUid: TSP_UUID? = nil
    fileprivate var _rowUid: TSP_UUID? = nil
    fileprivate var _columnAbsolute: Bool? = nil
    fileprivate var _rowAbsolute: Bool? = nil
  }

  struct ASTCategoryLevels: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var astColumnGroupLevel: UInt32 {
      get {return _astColumnGroupLevel ?? 0}
      set {_astColumnGroupLevel = newValue}
    }
    /// Returns true if `astColumnGroupLevel` has been explicitly set.
    var hasAstColumnGroupLevel: Bool {return self._astColumnGroupLevel != nil}
    /// Clears the value of `astColumnGroupLevel`. Subsequent reads from it will return its default value.
    mutating func clearAstColumnGroupLevel() {self._astColumnGroupLevel = nil}

    var astRowGroupLevel: UInt32 {
      get {return _astRowGroupLevel ?? 0}
      set {_astRowGroupLevel = newValue}
    }
    /// Returns true if `astRowGroupLevel` has been explicitly set.
    var hasAstRowGroupLevel: Bool {return self._astRowGroupLevel != nil}
    /// Clears the value of `astRowGroupLevel`. Subsequent reads from it will return its default value.
    mutating func clearAstRowGroupLevel() {self._astRowGroupLevel = nil}

    var astAggIndexLevel: UInt32 {
      get {return _astAggIndexLevel ?? 0}
      set {_astAggIndexLevel = newValue}
    }
    /// Returns true if `astAggIndexLevel` has been explicitly set.
    var hasAstAggIndexLevel: Bool {return self._astAggIndexLevel != nil}
    /// Clears the value of `astAggIndexLevel`. Subsequent reads from it will return its default value.
    mutating func clearAstAggIndexLevel() {self._astAggIndexLevel = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _astColumnGroupLevel: UInt32? = nil
    fileprivate var _astRowGroupLevel: UInt32? = nil
    fileprivate var _astAggIndexLevel: UInt32? = nil
  }

  struct ASTCategoryReferenceArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var categoryRef: TSCE_CategoryReferenceArchive {
      get {return _categoryRef ?? TSCE_CategoryReferenceArchive()}
      set {_categoryRef = newValue}
    }
    /// Returns true if `categoryRef` has been explicitly set.
    var hasCategoryRef: Bool {return self._categoryRef != nil}
    /// Clears the value of `categoryRef`. Subsequent reads from it will return its default value.
    mutating func clearCategoryRef() {self._categoryRef = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _categoryRef: TSCE_CategoryReferenceArchive? = nil
  }

  struct ASTColonTractArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var relativeColumn: [TSCE_ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractRelativeRangeArchive] = []

    var relativeRow: [TSCE_ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractRelativeRangeArchive] = []

    var absoluteColumn: [TSCE_ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractAbsoluteRangeArchive] = []

    var absoluteRow: [TSCE_ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractAbsoluteRangeArchive] = []

    var preserveRectangular: Bool {
      get {return _preserveRectangular ?? true}
      set {_preserveRectangular = newValue}
    }
    /// Returns true if `preserveRectangular` has been explicitly set.
    var hasPreserveRectangular: Bool {return self._preserveRectangular != nil}
    /// Clears the value of `preserveRectangular`. Subsequent reads from it will return its default value.
    mutating func clearPreserveRectangular() {self._preserveRectangular = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct ASTColonTractRelativeRangeArchive: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var rangeBegin: Int32 {
        get {return _rangeBegin ?? 0}
        set {_rangeBegin = newValue}
      }
      /// Returns true if `rangeBegin` has been explicitly set.
      var hasRangeBegin: Bool {return self._rangeBegin != nil}
      /// Clears the value of `rangeBegin`. Subsequent reads from it will return its default value.
      mutating func clearRangeBegin() {self._rangeBegin = nil}

      var rangeEnd: Int32 {
        get {return _rangeEnd ?? 0}
        set {_rangeEnd = newValue}
      }
      /// Returns true if `rangeEnd` has been explicitly set.
      var hasRangeEnd: Bool {return self._rangeEnd != nil}
      /// Clears the value of `rangeEnd`. Subsequent reads from it will return its default value.
      mutating func clearRangeEnd() {self._rangeEnd = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _rangeBegin: Int32? = nil
      fileprivate var _rangeEnd: Int32? = nil
    }

    struct ASTColonTractAbsoluteRangeArchive: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var rangeBegin: UInt32 {
        get {return _rangeBegin ?? 0}
        set {_rangeBegin = newValue}
      }
      /// Returns true if `rangeBegin` has been explicitly set.
      var hasRangeBegin: Bool {return self._rangeBegin != nil}
      /// Clears the value of `rangeBegin`. Subsequent reads from it will return its default value.
      mutating func clearRangeBegin() {self._rangeBegin = nil}

      var rangeEnd: UInt32 {
        get {return _rangeEnd ?? 0}
        set {_rangeEnd = newValue}
      }
      /// Returns true if `rangeEnd` has been explicitly set.
      var hasRangeEnd: Bool {return self._rangeEnd != nil}
      /// Clears the value of `rangeEnd`. Subsequent reads from it will return its default value.
      mutating func clearRangeEnd() {self._rangeEnd = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _rangeBegin: UInt32? = nil
      fileprivate var _rangeEnd: UInt32? = nil
    }

    init() {}

    fileprivate var _preserveRectangular: Bool? = nil
  }

  struct ASTCrossTableReferenceExtraInfoArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var tableID: TSP_CFUUIDArchive {
      get {return _tableID ?? TSP_CFUUIDArchive()}
      set {_tableID = newValue}
    }
    /// Returns true if `tableID` has been explicitly set.
    var hasTableID: Bool {return self._tableID != nil}
    /// Clears the value of `tableID`. Subsequent reads from it will return its default value.
    mutating func clearTableID() {self._tableID = nil}

    var astReferenceWhitespaceAfterSheetName: String {
      get {return _astReferenceWhitespaceAfterSheetName ?? String()}
      set {_astReferenceWhitespaceAfterSheetName = newValue}
    }
    /// Returns true if `astReferenceWhitespaceAfterSheetName` has been explicitly set.
    var hasAstReferenceWhitespaceAfterSheetName: Bool {return self._astReferenceWhitespaceAfterSheetName != nil}
    /// Clears the value of `astReferenceWhitespaceAfterSheetName`. Subsequent reads from it will return its default value.
    mutating func clearAstReferenceWhitespaceAfterSheetName() {self._astReferenceWhitespaceAfterSheetName = nil}

    var astReferenceWhitespaceBeforeTableName: String {
      get {return _astReferenceWhitespaceBeforeTableName ?? String()}
      set {_astReferenceWhitespaceBeforeTableName = newValue}
    }
    /// Returns true if `astReferenceWhitespaceBeforeTableName` has been explicitly set.
    var hasAstReferenceWhitespaceBeforeTableName: Bool {return self._astReferenceWhitespaceBeforeTableName != nil}
    /// Clears the value of `astReferenceWhitespaceBeforeTableName`. Subsequent reads from it will return its default value.
    mutating func clearAstReferenceWhitespaceBeforeTableName() {self._astReferenceWhitespaceBeforeTableName = nil}

    var astReferenceWhitespaceAfterTableName: String {
      get {return _astReferenceWhitespaceAfterTableName ?? String()}
      set {_astReferenceWhitespaceAfterTableName = newValue}
    }
    /// Returns true if `astReferenceWhitespaceAfterTableName` has been explicitly set.
    var hasAstReferenceWhitespaceAfterTableName: Bool {return self._astReferenceWhitespaceAfterTableName != nil}
    /// Clears the value of `astReferenceWhitespaceAfterTableName`. Subsequent reads from it will return its default value.
    mutating func clearAstReferenceWhitespaceAfterTableName() {self._astReferenceWhitespaceAfterTableName = nil}

    var astReferenceWhitespaceBeforeCellAddress: String {
      get {return _astReferenceWhitespaceBeforeCellAddress ?? String()}
      set {_astReferenceWhitespaceBeforeCellAddress = newValue}
    }
    /// Returns true if `astReferenceWhitespaceBeforeCellAddress` has been explicitly set.
    var hasAstReferenceWhitespaceBeforeCellAddress: Bool {return self._astReferenceWhitespaceBeforeCellAddress != nil}
    /// Clears the value of `astReferenceWhitespaceBeforeCellAddress`. Subsequent reads from it will return its default value.
    mutating func clearAstReferenceWhitespaceBeforeCellAddress() {self._astReferenceWhitespaceBeforeCellAddress = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _tableID: TSP_CFUUIDArchive? = nil
    fileprivate var _astReferenceWhitespaceAfterSheetName: String? = nil
    fileprivate var _astReferenceWhitespaceBeforeTableName: String? = nil
    fileprivate var _astReferenceWhitespaceAfterTableName: String? = nil
    fileprivate var _astReferenceWhitespaceBeforeCellAddress: String? = nil
  }

  struct ASTLambdaIdentsListArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var astIdentifierString: [String] = []

    var astFirstSymbol: UInt32 {
      get {return _astFirstSymbol ?? 0}
      set {_astFirstSymbol = newValue}
    }
    /// Returns true if `astFirstSymbol` has been explicitly set.
    var hasAstFirstSymbol: Bool {return self._astFirstSymbol != nil}
    /// Clears the value of `astFirstSymbol`. Subsequent reads from it will return its default value.
    mutating func clearAstFirstSymbol() {self._astFirstSymbol = nil}

    var astWhitespaceBeforeIdents: String {
      get {return _astWhitespaceBeforeIdents ?? String()}
      set {_astWhitespaceBeforeIdents = newValue}
    }
    /// Returns true if `astWhitespaceBeforeIdents` has been explicitly set.
    var hasAstWhitespaceBeforeIdents: Bool {return self._astWhitespaceBeforeIdents != nil}
    /// Clears the value of `astWhitespaceBeforeIdents`. Subsequent reads from it will return its default value.
    mutating func clearAstWhitespaceBeforeIdents() {self._astWhitespaceBeforeIdents = nil}

    var astWhitespaceAfterIdents: String {
      get {return _astWhitespaceAfterIdents ?? String()}
      set {_astWhitespaceAfterIdents = newValue}
    }
    /// Returns true if `astWhitespaceAfterIdents` has been explicitly set.
    var hasAstWhitespaceAfterIdents: Bool {return self._astWhitespaceAfterIdents != nil}
    /// Clears the value of `astWhitespaceAfterIdents`. Subsequent reads from it will return its default value.
    mutating func clearAstWhitespaceAfterIdents() {self._astWhitespaceAfterIdents = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _astFirstSymbol: UInt32? = nil
    fileprivate var _astWhitespaceBeforeIdents: String? = nil
    fileprivate var _astWhitespaceAfterIdents: String? = nil
  }

  struct ASTNodeArchive: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var astNodeType: TSCE_ASTNodeArrayArchive.ASTNodeType {
      get {return _storage._astNodeType ?? .additionNode}
      set {_uniqueStorage()._astNodeType = newValue}
    }
    /// Returns true if `astNodeType` has been explicitly set.
    var hasAstNodeType: Bool {return _storage._astNodeType != nil}
    /// Clears the value of `astNodeType`. Subsequent reads from it will return its default value.
    mutating func clearAstNodeType() {_uniqueStorage()._astNodeType = nil}

    var astFunctionNodeIndex: UInt32 {
      get {return _storage._astFunctionNodeIndex ?? 0}
      set {_uniqueStorage()._astFunctionNodeIndex = newValue}
    }
    /// Returns true if `astFunctionNodeIndex` has been explicitly set.
    var hasAstFunctionNodeIndex: Bool {return _storage._astFunctionNodeIndex != nil}
    /// Clears the value of `astFunctionNodeIndex`. Subsequent reads from it will return its default value.
    mutating func clearAstFunctionNodeIndex() {_uniqueStorage()._astFunctionNodeIndex = nil}

    var astFunctionNodeNumArgs: UInt32 {
      get {return _storage._astFunctionNodeNumArgs ?? 0}
      set {_uniqueStorage()._astFunctionNodeNumArgs = newValue}
    }
    /// Returns true if `astFunctionNodeNumArgs` has been explicitly set.
    var hasAstFunctionNodeNumArgs: Bool {return _storage._astFunctionNodeNumArgs != nil}
    /// Clears the value of `astFunctionNodeNumArgs`. Subsequent reads from it will return its default value.
    mutating func clearAstFunctionNodeNumArgs() {_uniqueStorage()._astFunctionNodeNumArgs = nil}

    var astNumberNodeNumber: Double {
      get {return _storage._astNumberNodeNumber ?? 0}
      set {_uniqueStorage()._astNumberNodeNumber = newValue}
    }
    /// Returns true if `astNumberNodeNumber` has been explicitly set.
    var hasAstNumberNodeNumber: Bool {return _storage._astNumberNodeNumber != nil}
    /// Clears the value of `astNumberNodeNumber`. Subsequent reads from it will return its default value.
    mutating func clearAstNumberNodeNumber() {_uniqueStorage()._astNumberNodeNumber = nil}

    var astBooleanNodeBoolean: Bool {
      get {return _storage._astBooleanNodeBoolean ?? false}
      set {_uniqueStorage()._astBooleanNodeBoolean = newValue}
    }
    /// Returns true if `astBooleanNodeBoolean` has been explicitly set.
    var hasAstBooleanNodeBoolean: Bool {return _storage._astBooleanNodeBoolean != nil}
    /// Clears the value of `astBooleanNodeBoolean`. Subsequent reads from it will return its default value.
    mutating func clearAstBooleanNodeBoolean() {_uniqueStorage()._astBooleanNodeBoolean = nil}

    var astStringNodeString: String {
      get {return _storage._astStringNodeString ?? String()}
      set {_uniqueStorage()._astStringNodeString = newValue}
    }
    /// Returns true if `astStringNodeString` has been explicitly set.
    var hasAstStringNodeString: Bool {return _storage._astStringNodeString != nil}
    /// Clears the value of `astStringNodeString`. Subsequent reads from it will return its default value.
    mutating func clearAstStringNodeString() {_uniqueStorage()._astStringNodeString = nil}

    var astDateNodeDateNum: Double {
      get {return _storage._astDateNodeDateNum ?? 0}
      set {_uniqueStorage()._astDateNodeDateNum = newValue}
    }
    /// Returns true if `astDateNodeDateNum` has been explicitly set.
    var hasAstDateNodeDateNum: Bool {return _storage._astDateNodeDateNum != nil}
    /// Clears the value of `astDateNodeDateNum`. Subsequent reads from it will return its default value.
    mutating func clearAstDateNodeDateNum() {_uniqueStorage()._astDateNodeDateNum = nil}

    var astDateNodeSuppressDateFormat: Bool {
      get {return _storage._astDateNodeSuppressDateFormat ?? false}
      set {_uniqueStorage()._astDateNodeSuppressDateFormat = newValue}
    }
    /// Returns true if `astDateNodeSuppressDateFormat` has been explicitly set.
    var hasAstDateNodeSuppressDateFormat: Bool {return _storage._astDateNodeSuppressDateFormat != nil}
    /// Clears the value of `astDateNodeSuppressDateFormat`. Subsequent reads from it will return its default value.
    mutating func clearAstDateNodeSuppressDateFormat() {_uniqueStorage()._astDateNodeSuppressDateFormat = nil}

    var astDateNodeSuppressTimeFormat: Bool {
      get {return _storage._astDateNodeSuppressTimeFormat ?? false}
      set {_uniqueStorage()._astDateNodeSuppressTimeFormat = newValue}
    }
    /// Returns true if `astDateNodeSuppressTimeFormat` has been explicitly set.
    var hasAstDateNodeSuppressTimeFormat: Bool {return _storage._astDateNodeSuppressTimeFormat != nil}
    /// Clears the value of `astDateNodeSuppressTimeFormat`. Subsequent reads from it will return its default value.
    mutating func clearAstDateNodeSuppressTimeFormat() {_uniqueStorage()._astDateNodeSuppressTimeFormat = nil}

    var astDateNodeDateTimeFormat: String {
      get {return _storage._astDateNodeDateTimeFormat ?? String()}
      set {_uniqueStorage()._astDateNodeDateTimeFormat = newValue}
    }
    /// Returns true if `astDateNodeDateTimeFormat` has been explicitly set.
    var hasAstDateNodeDateTimeFormat: Bool {return _storage._astDateNodeDateTimeFormat != nil}
    /// Clears the value of `astDateNodeDateTimeFormat`. Subsequent reads from it will return its default value.
    mutating func clearAstDateNodeDateTimeFormat() {_uniqueStorage()._astDateNodeDateTimeFormat = nil}

    var astDurationNodeUnitNum: Double {
      get {return _storage._astDurationNodeUnitNum ?? 0}
      set {_uniqueStorage()._astDurationNodeUnitNum = newValue}
    }
    /// Returns true if `astDurationNodeUnitNum` has been explicitly set.
    var hasAstDurationNodeUnitNum: Bool {return _storage._astDurationNodeUnitNum != nil}
    /// Clears the value of `astDurationNodeUnitNum`. Subsequent reads from it will return its default value.
    mutating func clearAstDurationNodeUnitNum() {_uniqueStorage()._astDurationNodeUnitNum = nil}

    var astDurationNodeUnit: Int32 {
      get {return _storage._astDurationNodeUnit ?? 0}
      set {_uniqueStorage()._astDurationNodeUnit = newValue}
    }
    /// Returns true if `astDurationNodeUnit` has been explicitly set.
    var hasAstDurationNodeUnit: Bool {return _storage._astDurationNodeUnit != nil}
    /// Clears the value of `astDurationNodeUnit`. Subsequent reads from it will return its default value.
    mutating func clearAstDurationNodeUnit() {_uniqueStorage()._astDurationNodeUnit = nil}

    var astDurationNodeStyle: UInt32 {
      get {return _storage._astDurationNodeStyle ?? 0}
      set {_uniqueStorage()._astDurationNodeStyle = newValue}
    }
    /// Returns true if `astDurationNodeStyle` has been explicitly set.
    var hasAstDurationNodeStyle: Bool {return _storage._astDurationNodeStyle != nil}
    /// Clears the value of `astDurationNodeStyle`. Subsequent reads from it will return its default value.
    mutating func clearAstDurationNodeStyle() {_uniqueStorage()._astDurationNodeStyle = nil}

    var astDurationNodeDurationUnitLargest: UInt32 {
      get {return _storage._astDurationNodeDurationUnitLargest ?? 0}
      set {_uniqueStorage()._astDurationNodeDurationUnitLargest = newValue}
    }
    /// Returns true if `astDurationNodeDurationUnitLargest` has been explicitly set.
    var hasAstDurationNodeDurationUnitLargest: Bool {return _storage._astDurationNodeDurationUnitLargest != nil}
    /// Clears the value of `astDurationNodeDurationUnitLargest`. Subsequent reads from it will return its default value.
    mutating func clearAstDurationNodeDurationUnitLargest() {_uniqueStorage()._astDurationNodeDurationUnitLargest = nil}

    var astDurationNodeDurationUnitSmallest: UInt32 {
      get {return _storage._astDurationNodeDurationUnitSmallest ?? 0}
      set {_uniqueStorage()._astDurationNodeDurationUnitSmallest = newValue}
    }
    /// Returns true if `astDurationNodeDurationUnitSmallest` has been explicitly set.
    var hasAstDurationNodeDurationUnitSmallest: Bool {return _storage._astDurationNodeDurationUnitSmallest != nil}
    /// Clears the value of `astDurationNodeDurationUnitSmallest`. Subsequent reads from it will return its default value.
    mutating func clearAstDurationNodeDurationUnitSmallest() {_uniqueStorage()._astDurationNodeDurationUnitSmallest = nil}

    var astDurationNodeUseAutomaticUnits: Bool {
      get {return _storage._astDurationNodeUseAutomaticUnits ?? false}
      set {_uniqueStorage()._astDurationNodeUseAutomaticUnits = newValue}
    }
    /// Returns true if `astDurationNodeUseAutomaticUnits` has been explicitly set.
    var hasAstDurationNodeUseAutomaticUnits: Bool {return _storage._astDurationNodeUseAutomaticUnits != nil}
    /// Clears the value of `astDurationNodeUseAutomaticUnits`. Subsequent reads from it will return its default value.
    mutating func clearAstDurationNodeUseAutomaticUnits() {_uniqueStorage()._astDurationNodeUseAutomaticUnits = nil}

    var astTokenNodeBoolean: Bool {
      get {return _storage._astTokenNodeBoolean ?? false}
      set {_uniqueStorage()._astTokenNodeBoolean = newValue}
    }
    /// Returns true if `astTokenNodeBoolean` has been explicitly set.
    var hasAstTokenNodeBoolean: Bool {return _storage._astTokenNodeBoolean != nil}
    /// Clears the value of `astTokenNodeBoolean`. Subsequent reads from it will return its default value.
    mutating func clearAstTokenNodeBoolean() {_uniqueStorage()._astTokenNodeBoolean = nil}

    var astArrayNodeNumCol: UInt32 {
      get {return _storage._astArrayNodeNumCol ?? 0}
      set {_uniqueStorage()._astArrayNodeNumCol = newValue}
    }
    /// Returns true if `astArrayNodeNumCol` has been explicitly set.
    var hasAstArrayNodeNumCol: Bool {return _storage._astArrayNodeNumCol != nil}
    /// Clears the value of `astArrayNodeNumCol`. Subsequent reads from it will return its default value.
    mutating func clearAstArrayNodeNumCol() {_uniqueStorage()._astArrayNodeNumCol = nil}

    var astArrayNodeNumRow: UInt32 {
      get {return _storage._astArrayNodeNumRow ?? 0}
      set {_uniqueStorage()._astArrayNodeNumRow = newValue}
    }
    /// Returns true if `astArrayNodeNumRow` has been explicitly set.
    var hasAstArrayNodeNumRow: Bool {return _storage._astArrayNodeNumRow != nil}
    /// Clears the value of `astArrayNodeNumRow`. Subsequent reads from it will return its default value.
    mutating func clearAstArrayNodeNumRow() {_uniqueStorage()._astArrayNodeNumRow = nil}

    var astListNodeNumArgs: UInt32 {
      get {return _storage._astListNodeNumArgs ?? 0}
      set {_uniqueStorage()._astListNodeNumArgs = newValue}
    }
    /// Returns true if `astListNodeNumArgs` has been explicitly set.
    var hasAstListNodeNumArgs: Bool {return _storage._astListNodeNumArgs != nil}
    /// Clears the value of `astListNodeNumArgs`. Subsequent reads from it will return its default value.
    mutating func clearAstListNodeNumArgs() {_uniqueStorage()._astListNodeNumArgs = nil}

    var astThunkNodeArray: TSCE_ASTNodeArrayArchive {
      get {return _storage._astThunkNodeArray ?? TSCE_ASTNodeArrayArchive()}
      set {_uniqueStorage()._astThunkNodeArray = newValue}
    }
    /// Returns true if `astThunkNodeArray` has been explicitly set.
    var hasAstThunkNodeArray: Bool {return _storage._astThunkNodeArray != nil}
    /// Clears the value of `astThunkNodeArray`. Subsequent reads from it will return its default value.
    mutating func clearAstThunkNodeArray() {_uniqueStorage()._astThunkNodeArray = nil}

    var astLocalCellReferenceNodeReference: TSCE_ASTNodeArrayArchive.ASTLocalCellReferenceNodeArchive {
      get {return _storage._astLocalCellReferenceNodeReference ?? TSCE_ASTNodeArrayArchive.ASTLocalCellReferenceNodeArchive()}
      set {_uniqueStorage()._astLocalCellReferenceNodeReference = newValue}
    }
    /// Returns true if `astLocalCellReferenceNodeReference` has been explicitly set.
    var hasAstLocalCellReferenceNodeReference: Bool {return _storage._astLocalCellReferenceNodeReference != nil}
    /// Clears the value of `astLocalCellReferenceNodeReference`. Subsequent reads from it will return its default value.
    mutating func clearAstLocalCellReferenceNodeReference() {_uniqueStorage()._astLocalCellReferenceNodeReference = nil}

    var astCrossTableCellReferenceNodeReference: TSCE_ASTNodeArrayArchive.ASTCrossTableCellReferenceNodeArchive {
      get {return _storage._astCrossTableCellReferenceNodeReference ?? TSCE_ASTNodeArrayArchive.ASTCrossTableCellReferenceNodeArchive()}
      set {_uniqueStorage()._astCrossTableCellReferenceNodeReference = newValue}
    }
    /// Returns true if `astCrossTableCellReferenceNodeReference` has been explicitly set.
    var hasAstCrossTableCellReferenceNodeReference: Bool {return _storage._astCrossTableCellReferenceNodeReference != nil}
    /// Clears the value of `astCrossTableCellReferenceNodeReference`. Subsequent reads from it will return its default value.
    mutating func clearAstCrossTableCellReferenceNodeReference() {_uniqueStorage()._astCrossTableCellReferenceNodeReference = nil}

    var astUnknownFunctionNodeString: String {
      get {return _storage._astUnknownFunctionNodeString ?? String()}
      set {_uniqueStorage()._astUnknownFunctionNodeString = newValue}
    }
    /// Returns true if `astUnknownFunctionNodeString` has been explicitly set.
    var hasAstUnknownFunctionNodeString: Bool {return _storage._astUnknownFunctionNodeString != nil}
    /// Clears the value of `astUnknownFunctionNodeString`. Subsequent reads from it will return its default value.
    mutating func clearAstUnknownFunctionNodeString() {_uniqueStorage()._astUnknownFunctionNodeString = nil}

    var astUnknownFunctionNodeNumArgs: UInt32 {
      get {return _storage._astUnknownFunctionNodeNumArgs ?? 0}
      set {_uniqueStorage()._astUnknownFunctionNodeNumArgs = newValue}
    }
    /// Returns true if `astUnknownFunctionNodeNumArgs` has been explicitly set.
    var hasAstUnknownFunctionNodeNumArgs: Bool {return _storage._astUnknownFunctionNodeNumArgs != nil}
    /// Clears the value of `astUnknownFunctionNodeNumArgs`. Subsequent reads from it will return its default value.
    mutating func clearAstUnknownFunctionNodeNumArgs() {_uniqueStorage()._astUnknownFunctionNodeNumArgs = nil}

    var astWhitespace: String {
      get {return _storage._astWhitespace ?? String()}
      set {_uniqueStorage()._astWhitespace = newValue}
    }
    /// Returns true if `astWhitespace` has been explicitly set.
    var hasAstWhitespace: Bool {return _storage._astWhitespace != nil}
    /// Clears the value of `astWhitespace`. Subsequent reads from it will return its default value.
    mutating func clearAstWhitespace() {_uniqueStorage()._astWhitespace = nil}

    var astColumn: TSCE_ASTNodeArrayArchive.ASTColumnCoordinateArchive {
      get {return _storage._astColumn ?? TSCE_ASTNodeArrayArchive.ASTColumnCoordinateArchive()}
      set {_uniqueStorage()._astColumn = newValue}
    }
    /// Returns true if `astColumn` has been explicitly set.
    var hasAstColumn: Bool {return _storage._astColumn != nil}
    /// Clears the value of `astColumn`. Subsequent reads from it will return its default value.
    mutating func clearAstColumn() {_uniqueStorage()._astColumn = nil}

    var astRow: TSCE_ASTNodeArrayArchive.ASTRowCoordinateArchive {
      get {return _storage._astRow ?? TSCE_ASTNodeArrayArchive.ASTRowCoordinateArchive()}
      set {_uniqueStorage()._astRow = newValue}
    }
    /// Returns true if `astRow` has been explicitly set.
    var hasAstRow: Bool {return _storage._astRow != nil}
    /// Clears the value of `astRow`. Subsequent reads from it will return its default value.
    mutating func clearAstRow() {_uniqueStorage()._astRow = nil}

    var astCrossTableReferenceExtraInfo: TSCE_ASTNodeArrayArchive.ASTCrossTableReferenceExtraInfoArchive {
      get {return _storage._astCrossTableReferenceExtraInfo ?? TSCE_ASTNodeArrayArchive.ASTCrossTableReferenceExtraInfoArchive()}
      set {_uniqueStorage()._astCrossTableReferenceExtraInfo = newValue}
    }
    /// Returns true if `astCrossTableReferenceExtraInfo` has been explicitly set.
    var hasAstCrossTableReferenceExtraInfo: Bool {return _storage._astCrossTableReferenceExtraInfo != nil}
    /// Clears the value of `astCrossTableReferenceExtraInfo`. Subsequent reads from it will return its default value.
    mutating func clearAstCrossTableReferenceExtraInfo() {_uniqueStorage()._astCrossTableReferenceExtraInfo = nil}

    var astUidCoordinate: TSCE_ASTNodeArrayArchive.ASTUidCoordinateArchive {
      get {return _storage._astUidCoordinate ?? TSCE_ASTNodeArrayArchive.ASTUidCoordinateArchive()}
      set {_uniqueStorage()._astUidCoordinate = newValue}
    }
    /// Returns true if `astUidCoordinate` has been explicitly set.
    var hasAstUidCoordinate: Bool {return _storage._astUidCoordinate != nil}
    /// Clears the value of `astUidCoordinate`. Subsequent reads from it will return its default value.
    mutating func clearAstUidCoordinate() {_uniqueStorage()._astUidCoordinate = nil}

    var astStickyBits: TSCE_ASTNodeArrayArchive.ASTStickyBits {
      get {return _storage._astStickyBits ?? TSCE_ASTNodeArrayArchive.ASTStickyBits()}
      set {_uniqueStorage()._astStickyBits = newValue}
    }
    /// Returns true if `astStickyBits` has been explicitly set.
    var hasAstStickyBits: Bool {return _storage._astStickyBits != nil}
    /// Clears the value of `astStickyBits`. Subsequent reads from it will return its default value.
    mutating func clearAstStickyBits() {_uniqueStorage()._astStickyBits = nil}

    var astFrozenStickyBits: TSCE_ASTNodeArrayArchive.ASTStickyBits {
      get {return _storage._astFrozenStickyBits ?? TSCE_ASTNodeArrayArchive.ASTStickyBits()}
      set {_uniqueStorage()._astFrozenStickyBits = newValue}
    }
    /// Returns true if `astFrozenStickyBits` has been explicitly set.
    var hasAstFrozenStickyBits: Bool {return _storage._astFrozenStickyBits != nil}
    /// Clears the value of `astFrozenStickyBits`. Subsequent reads from it will return its default value.
    mutating func clearAstFrozenStickyBits() {_uniqueStorage()._astFrozenStickyBits = nil}

    var astLetIdentifier: String {
      get {return _storage._astLetIdentifier ?? String()}
      set {_uniqueStorage()._astLetIdentifier = newValue}
    }
    /// Returns true if `astLetIdentifier` has been explicitly set.
    var hasAstLetIdentifier: Bool {return _storage._astLetIdentifier != nil}
    /// Clears the value of `astLetIdentifier`. Subsequent reads from it will return its default value.
    mutating func clearAstLetIdentifier() {_uniqueStorage()._astLetIdentifier = nil}

    var astLetWhitespace: String {
      get {return _storage._astLetWhitespace ?? String()}
      set {_uniqueStorage()._astLetWhitespace = newValue}
    }
    /// Returns true if `astLetWhitespace` has been explicitly set.
    var hasAstLetWhitespace: Bool {return _storage._astLetWhitespace != nil}
    /// Clears the value of `astLetWhitespace`. Subsequent reads from it will return its default value.
    mutating func clearAstLetWhitespace() {_uniqueStorage()._astLetWhitespace = nil}

    var astLetIsContinuation: Bool {
      get {return _storage._astLetIsContinuation ?? false}
      set {_uniqueStorage()._astLetIsContinuation = newValue}
    }
    /// Returns true if `astLetIsContinuation` has been explicitly set.
    var hasAstLetIsContinuation: Bool {return _storage._astLetIsContinuation != nil}
    /// Clears the value of `astLetIsContinuation`. Subsequent reads from it will return its default value.
    mutating func clearAstLetIsContinuation() {_uniqueStorage()._astLetIsContinuation = nil}

    var astSymbol: UInt32 {
      get {return _storage._astSymbol ?? 0}
      set {_uniqueStorage()._astSymbol = newValue}
    }
    /// Returns true if `astSymbol` has been explicitly set.
    var hasAstSymbol: Bool {return _storage._astSymbol != nil}
    /// Clears the value of `astSymbol`. Subsequent reads from it will return its default value.
    mutating func clearAstSymbol() {_uniqueStorage()._astSymbol = nil}

    var astTractList: TSCE_ASTNodeArrayArchive.ASTUidTractList {
      get {return _storage._astTractList ?? TSCE_ASTNodeArrayArchive.ASTUidTractList()}
      set {_uniqueStorage()._astTractList = newValue}
    }
    /// Returns true if `astTractList` has been explicitly set.
    var hasAstTractList: Bool {return _storage._astTractList != nil}
    /// Clears the value of `astTractList`. Subsequent reads from it will return its default value.
    mutating func clearAstTractList() {_uniqueStorage()._astTractList = nil}

    var astCategoryRef: TSCE_ASTNodeArrayArchive.ASTCategoryReferenceArchive {
      get {return _storage._astCategoryRef ?? TSCE_ASTNodeArrayArchive.ASTCategoryReferenceArchive()}
      set {_uniqueStorage()._astCategoryRef = newValue}
    }
    /// Returns true if `astCategoryRef` has been explicitly set.
    var hasAstCategoryRef: Bool {return _storage._astCategoryRef != nil}
    /// Clears the value of `astCategoryRef`. Subsequent reads from it will return its default value.
    mutating func clearAstCategoryRef() {_uniqueStorage()._astCategoryRef = nil}

    var astColonTract: TSCE_ASTNodeArrayArchive.ASTColonTractArchive {
      get {return _storage._astColonTract ?? TSCE_ASTNodeArrayArchive.ASTColonTractArchive()}
      set {_uniqueStorage()._astColonTract = newValue}
    }
    /// Returns true if `astColonTract` has been explicitly set.
    var hasAstColonTract: Bool {return _storage._astColonTract != nil}
    /// Clears the value of `astColonTract`. Subsequent reads from it will return its default value.
    mutating func clearAstColonTract() {_uniqueStorage()._astColonTract = nil}

    var astNumberNodeDecimalLow: UInt64 {
      get {return _storage._astNumberNodeDecimalLow ?? 0}
      set {_uniqueStorage()._astNumberNodeDecimalLow = newValue}
    }
    /// Returns true if `astNumberNodeDecimalLow` has been explicitly set.
    var hasAstNumberNodeDecimalLow: Bool {return _storage._astNumberNodeDecimalLow != nil}
    /// Clears the value of `astNumberNodeDecimalLow`. Subsequent reads from it will return its default value.
    mutating func clearAstNumberNodeDecimalLow() {_uniqueStorage()._astNumberNodeDecimalLow = nil}

    var astNumberNodeDecimalHigh: UInt64 {
      get {return _storage._astNumberNodeDecimalHigh ?? 0}
      set {_uniqueStorage()._astNumberNodeDecimalHigh = newValue}
    }
    /// Returns true if `astNumberNodeDecimalHigh` has been explicitly set.
    var hasAstNumberNodeDecimalHigh: Bool {return _storage._astNumberNodeDecimalHigh != nil}
    /// Clears the value of `astNumberNodeDecimalHigh`. Subsequent reads from it will return its default value.
    mutating func clearAstNumberNodeDecimalHigh() {_uniqueStorage()._astNumberNodeDecimalHigh = nil}

    var astCategoryLevels: TSCE_ASTNodeArrayArchive.ASTCategoryLevels {
      get {return _storage._astCategoryLevels ?? TSCE_ASTNodeArrayArchive.ASTCategoryLevels()}
      set {_uniqueStorage()._astCategoryLevels = newValue}
    }
    /// Returns true if `astCategoryLevels` has been explicitly set.
    var hasAstCategoryLevels: Bool {return _storage._astCategoryLevels != nil}
    /// Clears the value of `astCategoryLevels`. Subsequent reads from it will return its default value.
    mutating func clearAstCategoryLevels() {_uniqueStorage()._astCategoryLevels = nil}

    var astLambdaIdents: TSCE_ASTNodeArrayArchive.ASTLambdaIdentsListArchive {
      get {return _storage._astLambdaIdents ?? TSCE_ASTNodeArrayArchive.ASTLambdaIdentsListArchive()}
      set {_uniqueStorage()._astLambdaIdents = newValue}
    }
    /// Returns true if `astLambdaIdents` has been explicitly set.
    var hasAstLambdaIdents: Bool {return _storage._astLambdaIdents != nil}
    /// Clears the value of `astLambdaIdents`. Subsequent reads from it will return its default value.
    mutating func clearAstLambdaIdents() {_uniqueStorage()._astLambdaIdents = nil}

    var astRangeContext: UInt32 {
      get {return _storage._astRangeContext ?? 0}
      set {_uniqueStorage()._astRangeContext = newValue}
    }
    /// Returns true if `astRangeContext` has been explicitly set.
    var hasAstRangeContext: Bool {return _storage._astRangeContext != nil}
    /// Clears the value of `astRangeContext`. Subsequent reads from it will return its default value.
    mutating func clearAstRangeContext() {_uniqueStorage()._astRangeContext = nil}

    var upgradeNodeType: TSCE_ASTNodeArrayArchive.ASTNodeType {
      get {return _storage._upgradeNodeType ?? .additionNode}
      set {_uniqueStorage()._upgradeNodeType = newValue}
    }
    /// Returns true if `upgradeNodeType` has been explicitly set.
    var hasUpgradeNodeType: Bool {return _storage._upgradeNodeType != nil}
    /// Clears the value of `upgradeNodeType`. Subsequent reads from it will return its default value.
    mutating func clearUpgradeNodeType() {_uniqueStorage()._upgradeNodeType = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

struct TSCE_FormulaTranslationFlagsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var excelImportTranslation: Bool {
    get {return _excelImportTranslation ?? false}
    set {_excelImportTranslation = newValue}
  }
  /// Returns true if `excelImportTranslation` has been explicitly set.
  var hasExcelImportTranslation: Bool {return self._excelImportTranslation != nil}
  /// Clears the value of `excelImportTranslation`. Subsequent reads from it will return its default value.
  mutating func clearExcelImportTranslation() {self._excelImportTranslation = nil}

  var numberToDateCoercionRemovalTranslation: Bool {
    get {return _numberToDateCoercionRemovalTranslation ?? false}
    set {_numberToDateCoercionRemovalTranslation = newValue}
  }
  /// Returns true if `numberToDateCoercionRemovalTranslation` has been explicitly set.
  var hasNumberToDateCoercionRemovalTranslation: Bool {return self._numberToDateCoercionRemovalTranslation != nil}
  /// Clears the value of `numberToDateCoercionRemovalTranslation`. Subsequent reads from it will return its default value.
  mutating func clearNumberToDateCoercionRemovalTranslation() {self._numberToDateCoercionRemovalTranslation = nil}

  var containsUidFormReferences: Bool {
    get {return _containsUidFormReferences ?? false}
    set {_containsUidFormReferences = newValue}
  }
  /// Returns true if `containsUidFormReferences` has been explicitly set.
  var hasContainsUidFormReferences: Bool {return self._containsUidFormReferences != nil}
  /// Clears the value of `containsUidFormReferences`. Subsequent reads from it will return its default value.
  mutating func clearContainsUidFormReferences() {self._containsUidFormReferences = nil}

  var containsFrozenReferences: Bool {
    get {return _containsFrozenReferences ?? false}
    set {_containsFrozenReferences = newValue}
  }
  /// Returns true if `containsFrozenReferences` has been explicitly set.
  var hasContainsFrozenReferences: Bool {return self._containsFrozenReferences != nil}
  /// Clears the value of `containsFrozenReferences`. Subsequent reads from it will return its default value.
  mutating func clearContainsFrozenReferences() {self._containsFrozenReferences = nil}

  var returnsPercentFormatted: Bool {
    get {return _returnsPercentFormatted ?? false}
    set {_returnsPercentFormatted = newValue}
  }
  /// Returns true if `returnsPercentFormatted` has been explicitly set.
  var hasReturnsPercentFormatted: Bool {return self._returnsPercentFormatted != nil}
  /// Clears the value of `returnsPercentFormatted`. Subsequent reads from it will return its default value.
  mutating func clearReturnsPercentFormatted() {self._returnsPercentFormatted = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _excelImportTranslation: Bool? = nil
  fileprivate var _numberToDateCoercionRemovalTranslation: Bool? = nil
  fileprivate var _containsUidFormReferences: Bool? = nil
  fileprivate var _containsFrozenReferences: Bool? = nil
  fileprivate var _returnsPercentFormatted: Bool? = nil
}

struct TSCE_FormulaArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var astNodeArray: TSCE_ASTNodeArrayArchive {
    get {return _astNodeArray ?? TSCE_ASTNodeArrayArchive()}
    set {_astNodeArray = newValue}
  }
  /// Returns true if `astNodeArray` has been explicitly set.
  var hasAstNodeArray: Bool {return self._astNodeArray != nil}
  /// Clears the value of `astNodeArray`. Subsequent reads from it will return its default value.
  mutating func clearAstNodeArray() {self._astNodeArray = nil}

  var hostColumn: UInt32 {
    get {return _hostColumn ?? 0}
    set {_hostColumn = newValue}
  }
  /// Returns true if `hostColumn` has been explicitly set.
  var hasHostColumn: Bool {return self._hostColumn != nil}
  /// Clears the value of `hostColumn`. Subsequent reads from it will return its default value.
  mutating func clearHostColumn() {self._hostColumn = nil}

  var hostRow: UInt32 {
    get {return _hostRow ?? 0}
    set {_hostRow = newValue}
  }
  /// Returns true if `hostRow` has been explicitly set.
  var hasHostRow: Bool {return self._hostRow != nil}
  /// Clears the value of `hostRow`. Subsequent reads from it will return its default value.
  mutating func clearHostRow() {self._hostRow = nil}

  var hostColumnIsNegative: Bool {
    get {return _hostColumnIsNegative ?? false}
    set {_hostColumnIsNegative = newValue}
  }
  /// Returns true if `hostColumnIsNegative` has been explicitly set.
  var hasHostColumnIsNegative: Bool {return self._hostColumnIsNegative != nil}
  /// Clears the value of `hostColumnIsNegative`. Subsequent reads from it will return its default value.
  mutating func clearHostColumnIsNegative() {self._hostColumnIsNegative = nil}

  var hostRowIsNegative: Bool {
    get {return _hostRowIsNegative ?? false}
    set {_hostRowIsNegative = newValue}
  }
  /// Returns true if `hostRowIsNegative` has been explicitly set.
  var hasHostRowIsNegative: Bool {return self._hostRowIsNegative != nil}
  /// Clears the value of `hostRowIsNegative`. Subsequent reads from it will return its default value.
  mutating func clearHostRowIsNegative() {self._hostRowIsNegative = nil}

  var translationFlags: TSCE_FormulaTranslationFlagsArchive {
    get {return _translationFlags ?? TSCE_FormulaTranslationFlagsArchive()}
    set {_translationFlags = newValue}
  }
  /// Returns true if `translationFlags` has been explicitly set.
  var hasTranslationFlags: Bool {return self._translationFlags != nil}
  /// Clears the value of `translationFlags`. Subsequent reads from it will return its default value.
  mutating func clearTranslationFlags() {self._translationFlags = nil}

  var hostTableUid: TSP_UUID {
    get {return _hostTableUid ?? TSP_UUID()}
    set {_hostTableUid = newValue}
  }
  /// Returns true if `hostTableUid` has been explicitly set.
  var hasHostTableUid: Bool {return self._hostTableUid != nil}
  /// Clears the value of `hostTableUid`. Subsequent reads from it will return its default value.
  mutating func clearHostTableUid() {self._hostTableUid = nil}

  var hostColumnUid: TSP_UUID {
    get {return _hostColumnUid ?? TSP_UUID()}
    set {_hostColumnUid = newValue}
  }
  /// Returns true if `hostColumnUid` has been explicitly set.
  var hasHostColumnUid: Bool {return self._hostColumnUid != nil}
  /// Clears the value of `hostColumnUid`. Subsequent reads from it will return its default value.
  mutating func clearHostColumnUid() {self._hostColumnUid = nil}

  var hostRowUid: TSP_UUID {
    get {return _hostRowUid ?? TSP_UUID()}
    set {_hostRowUid = newValue}
  }
  /// Returns true if `hostRowUid` has been explicitly set.
  var hasHostRowUid: Bool {return self._hostRowUid != nil}
  /// Clears the value of `hostRowUid`. Subsequent reads from it will return its default value.
  mutating func clearHostRowUid() {self._hostRowUid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _astNodeArray: TSCE_ASTNodeArrayArchive? = nil
  fileprivate var _hostColumn: UInt32? = nil
  fileprivate var _hostRow: UInt32? = nil
  fileprivate var _hostColumnIsNegative: Bool? = nil
  fileprivate var _hostRowIsNegative: Bool? = nil
  fileprivate var _translationFlags: TSCE_FormulaTranslationFlagsArchive? = nil
  fileprivate var _hostTableUid: TSP_UUID? = nil
  fileprivate var _hostColumnUid: TSP_UUID? = nil
  fileprivate var _hostRowUid: TSP_UUID? = nil
}

struct TSCE_FunctorArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var formula: TSCE_FormulaArchive {
    get {return _storage._formula ?? TSCE_FormulaArchive()}
    set {_uniqueStorage()._formula = newValue}
  }
  /// Returns true if `formula` has been explicitly set.
  var hasFormula: Bool {return _storage._formula != nil}
  /// Clears the value of `formula`. Subsequent reads from it will return its default value.
  mutating func clearFormula() {_uniqueStorage()._formula = nil}

  var numArgs: UInt32 {
    get {return _storage._numArgs ?? 0}
    set {_uniqueStorage()._numArgs = newValue}
  }
  /// Returns true if `numArgs` has been explicitly set.
  var hasNumArgs: Bool {return _storage._numArgs != nil}
  /// Clears the value of `numArgs`. Subsequent reads from it will return its default value.
  mutating func clearNumArgs() {_uniqueStorage()._numArgs = nil}

  var firstSymbol: UInt32 {
    get {return _storage._firstSymbol ?? 0}
    set {_uniqueStorage()._firstSymbol = newValue}
  }
  /// Returns true if `firstSymbol` has been explicitly set.
  var hasFirstSymbol: Bool {return _storage._firstSymbol != nil}
  /// Clears the value of `firstSymbol`. Subsequent reads from it will return its default value.
  mutating func clearFirstSymbol() {_uniqueStorage()._firstSymbol = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSCE_FormatStructArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var formatType: UInt32 {
    get {return _formatType ?? 0}
    set {_formatType = newValue}
  }
  /// Returns true if `formatType` has been explicitly set.
  var hasFormatType: Bool {return self._formatType != nil}
  /// Clears the value of `formatType`. Subsequent reads from it will return its default value.
  mutating func clearFormatType() {self._formatType = nil}

  var decimalPlaces: UInt32 {
    get {return _decimalPlaces ?? 0}
    set {_decimalPlaces = newValue}
  }
  /// Returns true if `decimalPlaces` has been explicitly set.
  var hasDecimalPlaces: Bool {return self._decimalPlaces != nil}
  /// Clears the value of `decimalPlaces`. Subsequent reads from it will return its default value.
  mutating func clearDecimalPlaces() {self._decimalPlaces = nil}

  var currencyCode: String {
    get {return _currencyCode ?? String()}
    set {_currencyCode = newValue}
  }
  /// Returns true if `currencyCode` has been explicitly set.
  var hasCurrencyCode: Bool {return self._currencyCode != nil}
  /// Clears the value of `currencyCode`. Subsequent reads from it will return its default value.
  mutating func clearCurrencyCode() {self._currencyCode = nil}

  var negativeStyle: UInt32 {
    get {return _negativeStyle ?? 0}
    set {_negativeStyle = newValue}
  }
  /// Returns true if `negativeStyle` has been explicitly set.
  var hasNegativeStyle: Bool {return self._negativeStyle != nil}
  /// Clears the value of `negativeStyle`. Subsequent reads from it will return its default value.
  mutating func clearNegativeStyle() {self._negativeStyle = nil}

  var showThousandsSeparator: Bool {
    get {return _showThousandsSeparator ?? false}
    set {_showThousandsSeparator = newValue}
  }
  /// Returns true if `showThousandsSeparator` has been explicitly set.
  var hasShowThousandsSeparator: Bool {return self._showThousandsSeparator != nil}
  /// Clears the value of `showThousandsSeparator`. Subsequent reads from it will return its default value.
  mutating func clearShowThousandsSeparator() {self._showThousandsSeparator = nil}

  var useAccountingStyle: Bool {
    get {return _useAccountingStyle ?? false}
    set {_useAccountingStyle = newValue}
  }
  /// Returns true if `useAccountingStyle` has been explicitly set.
  var hasUseAccountingStyle: Bool {return self._useAccountingStyle != nil}
  /// Clears the value of `useAccountingStyle`. Subsequent reads from it will return its default value.
  mutating func clearUseAccountingStyle() {self._useAccountingStyle = nil}

  var durationStyle: UInt32 {
    get {return _durationStyle ?? 0}
    set {_durationStyle = newValue}
  }
  /// Returns true if `durationStyle` has been explicitly set.
  var hasDurationStyle: Bool {return self._durationStyle != nil}
  /// Clears the value of `durationStyle`. Subsequent reads from it will return its default value.
  mutating func clearDurationStyle() {self._durationStyle = nil}

  var base: UInt32 {
    get {return _base ?? 0}
    set {_base = newValue}
  }
  /// Returns true if `base` has been explicitly set.
  var hasBase: Bool {return self._base != nil}
  /// Clears the value of `base`. Subsequent reads from it will return its default value.
  mutating func clearBase() {self._base = nil}

  var basePlaces: UInt32 {
    get {return _basePlaces ?? 0}
    set {_basePlaces = newValue}
  }
  /// Returns true if `basePlaces` has been explicitly set.
  var hasBasePlaces: Bool {return self._basePlaces != nil}
  /// Clears the value of `basePlaces`. Subsequent reads from it will return its default value.
  mutating func clearBasePlaces() {self._basePlaces = nil}

  var baseUseMinusSign: Bool {
    get {return _baseUseMinusSign ?? false}
    set {_baseUseMinusSign = newValue}
  }
  /// Returns true if `baseUseMinusSign` has been explicitly set.
  var hasBaseUseMinusSign: Bool {return self._baseUseMinusSign != nil}
  /// Clears the value of `baseUseMinusSign`. Subsequent reads from it will return its default value.
  mutating func clearBaseUseMinusSign() {self._baseUseMinusSign = nil}

  var fractionAccuracy: UInt32 {
    get {return _fractionAccuracy ?? 0}
    set {_fractionAccuracy = newValue}
  }
  /// Returns true if `fractionAccuracy` has been explicitly set.
  var hasFractionAccuracy: Bool {return self._fractionAccuracy != nil}
  /// Clears the value of `fractionAccuracy`. Subsequent reads from it will return its default value.
  mutating func clearFractionAccuracy() {self._fractionAccuracy = nil}

  var suppressDateFormat: Bool {
    get {return _suppressDateFormat ?? false}
    set {_suppressDateFormat = newValue}
  }
  /// Returns true if `suppressDateFormat` has been explicitly set.
  var hasSuppressDateFormat: Bool {return self._suppressDateFormat != nil}
  /// Clears the value of `suppressDateFormat`. Subsequent reads from it will return its default value.
  mutating func clearSuppressDateFormat() {self._suppressDateFormat = nil}

  var suppressTimeFormat: Bool {
    get {return _suppressTimeFormat ?? false}
    set {_suppressTimeFormat = newValue}
  }
  /// Returns true if `suppressTimeFormat` has been explicitly set.
  var hasSuppressTimeFormat: Bool {return self._suppressTimeFormat != nil}
  /// Clears the value of `suppressTimeFormat`. Subsequent reads from it will return its default value.
  mutating func clearSuppressTimeFormat() {self._suppressTimeFormat = nil}

  var dateTimeFormat: String {
    get {return _dateTimeFormat ?? String()}
    set {_dateTimeFormat = newValue}
  }
  /// Returns true if `dateTimeFormat` has been explicitly set.
  var hasDateTimeFormat: Bool {return self._dateTimeFormat != nil}
  /// Clears the value of `dateTimeFormat`. Subsequent reads from it will return its default value.
  mutating func clearDateTimeFormat() {self._dateTimeFormat = nil}

  var durationUnitLargest: UInt32 {
    get {return _durationUnitLargest ?? 0}
    set {_durationUnitLargest = newValue}
  }
  /// Returns true if `durationUnitLargest` has been explicitly set.
  var hasDurationUnitLargest: Bool {return self._durationUnitLargest != nil}
  /// Clears the value of `durationUnitLargest`. Subsequent reads from it will return its default value.
  mutating func clearDurationUnitLargest() {self._durationUnitLargest = nil}

  var durationUnitSmallest: UInt32 {
    get {return _durationUnitSmallest ?? 0}
    set {_durationUnitSmallest = newValue}
  }
  /// Returns true if `durationUnitSmallest` has been explicitly set.
  var hasDurationUnitSmallest: Bool {return self._durationUnitSmallest != nil}
  /// Clears the value of `durationUnitSmallest`. Subsequent reads from it will return its default value.
  mutating func clearDurationUnitSmallest() {self._durationUnitSmallest = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _formatType: UInt32? = nil
  fileprivate var _decimalPlaces: UInt32? = nil
  fileprivate var _currencyCode: String? = nil
  fileprivate var _negativeStyle: UInt32? = nil
  fileprivate var _showThousandsSeparator: Bool? = nil
  fileprivate var _useAccountingStyle: Bool? = nil
  fileprivate var _durationStyle: UInt32? = nil
  fileprivate var _base: UInt32? = nil
  fileprivate var _basePlaces: UInt32? = nil
  fileprivate var _baseUseMinusSign: Bool? = nil
  fileprivate var _fractionAccuracy: UInt32? = nil
  fileprivate var _suppressDateFormat: Bool? = nil
  fileprivate var _suppressTimeFormat: Bool? = nil
  fileprivate var _dateTimeFormat: String? = nil
  fileprivate var _durationUnitLargest: UInt32? = nil
  fileprivate var _durationUnitSmallest: UInt32? = nil
}

struct TSCE_RangeCoordinateArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var topLeftColumn: UInt32 {
    get {return _topLeftColumn ?? 0}
    set {_topLeftColumn = newValue}
  }
  /// Returns true if `topLeftColumn` has been explicitly set.
  var hasTopLeftColumn: Bool {return self._topLeftColumn != nil}
  /// Clears the value of `topLeftColumn`. Subsequent reads from it will return its default value.
  mutating func clearTopLeftColumn() {self._topLeftColumn = nil}

  var topLeftRow: UInt32 {
    get {return _topLeftRow ?? 0}
    set {_topLeftRow = newValue}
  }
  /// Returns true if `topLeftRow` has been explicitly set.
  var hasTopLeftRow: Bool {return self._topLeftRow != nil}
  /// Clears the value of `topLeftRow`. Subsequent reads from it will return its default value.
  mutating func clearTopLeftRow() {self._topLeftRow = nil}

  var bottomRightColumn: UInt32 {
    get {return _bottomRightColumn ?? 0}
    set {_bottomRightColumn = newValue}
  }
  /// Returns true if `bottomRightColumn` has been explicitly set.
  var hasBottomRightColumn: Bool {return self._bottomRightColumn != nil}
  /// Clears the value of `bottomRightColumn`. Subsequent reads from it will return its default value.
  mutating func clearBottomRightColumn() {self._bottomRightColumn = nil}

  var bottomRightRow: UInt32 {
    get {return _bottomRightRow ?? 0}
    set {_bottomRightRow = newValue}
  }
  /// Returns true if `bottomRightRow` has been explicitly set.
  var hasBottomRightRow: Bool {return self._bottomRightRow != nil}
  /// Clears the value of `bottomRightRow`. Subsequent reads from it will return its default value.
  mutating func clearBottomRightRow() {self._bottomRightRow = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _topLeftColumn: UInt32? = nil
  fileprivate var _topLeftRow: UInt32? = nil
  fileprivate var _bottomRightColumn: UInt32? = nil
  fileprivate var _bottomRightRow: UInt32? = nil
}

struct TSCE_TableTransposeInfoArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var numberOfFooterRows: UInt32 {
    get {return _numberOfFooterRows ?? 0}
    set {_numberOfFooterRows = newValue}
  }
  /// Returns true if `numberOfFooterRows` has been explicitly set.
  var hasNumberOfFooterRows: Bool {return self._numberOfFooterRows != nil}
  /// Clears the value of `numberOfFooterRows`. Subsequent reads from it will return its default value.
  mutating func clearNumberOfFooterRows() {self._numberOfFooterRows = nil}

  var bodyRangeForTransposedTable: TSCE_RangeCoordinateArchive {
    get {return _bodyRangeForTransposedTable ?? TSCE_RangeCoordinateArchive()}
    set {_bodyRangeForTransposedTable = newValue}
  }
  /// Returns true if `bodyRangeForTransposedTable` has been explicitly set.
  var hasBodyRangeForTransposedTable: Bool {return self._bodyRangeForTransposedTable != nil}
  /// Clears the value of `bodyRangeForTransposedTable`. Subsequent reads from it will return its default value.
  mutating func clearBodyRangeForTransposedTable() {self._bodyRangeForTransposedTable = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _numberOfFooterRows: UInt32? = nil
  fileprivate var _bodyRangeForTransposedTable: TSCE_RangeCoordinateArchive? = nil
}

struct TSCE_MergeOriginMovedArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var srcColumn: [UInt32] = []

  var srcRow: [UInt32] = []

  var dstColumn: [UInt32] = []

  var dstRow: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSCE_OwnerUIDMapperArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tableUid: TSP_UUID {
    get {return _storage._tableUid ?? TSP_UUID()}
    set {_uniqueStorage()._tableUid = newValue}
  }
  /// Returns true if `tableUid` has been explicitly set.
  var hasTableUid: Bool {return _storage._tableUid != nil}
  /// Clears the value of `tableUid`. Subsequent reads from it will return its default value.
  mutating func clearTableUid() {_uniqueStorage()._tableUid = nil}

  var nextTableUid: TSP_UUID {
    get {return _storage._nextTableUid ?? TSP_UUID()}
    set {_uniqueStorage()._nextTableUid = newValue}
  }
  /// Returns true if `nextTableUid` has been explicitly set.
  var hasNextTableUid: Bool {return _storage._nextTableUid != nil}
  /// Clears the value of `nextTableUid`. Subsequent reads from it will return its default value.
  mutating func clearNextTableUid() {_uniqueStorage()._nextTableUid = nil}

  var hiddenStateForRowsOwnerUid: TSP_UUID {
    get {return _storage._hiddenStateForRowsOwnerUid ?? TSP_UUID()}
    set {_uniqueStorage()._hiddenStateForRowsOwnerUid = newValue}
  }
  /// Returns true if `hiddenStateForRowsOwnerUid` has been explicitly set.
  var hasHiddenStateForRowsOwnerUid: Bool {return _storage._hiddenStateForRowsOwnerUid != nil}
  /// Clears the value of `hiddenStateForRowsOwnerUid`. Subsequent reads from it will return its default value.
  mutating func clearHiddenStateForRowsOwnerUid() {_uniqueStorage()._hiddenStateForRowsOwnerUid = nil}

  var nextHiddenStateForRowsOwnerUid: TSP_UUID {
    get {return _storage._nextHiddenStateForRowsOwnerUid ?? TSP_UUID()}
    set {_uniqueStorage()._nextHiddenStateForRowsOwnerUid = newValue}
  }
  /// Returns true if `nextHiddenStateForRowsOwnerUid` has been explicitly set.
  var hasNextHiddenStateForRowsOwnerUid: Bool {return _storage._nextHiddenStateForRowsOwnerUid != nil}
  /// Clears the value of `nextHiddenStateForRowsOwnerUid`. Subsequent reads from it will return its default value.
  mutating func clearNextHiddenStateForRowsOwnerUid() {_uniqueStorage()._nextHiddenStateForRowsOwnerUid = nil}

  var hiddenStateForColumnsOwnerUid: TSP_UUID {
    get {return _storage._hiddenStateForColumnsOwnerUid ?? TSP_UUID()}
    set {_uniqueStorage()._hiddenStateForColumnsOwnerUid = newValue}
  }
  /// Returns true if `hiddenStateForColumnsOwnerUid` has been explicitly set.
  var hasHiddenStateForColumnsOwnerUid: Bool {return _storage._hiddenStateForColumnsOwnerUid != nil}
  /// Clears the value of `hiddenStateForColumnsOwnerUid`. Subsequent reads from it will return its default value.
  mutating func clearHiddenStateForColumnsOwnerUid() {_uniqueStorage()._hiddenStateForColumnsOwnerUid = nil}

  var nextHiddenStateForColumnsOwnerUid: TSP_UUID {
    get {return _storage._nextHiddenStateForColumnsOwnerUid ?? TSP_UUID()}
    set {_uniqueStorage()._nextHiddenStateForColumnsOwnerUid = newValue}
  }
  /// Returns true if `nextHiddenStateForColumnsOwnerUid` has been explicitly set.
  var hasNextHiddenStateForColumnsOwnerUid: Bool {return _storage._nextHiddenStateForColumnsOwnerUid != nil}
  /// Clears the value of `nextHiddenStateForColumnsOwnerUid`. Subsequent reads from it will return its default value.
  mutating func clearNextHiddenStateForColumnsOwnerUid() {_uniqueStorage()._nextHiddenStateForColumnsOwnerUid = nil}

  var conditionalStyleOwnerUid: TSP_UUID {
    get {return _storage._conditionalStyleOwnerUid ?? TSP_UUID()}
    set {_uniqueStorage()._conditionalStyleOwnerUid = newValue}
  }
  /// Returns true if `conditionalStyleOwnerUid` has been explicitly set.
  var hasConditionalStyleOwnerUid: Bool {return _storage._conditionalStyleOwnerUid != nil}
  /// Clears the value of `conditionalStyleOwnerUid`. Subsequent reads from it will return its default value.
  mutating func clearConditionalStyleOwnerUid() {_uniqueStorage()._conditionalStyleOwnerUid = nil}

  var nextConditionalStyleOwnerUid: TSP_UUID {
    get {return _storage._nextConditionalStyleOwnerUid ?? TSP_UUID()}
    set {_uniqueStorage()._nextConditionalStyleOwnerUid = newValue}
  }
  /// Returns true if `nextConditionalStyleOwnerUid` has been explicitly set.
  var hasNextConditionalStyleOwnerUid: Bool {return _storage._nextConditionalStyleOwnerUid != nil}
  /// Clears the value of `nextConditionalStyleOwnerUid`. Subsequent reads from it will return its default value.
  mutating func clearNextConditionalStyleOwnerUid() {_uniqueStorage()._nextConditionalStyleOwnerUid = nil}

  var sortRuleReferenceTrackerOwnerUid: TSP_UUID {
    get {return _storage._sortRuleReferenceTrackerOwnerUid ?? TSP_UUID()}
    set {_uniqueStorage()._sortRuleReferenceTrackerOwnerUid = newValue}
  }
  /// Returns true if `sortRuleReferenceTrackerOwnerUid` has been explicitly set.
  var hasSortRuleReferenceTrackerOwnerUid: Bool {return _storage._sortRuleReferenceTrackerOwnerUid != nil}
  /// Clears the value of `sortRuleReferenceTrackerOwnerUid`. Subsequent reads from it will return its default value.
  mutating func clearSortRuleReferenceTrackerOwnerUid() {_uniqueStorage()._sortRuleReferenceTrackerOwnerUid = nil}

  var nextSortRuleReferenceTrackerOwnerUid: TSP_UUID {
    get {return _storage._nextSortRuleReferenceTrackerOwnerUid ?? TSP_UUID()}
    set {_uniqueStorage()._nextSortRuleReferenceTrackerOwnerUid = newValue}
  }
  /// Returns true if `nextSortRuleReferenceTrackerOwnerUid` has been explicitly set.
  var hasNextSortRuleReferenceTrackerOwnerUid: Bool {return _storage._nextSortRuleReferenceTrackerOwnerUid != nil}
  /// Clears the value of `nextSortRuleReferenceTrackerOwnerUid`. Subsequent reads from it will return its default value.
  mutating func clearNextSortRuleReferenceTrackerOwnerUid() {_uniqueStorage()._nextSortRuleReferenceTrackerOwnerUid = nil}

  var mergeOwnerUid: TSP_UUID {
    get {return _storage._mergeOwnerUid ?? TSP_UUID()}
    set {_uniqueStorage()._mergeOwnerUid = newValue}
  }
  /// Returns true if `mergeOwnerUid` has been explicitly set.
  var hasMergeOwnerUid: Bool {return _storage._mergeOwnerUid != nil}
  /// Clears the value of `mergeOwnerUid`. Subsequent reads from it will return its default value.
  mutating func clearMergeOwnerUid() {_uniqueStorage()._mergeOwnerUid = nil}

  var nextMergeOwnerUid: TSP_UUID {
    get {return _storage._nextMergeOwnerUid ?? TSP_UUID()}
    set {_uniqueStorage()._nextMergeOwnerUid = newValue}
  }
  /// Returns true if `nextMergeOwnerUid` has been explicitly set.
  var hasNextMergeOwnerUid: Bool {return _storage._nextMergeOwnerUid != nil}
  /// Clears the value of `nextMergeOwnerUid`. Subsequent reads from it will return its default value.
  mutating func clearNextMergeOwnerUid() {_uniqueStorage()._nextMergeOwnerUid = nil}

  var categoryAggregatesOwnerUid: TSP_UUID {
    get {return _storage._categoryAggregatesOwnerUid ?? TSP_UUID()}
    set {_uniqueStorage()._categoryAggregatesOwnerUid = newValue}
  }
  /// Returns true if `categoryAggregatesOwnerUid` has been explicitly set.
  var hasCategoryAggregatesOwnerUid: Bool {return _storage._categoryAggregatesOwnerUid != nil}
  /// Clears the value of `categoryAggregatesOwnerUid`. Subsequent reads from it will return its default value.
  mutating func clearCategoryAggregatesOwnerUid() {_uniqueStorage()._categoryAggregatesOwnerUid = nil}

  var nextCategoryAggregatesOwnerUid: TSP_UUID {
    get {return _storage._nextCategoryAggregatesOwnerUid ?? TSP_UUID()}
    set {_uniqueStorage()._nextCategoryAggregatesOwnerUid = newValue}
  }
  /// Returns true if `nextCategoryAggregatesOwnerUid` has been explicitly set.
  var hasNextCategoryAggregatesOwnerUid: Bool {return _storage._nextCategoryAggregatesOwnerUid != nil}
  /// Clears the value of `nextCategoryAggregatesOwnerUid`. Subsequent reads from it will return its default value.
  mutating func clearNextCategoryAggregatesOwnerUid() {_uniqueStorage()._nextCategoryAggregatesOwnerUid = nil}

  var groupByUid: TSP_UUID {
    get {return _storage._groupByUid ?? TSP_UUID()}
    set {_uniqueStorage()._groupByUid = newValue}
  }
  /// Returns true if `groupByUid` has been explicitly set.
  var hasGroupByUid: Bool {return _storage._groupByUid != nil}
  /// Clears the value of `groupByUid`. Subsequent reads from it will return its default value.
  mutating func clearGroupByUid() {_uniqueStorage()._groupByUid = nil}

  var nextGroupByUid: TSP_UUID {
    get {return _storage._nextGroupByUid ?? TSP_UUID()}
    set {_uniqueStorage()._nextGroupByUid = newValue}
  }
  /// Returns true if `nextGroupByUid` has been explicitly set.
  var hasNextGroupByUid: Bool {return _storage._nextGroupByUid != nil}
  /// Clears the value of `nextGroupByUid`. Subsequent reads from it will return its default value.
  mutating func clearNextGroupByUid() {_uniqueStorage()._nextGroupByUid = nil}

  var pencilAnnotationOwnerUid: TSP_UUID {
    get {return _storage._pencilAnnotationOwnerUid ?? TSP_UUID()}
    set {_uniqueStorage()._pencilAnnotationOwnerUid = newValue}
  }
  /// Returns true if `pencilAnnotationOwnerUid` has been explicitly set.
  var hasPencilAnnotationOwnerUid: Bool {return _storage._pencilAnnotationOwnerUid != nil}
  /// Clears the value of `pencilAnnotationOwnerUid`. Subsequent reads from it will return its default value.
  mutating func clearPencilAnnotationOwnerUid() {_uniqueStorage()._pencilAnnotationOwnerUid = nil}

  var nextPencilAnnotationOwnerUid: TSP_UUID {
    get {return _storage._nextPencilAnnotationOwnerUid ?? TSP_UUID()}
    set {_uniqueStorage()._nextPencilAnnotationOwnerUid = newValue}
  }
  /// Returns true if `nextPencilAnnotationOwnerUid` has been explicitly set.
  var hasNextPencilAnnotationOwnerUid: Bool {return _storage._nextPencilAnnotationOwnerUid != nil}
  /// Clears the value of `nextPencilAnnotationOwnerUid`. Subsequent reads from it will return its default value.
  mutating func clearNextPencilAnnotationOwnerUid() {_uniqueStorage()._nextPencilAnnotationOwnerUid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSCE_RewriteTableUIDInfoArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tableUidMap: [TSCE_RewriteTableUIDInfoArchive.TableUIDMapEntryArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct TableUIDMapEntryArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var prevTableUid: TSP_UUID {
      get {return _prevTableUid ?? TSP_UUID()}
      set {_prevTableUid = newValue}
    }
    /// Returns true if `prevTableUid` has been explicitly set.
    var hasPrevTableUid: Bool {return self._prevTableUid != nil}
    /// Clears the value of `prevTableUid`. Subsequent reads from it will return its default value.
    mutating func clearPrevTableUid() {self._prevTableUid = nil}

    var newTableUid: TSP_UUID {
      get {return _newTableUid ?? TSP_UUID()}
      set {_newTableUid = newValue}
    }
    /// Returns true if `newTableUid` has been explicitly set.
    var hasNewTableUid: Bool {return self._newTableUid != nil}
    /// Clears the value of `newTableUid`. Subsequent reads from it will return its default value.
    mutating func clearNewTableUid() {self._newTableUid = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _prevTableUid: TSP_UUID? = nil
    fileprivate var _newTableUid: TSP_UUID? = nil
  }

  init() {}
}

struct TSCE_GroupByChangeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var changeType: TSCE_GroupByChangeArchive.ChangeType {
    get {return _changeType ?? .none}
    set {_changeType = newValue}
  }
  /// Returns true if `changeType` has been explicitly set.
  var hasChangeType: Bool {return self._changeType != nil}
  /// Clears the value of `changeType`. Subsequent reads from it will return its default value.
  mutating func clearChangeType() {self._changeType = nil}

  var groupByUid: TSP_UUID {
    get {return _groupByUid ?? TSP_UUID()}
    set {_groupByUid = newValue}
  }
  /// Returns true if `groupByUid` has been explicitly set.
  var hasGroupByUid: Bool {return self._groupByUid != nil}
  /// Clears the value of `groupByUid`. Subsequent reads from it will return its default value.
  mutating func clearGroupByUid() {self._groupByUid = nil}

  var previousLevel: UInt32 {
    get {return _previousLevel ?? 0}
    set {_previousLevel = newValue}
  }
  /// Returns true if `previousLevel` has been explicitly set.
  var hasPreviousLevel: Bool {return self._previousLevel != nil}
  /// Clears the value of `previousLevel`. Subsequent reads from it will return its default value.
  mutating func clearPreviousLevel() {self._previousLevel = nil}

  var updatedLevel: UInt32 {
    get {return _updatedLevel ?? 0}
    set {_updatedLevel = newValue}
  }
  /// Returns true if `updatedLevel` has been explicitly set.
  var hasUpdatedLevel: Bool {return self._updatedLevel != nil}
  /// Clears the value of `updatedLevel`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedLevel() {self._updatedLevel = nil}

  var previousToUpdatedMap: TSP_UUIDMapArchive {
    get {return _previousToUpdatedMap ?? TSP_UUIDMapArchive()}
    set {_previousToUpdatedMap = newValue}
  }
  /// Returns true if `previousToUpdatedMap` has been explicitly set.
  var hasPreviousToUpdatedMap: Bool {return self._previousToUpdatedMap != nil}
  /// Clears the value of `previousToUpdatedMap`. Subsequent reads from it will return its default value.
  mutating func clearPreviousToUpdatedMap() {self._previousToUpdatedMap = nil}

  var updatedToPreviousMap: TSP_UUIDMapArchive {
    get {return _updatedToPreviousMap ?? TSP_UUIDMapArchive()}
    set {_updatedToPreviousMap = newValue}
  }
  /// Returns true if `updatedToPreviousMap` has been explicitly set.
  var hasUpdatedToPreviousMap: Bool {return self._updatedToPreviousMap != nil}
  /// Clears the value of `updatedToPreviousMap`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedToPreviousMap() {self._updatedToPreviousMap = nil}

  var removedGroupUids: [TSP_UUID] = []

  var groupingColumnChanges: [TSCE_GroupByChangeArchive.GroupingColumnChangeArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ChangeType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case none = 0
    case groupValueChange = 1
    case groupDefinitionChange = 2
    case removeGroupLevel = 3
    case addGroupLevel = 4
    case promote = 5
    case demote = 6

    init() {
      self = .none
    }

  }

  struct GroupingColumnChangeArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var oldLevel: UInt32 {
      get {return _oldLevel ?? 0}
      set {_oldLevel = newValue}
    }
    /// Returns true if `oldLevel` has been explicitly set.
    var hasOldLevel: Bool {return self._oldLevel != nil}
    /// Clears the value of `oldLevel`. Subsequent reads from it will return its default value.
    mutating func clearOldLevel() {self._oldLevel = nil}

    var newLevel: UInt32 {
      get {return _newLevel ?? 0}
      set {_newLevel = newValue}
    }
    /// Returns true if `newLevel` has been explicitly set.
    var hasNewLevel: Bool {return self._newLevel != nil}
    /// Clears the value of `newLevel`. Subsequent reads from it will return its default value.
    mutating func clearNewLevel() {self._newLevel = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _oldLevel: UInt32? = nil
    fileprivate var _newLevel: UInt32? = nil
  }

  init() {}

  fileprivate var _changeType: TSCE_GroupByChangeArchive.ChangeType? = nil
  fileprivate var _groupByUid: TSP_UUID? = nil
  fileprivate var _previousLevel: UInt32? = nil
  fileprivate var _updatedLevel: UInt32? = nil
  fileprivate var _previousToUpdatedMap: TSP_UUIDMapArchive? = nil
  fileprivate var _updatedToPreviousMap: TSP_UUIDMapArchive? = nil
}

struct TSCE_RewriteGroupNodeUIDInfoArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groupByUid: TSP_UUID {
    get {return _groupByUid ?? TSP_UUID()}
    set {_groupByUid = newValue}
  }
  /// Returns true if `groupByUid` has been explicitly set.
  var hasGroupByUid: Bool {return self._groupByUid != nil}
  /// Clears the value of `groupByUid`. Subsequent reads from it will return its default value.
  mutating func clearGroupByUid() {self._groupByUid = nil}

  var groupNodeUidMap: TSP_UUIDMapArchive {
    get {return _groupNodeUidMap ?? TSP_UUIDMapArchive()}
    set {_groupNodeUidMap = newValue}
  }
  /// Returns true if `groupNodeUidMap` has been explicitly set.
  var hasGroupNodeUidMap: Bool {return self._groupNodeUidMap != nil}
  /// Clears the value of `groupNodeUidMap`. Subsequent reads from it will return its default value.
  mutating func clearGroupNodeUidMap() {self._groupNodeUidMap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _groupByUid: TSP_UUID? = nil
  fileprivate var _groupNodeUidMap: TSP_UUIDMapArchive? = nil
}

struct TSCE_IndexedUidsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uids: [TSCE_IndexedUidsArchive.IndexedUid] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct IndexedUid: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uidForIndex: TSP_UUID {
      get {return _uidForIndex ?? TSP_UUID()}
      set {_uidForIndex = newValue}
    }
    /// Returns true if `uidForIndex` has been explicitly set.
    var hasUidForIndex: Bool {return self._uidForIndex != nil}
    /// Clears the value of `uidForIndex`. Subsequent reads from it will return its default value.
    mutating func clearUidForIndex() {self._uidForIndex = nil}

    var indexForUid: UInt32 {
      get {return _indexForUid ?? 0}
      set {_indexForUid = newValue}
    }
    /// Returns true if `indexForUid` has been explicitly set.
    var hasIndexForUid: Bool {return self._indexForUid != nil}
    /// Clears the value of `indexForUid`. Subsequent reads from it will return its default value.
    mutating func clearIndexForUid() {self._indexForUid = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _uidForIndex: TSP_UUID? = nil
    fileprivate var _indexForUid: UInt32? = nil
  }

  init() {}
}

struct TSCE_RewriteRangeEntryArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rangeLocation: UInt32 {
    get {return _rangeLocation ?? 0}
    set {_rangeLocation = newValue}
  }
  /// Returns true if `rangeLocation` has been explicitly set.
  var hasRangeLocation: Bool {return self._rangeLocation != nil}
  /// Clears the value of `rangeLocation`. Subsequent reads from it will return its default value.
  mutating func clearRangeLocation() {self._rangeLocation = nil}

  var rangeLength: UInt32 {
    get {return _rangeLength ?? 0}
    set {_rangeLength = newValue}
  }
  /// Returns true if `rangeLength` has been explicitly set.
  var hasRangeLength: Bool {return self._rangeLength != nil}
  /// Clears the value of `rangeLength`. Subsequent reads from it will return its default value.
  mutating func clearRangeLength() {self._rangeLength = nil}

  var rangeUids: [TSP_UUID] = []

  var offset: UInt32 {
    get {return _offset ?? 0}
    set {_offset = newValue}
  }
  /// Returns true if `offset` has been explicitly set.
  var hasOffset: Bool {return self._offset != nil}
  /// Clears the value of `offset`. Subsequent reads from it will return its default value.
  mutating func clearOffset() {self._offset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rangeLocation: UInt32? = nil
  fileprivate var _rangeLength: UInt32? = nil
  fileprivate var _offset: UInt32? = nil
}

struct TSCE_ColumnOrRowUuidsInfoArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isRows: Bool {
    get {return _storage._isRows ?? false}
    set {_uniqueStorage()._isRows = newValue}
  }
  /// Returns true if `isRows` has been explicitly set.
  var hasIsRows: Bool {return _storage._isRows != nil}
  /// Clears the value of `isRows`. Subsequent reads from it will return its default value.
  mutating func clearIsRows() {_uniqueStorage()._isRows = nil}

  var tableUid: TSP_UUID {
    get {return _storage._tableUid ?? TSP_UUID()}
    set {_uniqueStorage()._tableUid = newValue}
  }
  /// Returns true if `tableUid` has been explicitly set.
  var hasTableUid: Bool {return _storage._tableUid != nil}
  /// Clears the value of `tableUid`. Subsequent reads from it will return its default value.
  mutating func clearTableUid() {_uniqueStorage()._tableUid = nil}

  var condStyleOwnerUid: TSP_UUID {
    get {return _storage._condStyleOwnerUid ?? TSP_UUID()}
    set {_uniqueStorage()._condStyleOwnerUid = newValue}
  }
  /// Returns true if `condStyleOwnerUid` has been explicitly set.
  var hasCondStyleOwnerUid: Bool {return _storage._condStyleOwnerUid != nil}
  /// Clears the value of `condStyleOwnerUid`. Subsequent reads from it will return its default value.
  mutating func clearCondStyleOwnerUid() {_uniqueStorage()._condStyleOwnerUid = nil}

  var groupByUid: TSP_UUID {
    get {return _storage._groupByUid ?? TSP_UUID()}
    set {_uniqueStorage()._groupByUid = newValue}
  }
  /// Returns true if `groupByUid` has been explicitly set.
  var hasGroupByUid: Bool {return _storage._groupByUid != nil}
  /// Clears the value of `groupByUid`. Subsequent reads from it will return its default value.
  mutating func clearGroupByUid() {_uniqueStorage()._groupByUid = nil}

  var uids: TSCE_IndexedUidsArchive {
    get {return _storage._uids ?? TSCE_IndexedUidsArchive()}
    set {_uniqueStorage()._uids = newValue}
  }
  /// Returns true if `uids` has been explicitly set.
  var hasUids: Bool {return _storage._uids != nil}
  /// Clears the value of `uids`. Subsequent reads from it will return its default value.
  mutating func clearUids() {_uniqueStorage()._uids = nil}

  var rangeEntries: [TSCE_RewriteRangeEntryArchive] {
    get {return _storage._rangeEntries}
    set {_uniqueStorage()._rangeEntries = newValue}
  }

  var tableRange: TSCE_RangeCoordinateArchive {
    get {return _storage._tableRange ?? TSCE_RangeCoordinateArchive()}
    set {_uniqueStorage()._tableRange = newValue}
  }
  /// Returns true if `tableRange` has been explicitly set.
  var hasTableRange: Bool {return _storage._tableRange != nil}
  /// Clears the value of `tableRange`. Subsequent reads from it will return its default value.
  mutating func clearTableRange() {_uniqueStorage()._tableRange = nil}

  var insertAtUid: TSP_UUID {
    get {return _storage._insertAtUid ?? TSP_UUID()}
    set {_uniqueStorage()._insertAtUid = newValue}
  }
  /// Returns true if `insertAtUid` has been explicitly set.
  var hasInsertAtUid: Bool {return _storage._insertAtUid != nil}
  /// Clears the value of `insertAtUid`. Subsequent reads from it will return its default value.
  mutating func clearInsertAtUid() {_uniqueStorage()._insertAtUid = nil}

  var insertOppositeUid: TSP_UUID {
    get {return _storage._insertOppositeUid ?? TSP_UUID()}
    set {_uniqueStorage()._insertOppositeUid = newValue}
  }
  /// Returns true if `insertOppositeUid` has been explicitly set.
  var hasInsertOppositeUid: Bool {return _storage._insertOppositeUid != nil}
  /// Clears the value of `insertOppositeUid`. Subsequent reads from it will return its default value.
  mutating func clearInsertOppositeUid() {_uniqueStorage()._insertOppositeUid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSCE_RegionInfoArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tableUid: TSP_UUID {
    get {return _tableUid ?? TSP_UUID()}
    set {_tableUid = newValue}
  }
  /// Returns true if `tableUid` has been explicitly set.
  var hasTableUid: Bool {return self._tableUid != nil}
  /// Clears the value of `tableUid`. Subsequent reads from it will return its default value.
  mutating func clearTableUid() {self._tableUid = nil}

  var columnUids: TSCE_IndexedUidsArchive {
    get {return _columnUids ?? TSCE_IndexedUidsArchive()}
    set {_columnUids = newValue}
  }
  /// Returns true if `columnUids` has been explicitly set.
  var hasColumnUids: Bool {return self._columnUids != nil}
  /// Clears the value of `columnUids`. Subsequent reads from it will return its default value.
  mutating func clearColumnUids() {self._columnUids = nil}

  var rowUids: TSCE_IndexedUidsArchive {
    get {return _rowUids ?? TSCE_IndexedUidsArchive()}
    set {_rowUids = newValue}
  }
  /// Returns true if `rowUids` has been explicitly set.
  var hasRowUids: Bool {return self._rowUids != nil}
  /// Clears the value of `rowUids`. Subsequent reads from it will return its default value.
  mutating func clearRowUids() {self._rowUids = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tableUid: TSP_UUID? = nil
  fileprivate var _columnUids: TSCE_IndexedUidsArchive? = nil
  fileprivate var _rowUids: TSCE_IndexedUidsArchive? = nil
}

struct TSCE_RegionMovedInfoArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var srcRegion: TSCE_RegionInfoArchive {
    get {return _srcRegion ?? TSCE_RegionInfoArchive()}
    set {_srcRegion = newValue}
  }
  /// Returns true if `srcRegion` has been explicitly set.
  var hasSrcRegion: Bool {return self._srcRegion != nil}
  /// Clears the value of `srcRegion`. Subsequent reads from it will return its default value.
  mutating func clearSrcRegion() {self._srcRegion = nil}

  var dstRegion: TSCE_RegionInfoArchive {
    get {return _dstRegion ?? TSCE_RegionInfoArchive()}
    set {_dstRegion = newValue}
  }
  /// Returns true if `dstRegion` has been explicitly set.
  var hasDstRegion: Bool {return self._dstRegion != nil}
  /// Clears the value of `dstRegion`. Subsequent reads from it will return its default value.
  mutating func clearDstRegion() {self._dstRegion = nil}

  var spanRows: Bool {
    get {return _spanRows ?? false}
    set {_spanRows = newValue}
  }
  /// Returns true if `spanRows` has been explicitly set.
  var hasSpanRows: Bool {return self._spanRows != nil}
  /// Clears the value of `spanRows`. Subsequent reads from it will return its default value.
  mutating func clearSpanRows() {self._spanRows = nil}

  var spanColumns: Bool {
    get {return _spanColumns ?? false}
    set {_spanColumns = newValue}
  }
  /// Returns true if `spanColumns` has been explicitly set.
  var hasSpanColumns: Bool {return self._spanColumns != nil}
  /// Clears the value of `spanColumns`. Subsequent reads from it will return its default value.
  mutating func clearSpanColumns() {self._spanColumns = nil}

  var originalSrcRegion: TSCE_RegionInfoArchive {
    get {return _originalSrcRegion ?? TSCE_RegionInfoArchive()}
    set {_originalSrcRegion = newValue}
  }
  /// Returns true if `originalSrcRegion` has been explicitly set.
  var hasOriginalSrcRegion: Bool {return self._originalSrcRegion != nil}
  /// Clears the value of `originalSrcRegion`. Subsequent reads from it will return its default value.
  mutating func clearOriginalSrcRegion() {self._originalSrcRegion = nil}

  var finalDestTableUid: TSP_UUID {
    get {return _finalDestTableUid ?? TSP_UUID()}
    set {_finalDestTableUid = newValue}
  }
  /// Returns true if `finalDestTableUid` has been explicitly set.
  var hasFinalDestTableUid: Bool {return self._finalDestTableUid != nil}
  /// Clears the value of `finalDestTableUid`. Subsequent reads from it will return its default value.
  mutating func clearFinalDestTableUid() {self._finalDestTableUid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _srcRegion: TSCE_RegionInfoArchive? = nil
  fileprivate var _dstRegion: TSCE_RegionInfoArchive? = nil
  fileprivate var _spanRows: Bool? = nil
  fileprivate var _spanColumns: Bool? = nil
  fileprivate var _originalSrcRegion: TSCE_RegionInfoArchive? = nil
  fileprivate var _finalDestTableUid: TSP_UUID? = nil
}

struct TSCE_MergeSourceArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var coordColumn: UInt32 {
    get {return _coordColumn ?? 0}
    set {_coordColumn = newValue}
  }
  /// Returns true if `coordColumn` has been explicitly set.
  var hasCoordColumn: Bool {return self._coordColumn != nil}
  /// Clears the value of `coordColumn`. Subsequent reads from it will return its default value.
  mutating func clearCoordColumn() {self._coordColumn = nil}

  var coordRow: UInt32 {
    get {return _coordRow ?? 0}
    set {_coordRow = newValue}
  }
  /// Returns true if `coordRow` has been explicitly set.
  var hasCoordRow: Bool {return self._coordRow != nil}
  /// Clears the value of `coordRow`. Subsequent reads from it will return its default value.
  mutating func clearCoordRow() {self._coordRow = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _coordColumn: UInt32? = nil
  fileprivate var _coordRow: UInt32? = nil
}

struct TSCE_HauntedOwnerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerUid: TSP_UUID {
    get {return _ownerUid ?? TSP_UUID()}
    set {_ownerUid = newValue}
  }
  /// Returns true if `ownerUid` has been explicitly set.
  var hasOwnerUid: Bool {return self._ownerUid != nil}
  /// Clears the value of `ownerUid`. Subsequent reads from it will return its default value.
  mutating func clearOwnerUid() {self._ownerUid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ownerUid: TSP_UUID? = nil
}

struct TSCE_SpillOwnerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerUid: TSP_UUID {
    get {return _ownerUid ?? TSP_UUID()}
    set {_ownerUid = newValue}
  }
  /// Returns true if `ownerUid` has been explicitly set.
  var hasOwnerUid: Bool {return self._ownerUid != nil}
  /// Clears the value of `ownerUid`. Subsequent reads from it will return its default value.
  mutating func clearOwnerUid() {self._ownerUid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ownerUid: TSP_UUID? = nil
}

struct TSCE_CellCoordinateArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var packedData: UInt32 {
    get {return _packedData ?? 0}
    set {_packedData = newValue}
  }
  /// Returns true if `packedData` has been explicitly set.
  var hasPackedData: Bool {return self._packedData != nil}
  /// Clears the value of `packedData`. Subsequent reads from it will return its default value.
  mutating func clearPackedData() {self._packedData = nil}

  var column: UInt32 {
    get {return _column ?? 0}
    set {_column = newValue}
  }
  /// Returns true if `column` has been explicitly set.
  var hasColumn: Bool {return self._column != nil}
  /// Clears the value of `column`. Subsequent reads from it will return its default value.
  mutating func clearColumn() {self._column = nil}

  var row: UInt32 {
    get {return _row ?? 0}
    set {_row = newValue}
  }
  /// Returns true if `row` has been explicitly set.
  var hasRow: Bool {return self._row != nil}
  /// Clears the value of `row`. Subsequent reads from it will return its default value.
  mutating func clearRow() {self._row = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _packedData: UInt32? = nil
  fileprivate var _column: UInt32? = nil
  fileprivate var _row: UInt32? = nil
}

struct TSCE_CellCoordinateVectorArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cellCoord: [TSCE_CellCoordinateArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSCE_ExpandedCellRefObjectPairArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cellRef: TSCE_CellReferenceArchive {
    get {return _cellRef ?? TSCE_CellReferenceArchive()}
    set {_cellRef = newValue}
  }
  /// Returns true if `cellRef` has been explicitly set.
  var hasCellRef: Bool {return self._cellRef != nil}
  /// Clears the value of `cellRef`. Subsequent reads from it will return its default value.
  mutating func clearCellRef() {self._cellRef = nil}

  var object: TSP_Reference {
    get {return _object ?? TSP_Reference()}
    set {_object = newValue}
  }
  /// Returns true if `object` has been explicitly set.
  var hasObject: Bool {return self._object != nil}
  /// Clears the value of `object`. Subsequent reads from it will return its default value.
  mutating func clearObject() {self._object = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cellRef: TSCE_CellReferenceArchive? = nil
  fileprivate var _object: TSP_Reference? = nil
}

struct TSCE_ExpandedCellRefObjectMapArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cellRefObjectPair: [TSCE_ExpandedCellRefObjectPairArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSCE_FormulaAtCoordArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var column: UInt32 {
    get {return _storage._column ?? 0}
    set {_uniqueStorage()._column = newValue}
  }
  /// Returns true if `column` has been explicitly set.
  var hasColumn: Bool {return _storage._column != nil}
  /// Clears the value of `column`. Subsequent reads from it will return its default value.
  mutating func clearColumn() {_uniqueStorage()._column = nil}

  var row: UInt32 {
    get {return _storage._row ?? 0}
    set {_uniqueStorage()._row = newValue}
  }
  /// Returns true if `row` has been explicitly set.
  var hasRow: Bool {return _storage._row != nil}
  /// Clears the value of `row`. Subsequent reads from it will return its default value.
  mutating func clearRow() {_uniqueStorage()._row = nil}

  var formula: TSCE_FormulaArchive {
    get {return _storage._formula ?? TSCE_FormulaArchive()}
    set {_uniqueStorage()._formula = newValue}
  }
  /// Returns true if `formula` has been explicitly set.
  var hasFormula: Bool {return _storage._formula != nil}
  /// Clears the value of `formula`. Subsequent reads from it will return its default value.
  mutating func clearFormula() {_uniqueStorage()._formula = nil}

  var repeatPreviousFormula: Bool {
    get {return _storage._repeatPreviousFormula ?? false}
    set {_uniqueStorage()._repeatPreviousFormula = newValue}
  }
  /// Returns true if `repeatPreviousFormula` has been explicitly set.
  var hasRepeatPreviousFormula: Bool {return _storage._repeatPreviousFormula != nil}
  /// Clears the value of `repeatPreviousFormula`. Subsequent reads from it will return its default value.
  mutating func clearRepeatPreviousFormula() {_uniqueStorage()._repeatPreviousFormula = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSCE_FormulaCoordPairsByOwnerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ownerKind: UInt32 {
    get {return _ownerKind ?? 0}
    set {_ownerKind = newValue}
  }
  /// Returns true if `ownerKind` has been explicitly set.
  var hasOwnerKind: Bool {return self._ownerKind != nil}
  /// Clears the value of `ownerKind`. Subsequent reads from it will return its default value.
  mutating func clearOwnerKind() {self._ownerKind = nil}

  var ownerUid: TSP_UUID {
    get {return _ownerUid ?? TSP_UUID()}
    set {_ownerUid = newValue}
  }
  /// Returns true if `ownerUid` has been explicitly set.
  var hasOwnerUid: Bool {return self._ownerUid != nil}
  /// Clears the value of `ownerUid`. Subsequent reads from it will return its default value.
  mutating func clearOwnerUid() {self._ownerUid = nil}

  var formulaAtCoords: [TSCE_FormulaAtCoordArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ownerKind: UInt32? = nil
  fileprivate var _ownerUid: TSP_UUID? = nil
}

struct TSCE_FormulasForUndoArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var formulasForOwner: [TSCE_FormulaCoordPairsByOwnerArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSCE_FormulaRewriteCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tableRewriteCommand: TSP_Reference {
    get {return _tableRewriteCommand ?? TSP_Reference()}
    set {_tableRewriteCommand = newValue}
  }
  /// Returns true if `tableRewriteCommand` has been explicitly set.
  var hasTableRewriteCommand: Bool {return self._tableRewriteCommand != nil}
  /// Clears the value of `tableRewriteCommand`. Subsequent reads from it will return its default value.
  mutating func clearTableRewriteCommand() {self._tableRewriteCommand = nil}

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tableRewriteCommand: TSP_Reference? = nil
  fileprivate var _super: TSK_CommandArchive? = nil
}

struct TSCE_TrackedReferenceArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ast: TSCE_ASTNodeArrayArchive {
    get {return _ast ?? TSCE_ASTNodeArrayArchive()}
    set {_ast = newValue}
  }
  /// Returns true if `ast` has been explicitly set.
  var hasAst: Bool {return self._ast != nil}
  /// Clears the value of `ast`. Subsequent reads from it will return its default value.
  mutating func clearAst() {self._ast = nil}

  var formulaID: UInt32 {
    get {return _formulaID ?? 0}
    set {_formulaID = newValue}
  }
  /// Returns true if `formulaID` has been explicitly set.
  var hasFormulaID: Bool {return self._formulaID != nil}
  /// Clears the value of `formulaID`. Subsequent reads from it will return its default value.
  mutating func clearFormulaID() {self._formulaID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ast: TSCE_ASTNodeArrayArchive? = nil
  fileprivate var _formulaID: UInt32? = nil
}

struct TSCE_ExpandedTrackedReferenceArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ast: TSCE_ASTNodeArrayArchive {
    get {return _ast ?? TSCE_ASTNodeArrayArchive()}
    set {_ast = newValue}
  }
  /// Returns true if `ast` has been explicitly set.
  var hasAst: Bool {return self._ast != nil}
  /// Clears the value of `ast`. Subsequent reads from it will return its default value.
  mutating func clearAst() {self._ast = nil}

  var formulaColumn: UInt32 {
    get {return _formulaColumn ?? 0}
    set {_formulaColumn = newValue}
  }
  /// Returns true if `formulaColumn` has been explicitly set.
  var hasFormulaColumn: Bool {return self._formulaColumn != nil}
  /// Clears the value of `formulaColumn`. Subsequent reads from it will return its default value.
  mutating func clearFormulaColumn() {self._formulaColumn = nil}

  var formulaRow: UInt32 {
    get {return _formulaRow ?? 0}
    set {_formulaRow = newValue}
  }
  /// Returns true if `formulaRow` has been explicitly set.
  var hasFormulaRow: Bool {return self._formulaRow != nil}
  /// Clears the value of `formulaRow`. Subsequent reads from it will return its default value.
  mutating func clearFormulaRow() {self._formulaRow = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ast: TSCE_ASTNodeArrayArchive? = nil
  fileprivate var _formulaColumn: UInt32? = nil
  fileprivate var _formulaRow: UInt32? = nil
}

struct TSCE_TrackedReferenceStoreArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: TSP_CFUUIDArchive {
    get {return _uuid ?? TSP_CFUUIDArchive()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {self._uuid = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var trackedReference: [TSP_Reference] = []

  var containedTrackedReference: [TSCE_TrackedReferenceArchive] = []

  var containedExpandedTrackedReference: [TSCE_ExpandedTrackedReferenceArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _uuid: TSP_CFUUIDArchive? = nil
}

struct TSCE_ViewTractRefArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tableUid: TSP_UUID {
    get {return _tableUid ?? TSP_UUID()}
    set {_tableUid = newValue}
  }
  /// Returns true if `tableUid` has been explicitly set.
  var hasTableUid: Bool {return self._tableUid != nil}
  /// Clears the value of `tableUid`. Subsequent reads from it will return its default value.
  mutating func clearTableUid() {self._tableUid = nil}

  var uidTract: TSCE_ASTNodeArrayArchive.ASTUidTract {
    get {return _uidTract ?? TSCE_ASTNodeArrayArchive.ASTUidTract()}
    set {_uidTract = newValue}
  }
  /// Returns true if `uidTract` has been explicitly set.
  var hasUidTract: Bool {return self._uidTract != nil}
  /// Clears the value of `uidTract`. Subsequent reads from it will return its default value.
  mutating func clearUidTract() {self._uidTract = nil}

  var preserveFlags: TSCE_PreserveColumnRowFlagsArchive {
    get {return _preserveFlags ?? TSCE_PreserveColumnRowFlagsArchive()}
    set {_preserveFlags = newValue}
  }
  /// Returns true if `preserveFlags` has been explicitly set.
  var hasPreserveFlags: Bool {return self._preserveFlags != nil}
  /// Clears the value of `preserveFlags`. Subsequent reads from it will return its default value.
  mutating func clearPreserveFlags() {self._preserveFlags = nil}

  var aggIndexLevel: UInt32 {
    get {return _aggIndexLevel ?? 0}
    set {_aggIndexLevel = newValue}
  }
  /// Returns true if `aggIndexLevel` has been explicitly set.
  var hasAggIndexLevel: Bool {return self._aggIndexLevel != nil}
  /// Clears the value of `aggIndexLevel`. Subsequent reads from it will return its default value.
  mutating func clearAggIndexLevel() {self._aggIndexLevel = nil}

  var columnGroupLevel: Int32 {
    get {return _columnGroupLevel ?? 0}
    set {_columnGroupLevel = newValue}
  }
  /// Returns true if `columnGroupLevel` has been explicitly set.
  var hasColumnGroupLevel: Bool {return self._columnGroupLevel != nil}
  /// Clears the value of `columnGroupLevel`. Subsequent reads from it will return its default value.
  mutating func clearColumnGroupLevel() {self._columnGroupLevel = nil}

  var rowGroupLevel: Int32 {
    get {return _rowGroupLevel ?? 0}
    set {_rowGroupLevel = newValue}
  }
  /// Returns true if `rowGroupLevel` has been explicitly set.
  var hasRowGroupLevel: Bool {return self._rowGroupLevel != nil}
  /// Clears the value of `rowGroupLevel`. Subsequent reads from it will return its default value.
  mutating func clearRowGroupLevel() {self._rowGroupLevel = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tableUid: TSP_UUID? = nil
  fileprivate var _uidTract: TSCE_ASTNodeArrayArchive.ASTUidTract? = nil
  fileprivate var _preserveFlags: TSCE_PreserveColumnRowFlagsArchive? = nil
  fileprivate var _aggIndexLevel: UInt32? = nil
  fileprivate var _columnGroupLevel: Int32? = nil
  fileprivate var _rowGroupLevel: Int32? = nil
}

struct TSCE_BooleanCellValueArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Bool {
    get {return _value ?? false}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var format: TSK_FormatStructArchive {
    get {return _format ?? TSK_FormatStructArchive()}
    set {_format = newValue}
  }
  /// Returns true if `format` has been explicitly set.
  var hasFormat: Bool {return self._format != nil}
  /// Clears the value of `format`. Subsequent reads from it will return its default value.
  mutating func clearFormat() {self._format = nil}

  var formatIsExplicit: Bool {
    get {return _formatIsExplicit ?? false}
    set {_formatIsExplicit = newValue}
  }
  /// Returns true if `formatIsExplicit` has been explicitly set.
  var hasFormatIsExplicit: Bool {return self._formatIsExplicit != nil}
  /// Clears the value of `formatIsExplicit`. Subsequent reads from it will return its default value.
  mutating func clearFormatIsExplicit() {self._formatIsExplicit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: Bool? = nil
  fileprivate var _format: TSK_FormatStructArchive? = nil
  fileprivate var _formatIsExplicit: Bool? = nil
}

struct TSCE_DateCellValueArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Double {
    get {return _value ?? 0}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var format: TSK_FormatStructArchive {
    get {return _format ?? TSK_FormatStructArchive()}
    set {_format = newValue}
  }
  /// Returns true if `format` has been explicitly set.
  var hasFormat: Bool {return self._format != nil}
  /// Clears the value of `format`. Subsequent reads from it will return its default value.
  mutating func clearFormat() {self._format = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var formatIsImplicit: Bool {
    get {return _formatIsImplicit ?? false}
    set {_formatIsImplicit = newValue}
  }
  /// Returns true if `formatIsImplicit` has been explicitly set.
  var hasFormatIsImplicit: Bool {return self._formatIsImplicit != nil}
  /// Clears the value of `formatIsImplicit`. Subsequent reads from it will return its default value.
  mutating func clearFormatIsImplicit() {self._formatIsImplicit = nil}

  var formatIsExplicit: Bool {
    get {return _formatIsExplicit ?? false}
    set {_formatIsExplicit = newValue}
  }
  /// Returns true if `formatIsExplicit` has been explicitly set.
  var hasFormatIsExplicit: Bool {return self._formatIsExplicit != nil}
  /// Clears the value of `formatIsExplicit`. Subsequent reads from it will return its default value.
  mutating func clearFormatIsExplicit() {self._formatIsExplicit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: Double? = nil
  fileprivate var _format: TSK_FormatStructArchive? = nil
  fileprivate var _formatIsImplicit: Bool? = nil
  fileprivate var _formatIsExplicit: Bool? = nil
}

struct TSCE_NumberCellValueArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Double {
    get {return _value ?? 0}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unitIndex: Int32 {
    get {return _unitIndex ?? 0}
    set {_unitIndex = newValue}
  }
  /// Returns true if `unitIndex` has been explicitly set.
  var hasUnitIndex: Bool {return self._unitIndex != nil}
  /// Clears the value of `unitIndex`. Subsequent reads from it will return its default value.
  mutating func clearUnitIndex() {self._unitIndex = nil}

  var currencyCode: String {
    get {return _currencyCode ?? String()}
    set {_currencyCode = newValue}
  }
  /// Returns true if `currencyCode` has been explicitly set.
  var hasCurrencyCode: Bool {return self._currencyCode != nil}
  /// Clears the value of `currencyCode`. Subsequent reads from it will return its default value.
  mutating func clearCurrencyCode() {self._currencyCode = nil}

  var format: TSK_FormatStructArchive {
    get {return _format ?? TSK_FormatStructArchive()}
    set {_format = newValue}
  }
  /// Returns true if `format` has been explicitly set.
  var hasFormat: Bool {return self._format != nil}
  /// Clears the value of `format`. Subsequent reads from it will return its default value.
  mutating func clearFormat() {self._format = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var formatIsImplicit: Bool {
    get {return _formatIsImplicit ?? false}
    set {_formatIsImplicit = newValue}
  }
  /// Returns true if `formatIsImplicit` has been explicitly set.
  var hasFormatIsImplicit: Bool {return self._formatIsImplicit != nil}
  /// Clears the value of `formatIsImplicit`. Subsequent reads from it will return its default value.
  mutating func clearFormatIsImplicit() {self._formatIsImplicit = nil}

  var formatIsExplicit: Bool {
    get {return _formatIsExplicit ?? false}
    set {_formatIsExplicit = newValue}
  }
  /// Returns true if `formatIsExplicit` has been explicitly set.
  var hasFormatIsExplicit: Bool {return self._formatIsExplicit != nil}
  /// Clears the value of `formatIsExplicit`. Subsequent reads from it will return its default value.
  mutating func clearFormatIsExplicit() {self._formatIsExplicit = nil}

  var decimalLow: UInt64 {
    get {return _decimalLow ?? 0}
    set {_decimalLow = newValue}
  }
  /// Returns true if `decimalLow` has been explicitly set.
  var hasDecimalLow: Bool {return self._decimalLow != nil}
  /// Clears the value of `decimalLow`. Subsequent reads from it will return its default value.
  mutating func clearDecimalLow() {self._decimalLow = nil}

  var decimalHigh: UInt64 {
    get {return _decimalHigh ?? 0}
    set {_decimalHigh = newValue}
  }
  /// Returns true if `decimalHigh` has been explicitly set.
  var hasDecimalHigh: Bool {return self._decimalHigh != nil}
  /// Clears the value of `decimalHigh`. Subsequent reads from it will return its default value.
  mutating func clearDecimalHigh() {self._decimalHigh = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: Double? = nil
  fileprivate var _unitIndex: Int32? = nil
  fileprivate var _currencyCode: String? = nil
  fileprivate var _format: TSK_FormatStructArchive? = nil
  fileprivate var _formatIsImplicit: Bool? = nil
  fileprivate var _formatIsExplicit: Bool? = nil
  fileprivate var _decimalLow: UInt64? = nil
  fileprivate var _decimalHigh: UInt64? = nil
}

struct TSCE_StringCellValueArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var format: TSK_FormatStructArchive {
    get {return _format ?? TSK_FormatStructArchive()}
    set {_format = newValue}
  }
  /// Returns true if `format` has been explicitly set.
  var hasFormat: Bool {return self._format != nil}
  /// Clears the value of `format`. Subsequent reads from it will return its default value.
  mutating func clearFormat() {self._format = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var formatIsImplicit: Bool {
    get {return _formatIsImplicit ?? false}
    set {_formatIsImplicit = newValue}
  }
  /// Returns true if `formatIsImplicit` has been explicitly set.
  var hasFormatIsImplicit: Bool {return self._formatIsImplicit != nil}
  /// Clears the value of `formatIsImplicit`. Subsequent reads from it will return its default value.
  mutating func clearFormatIsImplicit() {self._formatIsImplicit = nil}

  var formatIsExplicit: Bool {
    get {return _formatIsExplicit ?? false}
    set {_formatIsExplicit = newValue}
  }
  /// Returns true if `formatIsExplicit` has been explicitly set.
  var hasFormatIsExplicit: Bool {return self._formatIsExplicit != nil}
  /// Clears the value of `formatIsExplicit`. Subsequent reads from it will return its default value.
  mutating func clearFormatIsExplicit() {self._formatIsExplicit = nil}

  var isRegex: Bool {
    get {return _isRegex ?? false}
    set {_isRegex = newValue}
  }
  /// Returns true if `isRegex` has been explicitly set.
  var hasIsRegex: Bool {return self._isRegex != nil}
  /// Clears the value of `isRegex`. Subsequent reads from it will return its default value.
  mutating func clearIsRegex() {self._isRegex = nil}

  var isCaseSensitiveRegex: Bool {
    get {return _isCaseSensitiveRegex ?? false}
    set {_isCaseSensitiveRegex = newValue}
  }
  /// Returns true if `isCaseSensitiveRegex` has been explicitly set.
  var hasIsCaseSensitiveRegex: Bool {return self._isCaseSensitiveRegex != nil}
  /// Clears the value of `isCaseSensitiveRegex`. Subsequent reads from it will return its default value.
  mutating func clearIsCaseSensitiveRegex() {self._isCaseSensitiveRegex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: String? = nil
  fileprivate var _format: TSK_FormatStructArchive? = nil
  fileprivate var _formatIsImplicit: Bool? = nil
  fileprivate var _formatIsExplicit: Bool? = nil
  fileprivate var _isRegex: Bool? = nil
  fileprivate var _isCaseSensitiveRegex: Bool? = nil
}

struct TSCE_ErrorCellValueArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorType: Int32 {
    get {return _errorType ?? 0}
    set {_errorType = newValue}
  }
  /// Returns true if `errorType` has been explicitly set.
  var hasErrorType: Bool {return self._errorType != nil}
  /// Clears the value of `errorType`. Subsequent reads from it will return its default value.
  mutating func clearErrorType() {self._errorType = nil}

  var extraInfoInt: Int32 {
    get {return _extraInfoInt ?? 0}
    set {_extraInfoInt = newValue}
  }
  /// Returns true if `extraInfoInt` has been explicitly set.
  var hasExtraInfoInt: Bool {return self._extraInfoInt != nil}
  /// Clears the value of `extraInfoInt`. Subsequent reads from it will return its default value.
  mutating func clearExtraInfoInt() {self._extraInfoInt = nil}

  var extraInfoString: String {
    get {return _extraInfoString ?? String()}
    set {_extraInfoString = newValue}
  }
  /// Returns true if `extraInfoString` has been explicitly set.
  var hasExtraInfoString: Bool {return self._extraInfoString != nil}
  /// Clears the value of `extraInfoString`. Subsequent reads from it will return its default value.
  mutating func clearExtraInfoString() {self._extraInfoString = nil}

  var extraInfoDouble: Double {
    get {return _extraInfoDouble ?? 0}
    set {_extraInfoDouble = newValue}
  }
  /// Returns true if `extraInfoDouble` has been explicitly set.
  var hasExtraInfoDouble: Bool {return self._extraInfoDouble != nil}
  /// Clears the value of `extraInfoDouble`. Subsequent reads from it will return its default value.
  mutating func clearExtraInfoDouble() {self._extraInfoDouble = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _errorType: Int32? = nil
  fileprivate var _extraInfoInt: Int32? = nil
  fileprivate var _extraInfoString: String? = nil
  fileprivate var _extraInfoDouble: Double? = nil
}

struct TSCE_CellValueArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cellValueType: TSCE_CellValueArchive.CellValueType {
    get {return _storage._cellValueType ?? .nilType}
    set {_uniqueStorage()._cellValueType = newValue}
  }
  /// Returns true if `cellValueType` has been explicitly set.
  var hasCellValueType: Bool {return _storage._cellValueType != nil}
  /// Clears the value of `cellValueType`. Subsequent reads from it will return its default value.
  mutating func clearCellValueType() {_uniqueStorage()._cellValueType = nil}

  var booleanValue: TSCE_BooleanCellValueArchive {
    get {return _storage._booleanValue ?? TSCE_BooleanCellValueArchive()}
    set {_uniqueStorage()._booleanValue = newValue}
  }
  /// Returns true if `booleanValue` has been explicitly set.
  var hasBooleanValue: Bool {return _storage._booleanValue != nil}
  /// Clears the value of `booleanValue`. Subsequent reads from it will return its default value.
  mutating func clearBooleanValue() {_uniqueStorage()._booleanValue = nil}

  var dateValue: TSCE_DateCellValueArchive {
    get {return _storage._dateValue ?? TSCE_DateCellValueArchive()}
    set {_uniqueStorage()._dateValue = newValue}
  }
  /// Returns true if `dateValue` has been explicitly set.
  var hasDateValue: Bool {return _storage._dateValue != nil}
  /// Clears the value of `dateValue`. Subsequent reads from it will return its default value.
  mutating func clearDateValue() {_uniqueStorage()._dateValue = nil}

  var numberValue: TSCE_NumberCellValueArchive {
    get {return _storage._numberValue ?? TSCE_NumberCellValueArchive()}
    set {_uniqueStorage()._numberValue = newValue}
  }
  /// Returns true if `numberValue` has been explicitly set.
  var hasNumberValue: Bool {return _storage._numberValue != nil}
  /// Clears the value of `numberValue`. Subsequent reads from it will return its default value.
  mutating func clearNumberValue() {_uniqueStorage()._numberValue = nil}

  var stringValue: TSCE_StringCellValueArchive {
    get {return _storage._stringValue ?? TSCE_StringCellValueArchive()}
    set {_uniqueStorage()._stringValue = newValue}
  }
  /// Returns true if `stringValue` has been explicitly set.
  var hasStringValue: Bool {return _storage._stringValue != nil}
  /// Clears the value of `stringValue`. Subsequent reads from it will return its default value.
  mutating func clearStringValue() {_uniqueStorage()._stringValue = nil}

  var errorValue: TSCE_ErrorCellValueArchive {
    get {return _storage._errorValue ?? TSCE_ErrorCellValueArchive()}
    set {_uniqueStorage()._errorValue = newValue}
  }
  /// Returns true if `errorValue` has been explicitly set.
  var hasErrorValue: Bool {return _storage._errorValue != nil}
  /// Clears the value of `errorValue`. Subsequent reads from it will return its default value.
  mutating func clearErrorValue() {_uniqueStorage()._errorValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum CellValueType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case nilType = 1
    case booleanType = 2
    case dateType = 3
    case numberType = 4
    case stringType = 5

    init() {
      self = .nilType
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TSCE"

extension TSCE_CellReferenceArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellReferenceArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}column\0\u{1}row\0\u{3}table_id\0")

  public var isInitialized: Bool {
    if self._column == nil {return false}
    if self._row == nil {return false}
    if self._tableID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._column) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._row) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tableID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._column {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._row {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._tableID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CellReferenceArchive, rhs: TSCE_CellReferenceArchive) -> Bool {
    if lhs._column != rhs._column {return false}
    if lhs._row != rhs._row {return false}
    if lhs._tableID != rhs._tableID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_InternalCellReferenceArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InternalCellReferenceArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}coordinate\0\u{3}owner_id\0")

  public var isInitialized: Bool {
    if self._coordinate == nil {return false}
    if self._ownerID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coordinate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._ownerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coordinate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ownerID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_InternalCellReferenceArchive, rhs: TSCE_InternalCellReferenceArchive) -> Bool {
    if lhs._coordinate != rhs._coordinate {return false}
    if lhs._ownerID != rhs._ownerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RelativeCellRefArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RelativeCellRefArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}relative_row_offset\0\u{3}relative_column_offset\0\u{3}table_uid\0\u{3}preserve_column\0\u{3}preserve_row\0\u{3}is_spanning_column\0\u{3}is_spanning_row\0")

  public var isInitialized: Bool {
    if let v = self._tableUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._relativeRowOffset) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._relativeColumnOffset) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tableUid) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._preserveColumn) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._preserveRow) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._isSpanningColumn) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._isSpanningRow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._relativeRowOffset {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._relativeColumnOffset {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._tableUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._preserveColumn {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._preserveRow {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._isSpanningColumn {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._isSpanningRow {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RelativeCellRefArchive, rhs: TSCE_RelativeCellRefArchive) -> Bool {
    if lhs._relativeRowOffset != rhs._relativeRowOffset {return false}
    if lhs._relativeColumnOffset != rhs._relativeColumnOffset {return false}
    if lhs._tableUid != rhs._tableUid {return false}
    if lhs._preserveColumn != rhs._preserveColumn {return false}
    if lhs._preserveRow != rhs._preserveRow {return false}
    if lhs._isSpanningColumn != rhs._isSpanningColumn {return false}
    if lhs._isSpanningRow != rhs._isSpanningRow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RangeReferenceArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RangeReferenceArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}table_id\0\u{3}top_left_column\0\u{3}top_left_row\0\u{3}bottom_right_column\0\u{3}bottom_right_row\0")

  public var isInitialized: Bool {
    if self._tableID == nil {return false}
    if self._topLeftColumn == nil {return false}
    if self._topLeftRow == nil {return false}
    if self._bottomRightColumn == nil {return false}
    if self._bottomRightRow == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tableID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._topLeftColumn) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._topLeftRow) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._bottomRightColumn) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._bottomRightRow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tableID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._topLeftColumn {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._topLeftRow {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._bottomRightColumn {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._bottomRightRow {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RangeReferenceArchive, rhs: TSCE_RangeReferenceArchive) -> Bool {
    if lhs._tableID != rhs._tableID {return false}
    if lhs._topLeftColumn != rhs._topLeftColumn {return false}
    if lhs._topLeftRow != rhs._topLeftRow {return false}
    if lhs._bottomRightColumn != rhs._bottomRightColumn {return false}
    if lhs._bottomRightRow != rhs._bottomRightRow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_InternalRangeReferenceArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InternalRangeReferenceArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}owner_id\0\u{1}range\0")

  public var isInitialized: Bool {
    if self._ownerID == nil {return false}
    if self._range == nil {return false}
    if let v = self._range, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._ownerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._range) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownerID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._range {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_InternalRangeReferenceArchive, rhs: TSCE_InternalRangeReferenceArchive) -> Bool {
    if lhs._ownerID != rhs._ownerID {return false}
    if lhs._range != rhs._range {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_IndexSetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IndexSetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}entries\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.entries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_IndexSetArchive, rhs: TSCE_IndexSetArchive) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_IndexSetArchive.IndexSetEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_IndexSetArchive.protoMessageName + ".IndexSetEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}range_begin\0\u{3}range_end\0")

  public var isInitialized: Bool {
    if self._rangeBegin == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._rangeBegin) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._rangeEnd) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rangeBegin {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rangeEnd {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_IndexSetArchive.IndexSetEntry, rhs: TSCE_IndexSetArchive.IndexSetEntry) -> Bool {
    if lhs._rangeBegin != rhs._rangeBegin {return false}
    if lhs._rangeEnd != rhs._rangeEnd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CellCoordSetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellCoordSetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}column_entries\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.columnEntries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.columnEntries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.columnEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.columnEntries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CellCoordSetArchive, rhs: TSCE_CellCoordSetArchive) -> Bool {
    if lhs.columnEntries != rhs.columnEntries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CellCoordSetArchive.ColumnEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_CellCoordSetArchive.protoMessageName + ".ColumnEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}column\0\u{3}row_set\0")

  public var isInitialized: Bool {
    if self._column == nil {return false}
    if self._rowSet == nil {return false}
    if let v = self._rowSet, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._column) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rowSet) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._column {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rowSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CellCoordSetArchive.ColumnEntry, rhs: TSCE_CellCoordSetArchive.ColumnEntry) -> Bool {
    if lhs._column != rhs._column {return false}
    if lhs._rowSet != rhs._rowSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_InternalCellRefSetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InternalCellRefSetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}owner_entries\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.ownerEntries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ownerEntries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ownerEntries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_InternalCellRefSetArchive, rhs: TSCE_InternalCellRefSetArchive) -> Bool {
    if lhs.ownerEntries != rhs.ownerEntries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_InternalCellRefSetArchive.OwnerEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_InternalCellRefSetArchive.protoMessageName + ".OwnerEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}owner_id\0\u{3}coord_set\0")

  public var isInitialized: Bool {
    if self._ownerID == nil {return false}
    if self._coordSet == nil {return false}
    if let v = self._coordSet, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._ownerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._coordSet) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownerID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._coordSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_InternalCellRefSetArchive.OwnerEntry, rhs: TSCE_InternalCellRefSetArchive.OwnerEntry) -> Bool {
    if lhs._ownerID != rhs._ownerID {return false}
    if lhs._coordSet != rhs._coordSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ColumnRowSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ColumnRowSize"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}num_columns\0\u{3}num_rows\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._numColumns) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._numRows) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._numColumns {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._numRows {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ColumnRowSize, rhs: TSCE_ColumnRowSize) -> Bool {
    if lhs._numColumns != rhs._numColumns {return false}
    if lhs._numRows != rhs._numRows {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CellRectArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellRectArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}origin\0\u{1}size\0")

  public var isInitialized: Bool {
    if self._origin == nil {return false}
    if self._size == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CellRectArchive, rhs: TSCE_CellRectArchive) -> Bool {
    if lhs._origin != rhs._origin {return false}
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CellRefSetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellRefSetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}owner_entries\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.ownerEntries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ownerEntries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ownerEntries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CellRefSetArchive, rhs: TSCE_CellRefSetArchive) -> Bool {
    if lhs.ownerEntries != rhs.ownerEntries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CellRefSetArchive.OwnerEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_CellRefSetArchive.protoMessageName + ".OwnerEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}owner_uid\0\u{3}coord_set\0")

  public var isInitialized: Bool {
    if self._ownerUid == nil {return false}
    if self._coordSet == nil {return false}
    if let v = self._ownerUid, !v.isInitialized {return false}
    if let v = self._coordSet, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ownerUid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._coordSet) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownerUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._coordSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CellRefSetArchive.OwnerEntry, rhs: TSCE_CellRefSetArchive.OwnerEntry) -> Bool {
    if lhs._ownerUid != rhs._ownerUid {return false}
    if lhs._coordSet != rhs._coordSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_UidCoordSetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UidCoordSetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}column_entries\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.columnEntries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.columnEntries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.columnEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.columnEntries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_UidCoordSetArchive, rhs: TSCE_UidCoordSetArchive) -> Bool {
    if lhs.columnEntries != rhs.columnEntries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_UidCoordSetArchive.ColumnEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_UidCoordSetArchive.protoMessageName + ".ColumnEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}column\0\u{3}row_set\0")

  public var isInitialized: Bool {
    if self._column == nil {return false}
    if let v = self._column, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rowSet) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._column) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rowSet) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._column {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.rowSet.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rowSet, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_UidCoordSetArchive.ColumnEntry, rhs: TSCE_UidCoordSetArchive.ColumnEntry) -> Bool {
    if lhs._column != rhs._column {return false}
    if lhs.rowSet != rhs.rowSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_UidCellRefSetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UidCellRefSetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}owner_entries\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.ownerEntries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ownerEntries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ownerEntries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_UidCellRefSetArchive, rhs: TSCE_UidCellRefSetArchive) -> Bool {
    if lhs.ownerEntries != rhs.ownerEntries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_UidCellRefSetArchive.OwnerEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_UidCellRefSetArchive.protoMessageName + ".OwnerEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}owner_uid\0\u{3}coord_set\0")

  public var isInitialized: Bool {
    if self._ownerUid == nil {return false}
    if self._coordSet == nil {return false}
    if let v = self._ownerUid, !v.isInitialized {return false}
    if let v = self._coordSet, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ownerUid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._coordSet) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownerUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._coordSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_UidCellRefSetArchive.OwnerEntry, rhs: TSCE_UidCellRefSetArchive.OwnerEntry) -> Bool {
    if lhs._ownerUid != rhs._ownerUid {return false}
    if lhs._coordSet != rhs._coordSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ReferencesToDirtyArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReferencesToDirtyArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}to_dirty_owner_ids\0\u{3}to_dirty_cells\0\u{3}to_dirty_cells_additional\0\u{3}to_dirty_range_refs\0\u{4}\u{2}calc_in_progress_cells\0\u{3}to_update_precedents_cells\0")

  public var isInitialized: Bool {
    if let v = self._toDirtyOwnerIds, !v.isInitialized {return false}
    if let v = self._toDirtyCells, !v.isInitialized {return false}
    if let v = self._toDirtyCellsAdditional, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.toDirtyRangeRefs) {return false}
    if let v = self._calcInProgressCells, !v.isInitialized {return false}
    if let v = self._toUpdatePrecedentsCells, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._toDirtyOwnerIds) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._toDirtyCells) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._toDirtyCellsAdditional) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.toDirtyRangeRefs) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._calcInProgressCells) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._toUpdatePrecedentsCells) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._toDirtyOwnerIds {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._toDirtyCells {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._toDirtyCellsAdditional {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.toDirtyRangeRefs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.toDirtyRangeRefs, fieldNumber: 4)
    }
    try { if let v = self._calcInProgressCells {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._toUpdatePrecedentsCells {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ReferencesToDirtyArchive, rhs: TSCE_ReferencesToDirtyArchive) -> Bool {
    if lhs._toDirtyOwnerIds != rhs._toDirtyOwnerIds {return false}
    if lhs._toDirtyCells != rhs._toDirtyCells {return false}
    if lhs._toDirtyCellsAdditional != rhs._toDirtyCellsAdditional {return false}
    if lhs.toDirtyRangeRefs != rhs.toDirtyRangeRefs {return false}
    if lhs._calcInProgressCells != rhs._calcInProgressCells {return false}
    if lhs._toUpdatePrecedentsCells != rhs._toUpdatePrecedentsCells {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CoordMapperArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CoordMapperArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}table_uid\0\u{3}summary_rows_set\0\u{3}summary_columns_set\0\u{3}label_rows_set\0\u{3}base_to_view_row_map\0\u{3}base_to_view_column_map\0\u{3}summary_to_view_row_map\0\u{3}summary_to_view_column_map\0")

  public var isInitialized: Bool {
    if self._tableUid == nil {return false}
    if let v = self._tableUid, !v.isInitialized {return false}
    if let v = self._summaryRowsSet, !v.isInitialized {return false}
    if let v = self._summaryColumnsSet, !v.isInitialized {return false}
    if let v = self._labelRowsSet, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.baseToViewRowMap) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.baseToViewColumnMap) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.summaryToViewRowMap) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.summaryToViewColumnMap) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tableUid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._summaryRowsSet) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._summaryColumnsSet) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._labelRowsSet) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.baseToViewRowMap) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.baseToViewColumnMap) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.summaryToViewRowMap) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.summaryToViewColumnMap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tableUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._summaryRowsSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._summaryColumnsSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._labelRowsSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.baseToViewRowMap.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.baseToViewRowMap, fieldNumber: 5)
    }
    if !self.baseToViewColumnMap.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.baseToViewColumnMap, fieldNumber: 6)
    }
    if !self.summaryToViewRowMap.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.summaryToViewRowMap, fieldNumber: 7)
    }
    if !self.summaryToViewColumnMap.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.summaryToViewColumnMap, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CoordMapperArchive, rhs: TSCE_CoordMapperArchive) -> Bool {
    if lhs._tableUid != rhs._tableUid {return false}
    if lhs._summaryRowsSet != rhs._summaryRowsSet {return false}
    if lhs._summaryColumnsSet != rhs._summaryColumnsSet {return false}
    if lhs._labelRowsSet != rhs._labelRowsSet {return false}
    if lhs.baseToViewRowMap != rhs.baseToViewRowMap {return false}
    if lhs.baseToViewColumnMap != rhs.baseToViewColumnMap {return false}
    if lhs.summaryToViewRowMap != rhs.summaryToViewRowMap {return false}
    if lhs.summaryToViewColumnMap != rhs.summaryToViewColumnMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CoordMapperArchive.BaseToViewEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_CoordMapperArchive.protoMessageName + ".BaseToViewEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}base_column_or_row\0\u{3}view_column_or_row\0")

  public var isInitialized: Bool {
    if self._baseColumnOrRow == nil {return false}
    if self._viewColumnOrRow == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._baseColumnOrRow) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._viewColumnOrRow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseColumnOrRow {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._viewColumnOrRow {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CoordMapperArchive.BaseToViewEntry, rhs: TSCE_CoordMapperArchive.BaseToViewEntry) -> Bool {
    if lhs._baseColumnOrRow != rhs._baseColumnOrRow {return false}
    if lhs._viewColumnOrRow != rhs._viewColumnOrRow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CoordMapperArchive.SummaryToViewEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_CoordMapperArchive.protoMessageName + ".SummaryToViewEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}summary_column_or_row\0\u{3}view_column_or_row\0")

  public var isInitialized: Bool {
    if self._summaryColumnOrRow == nil {return false}
    if self._viewColumnOrRow == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._summaryColumnOrRow) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._viewColumnOrRow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._summaryColumnOrRow {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._viewColumnOrRow {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CoordMapperArchive.SummaryToViewEntry, rhs: TSCE_CoordMapperArchive.SummaryToViewEntry) -> Bool {
    if lhs._summaryColumnOrRow != rhs._summaryColumnOrRow {return false}
    if lhs._viewColumnOrRow != rhs._viewColumnOrRow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ReferenceArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReferenceArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}reference_type\0\u{3}cell_reference\0\u{3}range_reference\0")

  fileprivate class _StorageClass {
    var _referenceType: TSCE_ReferenceArchive.ReferenceType? = nil
    var _cellReference: TSCE_CellReferenceArchive? = nil
    var _rangeReference: TSCE_RangeReferenceArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _referenceType = source._referenceType
      _cellReference = source._cellReference
      _rangeReference = source._rangeReference
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._referenceType == nil {return false}
      if let v = _storage._cellReference, !v.isInitialized {return false}
      if let v = _storage._rangeReference, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._referenceType) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._cellReference) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._rangeReference) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._referenceType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._cellReference {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._rangeReference {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ReferenceArchive, rhs: TSCE_ReferenceArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._referenceType != rhs_storage._referenceType {return false}
        if _storage._cellReference != rhs_storage._cellReference {return false}
        if _storage._rangeReference != rhs_storage._rangeReference {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ReferenceArchive.ReferenceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}CELL_REFERENCE\0\u{1}RANGE_REFERENCE\0\u{1}NAME_DEPENDENCY\0")
}

extension TSCE_EdgeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EdgeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}column\0\u{1}row\0\u{3}is_precedent\0\u{3}owner_id\0")

  public var isInitialized: Bool {
    if self._column == nil {return false}
    if self._row == nil {return false}
    if self._isPrecedent == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._column) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._row) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._isPrecedent) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ownerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._column {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._row {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._isPrecedent {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._ownerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_EdgeArchive, rhs: TSCE_EdgeArchive) -> Bool {
    if lhs._column != rhs._column {return false}
    if lhs._row != rhs._row {return false}
    if lhs._isPrecedent != rhs._isPrecedent {return false}
    if lhs._ownerID != rhs._ownerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_EdgesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EdgesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{9}packed_edge_without_owner\0\u{3}packed_edge_with_owner\0\u{3}owner_id_for_edge\0\u{3}internal_owner_id_for_edge\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 9: try { try decoder.decodeRepeatedUInt32Field(value: &self.packedEdgeWithoutOwner) }()
      case 10: try { try decoder.decodeRepeatedUInt32Field(value: &self.packedEdgeWithOwner) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.ownerIDForEdge) }()
      case 12: try { try decoder.decodeRepeatedUInt32Field(value: &self.internalOwnerIDForEdge) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.packedEdgeWithoutOwner.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.packedEdgeWithoutOwner, fieldNumber: 9)
    }
    if !self.packedEdgeWithOwner.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.packedEdgeWithOwner, fieldNumber: 10)
    }
    if !self.ownerIDForEdge.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ownerIDForEdge, fieldNumber: 11)
    }
    if !self.internalOwnerIDForEdge.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.internalOwnerIDForEdge, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_EdgesArchive, rhs: TSCE_EdgesArchive) -> Bool {
    if lhs.packedEdgeWithoutOwner != rhs.packedEdgeWithoutOwner {return false}
    if lhs.packedEdgeWithOwner != rhs.packedEdgeWithOwner {return false}
    if lhs.ownerIDForEdge != rhs.ownerIDForEdge {return false}
    if lhs.internalOwnerIDForEdge != rhs.internalOwnerIDForEdge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ExpandedEdgesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExpandedEdgesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}edge_without_owner_rows\0\u{3}edge_without_owner_columns\0\u{3}edge_with_owner_rows\0\u{3}edge_with_owner_columns\0\u{3}internal_owner_id_for_edge\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.edgeWithoutOwnerRows) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.edgeWithoutOwnerColumns) }()
      case 3: try { try decoder.decodeRepeatedUInt32Field(value: &self.edgeWithOwnerRows) }()
      case 4: try { try decoder.decodeRepeatedUInt32Field(value: &self.edgeWithOwnerColumns) }()
      case 5: try { try decoder.decodeRepeatedUInt32Field(value: &self.internalOwnerIDForEdge) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.edgeWithoutOwnerRows.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.edgeWithoutOwnerRows, fieldNumber: 1)
    }
    if !self.edgeWithoutOwnerColumns.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.edgeWithoutOwnerColumns, fieldNumber: 2)
    }
    if !self.edgeWithOwnerRows.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.edgeWithOwnerRows, fieldNumber: 3)
    }
    if !self.edgeWithOwnerColumns.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.edgeWithOwnerColumns, fieldNumber: 4)
    }
    if !self.internalOwnerIDForEdge.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.internalOwnerIDForEdge, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ExpandedEdgesArchive, rhs: TSCE_ExpandedEdgesArchive) -> Bool {
    if lhs.edgeWithoutOwnerRows != rhs.edgeWithoutOwnerRows {return false}
    if lhs.edgeWithoutOwnerColumns != rhs.edgeWithoutOwnerColumns {return false}
    if lhs.edgeWithOwnerRows != rhs.edgeWithOwnerRows {return false}
    if lhs.edgeWithOwnerColumns != rhs.edgeWithOwnerColumns {return false}
    if lhs.internalOwnerIDForEdge != rhs.internalOwnerIDForEdge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CellRecordArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellRecordArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}column\0\u{1}row\0\u{3}dirty_self_plus_precedents_count\0\u{3}is_in_a_cycle\0\u{1}edge\0\u{3}contains_a_formula\0\u{3}has_calculated_precedents\0\u{3}calculate_precedents_on_next_recalc\0\u{1}edges\0\u{3}translate_for_excel_import_on_next_recalc\0")

  public var isInitialized: Bool {
    if self._column == nil {return false}
    if self._row == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.edge) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._column) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._row) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._dirtySelfPlusPrecedentsCount) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._isInACycle) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.edge) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._containsAFormula) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._hasCalculatedPrecedents_p) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._calculatePrecedentsOnNextRecalc) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._edges) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self._translateForExcelImportOnNextRecalc) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._column {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._row {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._dirtySelfPlusPrecedentsCount {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._isInACycle {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    if !self.edge.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.edge, fieldNumber: 5)
    }
    try { if let v = self._containsAFormula {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._hasCalculatedPrecedents_p {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._calculatePrecedentsOnNextRecalc {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._edges {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._translateForExcelImportOnNextRecalc {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CellRecordArchive, rhs: TSCE_CellRecordArchive) -> Bool {
    if lhs._column != rhs._column {return false}
    if lhs._row != rhs._row {return false}
    if lhs._dirtySelfPlusPrecedentsCount != rhs._dirtySelfPlusPrecedentsCount {return false}
    if lhs._isInACycle != rhs._isInACycle {return false}
    if lhs.edge != rhs.edge {return false}
    if lhs._containsAFormula != rhs._containsAFormula {return false}
    if lhs._hasCalculatedPrecedents_p != rhs._hasCalculatedPrecedents_p {return false}
    if lhs._calculatePrecedentsOnNextRecalc != rhs._calculatePrecedentsOnNextRecalc {return false}
    if lhs._translateForExcelImportOnNextRecalc != rhs._translateForExcelImportOnNextRecalc {return false}
    if lhs._edges != rhs._edges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CellDependenciesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellDependenciesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cell_record\0\u{3}num_dirty_cells\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.cellRecord) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cellRecord) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._numDirtyCells) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cellRecord.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cellRecord, fieldNumber: 1)
    }
    try { if let v = self._numDirtyCells {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CellDependenciesArchive, rhs: TSCE_CellDependenciesArchive) -> Bool {
    if lhs.cellRecord != rhs.cellRecord {return false}
    if lhs._numDirtyCells != rhs._numDirtyCells {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CellRecordExpandedArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellRecordExpandedArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}column\0\u{1}row\0\u{3}dirty_self_plus_precedents_count\0\u{3}is_in_a_cycle\0\u{3}has_calculated_precedents\0\u{3}expanded_edges\0")

  public var isInitialized: Bool {
    if self._column == nil {return false}
    if self._row == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._column) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._row) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._dirtySelfPlusPrecedentsCount) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._isInACycle) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._hasCalculatedPrecedents_p) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._expandedEdges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._column {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._row {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._dirtySelfPlusPrecedentsCount {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._isInACycle {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._hasCalculatedPrecedents_p {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._expandedEdges {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CellRecordExpandedArchive, rhs: TSCE_CellRecordExpandedArchive) -> Bool {
    if lhs._column != rhs._column {return false}
    if lhs._row != rhs._row {return false}
    if lhs._dirtySelfPlusPrecedentsCount != rhs._dirtySelfPlusPrecedentsCount {return false}
    if lhs._isInACycle != rhs._isInACycle {return false}
    if lhs._hasCalculatedPrecedents_p != rhs._hasCalculatedPrecedents_p {return false}
    if lhs._expandedEdges != rhs._expandedEdges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CellDependenciesExpandedArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellDependenciesExpandedArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cell_record\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.cellRecord) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cellRecord) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cellRecord.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cellRecord, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CellDependenciesExpandedArchive, rhs: TSCE_CellDependenciesExpandedArchive) -> Bool {
    if lhs.cellRecord != rhs.cellRecord {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CellRecordTileArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellRecordTileArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}internal_owner_id\0\u{3}tile_column_begin\0\u{3}tile_row_begin\0\u{3}cell_records\0")

  public var isInitialized: Bool {
    if self._internalOwnerID == nil {return false}
    if self._tileColumnBegin == nil {return false}
    if self._tileRowBegin == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.cellRecords) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._internalOwnerID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._tileColumnBegin) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._tileRowBegin) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.cellRecords) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._internalOwnerID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tileColumnBegin {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._tileRowBegin {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    if !self.cellRecords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cellRecords, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CellRecordTileArchive, rhs: TSCE_CellRecordTileArchive) -> Bool {
    if lhs._internalOwnerID != rhs._internalOwnerID {return false}
    if lhs._tileColumnBegin != rhs._tileColumnBegin {return false}
    if lhs._tileRowBegin != rhs._tileRowBegin {return false}
    if lhs.cellRecords != rhs.cellRecords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CellDependenciesTiledArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellDependenciesTiledArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cell_record_tiles\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.cellRecordTiles) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cellRecordTiles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cellRecordTiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cellRecordTiles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CellDependenciesTiledArchive, rhs: TSCE_CellDependenciesTiledArchive) -> Bool {
    if lhs.cellRecordTiles != rhs.cellRecordTiles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_VolatileDependenciesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VolatileDependenciesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}volatile_time_cell_column\0\u{3}volatile_time_cell_row\0\u{3}volatile_random_cell_column\0\u{3}volatile_random_cell_row\0\u{3}volatile_location_cell_column\0\u{3}volatile_location_cell_row\0\u{3}volatile_compass_cell_column\0\u{3}volatile_compass_cell_row\0\u{3}calculated_dependency_cell_column\0\u{3}calculated_dependency_cell_row\0\u{3}volatile_geometry_cell\0\u{4}\u{2}volatile_geometry_cell_reference\0\u{4}\u{2}volatile_locale_cell_column\0\u{3}volatile_locale_cell_row\0\u{3}volatile_sheet_table_name_cell_column\0\u{3}volatile_sheet_table_name_cell_row\0\u{3}volatile_remote_data_cell_column\0\u{3}volatile_remote_data_cell_row\0")

  fileprivate class _StorageClass {
    var _volatileTimeCellColumn: [UInt32] = []
    var _volatileTimeCellRow: [UInt32] = []
    var _volatileRandomCellColumn: [UInt32] = []
    var _volatileRandomCellRow: [UInt32] = []
    var _volatileLocaleCellColumn: [UInt32] = []
    var _volatileLocaleCellRow: [UInt32] = []
    var _volatileLocationCellColumn: [UInt32] = []
    var _volatileLocationCellRow: [UInt32] = []
    var _volatileCompassCellColumn: [UInt32] = []
    var _volatileCompassCellRow: [UInt32] = []
    var _volatileRemoteDataCellColumn: [UInt32] = []
    var _volatileRemoteDataCellRow: [UInt32] = []
    var _volatileSheetTableNameCellColumn: [UInt32] = []
    var _volatileSheetTableNameCellRow: [UInt32] = []
    var _calculatedDependencyCellColumn: [UInt32] = []
    var _calculatedDependencyCellRow: [UInt32] = []
    var _volatileGeometryCellReference: [TSCE_CellReferenceArchive] = []
    var _volatileGeometryCell: [TSCE_CellCoordinateArchive] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _volatileTimeCellColumn = source._volatileTimeCellColumn
      _volatileTimeCellRow = source._volatileTimeCellRow
      _volatileRandomCellColumn = source._volatileRandomCellColumn
      _volatileRandomCellRow = source._volatileRandomCellRow
      _volatileLocaleCellColumn = source._volatileLocaleCellColumn
      _volatileLocaleCellRow = source._volatileLocaleCellRow
      _volatileLocationCellColumn = source._volatileLocationCellColumn
      _volatileLocationCellRow = source._volatileLocationCellRow
      _volatileCompassCellColumn = source._volatileCompassCellColumn
      _volatileCompassCellRow = source._volatileCompassCellRow
      _volatileRemoteDataCellColumn = source._volatileRemoteDataCellColumn
      _volatileRemoteDataCellRow = source._volatileRemoteDataCellRow
      _volatileSheetTableNameCellColumn = source._volatileSheetTableNameCellColumn
      _volatileSheetTableNameCellRow = source._volatileSheetTableNameCellRow
      _calculatedDependencyCellColumn = source._calculatedDependencyCellColumn
      _calculatedDependencyCellRow = source._calculatedDependencyCellRow
      _volatileGeometryCellReference = source._volatileGeometryCellReference
      _volatileGeometryCell = source._volatileGeometryCell
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._volatileGeometryCellReference) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._volatileTimeCellColumn) }()
        case 2: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._volatileTimeCellRow) }()
        case 3: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._volatileRandomCellColumn) }()
        case 4: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._volatileRandomCellRow) }()
        case 5: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._volatileLocationCellColumn) }()
        case 6: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._volatileLocationCellRow) }()
        case 7: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._volatileCompassCellColumn) }()
        case 8: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._volatileCompassCellRow) }()
        case 9: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._calculatedDependencyCellColumn) }()
        case 10: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._calculatedDependencyCellRow) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._volatileGeometryCell) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._volatileGeometryCellReference) }()
        case 15: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._volatileLocaleCellColumn) }()
        case 16: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._volatileLocaleCellRow) }()
        case 17: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._volatileSheetTableNameCellColumn) }()
        case 18: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._volatileSheetTableNameCellRow) }()
        case 19: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._volatileRemoteDataCellColumn) }()
        case 20: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._volatileRemoteDataCellRow) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._volatileTimeCellColumn.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._volatileTimeCellColumn, fieldNumber: 1)
      }
      if !_storage._volatileTimeCellRow.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._volatileTimeCellRow, fieldNumber: 2)
      }
      if !_storage._volatileRandomCellColumn.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._volatileRandomCellColumn, fieldNumber: 3)
      }
      if !_storage._volatileRandomCellRow.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._volatileRandomCellRow, fieldNumber: 4)
      }
      if !_storage._volatileLocationCellColumn.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._volatileLocationCellColumn, fieldNumber: 5)
      }
      if !_storage._volatileLocationCellRow.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._volatileLocationCellRow, fieldNumber: 6)
      }
      if !_storage._volatileCompassCellColumn.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._volatileCompassCellColumn, fieldNumber: 7)
      }
      if !_storage._volatileCompassCellRow.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._volatileCompassCellRow, fieldNumber: 8)
      }
      if !_storage._calculatedDependencyCellColumn.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._calculatedDependencyCellColumn, fieldNumber: 9)
      }
      if !_storage._calculatedDependencyCellRow.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._calculatedDependencyCellRow, fieldNumber: 10)
      }
      if !_storage._volatileGeometryCell.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._volatileGeometryCell, fieldNumber: 11)
      }
      if !_storage._volatileGeometryCellReference.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._volatileGeometryCellReference, fieldNumber: 13)
      }
      if !_storage._volatileLocaleCellColumn.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._volatileLocaleCellColumn, fieldNumber: 15)
      }
      if !_storage._volatileLocaleCellRow.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._volatileLocaleCellRow, fieldNumber: 16)
      }
      if !_storage._volatileSheetTableNameCellColumn.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._volatileSheetTableNameCellColumn, fieldNumber: 17)
      }
      if !_storage._volatileSheetTableNameCellRow.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._volatileSheetTableNameCellRow, fieldNumber: 18)
      }
      if !_storage._volatileRemoteDataCellColumn.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._volatileRemoteDataCellColumn, fieldNumber: 19)
      }
      if !_storage._volatileRemoteDataCellRow.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._volatileRemoteDataCellRow, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_VolatileDependenciesArchive, rhs: TSCE_VolatileDependenciesArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._volatileTimeCellColumn != rhs_storage._volatileTimeCellColumn {return false}
        if _storage._volatileTimeCellRow != rhs_storage._volatileTimeCellRow {return false}
        if _storage._volatileRandomCellColumn != rhs_storage._volatileRandomCellColumn {return false}
        if _storage._volatileRandomCellRow != rhs_storage._volatileRandomCellRow {return false}
        if _storage._volatileLocaleCellColumn != rhs_storage._volatileLocaleCellColumn {return false}
        if _storage._volatileLocaleCellRow != rhs_storage._volatileLocaleCellRow {return false}
        if _storage._volatileLocationCellColumn != rhs_storage._volatileLocationCellColumn {return false}
        if _storage._volatileLocationCellRow != rhs_storage._volatileLocationCellRow {return false}
        if _storage._volatileCompassCellColumn != rhs_storage._volatileCompassCellColumn {return false}
        if _storage._volatileCompassCellRow != rhs_storage._volatileCompassCellRow {return false}
        if _storage._volatileRemoteDataCellColumn != rhs_storage._volatileRemoteDataCellColumn {return false}
        if _storage._volatileRemoteDataCellRow != rhs_storage._volatileRemoteDataCellRow {return false}
        if _storage._volatileSheetTableNameCellColumn != rhs_storage._volatileSheetTableNameCellColumn {return false}
        if _storage._volatileSheetTableNameCellRow != rhs_storage._volatileSheetTableNameCellRow {return false}
        if _storage._calculatedDependencyCellColumn != rhs_storage._calculatedDependencyCellColumn {return false}
        if _storage._calculatedDependencyCellRow != rhs_storage._calculatedDependencyCellRow {return false}
        if _storage._volatileGeometryCellReference != rhs_storage._volatileGeometryCellReference {return false}
        if _storage._volatileGeometryCell != rhs_storage._volatileGeometryCell {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_VolatileDependenciesExpandedArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VolatileDependenciesExpandedArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}volatile_time_cells\0\u{3}volatile_random_cells\0\u{3}volatile_locale_cells\0\u{3}volatile_sheet_table_name_cells\0\u{3}volatile_remote_data_cells\0\u{4}\u{2}volatile_geometry_cell_refs\0")

  public var isInitialized: Bool {
    if let v = self._volatileTimeCells, !v.isInitialized {return false}
    if let v = self._volatileRandomCells, !v.isInitialized {return false}
    if let v = self._volatileLocaleCells, !v.isInitialized {return false}
    if let v = self._volatileSheetTableNameCells, !v.isInitialized {return false}
    if let v = self._volatileRemoteDataCells, !v.isInitialized {return false}
    if let v = self._volatileGeometryCellRefs, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._volatileTimeCells) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._volatileRandomCells) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._volatileLocaleCells) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._volatileSheetTableNameCells) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._volatileRemoteDataCells) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._volatileGeometryCellRefs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._volatileTimeCells {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._volatileRandomCells {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._volatileLocaleCells {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._volatileSheetTableNameCells {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._volatileRemoteDataCells {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._volatileGeometryCellRefs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_VolatileDependenciesExpandedArchive, rhs: TSCE_VolatileDependenciesExpandedArchive) -> Bool {
    if lhs._volatileTimeCells != rhs._volatileTimeCells {return false}
    if lhs._volatileRandomCells != rhs._volatileRandomCells {return false}
    if lhs._volatileLocaleCells != rhs._volatileLocaleCells {return false}
    if lhs._volatileSheetTableNameCells != rhs._volatileSheetTableNameCells {return false}
    if lhs._volatileRemoteDataCells != rhs._volatileRemoteDataCells {return false}
    if lhs._volatileGeometryCellRefs != rhs._volatileGeometryCellRefs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RTreeInternalNodeContentsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RTreeInternalNodeContentsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}min\0\u{1}max\0\u{1}child\0")

  public var isInitialized: Bool {
    if self._child == nil {return false}
    if let v = self._child, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.min) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.max) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._child) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.min.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.min, fieldNumber: 1)
    }
    if !self.max.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.max, fieldNumber: 2)
    }
    try { if let v = self._child {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RTreeInternalNodeContentsArchive, rhs: TSCE_RTreeInternalNodeContentsArchive) -> Bool {
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs._child != rhs._child {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RTreeLeafNodeContentsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RTreeLeafNodeContentsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}min\0\u{1}max\0\u{3}cell_reference\0")

  public var isInitialized: Bool {
    if self._cellReference == nil {return false}
    if let v = self._cellReference, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.min) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.max) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cellReference) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.min.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.min, fieldNumber: 1)
    }
    if !self.max.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.max, fieldNumber: 2)
    }
    try { if let v = self._cellReference {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RTreeLeafNodeContentsArchive, rhs: TSCE_RTreeLeafNodeContentsArchive) -> Bool {
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs._cellReference != rhs._cellReference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RTreeNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RTreeNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}level\0\u{1}count\0\u{3}internal_node_contents\0\u{3}leaf_node_contents\0")

  public var isInitialized: Bool {
    if self._level == nil {return false}
    if self._count == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.internalNodeContents) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.leafNodeContents) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._level) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._count) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.internalNodeContents) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.leafNodeContents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._level {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._count {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    if !self.internalNodeContents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.internalNodeContents, fieldNumber: 3)
    }
    if !self.leafNodeContents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.leafNodeContents, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RTreeNodeArchive, rhs: TSCE_RTreeNodeArchive) -> Bool {
    if lhs._level != rhs._level {return false}
    if lhs._count != rhs._count {return false}
    if lhs.internalNodeContents != rhs.internalNodeContents {return false}
    if lhs.leafNodeContents != rhs.leafNodeContents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RTreeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RTreeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}data_file_id\0\u{3}data_size\0\u{3}data_num_dims\0\u{3}data_elem_size\0\u{3}data_elem_real_size\0\u{3}data_max_nodes\0\u{3}data_min_nodes\0\u{1}root\0")

  public var isInitialized: Bool {
    if self._dataFileID == nil {return false}
    if self._dataSize == nil {return false}
    if self._dataNumDims == nil {return false}
    if self._dataElemSize == nil {return false}
    if self._dataElemRealSize == nil {return false}
    if self._dataMaxNodes == nil {return false}
    if self._dataMinNodes == nil {return false}
    if self._root == nil {return false}
    if let v = self._root, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._dataFileID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._dataSize) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._dataNumDims) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._dataElemSize) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._dataElemRealSize) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._dataMaxNodes) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._dataMinNodes) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._root) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._dataFileID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._dataSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._dataNumDims {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._dataElemSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._dataElemRealSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._dataMaxNodes {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._dataMinNodes {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._root {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RTreeArchive, rhs: TSCE_RTreeArchive) -> Bool {
    if lhs._dataFileID != rhs._dataFileID {return false}
    if lhs._dataSize != rhs._dataSize {return false}
    if lhs._dataNumDims != rhs._dataNumDims {return false}
    if lhs._dataElemSize != rhs._dataElemSize {return false}
    if lhs._dataElemRealSize != rhs._dataElemRealSize {return false}
    if lhs._dataMaxNodes != rhs._dataMaxNodes {return false}
    if lhs._dataMinNodes != rhs._dataMinNodes {return false}
    if lhs._root != rhs._root {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RangeBackDependencyArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RangeBackDependencyArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cell_coord_row\0\u{3}cell_coord_column\0\u{3}range_reference\0\u{3}internal_range_reference\0")

  public var isInitialized: Bool {
    if self._cellCoordRow == nil {return false}
    if self._cellCoordColumn == nil {return false}
    if let v = self._rangeReference, !v.isInitialized {return false}
    if let v = self._internalRangeReference, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._cellCoordRow) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._cellCoordColumn) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._rangeReference) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._internalRangeReference) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cellCoordRow {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cellCoordColumn {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._rangeReference {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._internalRangeReference {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RangeBackDependencyArchive, rhs: TSCE_RangeBackDependencyArchive) -> Bool {
    if lhs._cellCoordRow != rhs._cellCoordRow {return false}
    if lhs._cellCoordColumn != rhs._cellCoordColumn {return false}
    if lhs._rangeReference != rhs._rangeReference {return false}
    if lhs._internalRangeReference != rhs._internalRangeReference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RangeDependenciesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RangeDependenciesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{2}back_dependency\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.backDependency) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.backDependency) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.backDependency.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.backDependency, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RangeDependenciesArchive, rhs: TSCE_RangeDependenciesArchive) -> Bool {
    if lhs.backDependency != rhs.backDependency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RangePrecedentsTileArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RangePrecedentsTileArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}to_owner_id\0\u{3}from_to_range\0")

  public var isInitialized: Bool {
    if self._toOwnerID == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.fromToRange) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._toOwnerID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.fromToRange) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._toOwnerID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.fromToRange.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fromToRange, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RangePrecedentsTileArchive, rhs: TSCE_RangePrecedentsTileArchive) -> Bool {
    if lhs._toOwnerID != rhs._toOwnerID {return false}
    if lhs.fromToRange != rhs.fromToRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RangePrecedentsTileArchive.FromToRangeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_RangePrecedentsTileArchive.protoMessageName + ".FromToRangeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}from_coord\0\u{3}refers_to_rect\0")

  public var isInitialized: Bool {
    if self._fromCoord == nil {return false}
    if self._refersToRect == nil {return false}
    if let v = self._refersToRect, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fromCoord) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._refersToRect) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fromCoord {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._refersToRect {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RangePrecedentsTileArchive.FromToRangeArchive, rhs: TSCE_RangePrecedentsTileArchive.FromToRangeArchive) -> Bool {
    if lhs._fromCoord != rhs._fromCoord {return false}
    if lhs._refersToRect != rhs._refersToRect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RangeDependenciesTiledArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RangeDependenciesTiledArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}range_precedents_tile\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.rangePrecedentsTile) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rangePrecedentsTile) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rangePrecedentsTile.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rangePrecedentsTile, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RangeDependenciesTiledArchive, rhs: TSCE_RangeDependenciesTiledArchive) -> Bool {
    if lhs.rangePrecedentsTile != rhs.rangePrecedentsTile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_SpanningDependenciesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpanningDependenciesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}column\0\u{3}range_context\0\u{1}cell\0\u{3}total_range_for_deleted_table\0\u{3}body_range_for_deleted_table\0\u{3}referring_column_to_local_cells\0\u{3}referring_column_to_remote_cells\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.cell) {return false}
    if let v = self._totalRangeForDeletedTable, !v.isInitialized {return false}
    if let v = self._bodyRangeForDeletedTable, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.referringColumnToLocalCells) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.referringColumnToRemoteCells) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.column) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.rangeContext) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.cell) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._totalRangeForDeletedTable) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._bodyRangeForDeletedTable) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.referringColumnToLocalCells) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.referringColumnToRemoteCells) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.column.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.column, fieldNumber: 1)
    }
    if !self.rangeContext.isEmpty {
      try visitor.visitRepeatedEnumField(value: self.rangeContext, fieldNumber: 2)
    }
    if !self.cell.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cell, fieldNumber: 3)
    }
    try { if let v = self._totalRangeForDeletedTable {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._bodyRangeForDeletedTable {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.referringColumnToLocalCells.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.referringColumnToLocalCells, fieldNumber: 6)
    }
    if !self.referringColumnToRemoteCells.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.referringColumnToRemoteCells, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_SpanningDependenciesArchive, rhs: TSCE_SpanningDependenciesArchive) -> Bool {
    if lhs.column != rhs.column {return false}
    if lhs.rangeContext != rhs.rangeContext {return false}
    if lhs.cell != rhs.cell {return false}
    if lhs._totalRangeForDeletedTable != rhs._totalRangeForDeletedTable {return false}
    if lhs._bodyRangeForDeletedTable != rhs._bodyRangeForDeletedTable {return false}
    if lhs.referringColumnToLocalCells != rhs.referringColumnToLocalCells {return false}
    if lhs.referringColumnToRemoteCells != rhs.referringColumnToRemoteCells {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_SpanningDependenciesArchive.RangeContext: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DEFAULT\0\u{1}INCLUDE_HEADERS\0")
}

extension TSCE_SpanningDependenciesArchive.ReferringColumnToLocalCells: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_SpanningDependenciesArchive.protoMessageName + ".ReferringColumnToLocalCells"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}column\0\u{3}range_context\0\u{3}cell_coordinate\0")

  public var isInitialized: Bool {
    if self._column == nil {return false}
    if self._rangeContext == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._column) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._rangeContext) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.cellCoordinate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._column {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rangeContext {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    if !self.cellCoordinate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cellCoordinate, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_SpanningDependenciesArchive.ReferringColumnToLocalCells, rhs: TSCE_SpanningDependenciesArchive.ReferringColumnToLocalCells) -> Bool {
    if lhs._column != rhs._column {return false}
    if lhs._rangeContext != rhs._rangeContext {return false}
    if lhs.cellCoordinate != rhs.cellCoordinate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_SpanningDependenciesArchive.ReferringColumnToRemoteCells: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_SpanningDependenciesArchive.protoMessageName + ".ReferringColumnToRemoteCells"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}column\0\u{3}range_context\0\u{3}internal_cell_reference\0")

  public var isInitialized: Bool {
    if self._column == nil {return false}
    if self._rangeContext == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.internalCellReference) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._column) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._rangeContext) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.internalCellReference) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._column {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rangeContext {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    if !self.internalCellReference.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.internalCellReference, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_SpanningDependenciesArchive.ReferringColumnToRemoteCells, rhs: TSCE_SpanningDependenciesArchive.ReferringColumnToRemoteCells) -> Bool {
    if lhs._column != rhs._column {return false}
    if lhs._rangeContext != rhs._rangeContext {return false}
    if lhs.internalCellReference != rhs.internalCellReference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_SpanningDependenciesExpandedArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpanningDependenciesExpandedArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}coord_refers_to_spans\0\u{3}total_range_for_table\0\u{3}body_range_for_table\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.coordRefersToSpans) {return false}
    if let v = self._totalRangeForTable, !v.isInitialized {return false}
    if let v = self._bodyRangeForTable, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.coordRefersToSpans) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._totalRangeForTable) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._bodyRangeForTable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.coordRefersToSpans.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.coordRefersToSpans, fieldNumber: 1)
    }
    try { if let v = self._totalRangeForTable {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._bodyRangeForTable {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_SpanningDependenciesExpandedArchive, rhs: TSCE_SpanningDependenciesExpandedArchive) -> Bool {
    if lhs.coordRefersToSpans != rhs.coordRefersToSpans {return false}
    if lhs._totalRangeForTable != rhs._totalRangeForTable {return false}
    if lhs._bodyRangeForTable != rhs._bodyRangeForTable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_SpanningDependenciesExpandedArchive.RangeContext: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DEFAULT\0\u{1}INCLUDE_HEADERS\0")
}

extension TSCE_SpanningDependenciesExpandedArchive.ExtentRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_SpanningDependenciesExpandedArchive.protoMessageName + ".ExtentRange"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}extent_begin\0\u{3}extent_end\0")

  public var isInitialized: Bool {
    if self._extentBegin == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._extentBegin) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._extentEnd) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._extentBegin {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._extentEnd {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_SpanningDependenciesExpandedArchive.ExtentRange, rhs: TSCE_SpanningDependenciesExpandedArchive.ExtentRange) -> Bool {
    if lhs._extentBegin != rhs._extentBegin {return false}
    if lhs._extentEnd != rhs._extentEnd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_SpanningDependenciesExpandedArchive.ExtentRangeWithTableWithContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_SpanningDependenciesExpandedArchive.protoMessageName + ".ExtentRangeWithTableWithContext"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}owner_id\0\u{3}range_context\0\u{1}ranges\0")

  public var isInitialized: Bool {
    if self._ownerID == nil {return false}
    if self._rangeContext == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.ranges) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._ownerID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._rangeContext) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.ranges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownerID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rangeContext {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    if !self.ranges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranges, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_SpanningDependenciesExpandedArchive.ExtentRangeWithTableWithContext, rhs: TSCE_SpanningDependenciesExpandedArchive.ExtentRangeWithTableWithContext) -> Bool {
    if lhs._ownerID != rhs._ownerID {return false}
    if lhs._rangeContext != rhs._rangeContext {return false}
    if lhs.ranges != rhs.ranges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_SpanningDependenciesExpandedArchive.CellCoordRefersToExtents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_SpanningDependenciesExpandedArchive.protoMessageName + ".CellCoordRefersToExtents"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}coordinate\0\u{3}ranges_by_table_context\0")

  public var isInitialized: Bool {
    if self._coordinate == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rangesByTableContext) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coordinate) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rangesByTableContext) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coordinate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.rangesByTableContext.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rangesByTableContext, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_SpanningDependenciesExpandedArchive.CellCoordRefersToExtents, rhs: TSCE_SpanningDependenciesExpandedArchive.CellCoordRefersToExtents) -> Bool {
    if lhs._coordinate != rhs._coordinate {return false}
    if lhs.rangesByTableContext != rhs.rangesByTableContext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_WholeOwnerDependenciesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WholeOwnerDependenciesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}dependent_cell\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.dependentCell) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dependentCell) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dependentCell.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dependentCell, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_WholeOwnerDependenciesArchive, rhs: TSCE_WholeOwnerDependenciesArchive) -> Bool {
    if lhs.dependentCell != rhs.dependentCell {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_WholeOwnerDependenciesExpandedArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WholeOwnerDependenciesExpandedArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}dependent_cells\0")

  public var isInitialized: Bool {
    if let v = self._dependentCells, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._dependentCells) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._dependentCells {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_WholeOwnerDependenciesExpandedArchive, rhs: TSCE_WholeOwnerDependenciesExpandedArchive) -> Bool {
    if lhs._dependentCells != rhs._dependentCells {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ErrorArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ErrorArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}error_type_code\0\u{3}error_info_dictionary\0")

  public var isInitialized: Bool {
    if self._errorTypeCode == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.errorInfoDictionary) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._errorTypeCode) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.errorInfoDictionary) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._errorTypeCode {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.errorInfoDictionary.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errorInfoDictionary, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ErrorArchive, rhs: TSCE_ErrorArchive) -> Bool {
    if lhs._errorTypeCode != rhs._errorTypeCode {return false}
    if lhs.errorInfoDictionary != rhs.errorInfoDictionary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ErrorArchive.ErrorDictionaryEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_ErrorArchive.protoMessageName + ".ErrorDictionaryEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}error_key\0\u{3}value_for_key_string\0\u{3}value_for_key_number\0")

  public var isInitialized: Bool {
    if self._errorKey == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._errorKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._valueForKeyString) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self._valueForKeyNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._errorKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._valueForKeyString {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._valueForKeyNumber {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ErrorArchive.ErrorDictionaryEntry, rhs: TSCE_ErrorArchive.ErrorDictionaryEntry) -> Bool {
    if lhs._errorKey != rhs._errorKey {return false}
    if lhs._valueForKeyString != rhs._valueForKeyString {return false}
    if lhs._valueForKeyNumber != rhs._valueForKeyNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_WarningArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WarningArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}warning_type\0\u{3}warning_info_dictionary\0\u{3}range_ref\0")

  public var isInitialized: Bool {
    if self._warningType == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.warningInfoDictionary) {return false}
    if let v = self._rangeRef, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._warningType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.warningInfoDictionary) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._rangeRef) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._warningType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.warningInfoDictionary.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.warningInfoDictionary, fieldNumber: 2)
    }
    try { if let v = self._rangeRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_WarningArchive, rhs: TSCE_WarningArchive) -> Bool {
    if lhs._warningType != rhs._warningType {return false}
    if lhs.warningInfoDictionary != rhs.warningInfoDictionary {return false}
    if lhs._rangeRef != rhs._rangeRef {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_WarningArchive.WarningDictionaryEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_WarningArchive.protoMessageName + ".WarningDictionaryEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}warning_key\0\u{3}value_for_key_string\0\u{3}value_for_key_number\0")

  public var isInitialized: Bool {
    if self._warningKey == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._warningKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._valueForKeyString) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self._valueForKeyNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._warningKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._valueForKeyString {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._valueForKeyNumber {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_WarningArchive.WarningDictionaryEntry, rhs: TSCE_WarningArchive.WarningDictionaryEntry) -> Bool {
    if lhs._warningKey != rhs._warningKey {return false}
    if lhs._valueForKeyString != rhs._valueForKeyString {return false}
    if lhs._valueForKeyNumber != rhs._valueForKeyNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CellErrorsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellErrorsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}errors\0\u{3}enhanced_errors\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.errors) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.enhancedErrors) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.enhancedErrors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 1)
    }
    if !self.enhancedErrors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.enhancedErrors, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CellErrorsArchive, rhs: TSCE_CellErrorsArchive) -> Bool {
    if lhs.errors != rhs.errors {return false}
    if lhs.enhancedErrors != rhs.enhancedErrors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CellErrorsArchive.ErrorFlavor: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NONE\0\u{1}ERROR\0\u{1}REF_ERROR\0\u{1}CIRCULAR_REF_ERROR\0\u{1}UNSUPPORTED_FUNCTION_ERROR\0")
}

extension TSCE_CellErrorsArchive.ErrorForCell: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_CellErrorsArchive.protoMessageName + ".ErrorForCell"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}coordinate\0\u{3}error_flavor\0\u{3}err_due_to_cell\0")

  public var isInitialized: Bool {
    if self._coordinate == nil {return false}
    if self._errorFlavor == nil {return false}
    if let v = self._errDueToCell, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coordinate) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._errorFlavor) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._errDueToCell) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coordinate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._errorFlavor {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._errDueToCell {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CellErrorsArchive.ErrorForCell, rhs: TSCE_CellErrorsArchive.ErrorForCell) -> Bool {
    if lhs._coordinate != rhs._coordinate {return false}
    if lhs._errorFlavor != rhs._errorFlavor {return false}
    if lhs._errDueToCell != rhs._errDueToCell {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CellErrorsArchive.EnhancedErrorForCell: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_CellErrorsArchive.protoMessageName + ".EnhancedErrorForCell"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}coordinate\0\u{1}error\0\u{3}err_due_to_cell\0\u{3}sorted_warnings\0")

  public var isInitialized: Bool {
    if self._coordinate == nil {return false}
    if let v = self._error, !v.isInitialized {return false}
    if let v = self._errDueToCell, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.sortedWarnings) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coordinate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._errDueToCell) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.sortedWarnings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coordinate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._errDueToCell {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.sortedWarnings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sortedWarnings, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CellErrorsArchive.EnhancedErrorForCell, rhs: TSCE_CellErrorsArchive.EnhancedErrorForCell) -> Bool {
    if lhs._coordinate != rhs._coordinate {return false}
    if lhs._error != rhs._error {return false}
    if lhs._errDueToCell != rhs._errDueToCell {return false}
    if lhs.sortedWarnings != rhs.sortedWarnings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CellSpillSizesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellSpillSizesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}spills\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.spills) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.spills) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.spills.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spills, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CellSpillSizesArchive, rhs: TSCE_CellSpillSizesArchive) -> Bool {
    if lhs.spills != rhs.spills {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CellSpillSizesArchive.SpillForCell: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_CellSpillSizesArchive.protoMessageName + ".SpillForCell"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}coordinate\0\u{3}spill_size\0")

  public var isInitialized: Bool {
    if self._coordinate == nil {return false}
    if self._spillSize == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coordinate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spillSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coordinate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spillSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CellSpillSizesArchive.SpillForCell, rhs: TSCE_CellSpillSizesArchive.SpillForCell) -> Bool {
    if lhs._coordinate != rhs._coordinate {return false}
    if lhs._spillSize != rhs._spillSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_UuidReferencesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UuidReferencesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}table_refs\0\u{3}table_uuid_refs\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.tableRefs) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.tableUuidRefs) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tableRefs) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tableUuidRefs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tableRefs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tableRefs, fieldNumber: 1)
    }
    if !self.tableUuidRefs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tableUuidRefs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_UuidReferencesArchive, rhs: TSCE_UuidReferencesArchive) -> Bool {
    if lhs.tableRefs != rhs.tableRefs {return false}
    if lhs.tableUuidRefs != rhs.tableUuidRefs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_UuidReferencesArchive.TableRef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_UuidReferencesArchive.protoMessageName + ".TableRef"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}owner_uuid\0\u{3}coord_set\0")

  public var isInitialized: Bool {
    if self._ownerUuid == nil {return false}
    if let v = self._ownerUuid, !v.isInitialized {return false}
    if let v = self._coordSet, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ownerUuid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._coordSet) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownerUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._coordSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_UuidReferencesArchive.TableRef, rhs: TSCE_UuidReferencesArchive.TableRef) -> Bool {
    if lhs._ownerUuid != rhs._ownerUuid {return false}
    if lhs._coordSet != rhs._coordSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_UuidReferencesArchive.UuidRef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_UuidReferencesArchive.protoMessageName + ".UuidRef"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uuid\0\u{3}coord_set\0")

  public var isInitialized: Bool {
    if self._uuid == nil {return false}
    if let v = self._uuid, !v.isInitialized {return false}
    if let v = self._coordSet, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._coordSet) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._coordSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_UuidReferencesArchive.UuidRef, rhs: TSCE_UuidReferencesArchive.UuidRef) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs._coordSet != rhs._coordSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_UuidReferencesArchive.TableWithUuidRef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_UuidReferencesArchive.protoMessageName + ".TableWithUuidRef"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}owner_uuid\0\u{3}uuid_refs\0")

  public var isInitialized: Bool {
    if self._ownerUuid == nil {return false}
    if let v = self._ownerUuid, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.uuidRefs) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ownerUuid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.uuidRefs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownerUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.uuidRefs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uuidRefs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_UuidReferencesArchive.TableWithUuidRef, rhs: TSCE_UuidReferencesArchive.TableWithUuidRef) -> Bool {
    if lhs._ownerUuid != rhs._ownerUuid {return false}
    if lhs.uuidRefs != rhs.uuidRefs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_FormulaOwnerDependenciesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormulaOwnerDependenciesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}formula_owner_uid\0\u{3}internal_formula_owner_id\0\u{3}owner_kind\0\u{3}cell_dependencies\0\u{3}range_dependencies\0\u{3}volatile_dependencies\0\u{3}spanning_column_dependencies\0\u{3}spanning_row_dependencies\0\u{3}whole_owner_dependencies\0\u{3}cell_errors\0\u{3}formula_owner\0\u{3}base_owner_uid\0\u{3}tiled_cell_dependencies\0\u{3}uuid_references\0\u{3}tiled_range_dependencies\0\u{3}spill_range_sizes\0")

  fileprivate class _StorageClass {
    var _formulaOwnerUid: TSP_UUID? = nil
    var _internalFormulaOwnerID: UInt32? = nil
    var _ownerKind: UInt32? = nil
    var _cellDependencies: TSCE_CellDependenciesExpandedArchive? = nil
    var _rangeDependencies: TSCE_RangeDependenciesArchive? = nil
    var _volatileDependencies: TSCE_VolatileDependenciesExpandedArchive? = nil
    var _spanningColumnDependencies: TSCE_SpanningDependenciesExpandedArchive? = nil
    var _spanningRowDependencies: TSCE_SpanningDependenciesExpandedArchive? = nil
    var _wholeOwnerDependencies: TSCE_WholeOwnerDependenciesExpandedArchive? = nil
    var _cellErrors: TSCE_CellErrorsArchive? = nil
    var _formulaOwner: TSP_Reference? = nil
    var _baseOwnerUid: TSP_UUID? = nil
    var _tiledCellDependencies: TSCE_CellDependenciesTiledArchive? = nil
    var _uuidReferences: TSCE_UuidReferencesArchive? = nil
    var _tiledRangeDependencies: TSCE_RangeDependenciesTiledArchive? = nil
    var _spillRangeSizes: TSCE_CellSpillSizesArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _formulaOwnerUid = source._formulaOwnerUid
      _internalFormulaOwnerID = source._internalFormulaOwnerID
      _ownerKind = source._ownerKind
      _cellDependencies = source._cellDependencies
      _rangeDependencies = source._rangeDependencies
      _volatileDependencies = source._volatileDependencies
      _spanningColumnDependencies = source._spanningColumnDependencies
      _spanningRowDependencies = source._spanningRowDependencies
      _wholeOwnerDependencies = source._wholeOwnerDependencies
      _cellErrors = source._cellErrors
      _formulaOwner = source._formulaOwner
      _baseOwnerUid = source._baseOwnerUid
      _tiledCellDependencies = source._tiledCellDependencies
      _uuidReferences = source._uuidReferences
      _tiledRangeDependencies = source._tiledRangeDependencies
      _spillRangeSizes = source._spillRangeSizes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._formulaOwnerUid == nil {return false}
      if _storage._internalFormulaOwnerID == nil {return false}
      if let v = _storage._formulaOwnerUid, !v.isInitialized {return false}
      if let v = _storage._cellDependencies, !v.isInitialized {return false}
      if let v = _storage._rangeDependencies, !v.isInitialized {return false}
      if let v = _storage._volatileDependencies, !v.isInitialized {return false}
      if let v = _storage._spanningColumnDependencies, !v.isInitialized {return false}
      if let v = _storage._spanningRowDependencies, !v.isInitialized {return false}
      if let v = _storage._wholeOwnerDependencies, !v.isInitialized {return false}
      if let v = _storage._cellErrors, !v.isInitialized {return false}
      if let v = _storage._formulaOwner, !v.isInitialized {return false}
      if let v = _storage._baseOwnerUid, !v.isInitialized {return false}
      if let v = _storage._tiledCellDependencies, !v.isInitialized {return false}
      if let v = _storage._uuidReferences, !v.isInitialized {return false}
      if let v = _storage._tiledRangeDependencies, !v.isInitialized {return false}
      if let v = _storage._spillRangeSizes, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._formulaOwnerUid) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._internalFormulaOwnerID) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._ownerKind) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._cellDependencies) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._rangeDependencies) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._volatileDependencies) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._spanningColumnDependencies) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._spanningRowDependencies) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._wholeOwnerDependencies) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._cellErrors) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._formulaOwner) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._baseOwnerUid) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._tiledCellDependencies) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._uuidReferences) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._tiledRangeDependencies) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._spillRangeSizes) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._formulaOwnerUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._internalFormulaOwnerID {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._ownerKind {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._cellDependencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._rangeDependencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._volatileDependencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._spanningColumnDependencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._spanningRowDependencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._wholeOwnerDependencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._cellErrors {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._formulaOwner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._baseOwnerUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._tiledCellDependencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._uuidReferences {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._tiledRangeDependencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._spillRangeSizes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_FormulaOwnerDependenciesArchive, rhs: TSCE_FormulaOwnerDependenciesArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._formulaOwnerUid != rhs_storage._formulaOwnerUid {return false}
        if _storage._internalFormulaOwnerID != rhs_storage._internalFormulaOwnerID {return false}
        if _storage._ownerKind != rhs_storage._ownerKind {return false}
        if _storage._cellDependencies != rhs_storage._cellDependencies {return false}
        if _storage._rangeDependencies != rhs_storage._rangeDependencies {return false}
        if _storage._volatileDependencies != rhs_storage._volatileDependencies {return false}
        if _storage._spanningColumnDependencies != rhs_storage._spanningColumnDependencies {return false}
        if _storage._spanningRowDependencies != rhs_storage._spanningRowDependencies {return false}
        if _storage._wholeOwnerDependencies != rhs_storage._wholeOwnerDependencies {return false}
        if _storage._cellErrors != rhs_storage._cellErrors {return false}
        if _storage._formulaOwner != rhs_storage._formulaOwner {return false}
        if _storage._baseOwnerUid != rhs_storage._baseOwnerUid {return false}
        if _storage._tiledCellDependencies != rhs_storage._tiledCellDependencies {return false}
        if _storage._uuidReferences != rhs_storage._uuidReferences {return false}
        if _storage._tiledRangeDependencies != rhs_storage._tiledRangeDependencies {return false}
        if _storage._spillRangeSizes != rhs_storage._spillRangeSizes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_FormulaOwnerInfoArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormulaOwnerInfoArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}formula_owner_id\0\u{3}cell_dependencies\0\u{3}range_dependencies\0\u{3}volatile_dependencies\0\u{3}spanning_column_dependencies\0\u{3}spanning_row_dependencies\0\u{3}formula_owner\0\u{3}whole_owner_dependencies\0\u{3}cell_errors\0")

  fileprivate class _StorageClass {
    var _formulaOwnerID: TSP_CFUUIDArchive? = nil
    var _cellDependencies: TSCE_CellDependenciesArchive? = nil
    var _rangeDependencies: TSCE_RangeDependenciesArchive? = nil
    var _volatileDependencies: TSCE_VolatileDependenciesArchive? = nil
    var _spanningColumnDependencies: TSCE_SpanningDependenciesArchive? = nil
    var _spanningRowDependencies: TSCE_SpanningDependenciesArchive? = nil
    var _wholeOwnerDependencies: TSCE_WholeOwnerDependenciesArchive? = nil
    var _cellErrors: TSCE_CellErrorsArchive? = nil
    var _formulaOwner: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _formulaOwnerID = source._formulaOwnerID
      _cellDependencies = source._cellDependencies
      _rangeDependencies = source._rangeDependencies
      _volatileDependencies = source._volatileDependencies
      _spanningColumnDependencies = source._spanningColumnDependencies
      _spanningRowDependencies = source._spanningRowDependencies
      _wholeOwnerDependencies = source._wholeOwnerDependencies
      _cellErrors = source._cellErrors
      _formulaOwner = source._formulaOwner
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._formulaOwnerID == nil {return false}
      if let v = _storage._cellDependencies, !v.isInitialized {return false}
      if let v = _storage._rangeDependencies, !v.isInitialized {return false}
      if let v = _storage._volatileDependencies, !v.isInitialized {return false}
      if let v = _storage._spanningColumnDependencies, !v.isInitialized {return false}
      if let v = _storage._spanningRowDependencies, !v.isInitialized {return false}
      if let v = _storage._wholeOwnerDependencies, !v.isInitialized {return false}
      if let v = _storage._cellErrors, !v.isInitialized {return false}
      if let v = _storage._formulaOwner, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._formulaOwnerID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._cellDependencies) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._rangeDependencies) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._volatileDependencies) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._spanningColumnDependencies) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._spanningRowDependencies) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._formulaOwner) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._wholeOwnerDependencies) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._cellErrors) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._formulaOwnerID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._cellDependencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._rangeDependencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._volatileDependencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._spanningColumnDependencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._spanningRowDependencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._formulaOwner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._wholeOwnerDependencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._cellErrors {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_FormulaOwnerInfoArchive, rhs: TSCE_FormulaOwnerInfoArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._formulaOwnerID != rhs_storage._formulaOwnerID {return false}
        if _storage._cellDependencies != rhs_storage._cellDependencies {return false}
        if _storage._rangeDependencies != rhs_storage._rangeDependencies {return false}
        if _storage._volatileDependencies != rhs_storage._volatileDependencies {return false}
        if _storage._spanningColumnDependencies != rhs_storage._spanningColumnDependencies {return false}
        if _storage._spanningRowDependencies != rhs_storage._spanningRowDependencies {return false}
        if _storage._wholeOwnerDependencies != rhs_storage._wholeOwnerDependencies {return false}
        if _storage._cellErrors != rhs_storage._cellErrors {return false}
        if _storage._formulaOwner != rhs_storage._formulaOwner {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_SubFormulaOwnerIDArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubFormulaOwnerIDArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}base_owner_uid\0\u{3}owner_kind\0")

  public var isInitialized: Bool {
    if self._baseOwnerUid == nil {return false}
    if self._ownerKind == nil {return false}
    if let v = self._baseOwnerUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseOwnerUid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._ownerKind) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baseOwnerUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ownerKind {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_SubFormulaOwnerIDArchive, rhs: TSCE_SubFormulaOwnerIDArchive) -> Bool {
    if lhs._baseOwnerUid != rhs._baseOwnerUid {return false}
    if lhs._ownerKind != rhs._ownerKind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_OwnerIDMapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OwnerIDMapArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}map_entry\0\u{3}unregistered_internal_owner_id\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.mapEntry) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.mapEntry) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.unregisteredInternalOwnerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mapEntry.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mapEntry, fieldNumber: 1)
    }
    if !self.unregisteredInternalOwnerID.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.unregisteredInternalOwnerID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_OwnerIDMapArchive, rhs: TSCE_OwnerIDMapArchive) -> Bool {
    if lhs.mapEntry != rhs.mapEntry {return false}
    if lhs.unregisteredInternalOwnerID != rhs.unregisteredInternalOwnerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_OwnerIDMapArchive.OwnerIDMapArchiveEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_OwnerIDMapArchive.protoMessageName + ".OwnerIDMapArchiveEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}internal_owner_id\0\u{3}owner_id\0")

  public var isInitialized: Bool {
    if self._internalOwnerID == nil {return false}
    if self._ownerID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._internalOwnerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._ownerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._internalOwnerID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ownerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_OwnerIDMapArchive.OwnerIDMapArchiveEntry, rhs: TSCE_OwnerIDMapArchive.OwnerIDMapArchiveEntry) -> Bool {
    if lhs._internalOwnerID != rhs._internalOwnerID {return false}
    if lhs._ownerID != rhs._ownerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_UidLookupListArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UidLookupListArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uuids\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.uuids) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.uuids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uuids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_UidLookupListArchive, rhs: TSCE_UidLookupListArchive) -> Bool {
    if lhs.uuids != rhs.uuids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_DependencyTrackerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DependencyTrackerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}formula_owner_info\0\u{3}dirty_leaf\0\u{3}owner_id_map\0\u{3}internal_dirty_leaf\0\u{3}number_of_formulas\0\u{3}formula_owner_dependencies\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.formulaOwnerInfo) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.dirtyLeaf) {return false}
    if let v = self._ownerIDMap, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.internalDirtyLeaf) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.formulaOwnerDependencies) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.formulaOwnerInfo) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.dirtyLeaf) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._ownerIDMap) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.internalDirtyLeaf) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._numberOfFormulas) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.formulaOwnerDependencies) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.formulaOwnerInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.formulaOwnerInfo, fieldNumber: 1)
    }
    if !self.dirtyLeaf.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dirtyLeaf, fieldNumber: 2)
    }
    try { if let v = self._ownerIDMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.internalDirtyLeaf.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.internalDirtyLeaf, fieldNumber: 4)
    }
    try { if let v = self._numberOfFormulas {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    if !self.formulaOwnerDependencies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.formulaOwnerDependencies, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_DependencyTrackerArchive, rhs: TSCE_DependencyTrackerArchive) -> Bool {
    if lhs.formulaOwnerInfo != rhs.formulaOwnerInfo {return false}
    if lhs.dirtyLeaf != rhs.dirtyLeaf {return false}
    if lhs._ownerIDMap != rhs._ownerIDMap {return false}
    if lhs.internalDirtyLeaf != rhs.internalDirtyLeaf {return false}
    if lhs._numberOfFormulas != rhs._numberOfFormulas {return false}
    if lhs.formulaOwnerDependencies != rhs.formulaOwnerDependencies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RemoteDataSpecifierArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteDataSpecifierArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}function_index\0\u{1}symbol\0\u{1}attribute\0\u{1}date\0")

  public var isInitialized: Bool {
    if self._functionIndex == nil {return false}
    if self._symbol == nil {return false}
    if self._attribute == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._functionIndex) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._symbol) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._attribute) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._date) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._functionIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._symbol {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._attribute {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._date {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RemoteDataSpecifierArchive, rhs: TSCE_RemoteDataSpecifierArchive) -> Bool {
    if lhs._functionIndex != rhs._functionIndex {return false}
    if lhs._symbol != rhs._symbol {return false}
    if lhs._attribute != rhs._attribute {return false}
    if lhs._date != rhs._date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RemoteDataValueMapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteDataValueMapArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}entry\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.entry) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entry.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entry, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RemoteDataValueMapArchive, rhs: TSCE_RemoteDataValueMapArchive) -> Bool {
    if lhs.entry != rhs.entry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RemoteDataValueMapArchive.RemoteDataMapEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_RemoteDataValueMapArchive.protoMessageName + ".RemoteDataMapEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}specifier\0\u{1}value\0")

  public var isInitialized: Bool {
    if self._specifier == nil {return false}
    if self._value == nil {return false}
    if let v = self._specifier, !v.isInitialized {return false}
    if let v = self._value, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._specifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._specifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RemoteDataValueMapArchive.RemoteDataMapEntry, rhs: TSCE_RemoteDataValueMapArchive.RemoteDataMapEntry) -> Bool {
    if lhs._specifier != rhs._specifier {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_StockArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StockArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}symbol\0\u{1}date\0\u{1}attribute\0")

  public var isInitialized: Bool {
    if self._symbol == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.attribute) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._symbol) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._date) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.attribute) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._symbol {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._date {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    if !self.attribute.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attribute, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_StockArchive, rhs: TSCE_StockArchive) -> Bool {
    if lhs._symbol != rhs._symbol {return false}
    if lhs._date != rhs._date {return false}
    if lhs.attribute != rhs.attribute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_StockArchive.AttributeEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_StockArchive.protoMessageName + ".AttributeEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}attribute\0\u{1}value\0")

  public var isInitialized: Bool {
    if self._attribute == nil {return false}
    if self._value == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._attribute) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._attribute {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_StockArchive.AttributeEntry, rhs: TSCE_StockArchive.AttributeEntry) -> Bool {
    if lhs._attribute != rhs._attribute {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RemoteDataStoreArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteDataStoreArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}value_map\0\u{1}stocks\0")

  public var isInitialized: Bool {
    if self._valueMap == nil {return false}
    if let v = self._valueMap, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.stocks) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._valueMap) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.stocks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._valueMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.stocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stocks, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RemoteDataStoreArchive, rhs: TSCE_RemoteDataStoreArchive) -> Bool {
    if lhs._valueMap != rhs._valueMap {return false}
    if lhs.stocks != rhs.stocks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_NameTrackedReferencePair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NameTrackedReferencePair"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}tracked_reference\0\u{3}tracked_reference_id\0")

  public var isInitialized: Bool {
    if self._name == nil {return false}
    if let v = self._trackedReference, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._trackedReference) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._trackedReferenceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._trackedReference {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._trackedReferenceID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_NameTrackedReferencePair, rhs: TSCE_NameTrackedReferencePair) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._trackedReference != rhs._trackedReference {return false}
    if lhs._trackedReferenceID != rhs._trackedReferenceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_NamesByTrackedReferenceArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NamesByTrackedReferenceArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}table_id\0\u{3}name_tracked_reference_pair\0")

  public var isInitialized: Bool {
    if self._tableID == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.nameTrackedReferencePair) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tableID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.nameTrackedReferencePair) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tableID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nameTrackedReferencePair.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nameTrackedReferencePair, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_NamesByTrackedReferenceArchive, rhs: TSCE_NamesByTrackedReferenceArchive) -> Bool {
    if lhs._tableID != rhs._tableID {return false}
    if lhs.nameTrackedReferencePair != rhs.nameTrackedReferencePair {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_NamedReferenceManagerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NamedReferenceManagerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}reference_tracker\0\u{3}names_by_tracked_reference_by_table\0")

  public var isInitialized: Bool {
    if self._referenceTracker == nil {return false}
    if let v = self._referenceTracker, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.namesByTrackedReferenceByTable) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._referenceTracker) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.namesByTrackedReferenceByTable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._referenceTracker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.namesByTrackedReferenceByTable.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.namesByTrackedReferenceByTable, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_NamedReferenceManagerArchive, rhs: TSCE_NamedReferenceManagerArchive) -> Bool {
    if lhs._referenceTracker != rhs._referenceTracker {return false}
    if lhs.namesByTrackedReferenceByTable != rhs.namesByTrackedReferenceByTable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_UuidSetStoreArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UuidSetStoreArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uuidSet\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.uuidSet) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.uuidSet) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuidSet.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uuidSet, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_UuidSetStoreArchive, rhs: TSCE_UuidSetStoreArchive) -> Bool {
    if lhs.uuidSet != rhs.uuidSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_UuidSetStoreArchive.UuidSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_UuidSetStoreArchive.protoMessageName + ".UuidSet"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uuid\0\u{3}index_of_set\0")

  public var isInitialized: Bool {
    if self._indexOfSet == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.uuid) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._indexOfSet) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uuid.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uuid, fieldNumber: 1)
    }
    try { if let v = self._indexOfSet {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_UuidSetStoreArchive.UuidSet, rhs: TSCE_UuidSetStoreArchive.UuidSet) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs._indexOfSet != rhs._indexOfSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_UuidReferenceMapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UuidReferenceMapArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cell_refs_for_uuid\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.cellRefsForUuid) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cellRefsForUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cellRefsForUuid.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cellRefsForUuid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_UuidReferenceMapArchive, rhs: TSCE_UuidReferenceMapArchive) -> Bool {
    if lhs.cellRefsForUuid != rhs.cellRefsForUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_UuidReferenceMapArchive.CellRefsForUuid: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_UuidReferenceMapArchive.protoMessageName + ".CellRefsForUuid"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uuid\0\u{3}cell_ref\0\u{3}cell_refs\0")

  public var isInitialized: Bool {
    if self._uuid == nil {return false}
    if let v = self._uuid, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.cellRef) {return false}
    if let v = self._cellRefs, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.cellRef) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cellRefs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.cellRef.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cellRef, fieldNumber: 2)
    }
    try { if let v = self._cellRefs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_UuidReferenceMapArchive.CellRefsForUuid, rhs: TSCE_UuidReferenceMapArchive.CellRefsForUuid) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.cellRef != rhs.cellRef {return false}
    if lhs._cellRefs != rhs._cellRefs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_GroupByNodeMapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupByNodeMapArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}refs_for_group_by\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.refsForGroupBy) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.refsForGroupBy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.refsForGroupBy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.refsForGroupBy, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_GroupByNodeMapArchive, rhs: TSCE_GroupByNodeMapArchive) -> Bool {
    if lhs.refsForGroupBy != rhs.refsForGroupBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_GroupByNodeMapArchive.CellRefsForGroupNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_GroupByNodeMapArchive.protoMessageName + ".CellRefsForGroupNode"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_node_uid\0\u{4}\u{2}cell_refs\0")

  public var isInitialized: Bool {
    if self._groupNodeUid == nil {return false}
    if let v = self._groupNodeUid, !v.isInitialized {return false}
    if let v = self._cellRefs, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groupNodeUid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cellRefs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groupNodeUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cellRefs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_GroupByNodeMapArchive.CellRefsForGroupNode, rhs: TSCE_GroupByNodeMapArchive.CellRefsForGroupNode) -> Bool {
    if lhs._groupNodeUid != rhs._groupNodeUid {return false}
    if lhs._cellRefs != rhs._cellRefs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_GroupByNodeMapArchive.GroupNodesForGroupBy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_GroupByNodeMapArchive.protoMessageName + ".GroupNodesForGroupBy"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_by_uid\0\u{3}refs_for_group_node\0")

  public var isInitialized: Bool {
    if self._groupByUid == nil {return false}
    if let v = self._groupByUid, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.refsForGroupNode) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groupByUid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.refsForGroupNode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groupByUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.refsForGroupNode.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.refsForGroupNode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_GroupByNodeMapArchive.GroupNodesForGroupBy, rhs: TSCE_GroupByNodeMapArchive.GroupNodesForGroupBy) -> Bool {
    if lhs._groupByUid != rhs._groupByUid {return false}
    if lhs.refsForGroupNode != rhs.refsForGroupNode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CalculationEngineArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CalculationEngineArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}base_date_1904\0\u{3}dependency_tracker\0\u{3}named_reference_manager\0\u{3}excel_import_date_mode\0\u{3}saved_locale_identifier_for_4_2\0\u{3}document_random_seed\0\u{3}uuid_reference_map\0\u{4}\u{2}document_timestamp\0\u{3}document_timezone\0\u{3}table_uid_history\0\u{3}remote_data_store\0\u{3}group_node_map\0\u{3}header_name_manager\0\u{3}refs_to_dirty\0\u{3}saved_locale_identifier\0\u{3}begin_tracking_names_legacy_nrm\0\u{3}end_tracking_names_legacy_nrm\0")

  fileprivate class _StorageClass {
    var _baseDate1904: Bool? = nil
    var _dependencyTracker: TSCE_DependencyTrackerArchive? = nil
    var _namedReferenceManager: TSP_Reference? = nil
    var _excelImportDateMode: TSCE_CalculationEngineArchive.ExcelImportDateMode? = nil
    var _savedLocaleIdentifierFor42: String? = nil
    var _documentRandomSeed: UInt64? = nil
    var _uuidReferenceMap: TSCE_UuidReferenceMapArchive? = nil
    var _documentTimestamp: Double? = nil
    var _documentTimezone: String? = nil
    var _tableUidHistory: TSCE_RewriteTableUIDInfoArchive? = nil
    var _remoteDataStore: TSP_Reference? = nil
    var _groupNodeMap: TSCE_GroupByNodeMapArchive? = nil
    var _headerNameManager: TSP_Reference? = nil
    var _refsToDirty: TSP_Reference? = nil
    var _savedLocaleIdentifier: String? = nil
    var _beginTrackingNamesLegacyNrm: [TSP_UUID] = []
    var _endTrackingNamesLegacyNrm: [TSP_UUID] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _baseDate1904 = source._baseDate1904
      _dependencyTracker = source._dependencyTracker
      _namedReferenceManager = source._namedReferenceManager
      _excelImportDateMode = source._excelImportDateMode
      _savedLocaleIdentifierFor42 = source._savedLocaleIdentifierFor42
      _documentRandomSeed = source._documentRandomSeed
      _uuidReferenceMap = source._uuidReferenceMap
      _documentTimestamp = source._documentTimestamp
      _documentTimezone = source._documentTimezone
      _tableUidHistory = source._tableUidHistory
      _remoteDataStore = source._remoteDataStore
      _groupNodeMap = source._groupNodeMap
      _headerNameManager = source._headerNameManager
      _refsToDirty = source._refsToDirty
      _savedLocaleIdentifier = source._savedLocaleIdentifier
      _beginTrackingNamesLegacyNrm = source._beginTrackingNamesLegacyNrm
      _endTrackingNamesLegacyNrm = source._endTrackingNamesLegacyNrm
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._dependencyTracker == nil {return false}
      if let v = _storage._dependencyTracker, !v.isInitialized {return false}
      if let v = _storage._namedReferenceManager, !v.isInitialized {return false}
      if let v = _storage._uuidReferenceMap, !v.isInitialized {return false}
      if let v = _storage._tableUidHistory, !v.isInitialized {return false}
      if let v = _storage._remoteDataStore, !v.isInitialized {return false}
      if let v = _storage._groupNodeMap, !v.isInitialized {return false}
      if let v = _storage._headerNameManager, !v.isInitialized {return false}
      if let v = _storage._refsToDirty, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._beginTrackingNamesLegacyNrm) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._endTrackingNamesLegacyNrm) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._baseDate1904) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._dependencyTracker) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._namedReferenceManager) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._excelImportDateMode) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._savedLocaleIdentifierFor42) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._documentRandomSeed) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._uuidReferenceMap) }()
        case 9: try { try decoder.decodeSingularDoubleField(value: &_storage._documentTimestamp) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._documentTimezone) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._tableUidHistory) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._remoteDataStore) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._groupNodeMap) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._headerNameManager) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._refsToDirty) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._savedLocaleIdentifier) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._beginTrackingNamesLegacyNrm) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._endTrackingNamesLegacyNrm) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._baseDate1904 {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._dependencyTracker {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._namedReferenceManager {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._excelImportDateMode {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._savedLocaleIdentifierFor42 {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._documentRandomSeed {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._uuidReferenceMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._documentTimestamp {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._documentTimezone {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._tableUidHistory {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._remoteDataStore {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._groupNodeMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._headerNameManager {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._refsToDirty {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._savedLocaleIdentifier {
        try visitor.visitSingularStringField(value: v, fieldNumber: 16)
      } }()
      if !_storage._beginTrackingNamesLegacyNrm.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._beginTrackingNamesLegacyNrm, fieldNumber: 17)
      }
      if !_storage._endTrackingNamesLegacyNrm.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._endTrackingNamesLegacyNrm, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CalculationEngineArchive, rhs: TSCE_CalculationEngineArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._baseDate1904 != rhs_storage._baseDate1904 {return false}
        if _storage._dependencyTracker != rhs_storage._dependencyTracker {return false}
        if _storage._namedReferenceManager != rhs_storage._namedReferenceManager {return false}
        if _storage._excelImportDateMode != rhs_storage._excelImportDateMode {return false}
        if _storage._savedLocaleIdentifierFor42 != rhs_storage._savedLocaleIdentifierFor42 {return false}
        if _storage._documentRandomSeed != rhs_storage._documentRandomSeed {return false}
        if _storage._uuidReferenceMap != rhs_storage._uuidReferenceMap {return false}
        if _storage._documentTimestamp != rhs_storage._documentTimestamp {return false}
        if _storage._documentTimezone != rhs_storage._documentTimezone {return false}
        if _storage._tableUidHistory != rhs_storage._tableUidHistory {return false}
        if _storage._remoteDataStore != rhs_storage._remoteDataStore {return false}
        if _storage._groupNodeMap != rhs_storage._groupNodeMap {return false}
        if _storage._headerNameManager != rhs_storage._headerNameManager {return false}
        if _storage._refsToDirty != rhs_storage._refsToDirty {return false}
        if _storage._savedLocaleIdentifier != rhs_storage._savedLocaleIdentifier {return false}
        if _storage._beginTrackingNamesLegacyNrm != rhs_storage._beginTrackingNamesLegacyNrm {return false}
        if _storage._endTrackingNamesLegacyNrm != rhs_storage._endTrackingNamesLegacyNrm {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CalculationEngineArchive.ExcelImportDateMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}DATE_MODE_1900\0\u{1}DATE_MODE_1900_LEGACY\0\u{1}DATE_MODE_1904_LEGACY\0")
}

extension TSCE_PreserveColumnRowFlagsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreserveColumnRowFlagsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}begin_row_is_absolute\0\u{3}begin_column_is_absolute\0\u{3}end_row_is_absolute\0\u{3}end_column_is_absolute\0")

  public var isInitialized: Bool {
    if self._beginRowIsAbsolute == nil {return false}
    if self._beginColumnIsAbsolute == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._beginRowIsAbsolute) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._beginColumnIsAbsolute) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._endRowIsAbsolute) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._endColumnIsAbsolute) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._beginRowIsAbsolute {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._beginColumnIsAbsolute {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._endRowIsAbsolute {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._endColumnIsAbsolute {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_PreserveColumnRowFlagsArchive, rhs: TSCE_PreserveColumnRowFlagsArchive) -> Bool {
    if lhs._beginRowIsAbsolute != rhs._beginRowIsAbsolute {return false}
    if lhs._beginColumnIsAbsolute != rhs._beginColumnIsAbsolute {return false}
    if lhs._endRowIsAbsolute != rhs._endRowIsAbsolute {return false}
    if lhs._endColumnIsAbsolute != rhs._endColumnIsAbsolute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CategoryReferenceArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CategoryReferenceArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_by_uid\0\u{3}column_uid\0\u{3}aggregate_type\0\u{3}group_level\0\u{4}\u{2}group_uids\0\u{3}preserve_flags\0\u{3}relative_column\0\u{3}relative_group_uid\0\u{3}absolute_group_uid\0\u{3}option_refers_to_pivot_rows\0\u{3}option_refers_to_pivot_columns\0\u{3}agg_index_level\0\u{3}option_show_aggregate_name\0")

  fileprivate class _StorageClass {
    var _groupByUid: TSP_UUID? = nil
    var _columnUid: TSP_UUID? = nil
    var _aggregateType: UInt32? = nil
    var _groupLevel: Int32? = nil
    var _groupUids: TSCE_CategoryReferenceArchive.CatRefUidList? = nil
    var _preserveFlags: TSCE_PreserveColumnRowFlagsArchive? = nil
    var _relativeColumn: Int32? = nil
    var _relativeGroupUid: TSP_UUID? = nil
    var _absoluteGroupUid: TSP_UUID? = nil
    var _optionRefersToPivotRows: Bool? = nil
    var _optionRefersToPivotColumns: Bool? = nil
    var _aggIndexLevel: UInt32? = nil
    var _optionShowAggregateName: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _groupByUid = source._groupByUid
      _columnUid = source._columnUid
      _aggregateType = source._aggregateType
      _groupLevel = source._groupLevel
      _groupUids = source._groupUids
      _preserveFlags = source._preserveFlags
      _relativeColumn = source._relativeColumn
      _relativeGroupUid = source._relativeGroupUid
      _absoluteGroupUid = source._absoluteGroupUid
      _optionRefersToPivotRows = source._optionRefersToPivotRows
      _optionRefersToPivotColumns = source._optionRefersToPivotColumns
      _aggIndexLevel = source._aggIndexLevel
      _optionShowAggregateName = source._optionShowAggregateName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._groupByUid == nil {return false}
      if _storage._columnUid == nil {return false}
      if _storage._aggregateType == nil {return false}
      if _storage._groupLevel == nil {return false}
      if let v = _storage._groupByUid, !v.isInitialized {return false}
      if let v = _storage._columnUid, !v.isInitialized {return false}
      if let v = _storage._groupUids, !v.isInitialized {return false}
      if let v = _storage._preserveFlags, !v.isInitialized {return false}
      if let v = _storage._relativeGroupUid, !v.isInitialized {return false}
      if let v = _storage._absoluteGroupUid, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._groupByUid) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._columnUid) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._aggregateType) }()
        case 4: try { try decoder.decodeSingularSInt32Field(value: &_storage._groupLevel) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._groupUids) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._preserveFlags) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._relativeColumn) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._relativeGroupUid) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._absoluteGroupUid) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._optionRefersToPivotRows) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._optionRefersToPivotColumns) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._aggIndexLevel) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._optionShowAggregateName) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._groupByUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._columnUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._aggregateType {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._groupLevel {
        try visitor.visitSingularSInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._groupUids {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._preserveFlags {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._relativeColumn {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._relativeGroupUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._absoluteGroupUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._optionRefersToPivotRows {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._optionRefersToPivotColumns {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._aggIndexLevel {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._optionShowAggregateName {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CategoryReferenceArchive, rhs: TSCE_CategoryReferenceArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._groupByUid != rhs_storage._groupByUid {return false}
        if _storage._columnUid != rhs_storage._columnUid {return false}
        if _storage._aggregateType != rhs_storage._aggregateType {return false}
        if _storage._groupLevel != rhs_storage._groupLevel {return false}
        if _storage._groupUids != rhs_storage._groupUids {return false}
        if _storage._preserveFlags != rhs_storage._preserveFlags {return false}
        if _storage._relativeColumn != rhs_storage._relativeColumn {return false}
        if _storage._relativeGroupUid != rhs_storage._relativeGroupUid {return false}
        if _storage._absoluteGroupUid != rhs_storage._absoluteGroupUid {return false}
        if _storage._optionRefersToPivotRows != rhs_storage._optionRefersToPivotRows {return false}
        if _storage._optionRefersToPivotColumns != rhs_storage._optionRefersToPivotColumns {return false}
        if _storage._aggIndexLevel != rhs_storage._aggIndexLevel {return false}
        if _storage._optionShowAggregateName != rhs_storage._optionShowAggregateName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CategoryReferenceArchive.CatRefUidList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_CategoryReferenceArchive.protoMessageName + ".CatRefUidList"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uid\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.uid) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.uid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CategoryReferenceArchive.CatRefUidList, rhs: TSCE_CategoryReferenceArchive.CatRefUidList) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ASTNodeArrayArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ASTNodeArrayArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}AST_node\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.astNode) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.astNode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.astNode.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.astNode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ASTNodeArrayArchive, rhs: TSCE_ASTNodeArrayArchive) -> Bool {
    if lhs.astNode != rhs.astNode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ASTNodeArrayArchive.ASTNodeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ADDITION_NODE\0\u{1}SUBTRACTION_NODE\0\u{1}MULTIPLICATION_NODE\0\u{1}DIVISION_NODE\0\u{1}POWER_NODE\0\u{1}CONCATENATION_NODE\0\u{1}GREATER_THAN_NODE\0\u{1}GREATER_THAN_OR_EQUAL_TO_NODE\0\u{1}LESS_THAN_NODE\0\u{1}LESS_THAN_OR_EQUAL_TO_NODE\0\u{1}EQUAL_TO_NODE\0\u{1}NOT_EQUAL_TO_NODE\0\u{1}NEGATION_NODE\0\u{1}PLUS_SIGN_NODE\0\u{1}PERCENT_NODE\0\u{1}FUNCTION_NODE\0\u{1}NUMBER_NODE\0\u{1}BOOLEAN_NODE\0\u{1}STRING_NODE\0\u{1}DATE_NODE\0\u{1}DURATION_NODE\0\u{1}EMPTY_ARGUMENT_NODE\0\u{1}TOKEN_NODE\0\u{1}ARRAY_NODE\0\u{1}LIST_NODE\0\u{1}THUNK_NODE\0\u{1}LOCAL_CELL_REFERENCE_NODE\0\u{1}CROSS_TABLE_CELL_REFERENCE_NODE\0\u{1}COLON_NODE\0\u{1}REFERENCE_ERROR_NODE\0\u{1}UNKNOWN_FUNCTION_NODE\0\u{1}APPEND_WHITESPACE_NODE\0\u{1}PREPEND_WHITESPACE_NODE\0\u{1}BEGIN_THUNK_NODE\0\u{1}END_THUNK_NODE\0\u{1}CELL_REFERENCE_NODE\0\u{2}\u{9}COLON_NODE_WITH_UIDS\0\u{1}REFERENCE_ERROR_WITH_UIDS\0\u{2}\u{2}UID_REFERENCE_NODE\0\u{2}\u{4}LET_BIND_NODE\0\u{1}VAR_NODE\0\u{1}END_SCOPE_NODE\0\u{1}LAMBDA_NODE\0\u{1}BEGIN_LAMBDA_THUNK_NODE\0\u{1}END_LAMBDA_THUNK_NODE\0\u{2}\u{6}LINKED_CELL_REF_NODE\0\u{1}LINKED_COLUMN_REF_NODE\0\u{1}LINKED_ROW_REF_NODE\0\u{1}CATEGORY_REF_NODE\0\u{1}COLON_TRACT_NODE\0\u{1}VIEW_TRACT_REF_NODE\0\u{1}INTERSECTION_NODE\0\u{1}SPILL_RANGE_NODE\0")
}

extension TSCE_ASTNodeArrayArchive.ASTUidTractPurpose: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UIDS_INCLUDED\0\u{1}UIDS_PREMERGE\0\u{1}UIDS_PREMOVEREGION\0\u{1}UIDS_EXCLUDED\0\u{1}UIDS_ACTIVE\0\u{1}UIDS_PREMERGE_TOPLEFT\0\u{1}UIDS_REMOVED_BY_MOVE\0\u{1}FULLTUPLE_ROW_COLUMN_HEADER\0\u{1}FULLTUPLE_AGGREGATE_RULE_UID\0\u{1}FULLTUPLE_ROW_COLUMN_RULE_VALUE_PAIRS\0")
}

extension TSCE_ASTNodeArrayArchive.ASTLocalCellReferenceNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_ASTNodeArrayArchive.protoMessageName + ".ASTLocalCellReferenceNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}row_handle\0\u{3}column_handle\0\u{3}row_is_sticky\0\u{3}column_is_sticky\0")

  public var isInitialized: Bool {
    if self._rowHandle == nil {return false}
    if self._columnHandle == nil {return false}
    if self._rowIsSticky == nil {return false}
    if self._columnIsSticky == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._rowHandle) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._columnHandle) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._rowIsSticky) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._columnIsSticky) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rowHandle {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._columnHandle {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._rowIsSticky {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._columnIsSticky {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ASTNodeArrayArchive.ASTLocalCellReferenceNodeArchive, rhs: TSCE_ASTNodeArrayArchive.ASTLocalCellReferenceNodeArchive) -> Bool {
    if lhs._rowHandle != rhs._rowHandle {return false}
    if lhs._columnHandle != rhs._columnHandle {return false}
    if lhs._rowIsSticky != rhs._rowIsSticky {return false}
    if lhs._columnIsSticky != rhs._columnIsSticky {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ASTNodeArrayArchive.ASTCrossTableCellReferenceNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_ASTNodeArrayArchive.protoMessageName + ".ASTCrossTableCellReferenceNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}row_handle\0\u{3}column_handle\0\u{3}row_is_sticky\0\u{3}column_is_sticky\0\u{3}table_id\0\u{3}AST_reference_whitespace_after_sheet_name\0\u{3}AST_reference_whitespace_before_table_name\0\u{3}AST_reference_whitespace_after_table_name\0\u{3}AST_reference_whitespace_before_cell_address\0")

  public var isInitialized: Bool {
    if self._rowHandle == nil {return false}
    if self._columnHandle == nil {return false}
    if self._rowIsSticky == nil {return false}
    if self._columnIsSticky == nil {return false}
    if self._tableID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._rowHandle) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._columnHandle) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._rowIsSticky) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._columnIsSticky) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._tableID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._astReferenceWhitespaceAfterSheetName) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._astReferenceWhitespaceBeforeTableName) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._astReferenceWhitespaceAfterTableName) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._astReferenceWhitespaceBeforeCellAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rowHandle {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._columnHandle {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._rowIsSticky {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._columnIsSticky {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._tableID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._astReferenceWhitespaceAfterSheetName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._astReferenceWhitespaceBeforeTableName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._astReferenceWhitespaceAfterTableName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._astReferenceWhitespaceBeforeCellAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ASTNodeArrayArchive.ASTCrossTableCellReferenceNodeArchive, rhs: TSCE_ASTNodeArrayArchive.ASTCrossTableCellReferenceNodeArchive) -> Bool {
    if lhs._rowHandle != rhs._rowHandle {return false}
    if lhs._columnHandle != rhs._columnHandle {return false}
    if lhs._rowIsSticky != rhs._rowIsSticky {return false}
    if lhs._columnIsSticky != rhs._columnIsSticky {return false}
    if lhs._tableID != rhs._tableID {return false}
    if lhs._astReferenceWhitespaceAfterSheetName != rhs._astReferenceWhitespaceAfterSheetName {return false}
    if lhs._astReferenceWhitespaceBeforeTableName != rhs._astReferenceWhitespaceBeforeTableName {return false}
    if lhs._astReferenceWhitespaceAfterTableName != rhs._astReferenceWhitespaceAfterTableName {return false}
    if lhs._astReferenceWhitespaceBeforeCellAddress != rhs._astReferenceWhitespaceBeforeCellAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ASTNodeArrayArchive.ASTColumnCoordinateArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_ASTNodeArrayArchive.protoMessageName + ".ASTColumnCoordinateArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}column\0\u{1}absolute\0")

  public var isInitialized: Bool {
    if self._column == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularSInt32Field(value: &self._column) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._absolute) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._column {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._absolute {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ASTNodeArrayArchive.ASTColumnCoordinateArchive, rhs: TSCE_ASTNodeArrayArchive.ASTColumnCoordinateArchive) -> Bool {
    if lhs._column != rhs._column {return false}
    if lhs._absolute != rhs._absolute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ASTNodeArrayArchive.ASTRowCoordinateArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_ASTNodeArrayArchive.protoMessageName + ".ASTRowCoordinateArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}row\0\u{1}absolute\0")

  public var isInitialized: Bool {
    if self._row == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularSInt32Field(value: &self._row) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._absolute) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._row {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._absolute {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ASTNodeArrayArchive.ASTRowCoordinateArchive, rhs: TSCE_ASTNodeArrayArchive.ASTRowCoordinateArchive) -> Bool {
    if lhs._row != rhs._row {return false}
    if lhs._absolute != rhs._absolute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ASTNodeArrayArchive.ASTUidList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_ASTNodeArrayArchive.protoMessageName + ".ASTUidList"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uid\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.uid) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.uid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ASTNodeArrayArchive.ASTUidList, rhs: TSCE_ASTNodeArrayArchive.ASTUidList) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ASTNodeArrayArchive.ASTUidTract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_ASTNodeArrayArchive.protoMessageName + ".ASTUidTract"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}columnUids\0\u{1}rowUids\0\u{3}is_range_ref\0\u{1}purpose\0\u{3}preserve_rectangular\0")

  public var isInitialized: Bool {
    if self._columnUids == nil {return false}
    if self._rowUids == nil {return false}
    if let v = self._columnUids, !v.isInitialized {return false}
    if let v = self._rowUids, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._columnUids) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rowUids) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._isRangeRef) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._purpose) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._preserveRectangular) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._columnUids {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rowUids {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._isRangeRef {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._purpose {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._preserveRectangular {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ASTNodeArrayArchive.ASTUidTract, rhs: TSCE_ASTNodeArrayArchive.ASTUidTract) -> Bool {
    if lhs._columnUids != rhs._columnUids {return false}
    if lhs._rowUids != rhs._rowUids {return false}
    if lhs._isRangeRef != rhs._isRangeRef {return false}
    if lhs._purpose != rhs._purpose {return false}
    if lhs._preserveRectangular != rhs._preserveRectangular {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ASTNodeArrayArchive.ASTStickyBits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_ASTNodeArrayArchive.protoMessageName + ".ASTStickyBits"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}begin_row_is_absolute\0\u{3}begin_column_is_absolute\0\u{3}end_row_is_absolute\0\u{3}end_column_is_absolute\0")

  public var isInitialized: Bool {
    if self._beginRowIsAbsolute == nil {return false}
    if self._beginColumnIsAbsolute == nil {return false}
    if self._endRowIsAbsolute == nil {return false}
    if self._endColumnIsAbsolute == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._beginRowIsAbsolute) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._beginColumnIsAbsolute) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._endRowIsAbsolute) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._endColumnIsAbsolute) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._beginRowIsAbsolute {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._beginColumnIsAbsolute {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._endRowIsAbsolute {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._endColumnIsAbsolute {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ASTNodeArrayArchive.ASTStickyBits, rhs: TSCE_ASTNodeArrayArchive.ASTStickyBits) -> Bool {
    if lhs._beginRowIsAbsolute != rhs._beginRowIsAbsolute {return false}
    if lhs._beginColumnIsAbsolute != rhs._beginColumnIsAbsolute {return false}
    if lhs._endRowIsAbsolute != rhs._endRowIsAbsolute {return false}
    if lhs._endColumnIsAbsolute != rhs._endColumnIsAbsolute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ASTNodeArrayArchive.ASTUidTractList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_ASTNodeArrayArchive.protoMessageName + ".ASTUidTractList"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}tract\0\u{3}sticky_bits\0")

  public var isInitialized: Bool {
    if self._stickyBits == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.tract) {return false}
    if let v = self._stickyBits, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tract) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._stickyBits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tract.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tract, fieldNumber: 1)
    }
    try { if let v = self._stickyBits {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ASTNodeArrayArchive.ASTUidTractList, rhs: TSCE_ASTNodeArrayArchive.ASTUidTractList) -> Bool {
    if lhs.tract != rhs.tract {return false}
    if lhs._stickyBits != rhs._stickyBits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ASTNodeArrayArchive.ASTUidCoordinateArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_ASTNodeArrayArchive.protoMessageName + ".ASTUidCoordinateArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}column_uid\0\u{3}row_uid\0\u{3}column_absolute\0\u{3}row_absolute\0")

  public var isInitialized: Bool {
    if self._columnUid == nil {return false}
    if self._rowUid == nil {return false}
    if self._columnAbsolute == nil {return false}
    if self._rowAbsolute == nil {return false}
    if let v = self._columnUid, !v.isInitialized {return false}
    if let v = self._rowUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._columnUid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rowUid) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._columnAbsolute) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._rowAbsolute) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._columnUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rowUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._columnAbsolute {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._rowAbsolute {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ASTNodeArrayArchive.ASTUidCoordinateArchive, rhs: TSCE_ASTNodeArrayArchive.ASTUidCoordinateArchive) -> Bool {
    if lhs._columnUid != rhs._columnUid {return false}
    if lhs._rowUid != rhs._rowUid {return false}
    if lhs._columnAbsolute != rhs._columnAbsolute {return false}
    if lhs._rowAbsolute != rhs._rowAbsolute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ASTNodeArrayArchive.ASTCategoryLevels: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_ASTNodeArrayArchive.protoMessageName + ".ASTCategoryLevels"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}AST_column_group_level\0\u{3}AST_row_group_level\0\u{3}AST_agg_index_level\0")

  public var isInitialized: Bool {
    if self._astColumnGroupLevel == nil {return false}
    if self._astRowGroupLevel == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._astColumnGroupLevel) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._astRowGroupLevel) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._astAggIndexLevel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._astColumnGroupLevel {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._astRowGroupLevel {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._astAggIndexLevel {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ASTNodeArrayArchive.ASTCategoryLevels, rhs: TSCE_ASTNodeArrayArchive.ASTCategoryLevels) -> Bool {
    if lhs._astColumnGroupLevel != rhs._astColumnGroupLevel {return false}
    if lhs._astRowGroupLevel != rhs._astRowGroupLevel {return false}
    if lhs._astAggIndexLevel != rhs._astAggIndexLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ASTNodeArrayArchive.ASTCategoryReferenceArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_ASTNodeArrayArchive.protoMessageName + ".ASTCategoryReferenceArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}category_ref\0")

  public var isInitialized: Bool {
    if self._categoryRef == nil {return false}
    if let v = self._categoryRef, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._categoryRef) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._categoryRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ASTNodeArrayArchive.ASTCategoryReferenceArchive, rhs: TSCE_ASTNodeArrayArchive.ASTCategoryReferenceArchive) -> Bool {
    if lhs._categoryRef != rhs._categoryRef {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ASTNodeArrayArchive.ASTColonTractArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_ASTNodeArrayArchive.protoMessageName + ".ASTColonTractArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}relative_column\0\u{3}relative_row\0\u{3}absolute_column\0\u{3}absolute_row\0\u{3}preserve_rectangular\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.relativeColumn) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.relativeRow) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.absoluteColumn) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.absoluteRow) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.relativeColumn) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.relativeRow) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.absoluteColumn) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.absoluteRow) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._preserveRectangular) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.relativeColumn.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relativeColumn, fieldNumber: 1)
    }
    if !self.relativeRow.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relativeRow, fieldNumber: 2)
    }
    if !self.absoluteColumn.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.absoluteColumn, fieldNumber: 3)
    }
    if !self.absoluteRow.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.absoluteRow, fieldNumber: 4)
    }
    try { if let v = self._preserveRectangular {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ASTNodeArrayArchive.ASTColonTractArchive, rhs: TSCE_ASTNodeArrayArchive.ASTColonTractArchive) -> Bool {
    if lhs.relativeColumn != rhs.relativeColumn {return false}
    if lhs.relativeRow != rhs.relativeRow {return false}
    if lhs.absoluteColumn != rhs.absoluteColumn {return false}
    if lhs.absoluteRow != rhs.absoluteRow {return false}
    if lhs._preserveRectangular != rhs._preserveRectangular {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractRelativeRangeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_ASTNodeArrayArchive.ASTColonTractArchive.protoMessageName + ".ASTColonTractRelativeRangeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}range_begin\0\u{3}range_end\0")

  public var isInitialized: Bool {
    if self._rangeBegin == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._rangeBegin) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._rangeEnd) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rangeBegin {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rangeEnd {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractRelativeRangeArchive, rhs: TSCE_ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractRelativeRangeArchive) -> Bool {
    if lhs._rangeBegin != rhs._rangeBegin {return false}
    if lhs._rangeEnd != rhs._rangeEnd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractAbsoluteRangeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_ASTNodeArrayArchive.ASTColonTractArchive.protoMessageName + ".ASTColonTractAbsoluteRangeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}range_begin\0\u{3}range_end\0")

  public var isInitialized: Bool {
    if self._rangeBegin == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._rangeBegin) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._rangeEnd) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rangeBegin {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rangeEnd {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractAbsoluteRangeArchive, rhs: TSCE_ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractAbsoluteRangeArchive) -> Bool {
    if lhs._rangeBegin != rhs._rangeBegin {return false}
    if lhs._rangeEnd != rhs._rangeEnd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ASTNodeArrayArchive.ASTCrossTableReferenceExtraInfoArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_ASTNodeArrayArchive.protoMessageName + ".ASTCrossTableReferenceExtraInfoArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}table_id\0\u{3}AST_reference_whitespace_after_sheet_name\0\u{3}AST_reference_whitespace_before_table_name\0\u{3}AST_reference_whitespace_after_table_name\0\u{3}AST_reference_whitespace_before_cell_address\0")

  public var isInitialized: Bool {
    if self._tableID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tableID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._astReferenceWhitespaceAfterSheetName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._astReferenceWhitespaceBeforeTableName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._astReferenceWhitespaceAfterTableName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._astReferenceWhitespaceBeforeCellAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tableID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._astReferenceWhitespaceAfterSheetName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._astReferenceWhitespaceBeforeTableName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._astReferenceWhitespaceAfterTableName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._astReferenceWhitespaceBeforeCellAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ASTNodeArrayArchive.ASTCrossTableReferenceExtraInfoArchive, rhs: TSCE_ASTNodeArrayArchive.ASTCrossTableReferenceExtraInfoArchive) -> Bool {
    if lhs._tableID != rhs._tableID {return false}
    if lhs._astReferenceWhitespaceAfterSheetName != rhs._astReferenceWhitespaceAfterSheetName {return false}
    if lhs._astReferenceWhitespaceBeforeTableName != rhs._astReferenceWhitespaceBeforeTableName {return false}
    if lhs._astReferenceWhitespaceAfterTableName != rhs._astReferenceWhitespaceAfterTableName {return false}
    if lhs._astReferenceWhitespaceBeforeCellAddress != rhs._astReferenceWhitespaceBeforeCellAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ASTNodeArrayArchive.ASTLambdaIdentsListArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_ASTNodeArrayArchive.protoMessageName + ".ASTLambdaIdentsListArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}AST_identifier_string\0\u{3}AST_first_symbol\0\u{3}AST_whitespace_before_idents\0\u{3}AST_whitespace_after_idents\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.astIdentifierString) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._astFirstSymbol) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._astWhitespaceBeforeIdents) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._astWhitespaceAfterIdents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.astIdentifierString.isEmpty {
      try visitor.visitRepeatedStringField(value: self.astIdentifierString, fieldNumber: 1)
    }
    try { if let v = self._astFirstSymbol {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._astWhitespaceBeforeIdents {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._astWhitespaceAfterIdents {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ASTNodeArrayArchive.ASTLambdaIdentsListArchive, rhs: TSCE_ASTNodeArrayArchive.ASTLambdaIdentsListArchive) -> Bool {
    if lhs.astIdentifierString != rhs.astIdentifierString {return false}
    if lhs._astFirstSymbol != rhs._astFirstSymbol {return false}
    if lhs._astWhitespaceBeforeIdents != rhs._astWhitespaceBeforeIdents {return false}
    if lhs._astWhitespaceAfterIdents != rhs._astWhitespaceAfterIdents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ASTNodeArrayArchive.ASTNodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_ASTNodeArrayArchive.protoMessageName + ".ASTNodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}AST_node_type\0\u{3}AST_function_node_index\0\u{3}AST_function_node_numArgs\0\u{3}AST_number_node_number\0\u{3}AST_boolean_node_boolean\0\u{3}AST_string_node_string\0\u{3}AST_date_node_dateNum\0\u{3}AST_duration_node_unitNum\0\u{3}AST_duration_node_unit\0\u{3}AST_token_node_boolean\0\u{3}AST_array_node_numCol\0\u{3}AST_array_node_numRow\0\u{3}AST_list_node_numArgs\0\u{3}AST_thunk_node_array\0\u{3}AST_local_cell_reference_node_reference\0\u{3}AST_cross_table_cell_reference_node_reference\0\u{3}AST_unknown_function_node_string\0\u{3}AST_unknown_function_node_numArgs\0\u{3}AST_date_node_suppress_date_format\0\u{3}AST_date_node_suppress_time_format\0\u{3}AST_date_node_date_time_format\0\u{3}AST_duration_node_style\0\u{3}AST_duration_node_duration_unit_largest\0\u{3}AST_duration_node_duration_unit_smallest\0\u{3}AST_whitespace\0\u{3}AST_column\0\u{3}AST_row\0\u{3}AST_cross_table_reference_extra_info\0\u{3}AST_duration_node_use_automatic_units\0\u{3}AST_uid_coordinate\0\u{4}\u{3}AST_sticky_bits\0\u{3}AST_let_identifier\0\u{3}AST_let_whitespace\0\u{3}AST_let_is_continuation\0\u{3}AST_symbol\0\u{3}AST_tract_list\0\u{3}AST_category_ref\0\u{3}AST_colon_tract\0\u{3}AST_frozen_sticky_bits\0\u{3}AST_number_node_decimal_low\0\u{3}AST_number_node_decimal_high\0\u{3}AST_category_levels\0\u{3}AST_lambda_idents\0\u{3}AST_range_context\0\u{3}upgrade_node_type\0")

  fileprivate class _StorageClass {
    var _astNodeType: TSCE_ASTNodeArrayArchive.ASTNodeType? = nil
    var _astFunctionNodeIndex: UInt32? = nil
    var _astFunctionNodeNumArgs: UInt32? = nil
    var _astNumberNodeNumber: Double? = nil
    var _astBooleanNodeBoolean: Bool? = nil
    var _astStringNodeString: String? = nil
    var _astDateNodeDateNum: Double? = nil
    var _astDateNodeSuppressDateFormat: Bool? = nil
    var _astDateNodeSuppressTimeFormat: Bool? = nil
    var _astDateNodeDateTimeFormat: String? = nil
    var _astDurationNodeUnitNum: Double? = nil
    var _astDurationNodeUnit: Int32? = nil
    var _astDurationNodeStyle: UInt32? = nil
    var _astDurationNodeDurationUnitLargest: UInt32? = nil
    var _astDurationNodeDurationUnitSmallest: UInt32? = nil
    var _astDurationNodeUseAutomaticUnits: Bool? = nil
    var _astTokenNodeBoolean: Bool? = nil
    var _astArrayNodeNumCol: UInt32? = nil
    var _astArrayNodeNumRow: UInt32? = nil
    var _astListNodeNumArgs: UInt32? = nil
    var _astThunkNodeArray: TSCE_ASTNodeArrayArchive? = nil
    var _astLocalCellReferenceNodeReference: TSCE_ASTNodeArrayArchive.ASTLocalCellReferenceNodeArchive? = nil
    var _astCrossTableCellReferenceNodeReference: TSCE_ASTNodeArrayArchive.ASTCrossTableCellReferenceNodeArchive? = nil
    var _astUnknownFunctionNodeString: String? = nil
    var _astUnknownFunctionNodeNumArgs: UInt32? = nil
    var _astWhitespace: String? = nil
    var _astColumn: TSCE_ASTNodeArrayArchive.ASTColumnCoordinateArchive? = nil
    var _astRow: TSCE_ASTNodeArrayArchive.ASTRowCoordinateArchive? = nil
    var _astCrossTableReferenceExtraInfo: TSCE_ASTNodeArrayArchive.ASTCrossTableReferenceExtraInfoArchive? = nil
    var _astUidCoordinate: TSCE_ASTNodeArrayArchive.ASTUidCoordinateArchive? = nil
    var _astStickyBits: TSCE_ASTNodeArrayArchive.ASTStickyBits? = nil
    var _astFrozenStickyBits: TSCE_ASTNodeArrayArchive.ASTStickyBits? = nil
    var _astLetIdentifier: String? = nil
    var _astLetWhitespace: String? = nil
    var _astLetIsContinuation: Bool? = nil
    var _astSymbol: UInt32? = nil
    var _astTractList: TSCE_ASTNodeArrayArchive.ASTUidTractList? = nil
    var _astCategoryRef: TSCE_ASTNodeArrayArchive.ASTCategoryReferenceArchive? = nil
    var _astColonTract: TSCE_ASTNodeArrayArchive.ASTColonTractArchive? = nil
    var _astNumberNodeDecimalLow: UInt64? = nil
    var _astNumberNodeDecimalHigh: UInt64? = nil
    var _astCategoryLevels: TSCE_ASTNodeArrayArchive.ASTCategoryLevels? = nil
    var _astLambdaIdents: TSCE_ASTNodeArrayArchive.ASTLambdaIdentsListArchive? = nil
    var _astRangeContext: UInt32? = nil
    var _upgradeNodeType: TSCE_ASTNodeArrayArchive.ASTNodeType? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _astNodeType = source._astNodeType
      _astFunctionNodeIndex = source._astFunctionNodeIndex
      _astFunctionNodeNumArgs = source._astFunctionNodeNumArgs
      _astNumberNodeNumber = source._astNumberNodeNumber
      _astBooleanNodeBoolean = source._astBooleanNodeBoolean
      _astStringNodeString = source._astStringNodeString
      _astDateNodeDateNum = source._astDateNodeDateNum
      _astDateNodeSuppressDateFormat = source._astDateNodeSuppressDateFormat
      _astDateNodeSuppressTimeFormat = source._astDateNodeSuppressTimeFormat
      _astDateNodeDateTimeFormat = source._astDateNodeDateTimeFormat
      _astDurationNodeUnitNum = source._astDurationNodeUnitNum
      _astDurationNodeUnit = source._astDurationNodeUnit
      _astDurationNodeStyle = source._astDurationNodeStyle
      _astDurationNodeDurationUnitLargest = source._astDurationNodeDurationUnitLargest
      _astDurationNodeDurationUnitSmallest = source._astDurationNodeDurationUnitSmallest
      _astDurationNodeUseAutomaticUnits = source._astDurationNodeUseAutomaticUnits
      _astTokenNodeBoolean = source._astTokenNodeBoolean
      _astArrayNodeNumCol = source._astArrayNodeNumCol
      _astArrayNodeNumRow = source._astArrayNodeNumRow
      _astListNodeNumArgs = source._astListNodeNumArgs
      _astThunkNodeArray = source._astThunkNodeArray
      _astLocalCellReferenceNodeReference = source._astLocalCellReferenceNodeReference
      _astCrossTableCellReferenceNodeReference = source._astCrossTableCellReferenceNodeReference
      _astUnknownFunctionNodeString = source._astUnknownFunctionNodeString
      _astUnknownFunctionNodeNumArgs = source._astUnknownFunctionNodeNumArgs
      _astWhitespace = source._astWhitespace
      _astColumn = source._astColumn
      _astRow = source._astRow
      _astCrossTableReferenceExtraInfo = source._astCrossTableReferenceExtraInfo
      _astUidCoordinate = source._astUidCoordinate
      _astStickyBits = source._astStickyBits
      _astFrozenStickyBits = source._astFrozenStickyBits
      _astLetIdentifier = source._astLetIdentifier
      _astLetWhitespace = source._astLetWhitespace
      _astLetIsContinuation = source._astLetIsContinuation
      _astSymbol = source._astSymbol
      _astTractList = source._astTractList
      _astCategoryRef = source._astCategoryRef
      _astColonTract = source._astColonTract
      _astNumberNodeDecimalLow = source._astNumberNodeDecimalLow
      _astNumberNodeDecimalHigh = source._astNumberNodeDecimalHigh
      _astCategoryLevels = source._astCategoryLevels
      _astLambdaIdents = source._astLambdaIdents
      _astRangeContext = source._astRangeContext
      _upgradeNodeType = source._upgradeNodeType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._astNodeType == nil {return false}
      if let v = _storage._astThunkNodeArray, !v.isInitialized {return false}
      if let v = _storage._astLocalCellReferenceNodeReference, !v.isInitialized {return false}
      if let v = _storage._astCrossTableCellReferenceNodeReference, !v.isInitialized {return false}
      if let v = _storage._astColumn, !v.isInitialized {return false}
      if let v = _storage._astRow, !v.isInitialized {return false}
      if let v = _storage._astCrossTableReferenceExtraInfo, !v.isInitialized {return false}
      if let v = _storage._astUidCoordinate, !v.isInitialized {return false}
      if let v = _storage._astStickyBits, !v.isInitialized {return false}
      if let v = _storage._astFrozenStickyBits, !v.isInitialized {return false}
      if let v = _storage._astTractList, !v.isInitialized {return false}
      if let v = _storage._astCategoryRef, !v.isInitialized {return false}
      if let v = _storage._astColonTract, !v.isInitialized {return false}
      if let v = _storage._astCategoryLevels, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._astNodeType) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._astFunctionNodeIndex) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._astFunctionNodeNumArgs) }()
        case 4: try { try decoder.decodeSingularDoubleField(value: &_storage._astNumberNodeNumber) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._astBooleanNodeBoolean) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._astStringNodeString) }()
        case 7: try { try decoder.decodeSingularDoubleField(value: &_storage._astDateNodeDateNum) }()
        case 8: try { try decoder.decodeSingularDoubleField(value: &_storage._astDurationNodeUnitNum) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._astDurationNodeUnit) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._astTokenNodeBoolean) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._astArrayNodeNumCol) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._astArrayNodeNumRow) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._astListNodeNumArgs) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._astThunkNodeArray) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._astLocalCellReferenceNodeReference) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._astCrossTableCellReferenceNodeReference) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._astUnknownFunctionNodeString) }()
        case 18: try { try decoder.decodeSingularUInt32Field(value: &_storage._astUnknownFunctionNodeNumArgs) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._astDateNodeSuppressDateFormat) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._astDateNodeSuppressTimeFormat) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._astDateNodeDateTimeFormat) }()
        case 22: try { try decoder.decodeSingularUInt32Field(value: &_storage._astDurationNodeStyle) }()
        case 23: try { try decoder.decodeSingularUInt32Field(value: &_storage._astDurationNodeDurationUnitLargest) }()
        case 24: try { try decoder.decodeSingularUInt32Field(value: &_storage._astDurationNodeDurationUnitSmallest) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._astWhitespace) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._astColumn) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._astRow) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._astCrossTableReferenceExtraInfo) }()
        case 29: try { try decoder.decodeSingularBoolField(value: &_storage._astDurationNodeUseAutomaticUnits) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._astUidCoordinate) }()
        case 33: try { try decoder.decodeSingularMessageField(value: &_storage._astStickyBits) }()
        case 34: try { try decoder.decodeSingularStringField(value: &_storage._astLetIdentifier) }()
        case 35: try { try decoder.decodeSingularStringField(value: &_storage._astLetWhitespace) }()
        case 36: try { try decoder.decodeSingularBoolField(value: &_storage._astLetIsContinuation) }()
        case 37: try { try decoder.decodeSingularUInt32Field(value: &_storage._astSymbol) }()
        case 38: try { try decoder.decodeSingularMessageField(value: &_storage._astTractList) }()
        case 39: try { try decoder.decodeSingularMessageField(value: &_storage._astCategoryRef) }()
        case 40: try { try decoder.decodeSingularMessageField(value: &_storage._astColonTract) }()
        case 41: try { try decoder.decodeSingularMessageField(value: &_storage._astFrozenStickyBits) }()
        case 42: try { try decoder.decodeSingularUInt64Field(value: &_storage._astNumberNodeDecimalLow) }()
        case 43: try { try decoder.decodeSingularUInt64Field(value: &_storage._astNumberNodeDecimalHigh) }()
        case 44: try { try decoder.decodeSingularMessageField(value: &_storage._astCategoryLevels) }()
        case 45: try { try decoder.decodeSingularMessageField(value: &_storage._astLambdaIdents) }()
        case 46: try { try decoder.decodeSingularUInt32Field(value: &_storage._astRangeContext) }()
        case 47: try { try decoder.decodeSingularEnumField(value: &_storage._upgradeNodeType) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._astNodeType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._astFunctionNodeIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._astFunctionNodeNumArgs {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._astNumberNodeNumber {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._astBooleanNodeBoolean {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._astStringNodeString {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._astDateNodeDateNum {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._astDurationNodeUnitNum {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._astDurationNodeUnit {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._astTokenNodeBoolean {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._astArrayNodeNumCol {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._astArrayNodeNumRow {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._astListNodeNumArgs {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._astThunkNodeArray {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._astLocalCellReferenceNodeReference {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._astCrossTableCellReferenceNodeReference {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._astUnknownFunctionNodeString {
        try visitor.visitSingularStringField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._astUnknownFunctionNodeNumArgs {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._astDateNodeSuppressDateFormat {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._astDateNodeSuppressTimeFormat {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._astDateNodeDateTimeFormat {
        try visitor.visitSingularStringField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._astDurationNodeStyle {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._astDurationNodeDurationUnitLargest {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._astDurationNodeDurationUnitSmallest {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._astWhitespace {
        try visitor.visitSingularStringField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._astColumn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._astRow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      } }()
      try { if let v = _storage._astCrossTableReferenceExtraInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._astDurationNodeUseAutomaticUnits {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._astUidCoordinate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._astStickyBits {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      } }()
      try { if let v = _storage._astLetIdentifier {
        try visitor.visitSingularStringField(value: v, fieldNumber: 34)
      } }()
      try { if let v = _storage._astLetWhitespace {
        try visitor.visitSingularStringField(value: v, fieldNumber: 35)
      } }()
      try { if let v = _storage._astLetIsContinuation {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 36)
      } }()
      try { if let v = _storage._astSymbol {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 37)
      } }()
      try { if let v = _storage._astTractList {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      } }()
      try { if let v = _storage._astCategoryRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      } }()
      try { if let v = _storage._astColonTract {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      } }()
      try { if let v = _storage._astFrozenStickyBits {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      } }()
      try { if let v = _storage._astNumberNodeDecimalLow {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 42)
      } }()
      try { if let v = _storage._astNumberNodeDecimalHigh {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 43)
      } }()
      try { if let v = _storage._astCategoryLevels {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      } }()
      try { if let v = _storage._astLambdaIdents {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      } }()
      try { if let v = _storage._astRangeContext {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 46)
      } }()
      try { if let v = _storage._upgradeNodeType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 47)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ASTNodeArrayArchive.ASTNodeArchive, rhs: TSCE_ASTNodeArrayArchive.ASTNodeArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._astNodeType != rhs_storage._astNodeType {return false}
        if _storage._astFunctionNodeIndex != rhs_storage._astFunctionNodeIndex {return false}
        if _storage._astFunctionNodeNumArgs != rhs_storage._astFunctionNodeNumArgs {return false}
        if _storage._astNumberNodeNumber != rhs_storage._astNumberNodeNumber {return false}
        if _storage._astBooleanNodeBoolean != rhs_storage._astBooleanNodeBoolean {return false}
        if _storage._astStringNodeString != rhs_storage._astStringNodeString {return false}
        if _storage._astDateNodeDateNum != rhs_storage._astDateNodeDateNum {return false}
        if _storage._astDateNodeSuppressDateFormat != rhs_storage._astDateNodeSuppressDateFormat {return false}
        if _storage._astDateNodeSuppressTimeFormat != rhs_storage._astDateNodeSuppressTimeFormat {return false}
        if _storage._astDateNodeDateTimeFormat != rhs_storage._astDateNodeDateTimeFormat {return false}
        if _storage._astDurationNodeUnitNum != rhs_storage._astDurationNodeUnitNum {return false}
        if _storage._astDurationNodeUnit != rhs_storage._astDurationNodeUnit {return false}
        if _storage._astDurationNodeStyle != rhs_storage._astDurationNodeStyle {return false}
        if _storage._astDurationNodeDurationUnitLargest != rhs_storage._astDurationNodeDurationUnitLargest {return false}
        if _storage._astDurationNodeDurationUnitSmallest != rhs_storage._astDurationNodeDurationUnitSmallest {return false}
        if _storage._astDurationNodeUseAutomaticUnits != rhs_storage._astDurationNodeUseAutomaticUnits {return false}
        if _storage._astTokenNodeBoolean != rhs_storage._astTokenNodeBoolean {return false}
        if _storage._astArrayNodeNumCol != rhs_storage._astArrayNodeNumCol {return false}
        if _storage._astArrayNodeNumRow != rhs_storage._astArrayNodeNumRow {return false}
        if _storage._astListNodeNumArgs != rhs_storage._astListNodeNumArgs {return false}
        if _storage._astThunkNodeArray != rhs_storage._astThunkNodeArray {return false}
        if _storage._astLocalCellReferenceNodeReference != rhs_storage._astLocalCellReferenceNodeReference {return false}
        if _storage._astCrossTableCellReferenceNodeReference != rhs_storage._astCrossTableCellReferenceNodeReference {return false}
        if _storage._astUnknownFunctionNodeString != rhs_storage._astUnknownFunctionNodeString {return false}
        if _storage._astUnknownFunctionNodeNumArgs != rhs_storage._astUnknownFunctionNodeNumArgs {return false}
        if _storage._astWhitespace != rhs_storage._astWhitespace {return false}
        if _storage._astColumn != rhs_storage._astColumn {return false}
        if _storage._astRow != rhs_storage._astRow {return false}
        if _storage._astCrossTableReferenceExtraInfo != rhs_storage._astCrossTableReferenceExtraInfo {return false}
        if _storage._astUidCoordinate != rhs_storage._astUidCoordinate {return false}
        if _storage._astStickyBits != rhs_storage._astStickyBits {return false}
        if _storage._astFrozenStickyBits != rhs_storage._astFrozenStickyBits {return false}
        if _storage._astLetIdentifier != rhs_storage._astLetIdentifier {return false}
        if _storage._astLetWhitespace != rhs_storage._astLetWhitespace {return false}
        if _storage._astLetIsContinuation != rhs_storage._astLetIsContinuation {return false}
        if _storage._astSymbol != rhs_storage._astSymbol {return false}
        if _storage._astTractList != rhs_storage._astTractList {return false}
        if _storage._astCategoryRef != rhs_storage._astCategoryRef {return false}
        if _storage._astColonTract != rhs_storage._astColonTract {return false}
        if _storage._astNumberNodeDecimalLow != rhs_storage._astNumberNodeDecimalLow {return false}
        if _storage._astNumberNodeDecimalHigh != rhs_storage._astNumberNodeDecimalHigh {return false}
        if _storage._astCategoryLevels != rhs_storage._astCategoryLevels {return false}
        if _storage._astLambdaIdents != rhs_storage._astLambdaIdents {return false}
        if _storage._astRangeContext != rhs_storage._astRangeContext {return false}
        if _storage._upgradeNodeType != rhs_storage._upgradeNodeType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_FormulaTranslationFlagsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormulaTranslationFlagsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}excel_import_translation\0\u{3}number_to_date_coercion_removal_translation\0\u{3}contains_uid_form_references\0\u{3}contains_frozen_references\0\u{3}returns_percent_formatted\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._excelImportTranslation) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._numberToDateCoercionRemovalTranslation) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._containsUidFormReferences) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._containsFrozenReferences) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._returnsPercentFormatted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._excelImportTranslation {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._numberToDateCoercionRemovalTranslation {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._containsUidFormReferences {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._containsFrozenReferences {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._returnsPercentFormatted {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_FormulaTranslationFlagsArchive, rhs: TSCE_FormulaTranslationFlagsArchive) -> Bool {
    if lhs._excelImportTranslation != rhs._excelImportTranslation {return false}
    if lhs._numberToDateCoercionRemovalTranslation != rhs._numberToDateCoercionRemovalTranslation {return false}
    if lhs._containsUidFormReferences != rhs._containsUidFormReferences {return false}
    if lhs._containsFrozenReferences != rhs._containsFrozenReferences {return false}
    if lhs._returnsPercentFormatted != rhs._returnsPercentFormatted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_FormulaArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormulaArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}AST_node_array\0\u{3}host_column\0\u{3}host_row\0\u{3}host_column_is_negative\0\u{3}host_row_is_negative\0\u{3}translation_flags\0\u{3}host_table_uid\0\u{3}host_column_uid\0\u{3}host_row_uid\0")

  public var isInitialized: Bool {
    if self._astNodeArray == nil {return false}
    if let v = self._astNodeArray, !v.isInitialized {return false}
    if let v = self._hostTableUid, !v.isInitialized {return false}
    if let v = self._hostColumnUid, !v.isInitialized {return false}
    if let v = self._hostRowUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._astNodeArray) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._hostColumn) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._hostRow) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._hostColumnIsNegative) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._hostRowIsNegative) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._translationFlags) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._hostTableUid) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._hostColumnUid) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._hostRowUid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._astNodeArray {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._hostColumn {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hostRow {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._hostColumnIsNegative {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._hostRowIsNegative {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._translationFlags {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._hostTableUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._hostColumnUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._hostRowUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_FormulaArchive, rhs: TSCE_FormulaArchive) -> Bool {
    if lhs._astNodeArray != rhs._astNodeArray {return false}
    if lhs._hostColumn != rhs._hostColumn {return false}
    if lhs._hostRow != rhs._hostRow {return false}
    if lhs._hostColumnIsNegative != rhs._hostColumnIsNegative {return false}
    if lhs._hostRowIsNegative != rhs._hostRowIsNegative {return false}
    if lhs._translationFlags != rhs._translationFlags {return false}
    if lhs._hostTableUid != rhs._hostTableUid {return false}
    if lhs._hostColumnUid != rhs._hostColumnUid {return false}
    if lhs._hostRowUid != rhs._hostRowUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_FunctorArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FunctorArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}formula\0\u{3}num_args\0\u{3}first_symbol\0")

  fileprivate class _StorageClass {
    var _formula: TSCE_FormulaArchive? = nil
    var _numArgs: UInt32? = nil
    var _firstSymbol: UInt32? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _formula = source._formula
      _numArgs = source._numArgs
      _firstSymbol = source._firstSymbol
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._formula == nil {return false}
      if _storage._numArgs == nil {return false}
      if let v = _storage._formula, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._formula) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._numArgs) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._firstSymbol) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._formula {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._numArgs {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._firstSymbol {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_FunctorArchive, rhs: TSCE_FunctorArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._formula != rhs_storage._formula {return false}
        if _storage._numArgs != rhs_storage._numArgs {return false}
        if _storage._firstSymbol != rhs_storage._firstSymbol {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_FormatStructArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormatStructArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}format_type\0\u{3}decimal_places\0\u{3}currency_code\0\u{3}negative_style\0\u{3}show_thousands_separator\0\u{3}use_accounting_style\0\u{3}duration_style\0\u{1}base\0\u{3}base_places\0\u{3}base_use_minus_sign\0\u{3}fraction_accuracy\0\u{3}suppress_date_format\0\u{3}suppress_time_format\0\u{3}date_time_format\0\u{3}duration_unit_largest\0\u{3}duration_unit_smallest\0")

  public var isInitialized: Bool {
    if self._formatType == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._formatType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._decimalPlaces) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._currencyCode) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._negativeStyle) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._showThousandsSeparator) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._useAccountingStyle) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._durationStyle) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._base) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._basePlaces) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self._baseUseMinusSign) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self._fractionAccuracy) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self._suppressDateFormat) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self._suppressTimeFormat) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self._dateTimeFormat) }()
      case 15: try { try decoder.decodeSingularUInt32Field(value: &self._durationUnitLargest) }()
      case 16: try { try decoder.decodeSingularUInt32Field(value: &self._durationUnitSmallest) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._formatType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._decimalPlaces {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._currencyCode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._negativeStyle {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._showThousandsSeparator {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._useAccountingStyle {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._durationStyle {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._base {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._basePlaces {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._baseUseMinusSign {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._fractionAccuracy {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._suppressDateFormat {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._suppressTimeFormat {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._dateTimeFormat {
      try visitor.visitSingularStringField(value: v, fieldNumber: 14)
    } }()
    try { if let v = self._durationUnitLargest {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 15)
    } }()
    try { if let v = self._durationUnitSmallest {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 16)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_FormatStructArchive, rhs: TSCE_FormatStructArchive) -> Bool {
    if lhs._formatType != rhs._formatType {return false}
    if lhs._decimalPlaces != rhs._decimalPlaces {return false}
    if lhs._currencyCode != rhs._currencyCode {return false}
    if lhs._negativeStyle != rhs._negativeStyle {return false}
    if lhs._showThousandsSeparator != rhs._showThousandsSeparator {return false}
    if lhs._useAccountingStyle != rhs._useAccountingStyle {return false}
    if lhs._durationStyle != rhs._durationStyle {return false}
    if lhs._base != rhs._base {return false}
    if lhs._basePlaces != rhs._basePlaces {return false}
    if lhs._baseUseMinusSign != rhs._baseUseMinusSign {return false}
    if lhs._fractionAccuracy != rhs._fractionAccuracy {return false}
    if lhs._suppressDateFormat != rhs._suppressDateFormat {return false}
    if lhs._suppressTimeFormat != rhs._suppressTimeFormat {return false}
    if lhs._dateTimeFormat != rhs._dateTimeFormat {return false}
    if lhs._durationUnitLargest != rhs._durationUnitLargest {return false}
    if lhs._durationUnitSmallest != rhs._durationUnitSmallest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RangeCoordinateArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RangeCoordinateArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}top_left_column\0\u{3}top_left_row\0\u{3}bottom_right_column\0\u{3}bottom_right_row\0")

  public var isInitialized: Bool {
    if self._topLeftColumn == nil {return false}
    if self._topLeftRow == nil {return false}
    if self._bottomRightColumn == nil {return false}
    if self._bottomRightRow == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._topLeftColumn) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._topLeftRow) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._bottomRightColumn) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._bottomRightRow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._topLeftColumn {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._topLeftRow {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._bottomRightColumn {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._bottomRightRow {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RangeCoordinateArchive, rhs: TSCE_RangeCoordinateArchive) -> Bool {
    if lhs._topLeftColumn != rhs._topLeftColumn {return false}
    if lhs._topLeftRow != rhs._topLeftRow {return false}
    if lhs._bottomRightColumn != rhs._bottomRightColumn {return false}
    if lhs._bottomRightRow != rhs._bottomRightRow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_TableTransposeInfoArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TableTransposeInfoArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{3}number_of_footer_rows\0\u{3}body_range_for_transposed_table\0")

  public var isInitialized: Bool {
    if self._numberOfFooterRows == nil {return false}
    if self._bodyRangeForTransposedTable == nil {return false}
    if let v = self._bodyRangeForTransposedTable, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._numberOfFooterRows) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._bodyRangeForTransposedTable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._numberOfFooterRows {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._bodyRangeForTransposedTable {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_TableTransposeInfoArchive, rhs: TSCE_TableTransposeInfoArchive) -> Bool {
    if lhs._numberOfFooterRows != rhs._numberOfFooterRows {return false}
    if lhs._bodyRangeForTransposedTable != rhs._bodyRangeForTransposedTable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_MergeOriginMovedArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MergeOriginMovedArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}src_column\0\u{3}src_row\0\u{3}dst_column\0\u{3}dst_row\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.srcColumn) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.srcRow) }()
      case 3: try { try decoder.decodeRepeatedUInt32Field(value: &self.dstColumn) }()
      case 4: try { try decoder.decodeRepeatedUInt32Field(value: &self.dstRow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.srcColumn.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.srcColumn, fieldNumber: 1)
    }
    if !self.srcRow.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.srcRow, fieldNumber: 2)
    }
    if !self.dstColumn.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.dstColumn, fieldNumber: 3)
    }
    if !self.dstRow.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.dstRow, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_MergeOriginMovedArchive, rhs: TSCE_MergeOriginMovedArchive) -> Bool {
    if lhs.srcColumn != rhs.srcColumn {return false}
    if lhs.srcRow != rhs.srcRow {return false}
    if lhs.dstColumn != rhs.dstColumn {return false}
    if lhs.dstRow != rhs.dstRow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_OwnerUIDMapperArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OwnerUIDMapperArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}table_uid\0\u{3}next_table_uid\0\u{3}hidden_state_for_rows_owner_uid\0\u{3}next_hidden_state_for_rows_owner_uid\0\u{3}hidden_state_for_columns_owner_uid\0\u{3}next_hidden_state_for_columns_owner_uid\0\u{3}conditional_style_owner_uid\0\u{3}next_conditional_style_owner_uid\0\u{3}sort_rule_reference_tracker_owner_uid\0\u{3}next_sort_rule_reference_tracker_owner_uid\0\u{3}merge_owner_uid\0\u{3}next_merge_owner_uid\0\u{4}\u{3}category_aggregates_owner_uid\0\u{3}next_category_aggregates_owner_uid\0\u{3}group_by_uid\0\u{3}next_group_by_uid\0\u{3}pencil_annotation_owner_uid\0\u{3}next_pencil_annotation_owner_uid\0")

  fileprivate class _StorageClass {
    var _tableUid: TSP_UUID? = nil
    var _nextTableUid: TSP_UUID? = nil
    var _hiddenStateForRowsOwnerUid: TSP_UUID? = nil
    var _nextHiddenStateForRowsOwnerUid: TSP_UUID? = nil
    var _hiddenStateForColumnsOwnerUid: TSP_UUID? = nil
    var _nextHiddenStateForColumnsOwnerUid: TSP_UUID? = nil
    var _conditionalStyleOwnerUid: TSP_UUID? = nil
    var _nextConditionalStyleOwnerUid: TSP_UUID? = nil
    var _sortRuleReferenceTrackerOwnerUid: TSP_UUID? = nil
    var _nextSortRuleReferenceTrackerOwnerUid: TSP_UUID? = nil
    var _mergeOwnerUid: TSP_UUID? = nil
    var _nextMergeOwnerUid: TSP_UUID? = nil
    var _categoryAggregatesOwnerUid: TSP_UUID? = nil
    var _nextCategoryAggregatesOwnerUid: TSP_UUID? = nil
    var _groupByUid: TSP_UUID? = nil
    var _nextGroupByUid: TSP_UUID? = nil
    var _pencilAnnotationOwnerUid: TSP_UUID? = nil
    var _nextPencilAnnotationOwnerUid: TSP_UUID? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tableUid = source._tableUid
      _nextTableUid = source._nextTableUid
      _hiddenStateForRowsOwnerUid = source._hiddenStateForRowsOwnerUid
      _nextHiddenStateForRowsOwnerUid = source._nextHiddenStateForRowsOwnerUid
      _hiddenStateForColumnsOwnerUid = source._hiddenStateForColumnsOwnerUid
      _nextHiddenStateForColumnsOwnerUid = source._nextHiddenStateForColumnsOwnerUid
      _conditionalStyleOwnerUid = source._conditionalStyleOwnerUid
      _nextConditionalStyleOwnerUid = source._nextConditionalStyleOwnerUid
      _sortRuleReferenceTrackerOwnerUid = source._sortRuleReferenceTrackerOwnerUid
      _nextSortRuleReferenceTrackerOwnerUid = source._nextSortRuleReferenceTrackerOwnerUid
      _mergeOwnerUid = source._mergeOwnerUid
      _nextMergeOwnerUid = source._nextMergeOwnerUid
      _categoryAggregatesOwnerUid = source._categoryAggregatesOwnerUid
      _nextCategoryAggregatesOwnerUid = source._nextCategoryAggregatesOwnerUid
      _groupByUid = source._groupByUid
      _nextGroupByUid = source._nextGroupByUid
      _pencilAnnotationOwnerUid = source._pencilAnnotationOwnerUid
      _nextPencilAnnotationOwnerUid = source._nextPencilAnnotationOwnerUid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._tableUid == nil {return false}
      if _storage._nextTableUid == nil {return false}
      if _storage._hiddenStateForRowsOwnerUid == nil {return false}
      if _storage._nextHiddenStateForRowsOwnerUid == nil {return false}
      if _storage._hiddenStateForColumnsOwnerUid == nil {return false}
      if _storage._nextHiddenStateForColumnsOwnerUid == nil {return false}
      if _storage._conditionalStyleOwnerUid == nil {return false}
      if _storage._nextConditionalStyleOwnerUid == nil {return false}
      if _storage._sortRuleReferenceTrackerOwnerUid == nil {return false}
      if _storage._nextSortRuleReferenceTrackerOwnerUid == nil {return false}
      if _storage._mergeOwnerUid == nil {return false}
      if _storage._nextMergeOwnerUid == nil {return false}
      if _storage._categoryAggregatesOwnerUid == nil {return false}
      if _storage._nextCategoryAggregatesOwnerUid == nil {return false}
      if _storage._groupByUid == nil {return false}
      if _storage._nextGroupByUid == nil {return false}
      if _storage._pencilAnnotationOwnerUid == nil {return false}
      if _storage._nextPencilAnnotationOwnerUid == nil {return false}
      if let v = _storage._tableUid, !v.isInitialized {return false}
      if let v = _storage._nextTableUid, !v.isInitialized {return false}
      if let v = _storage._hiddenStateForRowsOwnerUid, !v.isInitialized {return false}
      if let v = _storage._nextHiddenStateForRowsOwnerUid, !v.isInitialized {return false}
      if let v = _storage._hiddenStateForColumnsOwnerUid, !v.isInitialized {return false}
      if let v = _storage._nextHiddenStateForColumnsOwnerUid, !v.isInitialized {return false}
      if let v = _storage._conditionalStyleOwnerUid, !v.isInitialized {return false}
      if let v = _storage._nextConditionalStyleOwnerUid, !v.isInitialized {return false}
      if let v = _storage._sortRuleReferenceTrackerOwnerUid, !v.isInitialized {return false}
      if let v = _storage._nextSortRuleReferenceTrackerOwnerUid, !v.isInitialized {return false}
      if let v = _storage._mergeOwnerUid, !v.isInitialized {return false}
      if let v = _storage._nextMergeOwnerUid, !v.isInitialized {return false}
      if let v = _storage._categoryAggregatesOwnerUid, !v.isInitialized {return false}
      if let v = _storage._nextCategoryAggregatesOwnerUid, !v.isInitialized {return false}
      if let v = _storage._groupByUid, !v.isInitialized {return false}
      if let v = _storage._nextGroupByUid, !v.isInitialized {return false}
      if let v = _storage._pencilAnnotationOwnerUid, !v.isInitialized {return false}
      if let v = _storage._nextPencilAnnotationOwnerUid, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._tableUid) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._nextTableUid) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._hiddenStateForRowsOwnerUid) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._nextHiddenStateForRowsOwnerUid) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._hiddenStateForColumnsOwnerUid) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._nextHiddenStateForColumnsOwnerUid) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._conditionalStyleOwnerUid) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._nextConditionalStyleOwnerUid) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._sortRuleReferenceTrackerOwnerUid) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._nextSortRuleReferenceTrackerOwnerUid) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._mergeOwnerUid) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._nextMergeOwnerUid) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._categoryAggregatesOwnerUid) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._nextCategoryAggregatesOwnerUid) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._groupByUid) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._nextGroupByUid) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._pencilAnnotationOwnerUid) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._nextPencilAnnotationOwnerUid) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._tableUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._nextTableUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._hiddenStateForRowsOwnerUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._nextHiddenStateForRowsOwnerUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._hiddenStateForColumnsOwnerUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._nextHiddenStateForColumnsOwnerUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._conditionalStyleOwnerUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._nextConditionalStyleOwnerUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._sortRuleReferenceTrackerOwnerUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._nextSortRuleReferenceTrackerOwnerUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._mergeOwnerUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._nextMergeOwnerUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._categoryAggregatesOwnerUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._nextCategoryAggregatesOwnerUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._groupByUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._nextGroupByUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._pencilAnnotationOwnerUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._nextPencilAnnotationOwnerUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_OwnerUIDMapperArchive, rhs: TSCE_OwnerUIDMapperArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tableUid != rhs_storage._tableUid {return false}
        if _storage._nextTableUid != rhs_storage._nextTableUid {return false}
        if _storage._hiddenStateForRowsOwnerUid != rhs_storage._hiddenStateForRowsOwnerUid {return false}
        if _storage._nextHiddenStateForRowsOwnerUid != rhs_storage._nextHiddenStateForRowsOwnerUid {return false}
        if _storage._hiddenStateForColumnsOwnerUid != rhs_storage._hiddenStateForColumnsOwnerUid {return false}
        if _storage._nextHiddenStateForColumnsOwnerUid != rhs_storage._nextHiddenStateForColumnsOwnerUid {return false}
        if _storage._conditionalStyleOwnerUid != rhs_storage._conditionalStyleOwnerUid {return false}
        if _storage._nextConditionalStyleOwnerUid != rhs_storage._nextConditionalStyleOwnerUid {return false}
        if _storage._sortRuleReferenceTrackerOwnerUid != rhs_storage._sortRuleReferenceTrackerOwnerUid {return false}
        if _storage._nextSortRuleReferenceTrackerOwnerUid != rhs_storage._nextSortRuleReferenceTrackerOwnerUid {return false}
        if _storage._mergeOwnerUid != rhs_storage._mergeOwnerUid {return false}
        if _storage._nextMergeOwnerUid != rhs_storage._nextMergeOwnerUid {return false}
        if _storage._categoryAggregatesOwnerUid != rhs_storage._categoryAggregatesOwnerUid {return false}
        if _storage._nextCategoryAggregatesOwnerUid != rhs_storage._nextCategoryAggregatesOwnerUid {return false}
        if _storage._groupByUid != rhs_storage._groupByUid {return false}
        if _storage._nextGroupByUid != rhs_storage._nextGroupByUid {return false}
        if _storage._pencilAnnotationOwnerUid != rhs_storage._pencilAnnotationOwnerUid {return false}
        if _storage._nextPencilAnnotationOwnerUid != rhs_storage._nextPencilAnnotationOwnerUid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RewriteTableUIDInfoArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RewriteTableUIDInfoArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}table_uid_map\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.tableUidMap) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tableUidMap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tableUidMap.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tableUidMap, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RewriteTableUIDInfoArchive, rhs: TSCE_RewriteTableUIDInfoArchive) -> Bool {
    if lhs.tableUidMap != rhs.tableUidMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RewriteTableUIDInfoArchive.TableUIDMapEntryArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_RewriteTableUIDInfoArchive.protoMessageName + ".TableUIDMapEntryArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}prev_table_uid\0\u{3}new_table_uid\0")

  public var isInitialized: Bool {
    if self._prevTableUid == nil {return false}
    if self._newTableUid == nil {return false}
    if let v = self._prevTableUid, !v.isInitialized {return false}
    if let v = self._newTableUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._prevTableUid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newTableUid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prevTableUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newTableUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RewriteTableUIDInfoArchive.TableUIDMapEntryArchive, rhs: TSCE_RewriteTableUIDInfoArchive.TableUIDMapEntryArchive) -> Bool {
    if lhs._prevTableUid != rhs._prevTableUid {return false}
    if lhs._newTableUid != rhs._newTableUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_GroupByChangeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupByChangeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}change_type\0\u{3}group_by_uid\0\u{3}previous_level\0\u{3}updated_level\0\u{3}previous_to_updated_map\0\u{3}updated_to_previous_map\0\u{3}removed_group_uids\0\u{3}grouping_column_changes\0")

  public var isInitialized: Bool {
    if self._changeType == nil {return false}
    if self._groupByUid == nil {return false}
    if let v = self._groupByUid, !v.isInitialized {return false}
    if let v = self._previousToUpdatedMap, !v.isInitialized {return false}
    if let v = self._updatedToPreviousMap, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.removedGroupUids) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.groupingColumnChanges) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._changeType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._groupByUid) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._previousLevel) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._updatedLevel) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._previousToUpdatedMap) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updatedToPreviousMap) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.removedGroupUids) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.groupingColumnChanges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._changeType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._groupByUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._previousLevel {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._updatedLevel {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._previousToUpdatedMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._updatedToPreviousMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.removedGroupUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.removedGroupUids, fieldNumber: 7)
    }
    if !self.groupingColumnChanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupingColumnChanges, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_GroupByChangeArchive, rhs: TSCE_GroupByChangeArchive) -> Bool {
    if lhs._changeType != rhs._changeType {return false}
    if lhs._groupByUid != rhs._groupByUid {return false}
    if lhs._previousLevel != rhs._previousLevel {return false}
    if lhs._updatedLevel != rhs._updatedLevel {return false}
    if lhs._previousToUpdatedMap != rhs._previousToUpdatedMap {return false}
    if lhs._updatedToPreviousMap != rhs._updatedToPreviousMap {return false}
    if lhs.removedGroupUids != rhs.removedGroupUids {return false}
    if lhs.groupingColumnChanges != rhs.groupingColumnChanges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_GroupByChangeArchive.ChangeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NONE\0\u{1}GROUP_VALUE_CHANGE\0\u{1}GROUP_DEFINITION_CHANGE\0\u{1}REMOVE_GROUP_LEVEL\0\u{1}ADD_GROUP_LEVEL\0\u{1}PROMOTE\0\u{1}DEMOTE\0")
}

extension TSCE_GroupByChangeArchive.GroupingColumnChangeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_GroupByChangeArchive.protoMessageName + ".GroupingColumnChangeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}old_level\0\u{3}new_level\0")

  public var isInitialized: Bool {
    if self._oldLevel == nil {return false}
    if self._newLevel == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._oldLevel) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._newLevel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._oldLevel {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newLevel {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_GroupByChangeArchive.GroupingColumnChangeArchive, rhs: TSCE_GroupByChangeArchive.GroupingColumnChangeArchive) -> Bool {
    if lhs._oldLevel != rhs._oldLevel {return false}
    if lhs._newLevel != rhs._newLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RewriteGroupNodeUIDInfoArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RewriteGroupNodeUIDInfoArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_by_uid\0\u{3}group_node_uid_map\0")

  public var isInitialized: Bool {
    if self._groupNodeUidMap == nil {return false}
    if let v = self._groupByUid, !v.isInitialized {return false}
    if let v = self._groupNodeUidMap, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groupByUid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._groupNodeUidMap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groupByUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._groupNodeUidMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RewriteGroupNodeUIDInfoArchive, rhs: TSCE_RewriteGroupNodeUIDInfoArchive) -> Bool {
    if lhs._groupByUid != rhs._groupByUid {return false}
    if lhs._groupNodeUidMap != rhs._groupNodeUidMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_IndexedUidsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IndexedUidsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uids\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.uids) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.uids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_IndexedUidsArchive, rhs: TSCE_IndexedUidsArchive) -> Bool {
    if lhs.uids != rhs.uids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_IndexedUidsArchive.IndexedUid: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCE_IndexedUidsArchive.protoMessageName + ".IndexedUid"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}uid_for_index\0\u{3}index_for_uid\0")

  public var isInitialized: Bool {
    if self._uidForIndex == nil {return false}
    if self._indexForUid == nil {return false}
    if let v = self._uidForIndex, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uidForIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._indexForUid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uidForIndex {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._indexForUid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_IndexedUidsArchive.IndexedUid, rhs: TSCE_IndexedUidsArchive.IndexedUid) -> Bool {
    if lhs._uidForIndex != rhs._uidForIndex {return false}
    if lhs._indexForUid != rhs._indexForUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RewriteRangeEntryArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RewriteRangeEntryArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}range_location\0\u{3}range_length\0\u{3}range_uids\0\u{1}offset\0")

  public var isInitialized: Bool {
    if self._rangeLocation == nil {return false}
    if self._rangeLength == nil {return false}
    if self._offset == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rangeUids) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._rangeLocation) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._rangeLength) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.rangeUids) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rangeLocation {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rangeLength {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    if !self.rangeUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rangeUids, fieldNumber: 3)
    }
    try { if let v = self._offset {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RewriteRangeEntryArchive, rhs: TSCE_RewriteRangeEntryArchive) -> Bool {
    if lhs._rangeLocation != rhs._rangeLocation {return false}
    if lhs._rangeLength != rhs._rangeLength {return false}
    if lhs.rangeUids != rhs.rangeUids {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ColumnOrRowUuidsInfoArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ColumnOrRowUuidsInfoArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}is_rows\0\u{3}table_uid\0\u{3}cond_style_owner_uid\0\u{3}group_by_uid\0\u{1}uids\0\u{3}range_entries\0\u{3}table_range\0\u{3}insert_at_uid\0\u{3}insert_opposite_uid\0")

  fileprivate class _StorageClass {
    var _isRows: Bool? = nil
    var _tableUid: TSP_UUID? = nil
    var _condStyleOwnerUid: TSP_UUID? = nil
    var _groupByUid: TSP_UUID? = nil
    var _uids: TSCE_IndexedUidsArchive? = nil
    var _rangeEntries: [TSCE_RewriteRangeEntryArchive] = []
    var _tableRange: TSCE_RangeCoordinateArchive? = nil
    var _insertAtUid: TSP_UUID? = nil
    var _insertOppositeUid: TSP_UUID? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _isRows = source._isRows
      _tableUid = source._tableUid
      _condStyleOwnerUid = source._condStyleOwnerUid
      _groupByUid = source._groupByUid
      _uids = source._uids
      _rangeEntries = source._rangeEntries
      _tableRange = source._tableRange
      _insertAtUid = source._insertAtUid
      _insertOppositeUid = source._insertOppositeUid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._isRows == nil {return false}
      if _storage._tableUid == nil {return false}
      if _storage._condStyleOwnerUid == nil {return false}
      if _storage._groupByUid == nil {return false}
      if _storage._uids == nil {return false}
      if _storage._tableRange == nil {return false}
      if let v = _storage._tableUid, !v.isInitialized {return false}
      if let v = _storage._condStyleOwnerUid, !v.isInitialized {return false}
      if let v = _storage._groupByUid, !v.isInitialized {return false}
      if let v = _storage._uids, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._rangeEntries) {return false}
      if let v = _storage._tableRange, !v.isInitialized {return false}
      if let v = _storage._insertAtUid, !v.isInitialized {return false}
      if let v = _storage._insertOppositeUid, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._isRows) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._tableUid) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._condStyleOwnerUid) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._groupByUid) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._uids) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._rangeEntries) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._tableRange) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._insertAtUid) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._insertOppositeUid) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._isRows {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._tableUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._condStyleOwnerUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._groupByUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._uids {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._rangeEntries.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rangeEntries, fieldNumber: 6)
      }
      try { if let v = _storage._tableRange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._insertAtUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._insertOppositeUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ColumnOrRowUuidsInfoArchive, rhs: TSCE_ColumnOrRowUuidsInfoArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._isRows != rhs_storage._isRows {return false}
        if _storage._tableUid != rhs_storage._tableUid {return false}
        if _storage._condStyleOwnerUid != rhs_storage._condStyleOwnerUid {return false}
        if _storage._groupByUid != rhs_storage._groupByUid {return false}
        if _storage._uids != rhs_storage._uids {return false}
        if _storage._rangeEntries != rhs_storage._rangeEntries {return false}
        if _storage._tableRange != rhs_storage._tableRange {return false}
        if _storage._insertAtUid != rhs_storage._insertAtUid {return false}
        if _storage._insertOppositeUid != rhs_storage._insertOppositeUid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RegionInfoArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegionInfoArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}table_uid\0\u{3}column_uids\0\u{3}row_uids\0")

  public var isInitialized: Bool {
    if self._tableUid == nil {return false}
    if self._columnUids == nil {return false}
    if self._rowUids == nil {return false}
    if let v = self._tableUid, !v.isInitialized {return false}
    if let v = self._columnUids, !v.isInitialized {return false}
    if let v = self._rowUids, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tableUid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._columnUids) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._rowUids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tableUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._columnUids {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._rowUids {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RegionInfoArchive, rhs: TSCE_RegionInfoArchive) -> Bool {
    if lhs._tableUid != rhs._tableUid {return false}
    if lhs._columnUids != rhs._columnUids {return false}
    if lhs._rowUids != rhs._rowUids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_RegionMovedInfoArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegionMovedInfoArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}src_region\0\u{3}dst_region\0\u{3}span_rows\0\u{3}span_columns\0\u{3}original_src_region\0\u{3}final_dest_table_uid\0")

  public var isInitialized: Bool {
    if self._srcRegion == nil {return false}
    if self._dstRegion == nil {return false}
    if let v = self._srcRegion, !v.isInitialized {return false}
    if let v = self._dstRegion, !v.isInitialized {return false}
    if let v = self._originalSrcRegion, !v.isInitialized {return false}
    if let v = self._finalDestTableUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._srcRegion) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._dstRegion) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._spanRows) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._spanColumns) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._originalSrcRegion) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._finalDestTableUid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._srcRegion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._dstRegion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._spanRows {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._spanColumns {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._originalSrcRegion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._finalDestTableUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_RegionMovedInfoArchive, rhs: TSCE_RegionMovedInfoArchive) -> Bool {
    if lhs._srcRegion != rhs._srcRegion {return false}
    if lhs._dstRegion != rhs._dstRegion {return false}
    if lhs._spanRows != rhs._spanRows {return false}
    if lhs._spanColumns != rhs._spanColumns {return false}
    if lhs._originalSrcRegion != rhs._originalSrcRegion {return false}
    if lhs._finalDestTableUid != rhs._finalDestTableUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_MergeSourceArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MergeSourceArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}coord_column\0\u{3}coord_row\0")

  public var isInitialized: Bool {
    if self._coordColumn == nil {return false}
    if self._coordRow == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._coordColumn) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._coordRow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coordColumn {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._coordRow {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_MergeSourceArchive, rhs: TSCE_MergeSourceArchive) -> Bool {
    if lhs._coordColumn != rhs._coordColumn {return false}
    if lhs._coordRow != rhs._coordRow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_HauntedOwnerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HauntedOwnerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}owner_uid\0")

  public var isInitialized: Bool {
    if self._ownerUid == nil {return false}
    if let v = self._ownerUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ownerUid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownerUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_HauntedOwnerArchive, rhs: TSCE_HauntedOwnerArchive) -> Bool {
    if lhs._ownerUid != rhs._ownerUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_SpillOwnerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpillOwnerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}owner_uid\0")

  public var isInitialized: Bool {
    if self._ownerUid == nil {return false}
    if let v = self._ownerUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ownerUid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownerUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_SpillOwnerArchive, rhs: TSCE_SpillOwnerArchive) -> Bool {
    if lhs._ownerUid != rhs._ownerUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CellCoordinateArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellCoordinateArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}packedData\0\u{1}column\0\u{1}row\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._packedData) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._column) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._row) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._packedData {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._column {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._row {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CellCoordinateArchive, rhs: TSCE_CellCoordinateArchive) -> Bool {
    if lhs._packedData != rhs._packedData {return false}
    if lhs._column != rhs._column {return false}
    if lhs._row != rhs._row {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CellCoordinateVectorArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellCoordinateVectorArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cell_coord\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cellCoord) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cellCoord.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cellCoord, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CellCoordinateVectorArchive, rhs: TSCE_CellCoordinateVectorArchive) -> Bool {
    if lhs.cellCoord != rhs.cellCoord {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ExpandedCellRefObjectPairArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExpandedCellRefObjectPairArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cell_ref\0\u{1}object\0")

  public var isInitialized: Bool {
    if self._cellRef == nil {return false}
    if self._object == nil {return false}
    if let v = self._cellRef, !v.isInitialized {return false}
    if let v = self._object, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cellRef) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._object) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cellRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._object {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ExpandedCellRefObjectPairArchive, rhs: TSCE_ExpandedCellRefObjectPairArchive) -> Bool {
    if lhs._cellRef != rhs._cellRef {return false}
    if lhs._object != rhs._object {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ExpandedCellRefObjectMapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExpandedCellRefObjectMapArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cell_ref_object_pair\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.cellRefObjectPair) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cellRefObjectPair) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cellRefObjectPair.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cellRefObjectPair, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ExpandedCellRefObjectMapArchive, rhs: TSCE_ExpandedCellRefObjectMapArchive) -> Bool {
    if lhs.cellRefObjectPair != rhs.cellRefObjectPair {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_FormulaAtCoordArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormulaAtCoordArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}column\0\u{1}row\0\u{1}formula\0\u{3}repeat_previous_formula\0")

  fileprivate class _StorageClass {
    var _column: UInt32? = nil
    var _row: UInt32? = nil
    var _formula: TSCE_FormulaArchive? = nil
    var _repeatPreviousFormula: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _column = source._column
      _row = source._row
      _formula = source._formula
      _repeatPreviousFormula = source._repeatPreviousFormula
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._column == nil {return false}
      if _storage._row == nil {return false}
      if let v = _storage._formula, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._column) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._row) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._formula) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._repeatPreviousFormula) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._column {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._row {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._formula {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._repeatPreviousFormula {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_FormulaAtCoordArchive, rhs: TSCE_FormulaAtCoordArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._column != rhs_storage._column {return false}
        if _storage._row != rhs_storage._row {return false}
        if _storage._formula != rhs_storage._formula {return false}
        if _storage._repeatPreviousFormula != rhs_storage._repeatPreviousFormula {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_FormulaCoordPairsByOwnerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormulaCoordPairsByOwnerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}owner_kind\0\u{3}owner_uid\0\u{3}formula_at_coords\0")

  public var isInitialized: Bool {
    if self._ownerKind == nil {return false}
    if let v = self._ownerUid, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.formulaAtCoords) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._ownerKind) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._ownerUid) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.formulaAtCoords) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ownerKind {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ownerUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.formulaAtCoords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.formulaAtCoords, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_FormulaCoordPairsByOwnerArchive, rhs: TSCE_FormulaCoordPairsByOwnerArchive) -> Bool {
    if lhs._ownerKind != rhs._ownerKind {return false}
    if lhs._ownerUid != rhs._ownerUid {return false}
    if lhs.formulaAtCoords != rhs.formulaAtCoords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_FormulasForUndoArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormulasForUndoArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}formulas_for_owner\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.formulasForOwner) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.formulasForOwner) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.formulasForOwner.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.formulasForOwner, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_FormulasForUndoArchive, rhs: TSCE_FormulasForUndoArchive) -> Bool {
    if lhs.formulasForOwner != rhs.formulasForOwner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_FormulaRewriteCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormulaRewriteCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}table_rewrite_command\0\u{1}super\0")

  public var isInitialized: Bool {
    if let v = self._tableRewriteCommand, !v.isInitialized {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tableRewriteCommand) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tableRewriteCommand {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_FormulaRewriteCommandArchive, rhs: TSCE_FormulaRewriteCommandArchive) -> Bool {
    if lhs._tableRewriteCommand != rhs._tableRewriteCommand {return false}
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_TrackedReferenceArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrackedReferenceArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ast\0\u{3}formula_id\0")

  public var isInitialized: Bool {
    if self._ast == nil {return false}
    if self._formulaID == nil {return false}
    if let v = self._ast, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ast) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._formulaID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ast {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._formulaID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_TrackedReferenceArchive, rhs: TSCE_TrackedReferenceArchive) -> Bool {
    if lhs._ast != rhs._ast {return false}
    if lhs._formulaID != rhs._formulaID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ExpandedTrackedReferenceArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExpandedTrackedReferenceArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ast\0\u{3}formula_column\0\u{3}formula_row\0")

  public var isInitialized: Bool {
    if self._ast == nil {return false}
    if self._formulaColumn == nil {return false}
    if self._formulaRow == nil {return false}
    if let v = self._ast, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ast) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._formulaColumn) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._formulaRow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ast {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._formulaColumn {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._formulaRow {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ExpandedTrackedReferenceArchive, rhs: TSCE_ExpandedTrackedReferenceArchive) -> Bool {
    if lhs._ast != rhs._ast {return false}
    if lhs._formulaColumn != rhs._formulaColumn {return false}
    if lhs._formulaRow != rhs._formulaRow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_TrackedReferenceStoreArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrackedReferenceStoreArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uuid\0\u{3}tracked_reference\0\u{3}contained_tracked_reference\0\u{3}contained_expanded_tracked_reference\0")

  public var isInitialized: Bool {
    if self._uuid == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.trackedReference) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.containedTrackedReference) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.containedExpandedTrackedReference) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.trackedReference) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.containedTrackedReference) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.containedExpandedTrackedReference) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.trackedReference.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trackedReference, fieldNumber: 2)
    }
    if !self.containedTrackedReference.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.containedTrackedReference, fieldNumber: 3)
    }
    if !self.containedExpandedTrackedReference.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.containedExpandedTrackedReference, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_TrackedReferenceStoreArchive, rhs: TSCE_TrackedReferenceStoreArchive) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.trackedReference != rhs.trackedReference {return false}
    if lhs.containedTrackedReference != rhs.containedTrackedReference {return false}
    if lhs.containedExpandedTrackedReference != rhs.containedExpandedTrackedReference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ViewTractRefArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ViewTractRefArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}table_uid\0\u{3}uid_tract\0\u{3}preserve_flags\0\u{3}agg_index_level\0\u{3}column_group_level\0\u{3}row_group_level\0")

  public var isInitialized: Bool {
    if self._tableUid == nil {return false}
    if let v = self._tableUid, !v.isInitialized {return false}
    if let v = self._uidTract, !v.isInitialized {return false}
    if let v = self._preserveFlags, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tableUid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._uidTract) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._preserveFlags) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._aggIndexLevel) }()
      case 5: try { try decoder.decodeSingularSInt32Field(value: &self._columnGroupLevel) }()
      case 6: try { try decoder.decodeSingularSInt32Field(value: &self._rowGroupLevel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tableUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._uidTract {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._preserveFlags {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._aggIndexLevel {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._columnGroupLevel {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._rowGroupLevel {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ViewTractRefArchive, rhs: TSCE_ViewTractRefArchive) -> Bool {
    if lhs._tableUid != rhs._tableUid {return false}
    if lhs._uidTract != rhs._uidTract {return false}
    if lhs._preserveFlags != rhs._preserveFlags {return false}
    if lhs._aggIndexLevel != rhs._aggIndexLevel {return false}
    if lhs._columnGroupLevel != rhs._columnGroupLevel {return false}
    if lhs._rowGroupLevel != rhs._rowGroupLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_BooleanCellValueArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BooleanCellValueArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0\u{1}format\0\u{3}format_is_explicit\0")

  public var isInitialized: Bool {
    if self._value == nil {return false}
    if let v = self._format, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._format) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._formatIsExplicit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._format {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._formatIsExplicit {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_BooleanCellValueArchive, rhs: TSCE_BooleanCellValueArchive) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._format != rhs._format {return false}
    if lhs._formatIsExplicit != rhs._formatIsExplicit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_DateCellValueArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DateCellValueArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0\u{1}format\0\u{3}format_is_implicit\0\u{3}format_is_explicit\0")

  public var isInitialized: Bool {
    if self._value == nil {return false}
    if self._format == nil {return false}
    if let v = self._format, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._format) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._formatIsImplicit) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._formatIsExplicit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._format {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._formatIsImplicit {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._formatIsExplicit {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_DateCellValueArchive, rhs: TSCE_DateCellValueArchive) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._format != rhs._format {return false}
    if lhs._formatIsImplicit != rhs._formatIsImplicit {return false}
    if lhs._formatIsExplicit != rhs._formatIsExplicit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_NumberCellValueArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NumberCellValueArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0\u{3}unit_index\0\u{1}format\0\u{3}format_is_implicit\0\u{3}currency_code\0\u{3}format_is_explicit\0\u{3}decimal_low\0\u{3}decimal_high\0")

  public var isInitialized: Bool {
    if self._format == nil {return false}
    if let v = self._format, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._unitIndex) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._format) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._formatIsImplicit) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._currencyCode) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._formatIsExplicit) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self._decimalLow) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self._decimalHigh) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._unitIndex {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._format {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._formatIsImplicit {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._currencyCode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._formatIsExplicit {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._decimalLow {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._decimalHigh {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_NumberCellValueArchive, rhs: TSCE_NumberCellValueArchive) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._unitIndex != rhs._unitIndex {return false}
    if lhs._currencyCode != rhs._currencyCode {return false}
    if lhs._format != rhs._format {return false}
    if lhs._formatIsImplicit != rhs._formatIsImplicit {return false}
    if lhs._formatIsExplicit != rhs._formatIsExplicit {return false}
    if lhs._decimalLow != rhs._decimalLow {return false}
    if lhs._decimalHigh != rhs._decimalHigh {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_StringCellValueArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StringCellValueArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0\u{1}format\0\u{3}format_is_implicit\0\u{3}format_is_explicit\0\u{3}is_regex\0\u{3}is_case_sensitive_regex\0")

  public var isInitialized: Bool {
    if self._value == nil {return false}
    if self._format == nil {return false}
    if let v = self._format, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._format) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._formatIsImplicit) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._formatIsExplicit) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._isRegex) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._isCaseSensitiveRegex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._format {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._formatIsImplicit {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._formatIsExplicit {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._isRegex {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._isCaseSensitiveRegex {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_StringCellValueArchive, rhs: TSCE_StringCellValueArchive) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._format != rhs._format {return false}
    if lhs._formatIsImplicit != rhs._formatIsImplicit {return false}
    if lhs._formatIsExplicit != rhs._formatIsExplicit {return false}
    if lhs._isRegex != rhs._isRegex {return false}
    if lhs._isCaseSensitiveRegex != rhs._isCaseSensitiveRegex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_ErrorCellValueArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ErrorCellValueArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}error_type\0\u{4}\u{2}extra_info_int\0\u{3}extra_info_string\0\u{3}extra_info_double\0")

  public var isInitialized: Bool {
    if self._errorType == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._errorType) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._extraInfoInt) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._extraInfoString) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self._extraInfoDouble) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._errorType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._extraInfoInt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._extraInfoString {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._extraInfoDouble {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_ErrorCellValueArchive, rhs: TSCE_ErrorCellValueArchive) -> Bool {
    if lhs._errorType != rhs._errorType {return false}
    if lhs._extraInfoInt != rhs._extraInfoInt {return false}
    if lhs._extraInfoString != rhs._extraInfoString {return false}
    if lhs._extraInfoDouble != rhs._extraInfoDouble {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CellValueArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CellValueArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cell_value_type\0\u{3}boolean_value\0\u{3}date_value\0\u{3}number_value\0\u{3}string_value\0\u{3}error_value\0")

  fileprivate class _StorageClass {
    var _cellValueType: TSCE_CellValueArchive.CellValueType? = nil
    var _booleanValue: TSCE_BooleanCellValueArchive? = nil
    var _dateValue: TSCE_DateCellValueArchive? = nil
    var _numberValue: TSCE_NumberCellValueArchive? = nil
    var _stringValue: TSCE_StringCellValueArchive? = nil
    var _errorValue: TSCE_ErrorCellValueArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _cellValueType = source._cellValueType
      _booleanValue = source._booleanValue
      _dateValue = source._dateValue
      _numberValue = source._numberValue
      _stringValue = source._stringValue
      _errorValue = source._errorValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._cellValueType == nil {return false}
      if let v = _storage._booleanValue, !v.isInitialized {return false}
      if let v = _storage._dateValue, !v.isInitialized {return false}
      if let v = _storage._numberValue, !v.isInitialized {return false}
      if let v = _storage._stringValue, !v.isInitialized {return false}
      if let v = _storage._errorValue, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._cellValueType) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._booleanValue) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._dateValue) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._numberValue) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._stringValue) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._errorValue) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._cellValueType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._booleanValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._dateValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._numberValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._stringValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._errorValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCE_CellValueArchive, rhs: TSCE_CellValueArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._cellValueType != rhs_storage._cellValueType {return false}
        if _storage._booleanValue != rhs_storage._booleanValue {return false}
        if _storage._dateValue != rhs_storage._dateValue {return false}
        if _storage._numberValue != rhs_storage._numberValue {return false}
        if _storage._stringValue != rhs_storage._stringValue {return false}
        if _storage._errorValue != rhs_storage._errorValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCE_CellValueArchive.CellValueType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}NIL_TYPE\0\u{1}BOOLEAN_TYPE\0\u{1}DATE_TYPE\0\u{1}NUMBER_TYPE\0\u{1}STRING_TYPE\0")
}
