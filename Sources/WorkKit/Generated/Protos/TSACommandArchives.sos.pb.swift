// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TSACommandArchives.sos.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct TSASOS_InducedVerifyDrawableZOrdersWithServerCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var serverDrawableZOrderLists: [TSASOS_DrawableZOrderListArchive] = []

  var serverDrawableZOrderListsUndefined: Bool {
    get {return _serverDrawableZOrderListsUndefined ?? false}
    set {_serverDrawableZOrderListsUndefined = newValue}
  }
  /// Returns true if `serverDrawableZOrderListsUndefined` has been explicitly set.
  var hasServerDrawableZOrderListsUndefined: Bool {return self._serverDrawableZOrderListsUndefined != nil}
  /// Clears the value of `serverDrawableZOrderListsUndefined`. Subsequent reads from it will return its default value.
  mutating func clearServerDrawableZOrderListsUndefined() {self._serverDrawableZOrderListsUndefined = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _serverDrawableZOrderListsUndefined: Bool? = nil
}

struct TSASOS_PropagateMasterChangeCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var uuidsOfPreviouslyVisitedObjects: [TSP_UUID] = []

  var uuidsOfPreviouslyVisitedObjectsUndefined: Bool {
    get {return _uuidsOfPreviouslyVisitedObjectsUndefined ?? false}
    set {_uuidsOfPreviouslyVisitedObjectsUndefined = newValue}
  }
  /// Returns true if `uuidsOfPreviouslyVisitedObjectsUndefined` has been explicitly set.
  var hasUuidsOfPreviouslyVisitedObjectsUndefined: Bool {return self._uuidsOfPreviouslyVisitedObjectsUndefined != nil}
  /// Clears the value of `uuidsOfPreviouslyVisitedObjectsUndefined`. Subsequent reads from it will return its default value.
  mutating func clearUuidsOfPreviouslyVisitedObjectsUndefined() {self._uuidsOfPreviouslyVisitedObjectsUndefined = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _uuidsOfPreviouslyVisitedObjectsUndefined: Bool? = nil
}

struct TSASOS_CommandReapplyMasterArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var itemsToVisit: [TSP_UUID] = []

  var itemsToVisitUndefined: Bool {
    get {return _itemsToVisitUndefined ?? false}
    set {_itemsToVisitUndefined = newValue}
  }
  /// Returns true if `itemsToVisitUndefined` has been explicitly set.
  var hasItemsToVisitUndefined: Bool {return self._itemsToVisitUndefined != nil}
  /// Clears the value of `itemsToVisitUndefined`. Subsequent reads from it will return its default value.
  mutating func clearItemsToVisitUndefined() {self._itemsToVisitUndefined = nil}

  var isUndo: Bool {
    get {return _isUndo ?? false}
    set {_isUndo = newValue}
  }
  /// Returns true if `isUndo` has been explicitly set.
  var hasIsUndo: Bool {return self._isUndo != nil}
  /// Clears the value of `isUndo`. Subsequent reads from it will return its default value.
  mutating func clearIsUndo() {self._isUndo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _itemsToVisitUndefined: Bool? = nil
  fileprivate var _isUndo: Bool? = nil
}

struct TSASOS_VerifyActivityStreamWithServerCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
}

struct TSASOS_VerifyDocumentWithServerCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
}

struct TSASOS_VerifyDrawableZOrdersWithServerCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var drawableIDList: [TSP_UUID] = []

  var drawableIDListUndefined: Bool {
    get {return _drawableIDListUndefined ?? false}
    set {_drawableIDListUndefined = newValue}
  }
  /// Returns true if `drawableIDListUndefined` has been explicitly set.
  var hasDrawableIDListUndefined: Bool {return self._drawableIDListUndefined != nil}
  /// Clears the value of `drawableIDListUndefined`. Subsequent reads from it will return its default value.
  mutating func clearDrawableIDListUndefined() {self._drawableIDListUndefined = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _drawableIDListUndefined: Bool? = nil
}

struct TSASOS_VerifyObjectsWithServerCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var objectIDList: [TSP_UUID] = []

  var objectIDListUndefined: Bool {
    get {return _objectIDListUndefined ?? false}
    set {_objectIDListUndefined = newValue}
  }
  /// Returns true if `objectIDListUndefined` has been explicitly set.
  var hasObjectIDListUndefined: Bool {return self._objectIDListUndefined != nil}
  /// Clears the value of `objectIDListUndefined`. Subsequent reads from it will return its default value.
  mutating func clearObjectIDListUndefined() {self._objectIDListUndefined = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _objectIDListUndefined: Bool? = nil
}

struct TSASOS_VerifyTransformHistoryWithServerCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var sequenceStart: Int32 {
    get {return _sequenceStart ?? 0}
    set {_sequenceStart = newValue}
  }
  /// Returns true if `sequenceStart` has been explicitly set.
  var hasSequenceStart: Bool {return self._sequenceStart != nil}
  /// Clears the value of `sequenceStart`. Subsequent reads from it will return its default value.
  mutating func clearSequenceStart() {self._sequenceStart = nil}

  var sequenceEnd: Int32 {
    get {return _sequenceEnd ?? 0}
    set {_sequenceEnd = newValue}
  }
  /// Returns true if `sequenceEnd` has been explicitly set.
  var hasSequenceEnd: Bool {return self._sequenceEnd != nil}
  /// Clears the value of `sequenceEnd`. Subsequent reads from it will return its default value.
  mutating func clearSequenceEnd() {self._sequenceEnd = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _sequenceStart: Int32? = nil
  fileprivate var _sequenceEnd: Int32? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TSASOS"

extension TSASOS_InducedVerifyDrawableZOrdersWithServerCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InducedVerifyDrawableZOrdersWithServerCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}server_drawable_z_order_lists\0\u{3}server_drawable_z_order_lists_undefined\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.serverDrawableZOrderLists) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.serverDrawableZOrderLists) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._serverDrawableZOrderListsUndefined) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.serverDrawableZOrderLists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serverDrawableZOrderLists, fieldNumber: 2)
    }
    try { if let v = self._serverDrawableZOrderListsUndefined {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSASOS_InducedVerifyDrawableZOrdersWithServerCommandArchive, rhs: TSASOS_InducedVerifyDrawableZOrdersWithServerCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.serverDrawableZOrderLists != rhs.serverDrawableZOrderLists {return false}
    if lhs._serverDrawableZOrderListsUndefined != rhs._serverDrawableZOrderListsUndefined {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSASOS_PropagateMasterChangeCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PropagateMasterChangeCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}uuids_of_previously_visited_objects\0\u{3}uuids_of_previously_visited_objects_undefined\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.uuidsOfPreviouslyVisitedObjects) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.uuidsOfPreviouslyVisitedObjects) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._uuidsOfPreviouslyVisitedObjectsUndefined) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.uuidsOfPreviouslyVisitedObjects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uuidsOfPreviouslyVisitedObjects, fieldNumber: 2)
    }
    try { if let v = self._uuidsOfPreviouslyVisitedObjectsUndefined {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSASOS_PropagateMasterChangeCommandArchive, rhs: TSASOS_PropagateMasterChangeCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.uuidsOfPreviouslyVisitedObjects != rhs.uuidsOfPreviouslyVisitedObjects {return false}
    if lhs._uuidsOfPreviouslyVisitedObjectsUndefined != rhs._uuidsOfPreviouslyVisitedObjectsUndefined {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSASOS_CommandReapplyMasterArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandReapplyMasterArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}items_to_visit\0\u{3}items_to_visit_undefined\0\u{3}is_undo\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._isUndo == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.itemsToVisit) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.itemsToVisit) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._itemsToVisitUndefined) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._isUndo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.itemsToVisit.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.itemsToVisit, fieldNumber: 2)
    }
    try { if let v = self._itemsToVisitUndefined {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._isUndo {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSASOS_CommandReapplyMasterArchive, rhs: TSASOS_CommandReapplyMasterArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.itemsToVisit != rhs.itemsToVisit {return false}
    if lhs._itemsToVisitUndefined != rhs._itemsToVisitUndefined {return false}
    if lhs._isUndo != rhs._isUndo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSASOS_VerifyActivityStreamWithServerCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyActivityStreamWithServerCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSASOS_VerifyActivityStreamWithServerCommandArchive, rhs: TSASOS_VerifyActivityStreamWithServerCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSASOS_VerifyDocumentWithServerCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyDocumentWithServerCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSASOS_VerifyDocumentWithServerCommandArchive, rhs: TSASOS_VerifyDocumentWithServerCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSASOS_VerifyDrawableZOrdersWithServerCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyDrawableZOrdersWithServerCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}drawable_id_list\0\u{3}drawable_id_list_undefined\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.drawableIDList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.drawableIDList) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._drawableIDListUndefined) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.drawableIDList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.drawableIDList, fieldNumber: 2)
    }
    try { if let v = self._drawableIDListUndefined {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSASOS_VerifyDrawableZOrdersWithServerCommandArchive, rhs: TSASOS_VerifyDrawableZOrdersWithServerCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.drawableIDList != rhs.drawableIDList {return false}
    if lhs._drawableIDListUndefined != rhs._drawableIDListUndefined {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSASOS_VerifyObjectsWithServerCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyObjectsWithServerCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}object_id_list\0\u{3}object_id_list_undefined\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.objectIDList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.objectIDList) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._objectIDListUndefined) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.objectIDList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objectIDList, fieldNumber: 2)
    }
    try { if let v = self._objectIDListUndefined {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSASOS_VerifyObjectsWithServerCommandArchive, rhs: TSASOS_VerifyObjectsWithServerCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.objectIDList != rhs.objectIDList {return false}
    if lhs._objectIDListUndefined != rhs._objectIDListUndefined {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSASOS_VerifyTransformHistoryWithServerCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyTransformHistoryWithServerCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}sequence_start\0\u{3}sequence_end\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._sequenceStart == nil {return false}
    if self._sequenceEnd == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._sequenceStart) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._sequenceEnd) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sequenceStart {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sequenceEnd {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSASOS_VerifyTransformHistoryWithServerCommandArchive, rhs: TSASOS_VerifyTransformHistoryWithServerCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._sequenceStart != rhs._sequenceStart {return false}
    if lhs._sequenceEnd != rhs._sequenceEnd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
