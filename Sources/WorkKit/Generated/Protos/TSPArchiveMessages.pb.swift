// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TSPArchiveMessages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct TSP_ArchiveInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var identifier: UInt64 {
    get {return _identifier ?? 0}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {self._identifier = nil}

  var messageInfos: [TSP_MessageInfo] = []

  var shouldMerge: Bool {
    get {return _shouldMerge ?? false}
    set {_shouldMerge = newValue}
  }
  /// Returns true if `shouldMerge` has been explicitly set.
  var hasShouldMerge: Bool {return self._shouldMerge != nil}
  /// Clears the value of `shouldMerge`. Subsequent reads from it will return its default value.
  mutating func clearShouldMerge() {self._shouldMerge = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _identifier: UInt64? = nil
  fileprivate var _shouldMerge: Bool? = nil
}

struct TSP_MessageInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: UInt32 {
    get {return _type ?? 0}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var version: [UInt32] = []

  var length: UInt32 {
    get {return _length ?? 0}
    set {_length = newValue}
  }
  /// Returns true if `length` has been explicitly set.
  var hasLength: Bool {return self._length != nil}
  /// Clears the value of `length`. Subsequent reads from it will return its default value.
  mutating func clearLength() {self._length = nil}

  var fieldInfos: [TSP_FieldInfo] = []

  var objectReferences: [UInt64] = []

  var dataReferences: [UInt64] = []

  var baseMessageIndex: UInt32 {
    get {return _baseMessageIndex ?? 0}
    set {_baseMessageIndex = newValue}
  }
  /// Returns true if `baseMessageIndex` has been explicitly set.
  var hasBaseMessageIndex: Bool {return self._baseMessageIndex != nil}
  /// Clears the value of `baseMessageIndex`. Subsequent reads from it will return its default value.
  mutating func clearBaseMessageIndex() {self._baseMessageIndex = nil}

  var diffMergeVersion: [UInt32] = []

  var diffFieldPath: TSP_FieldPath {
    get {return _diffFieldPath ?? TSP_FieldPath()}
    set {_diffFieldPath = newValue}
  }
  /// Returns true if `diffFieldPath` has been explicitly set.
  var hasDiffFieldPath: Bool {return self._diffFieldPath != nil}
  /// Clears the value of `diffFieldPath`. Subsequent reads from it will return its default value.
  mutating func clearDiffFieldPath() {self._diffFieldPath = nil}

  var fieldsToRemove: [TSP_FieldPath] = []

  var diffReadVersion: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: UInt32? = nil
  fileprivate var _length: UInt32? = nil
  fileprivate var _baseMessageIndex: UInt32? = nil
  fileprivate var _diffFieldPath: TSP_FieldPath? = nil
}

struct TSP_FieldInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var path: TSP_FieldPath {
    get {return _path ?? TSP_FieldPath()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {self._path = nil}

  var type: TSP_FieldInfo.TypeEnum {
    get {return _type ?? .value}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var unknownFieldRule: TSP_FieldInfo.UnknownFieldRule {
    get {return _unknownFieldRule ?? .ignoreAndPreserveUntilModified}
    set {_unknownFieldRule = newValue}
  }
  /// Returns true if `unknownFieldRule` has been explicitly set.
  var hasUnknownFieldRule: Bool {return self._unknownFieldRule != nil}
  /// Clears the value of `unknownFieldRule`. Subsequent reads from it will return its default value.
  mutating func clearUnknownFieldRule() {self._unknownFieldRule = nil}

  var objectReferences: [UInt64] = []

  var dataReferences: [UInt64] = []

  var knownFieldRule: TSP_FieldInfo.KnownFieldRule {
    get {return _knownFieldRule ?? .none}
    set {_knownFieldRule = newValue}
  }
  /// Returns true if `knownFieldRule` has been explicitly set.
  var hasKnownFieldRule: Bool {return self._knownFieldRule != nil}
  /// Clears the value of `knownFieldRule`. Subsequent reads from it will return its default value.
  mutating func clearKnownFieldRule() {self._knownFieldRule = nil}

  var knownFieldVersion: [UInt32] = []

  var knownFieldFeatureIdentifier: String {
    get {return _knownFieldFeatureIdentifier ?? String()}
    set {_knownFieldFeatureIdentifier = newValue}
  }
  /// Returns true if `knownFieldFeatureIdentifier` has been explicitly set.
  var hasKnownFieldFeatureIdentifier: Bool {return self._knownFieldFeatureIdentifier != nil}
  /// Clears the value of `knownFieldFeatureIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearKnownFieldFeatureIdentifier() {self._knownFieldFeatureIdentifier = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case value = 0
    case objectReference = 1
    case dataReference = 2
    case message = 3

    init() {
      self = .value
    }

  }

  enum UnknownFieldRule: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case ignoreAndPreserveUntilModified = 0
    case ignoreAndPreserve = 1
    case mustUnderstand = 2
    case notSupported = -1

    init() {
      self = .ignoreAndPreserveUntilModified
    }

  }

  enum KnownFieldRule: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case none = 0
    case preserveNewerValueUntilModified = 1
    case preserveNewerValue = 2

    init() {
      self = .none
    }

  }

  init() {}

  fileprivate var _path: TSP_FieldPath? = nil
  fileprivate var _type: TSP_FieldInfo.TypeEnum? = nil
  fileprivate var _unknownFieldRule: TSP_FieldInfo.UnknownFieldRule? = nil
  fileprivate var _knownFieldRule: TSP_FieldInfo.KnownFieldRule? = nil
  fileprivate var _knownFieldFeatureIdentifier: String? = nil
}

struct TSP_FieldPath: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var path: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSP_ComponentInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var identifier: UInt64 {
    get {return _storage._identifier ?? 0}
    set {_uniqueStorage()._identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return _storage._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {_uniqueStorage()._identifier = nil}

  var preferredLocator: String {
    get {return _storage._preferredLocator ?? String()}
    set {_uniqueStorage()._preferredLocator = newValue}
  }
  /// Returns true if `preferredLocator` has been explicitly set.
  var hasPreferredLocator: Bool {return _storage._preferredLocator != nil}
  /// Clears the value of `preferredLocator`. Subsequent reads from it will return its default value.
  mutating func clearPreferredLocator() {_uniqueStorage()._preferredLocator = nil}

  var locator: String {
    get {return _storage._locator ?? String()}
    set {_uniqueStorage()._locator = newValue}
  }
  /// Returns true if `locator` has been explicitly set.
  var hasLocator: Bool {return _storage._locator != nil}
  /// Clears the value of `locator`. Subsequent reads from it will return its default value.
  mutating func clearLocator() {_uniqueStorage()._locator = nil}

  var documentReadVersion: [UInt32] {
    get {return _storage._documentReadVersion}
    set {_uniqueStorage()._documentReadVersion = newValue}
  }

  var documentWriteVersion: [UInt32] {
    get {return _storage._documentWriteVersion}
    set {_uniqueStorage()._documentWriteVersion = newValue}
  }

  var externalReferences: [TSP_ComponentExternalReference] {
    get {return _storage._externalReferences}
    set {_uniqueStorage()._externalReferences = newValue}
  }

  var dataReferences: [TSP_ComponentDataReference] {
    get {return _storage._dataReferences}
    set {_uniqueStorage()._dataReferences = newValue}
  }

  var isStoredOutsideObjectArchive: Bool {
    get {return _storage._isStoredOutsideObjectArchive ?? false}
    set {_uniqueStorage()._isStoredOutsideObjectArchive = newValue}
  }
  /// Returns true if `isStoredOutsideObjectArchive` has been explicitly set.
  var hasIsStoredOutsideObjectArchive: Bool {return _storage._isStoredOutsideObjectArchive != nil}
  /// Clears the value of `isStoredOutsideObjectArchive`. Subsequent reads from it will return its default value.
  mutating func clearIsStoredOutsideObjectArchive() {_uniqueStorage()._isStoredOutsideObjectArchive = nil}

  var objectUuidMapEntries: [TSP_ObjectUUIDMapEntry] {
    get {return _storage._objectUuidMapEntries}
    set {_uniqueStorage()._objectUuidMapEntries = newValue}
  }

  var saveToken: UInt64 {
    get {return _storage._saveToken ?? 0}
    set {_uniqueStorage()._saveToken = newValue}
  }
  /// Returns true if `saveToken` has been explicitly set.
  var hasSaveToken: Bool {return _storage._saveToken != nil}
  /// Clears the value of `saveToken`. Subsequent reads from it will return its default value.
  mutating func clearSaveToken() {_uniqueStorage()._saveToken = nil}

  var featureInfos: [TSP_FeatureInfo] {
    get {return _storage._featureInfos}
    set {_uniqueStorage()._featureInfos = newValue}
  }

  var componentReadVersion: [UInt32] {
    get {return _storage._componentReadVersion}
    set {_uniqueStorage()._componentReadVersion = newValue}
  }

  var componentRequiredVersion: [UInt32] {
    get {return _storage._componentRequiredVersion}
    set {_uniqueStorage()._componentRequiredVersion = newValue}
  }

  var compressionAlgorithm: UInt32 {
    get {return _storage._compressionAlgorithm ?? 0}
    set {_uniqueStorage()._compressionAlgorithm = newValue}
  }
  /// Returns true if `compressionAlgorithm` has been explicitly set.
  var hasCompressionAlgorithm: Bool {return _storage._compressionAlgorithm != nil}
  /// Clears the value of `compressionAlgorithm`. Subsequent reads from it will return its default value.
  mutating func clearCompressionAlgorithm() {_uniqueStorage()._compressionAlgorithm = nil}

  var canBeDropped: Bool {
    get {return _storage._canBeDropped ?? false}
    set {_uniqueStorage()._canBeDropped = newValue}
  }
  /// Returns true if `canBeDropped` has been explicitly set.
  var hasCanBeDropped: Bool {return _storage._canBeDropped != nil}
  /// Clears the value of `canBeDropped`. Subsequent reads from it will return its default value.
  mutating func clearCanBeDropped() {_uniqueStorage()._canBeDropped = nil}

  var versionedExternalReferences: [TSP_ComponentExternalReference] {
    get {return _storage._versionedExternalReferences}
    set {_uniqueStorage()._versionedExternalReferences = newValue}
  }

  var isWasteful: Bool {
    get {return _storage._isWasteful ?? false}
    set {_uniqueStorage()._isWasteful = newValue}
  }
  /// Returns true if `isWasteful` has been explicitly set.
  var hasIsWasteful: Bool {return _storage._isWasteful != nil}
  /// Clears the value of `isWasteful`. Subsequent reads from it will return its default value.
  mutating func clearIsWasteful() {_uniqueStorage()._isWasteful = nil}

  var ambiguousObjectIdentifiers: [UInt64] {
    get {return _storage._ambiguousObjectIdentifiers}
    set {_uniqueStorage()._ambiguousObjectIdentifiers = newValue}
  }

  var requiredPackageIdentifier: UInt32 {
    get {return _storage._requiredPackageIdentifier ?? 0}
    set {_uniqueStorage()._requiredPackageIdentifier = newValue}
  }
  /// Returns true if `requiredPackageIdentifier` has been explicitly set.
  var hasRequiredPackageIdentifier: Bool {return _storage._requiredPackageIdentifier != nil}
  /// Clears the value of `requiredPackageIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearRequiredPackageIdentifier() {_uniqueStorage()._requiredPackageIdentifier = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSP_ComponentExternalReference: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var componentIdentifier: UInt64 {
    get {return _componentIdentifier ?? 0}
    set {_componentIdentifier = newValue}
  }
  /// Returns true if `componentIdentifier` has been explicitly set.
  var hasComponentIdentifier: Bool {return self._componentIdentifier != nil}
  /// Clears the value of `componentIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearComponentIdentifier() {self._componentIdentifier = nil}

  var objectIdentifier: UInt64 {
    get {return _objectIdentifier ?? 0}
    set {_objectIdentifier = newValue}
  }
  /// Returns true if `objectIdentifier` has been explicitly set.
  var hasObjectIdentifier: Bool {return self._objectIdentifier != nil}
  /// Clears the value of `objectIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearObjectIdentifier() {self._objectIdentifier = nil}

  var isWeak: Bool {
    get {return _isWeak ?? false}
    set {_isWeak = newValue}
  }
  /// Returns true if `isWeak` has been explicitly set.
  var hasIsWeak: Bool {return self._isWeak != nil}
  /// Clears the value of `isWeak`. Subsequent reads from it will return its default value.
  mutating func clearIsWeak() {self._isWeak = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _componentIdentifier: UInt64? = nil
  fileprivate var _objectIdentifier: UInt64? = nil
  fileprivate var _isWeak: Bool? = nil
}

struct TSP_ComponentDataReference: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dataIdentifier: UInt64 {
    get {return _dataIdentifier ?? 0}
    set {_dataIdentifier = newValue}
  }
  /// Returns true if `dataIdentifier` has been explicitly set.
  var hasDataIdentifier: Bool {return self._dataIdentifier != nil}
  /// Clears the value of `dataIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearDataIdentifier() {self._dataIdentifier = nil}

  var objectReferenceList: [TSP_ComponentDataReference.ObjectReference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ObjectReference: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var objectIdentifier: UInt64 {
      get {return _objectIdentifier ?? 0}
      set {_objectIdentifier = newValue}
    }
    /// Returns true if `objectIdentifier` has been explicitly set.
    var hasObjectIdentifier: Bool {return self._objectIdentifier != nil}
    /// Clears the value of `objectIdentifier`. Subsequent reads from it will return its default value.
    mutating func clearObjectIdentifier() {self._objectIdentifier = nil}

    var count: UInt32 {
      get {return _count ?? 0}
      set {_count = newValue}
    }
    /// Returns true if `count` has been explicitly set.
    var hasCount: Bool {return self._count != nil}
    /// Clears the value of `count`. Subsequent reads from it will return its default value.
    mutating func clearCount() {self._count = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _objectIdentifier: UInt64? = nil
    fileprivate var _count: UInt32? = nil
  }

  init() {}

  fileprivate var _dataIdentifier: UInt64? = nil
}

struct TSP_ObjectUUIDMapEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var identifier: UInt64 {
    get {return _identifier ?? 0}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {self._identifier = nil}

  var uuid: TSP_UUID {
    get {return _uuid ?? TSP_UUID()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {self._uuid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _identifier: UInt64? = nil
  fileprivate var _uuid: TSP_UUID? = nil
}

struct TSP_FeatureInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var identifier: String {
    get {return _identifier ?? String()}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {self._identifier = nil}

  var readVersion: [UInt32] = []

  var writeVersion: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _identifier: String? = nil
}

struct TSP_PackageMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lastObjectIdentifier: UInt64 {
    get {return _lastObjectIdentifier ?? 0}
    set {_lastObjectIdentifier = newValue}
  }
  /// Returns true if `lastObjectIdentifier` has been explicitly set.
  var hasLastObjectIdentifier: Bool {return self._lastObjectIdentifier != nil}
  /// Clears the value of `lastObjectIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearLastObjectIdentifier() {self._lastObjectIdentifier = nil}

  var revision: TSP_DocumentRevision {
    get {return _revision ?? TSP_DocumentRevision()}
    set {_revision = newValue}
  }
  /// Returns true if `revision` has been explicitly set.
  var hasRevision: Bool {return self._revision != nil}
  /// Clears the value of `revision`. Subsequent reads from it will return its default value.
  mutating func clearRevision() {self._revision = nil}

  var components: [TSP_ComponentInfo] = []

  var datas: [TSP_DataInfo] = []

  var readVersion: [UInt32] = []

  var writeVersion: [UInt32] = []

  var fileFormatVersion: [UInt32] = []

  var saveToken: UInt64 {
    get {return _saveToken ?? 0}
    set {_saveToken = newValue}
  }
  /// Returns true if `saveToken` has been explicitly set.
  var hasSaveToken: Bool {return self._saveToken != nil}
  /// Clears the value of `saveToken`. Subsequent reads from it will return its default value.
  mutating func clearSaveToken() {self._saveToken = nil}

  var preferredPackageType: TSP_PackageMetadata.PackageType {
    get {return _preferredPackageType ?? .default}
    set {_preferredPackageType = newValue}
  }
  /// Returns true if `preferredPackageType` has been explicitly set.
  var hasPreferredPackageType: Bool {return self._preferredPackageType != nil}
  /// Clears the value of `preferredPackageType`. Subsequent reads from it will return its default value.
  mutating func clearPreferredPackageType() {self._preferredPackageType = nil}

  var dataMetadataMap: TSP_Reference {
    get {return _dataMetadataMap ?? TSP_Reference()}
    set {_dataMetadataMap = newValue}
  }
  /// Returns true if `dataMetadataMap` has been explicitly set.
  var hasDataMetadataMap: Bool {return self._dataMetadataMap != nil}
  /// Clears the value of `dataMetadataMap`. Subsequent reads from it will return its default value.
  mutating func clearDataMetadataMap() {self._dataMetadataMap = nil}

  var versionedComponents: [TSP_ComponentInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PackageType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case `default` = 0
    case directory = 1
    case singleFile = 2

    init() {
      self = .default
    }

  }

  init() {}

  fileprivate var _lastObjectIdentifier: UInt64? = nil
  fileprivate var _revision: TSP_DocumentRevision? = nil
  fileprivate var _saveToken: UInt64? = nil
  fileprivate var _preferredPackageType: TSP_PackageMetadata.PackageType? = nil
  fileprivate var _dataMetadataMap: TSP_Reference? = nil
}

struct TSP_DocumentRevision: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequence32: Int32 {
    get {return _sequence32 ?? 0}
    set {_sequence32 = newValue}
  }
  /// Returns true if `sequence32` has been explicitly set.
  var hasSequence32: Bool {return self._sequence32 != nil}
  /// Clears the value of `sequence32`. Subsequent reads from it will return its default value.
  mutating func clearSequence32() {self._sequence32 = nil}

  var identifier: String {
    get {return _identifier ?? String()}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {self._identifier = nil}

  var sequence64: UInt64 {
    get {return _sequence64 ?? 0}
    set {_sequence64 = newValue}
  }
  /// Returns true if `sequence64` has been explicitly set.
  var hasSequence64: Bool {return self._sequence64 != nil}
  /// Clears the value of `sequence64`. Subsequent reads from it will return its default value.
  mutating func clearSequence64() {self._sequence64 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sequence32: Int32? = nil
  fileprivate var _identifier: String? = nil
  fileprivate var _sequence64: UInt64? = nil
}

struct TSP_PasteboardMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: [UInt32] = []

  var appName: String {
    get {return _appName ?? String()}
    set {_appName = newValue}
  }
  /// Returns true if `appName` has been explicitly set.
  var hasAppName: Bool {return self._appName != nil}
  /// Clears the value of `appName`. Subsequent reads from it will return its default value.
  mutating func clearAppName() {self._appName = nil}

  var datas: [TSP_DataInfo] = []

  var sourceDocumentUuid: TSP_UUID {
    get {return _sourceDocumentUuid ?? TSP_UUID()}
    set {_sourceDocumentUuid = newValue}
  }
  /// Returns true if `sourceDocumentUuid` has been explicitly set.
  var hasSourceDocumentUuid: Bool {return self._sourceDocumentUuid != nil}
  /// Clears the value of `sourceDocumentUuid`. Subsequent reads from it will return its default value.
  mutating func clearSourceDocumentUuid() {self._sourceDocumentUuid = nil}

  var dataMetadataMap: TSP_Reference {
    get {return _dataMetadataMap ?? TSP_Reference()}
    set {_dataMetadataMap = newValue}
  }
  /// Returns true if `dataMetadataMap` has been explicitly set.
  var hasDataMetadataMap: Bool {return self._dataMetadataMap != nil}
  /// Clears the value of `dataMetadataMap`. Subsequent reads from it will return its default value.
  mutating func clearDataMetadataMap() {self._dataMetadataMap = nil}

  var readVersion: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _appName: String? = nil
  fileprivate var _sourceDocumentUuid: TSP_UUID? = nil
  fileprivate var _dataMetadataMap: TSP_Reference? = nil
}

struct TSP_DataInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var identifier: UInt64 {
    get {return _storage._identifier ?? 0}
    set {_uniqueStorage()._identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return _storage._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {_uniqueStorage()._identifier = nil}

  var digest: Data {
    get {return _storage._digest ?? Data()}
    set {_uniqueStorage()._digest = newValue}
  }
  /// Returns true if `digest` has been explicitly set.
  var hasDigest: Bool {return _storage._digest != nil}
  /// Clears the value of `digest`. Subsequent reads from it will return its default value.
  mutating func clearDigest() {_uniqueStorage()._digest = nil}

  var preferredFileName: String {
    get {return _storage._preferredFileName ?? String()}
    set {_uniqueStorage()._preferredFileName = newValue}
  }
  /// Returns true if `preferredFileName` has been explicitly set.
  var hasPreferredFileName: Bool {return _storage._preferredFileName != nil}
  /// Clears the value of `preferredFileName`. Subsequent reads from it will return its default value.
  mutating func clearPreferredFileName() {_uniqueStorage()._preferredFileName = nil}

  var fileName: String {
    get {return _storage._fileName ?? String()}
    set {_uniqueStorage()._fileName = newValue}
  }
  /// Returns true if `fileName` has been explicitly set.
  var hasFileName: Bool {return _storage._fileName != nil}
  /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
  mutating func clearFileName() {_uniqueStorage()._fileName = nil}

  var documentResourceLocator: String {
    get {return _storage._documentResourceLocator ?? String()}
    set {_uniqueStorage()._documentResourceLocator = newValue}
  }
  /// Returns true if `documentResourceLocator` has been explicitly set.
  var hasDocumentResourceLocator: Bool {return _storage._documentResourceLocator != nil}
  /// Clears the value of `documentResourceLocator`. Subsequent reads from it will return its default value.
  mutating func clearDocumentResourceLocator() {_uniqueStorage()._documentResourceLocator = nil}

  var sourceBookmarkData: Data {
    get {return _storage._sourceBookmarkData ?? Data()}
    set {_uniqueStorage()._sourceBookmarkData = newValue}
  }
  /// Returns true if `sourceBookmarkData` has been explicitly set.
  var hasSourceBookmarkData: Bool {return _storage._sourceBookmarkData != nil}
  /// Clears the value of `sourceBookmarkData`. Subsequent reads from it will return its default value.
  mutating func clearSourceBookmarkData() {_uniqueStorage()._sourceBookmarkData = nil}

  var remoteURL: String {
    get {return _storage._remoteURL ?? String()}
    set {_uniqueStorage()._remoteURL = newValue}
  }
  /// Returns true if `remoteURL` has been explicitly set.
  var hasRemoteURL: Bool {return _storage._remoteURL != nil}
  /// Clears the value of `remoteURL`. Subsequent reads from it will return its default value.
  mutating func clearRemoteURL() {_uniqueStorage()._remoteURL = nil}

  var canDownload: Bool {
    get {return _storage._canDownload ?? false}
    set {_uniqueStorage()._canDownload = newValue}
  }
  /// Returns true if `canDownload` has been explicitly set.
  var hasCanDownload: Bool {return _storage._canDownload != nil}
  /// Clears the value of `canDownload`. Subsequent reads from it will return its default value.
  mutating func clearCanDownload() {_uniqueStorage()._canDownload = nil}

  var downloadPriority: TSP_DataInfo.DownloadPriority {
    get {return _storage._downloadPriority ?? .default}
    set {_uniqueStorage()._downloadPriority = newValue}
  }
  /// Returns true if `downloadPriority` has been explicitly set.
  var hasDownloadPriority: Bool {return _storage._downloadPriority != nil}
  /// Clears the value of `downloadPriority`. Subsequent reads from it will return its default value.
  mutating func clearDownloadPriority() {_uniqueStorage()._downloadPriority = nil}

  var attributes: TSP_DataAttributes {
    get {return _storage._attributes ?? TSP_DataAttributes()}
    set {_uniqueStorage()._attributes = newValue}
  }
  /// Returns true if `attributes` has been explicitly set.
  var hasAttributes: Bool {return _storage._attributes != nil}
  /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
  mutating func clearAttributes() {_uniqueStorage()._attributes = nil}

  var encryptionInfo: TSP_EncryptionInfo {
    get {return _storage._encryptionInfo ?? TSP_EncryptionInfo()}
    set {_uniqueStorage()._encryptionInfo = newValue}
  }
  /// Returns true if `encryptionInfo` has been explicitly set.
  var hasEncryptionInfo: Bool {return _storage._encryptionInfo != nil}
  /// Clears the value of `encryptionInfo`. Subsequent reads from it will return its default value.
  mutating func clearEncryptionInfo() {_uniqueStorage()._encryptionInfo = nil}

  var lastMismatchedDigest: Data {
    get {return _storage._lastMismatchedDigest ?? Data()}
    set {_uniqueStorage()._lastMismatchedDigest = newValue}
  }
  /// Returns true if `lastMismatchedDigest` has been explicitly set.
  var hasLastMismatchedDigest: Bool {return _storage._lastMismatchedDigest != nil}
  /// Clears the value of `lastMismatchedDigest`. Subsequent reads from it will return its default value.
  mutating func clearLastMismatchedDigest() {_uniqueStorage()._lastMismatchedDigest = nil}

  var unmaterializedRanges: TSP_IndexSet {
    get {return _storage._unmaterializedRanges ?? TSP_IndexSet()}
    set {_uniqueStorage()._unmaterializedRanges = newValue}
  }
  /// Returns true if `unmaterializedRanges` has been explicitly set.
  var hasUnmaterializedRanges: Bool {return _storage._unmaterializedRanges != nil}
  /// Clears the value of `unmaterializedRanges`. Subsequent reads from it will return its default value.
  mutating func clearUnmaterializedRanges() {_uniqueStorage()._unmaterializedRanges = nil}

  var remoteDataLength: UInt64 {
    get {return _storage._remoteDataLength ?? 0}
    set {_uniqueStorage()._remoteDataLength = newValue}
  }
  /// Returns true if `remoteDataLength` has been explicitly set.
  var hasRemoteDataLength: Bool {return _storage._remoteDataLength != nil}
  /// Clears the value of `remoteDataLength`. Subsequent reads from it will return its default value.
  mutating func clearRemoteDataLength() {_uniqueStorage()._remoteDataLength = nil}

  var remoteDataHasPackageStorage: Bool {
    get {return _storage._remoteDataHasPackageStorage ?? false}
    set {_uniqueStorage()._remoteDataHasPackageStorage = newValue}
  }
  /// Returns true if `remoteDataHasPackageStorage` has been explicitly set.
  var hasRemoteDataHasPackageStorage: Bool {return _storage._remoteDataHasPackageStorage != nil}
  /// Clears the value of `remoteDataHasPackageStorage`. Subsequent reads from it will return its default value.
  mutating func clearRemoteDataHasPackageStorage() {_uniqueStorage()._remoteDataHasPackageStorage = nil}

  var uploadStatus: TSP_DataUploadStatus {
    get {return _storage._uploadStatus ?? .pending}
    set {_uniqueStorage()._uploadStatus = newValue}
  }
  /// Returns true if `uploadStatus` has been explicitly set.
  var hasUploadStatus: Bool {return _storage._uploadStatus != nil}
  /// Clears the value of `uploadStatus`. Subsequent reads from it will return its default value.
  mutating func clearUploadStatus() {_uniqueStorage()._uploadStatus = nil}

  var remoteDataMtime: Double {
    get {return _storage._remoteDataMtime ?? 0}
    set {_uniqueStorage()._remoteDataMtime = newValue}
  }
  /// Returns true if `remoteDataMtime` has been explicitly set.
  var hasRemoteDataMtime: Bool {return _storage._remoteDataMtime != nil}
  /// Clears the value of `remoteDataMtime`. Subsequent reads from it will return its default value.
  mutating func clearRemoteDataMtime() {_uniqueStorage()._remoteDataMtime = nil}

  var materializedLength: UInt64 {
    get {return _storage._materializedLength ?? 0}
    set {_uniqueStorage()._materializedLength = newValue}
  }
  /// Returns true if `materializedLength` has been explicitly set.
  var hasMaterializedLength: Bool {return _storage._materializedLength != nil}
  /// Clears the value of `materializedLength`. Subsequent reads from it will return its default value.
  mutating func clearMaterializedLength() {_uniqueStorage()._materializedLength = nil}

  var pasteboardExternalFilePath: String {
    get {return _storage._pasteboardExternalFilePath ?? String()}
    set {_uniqueStorage()._pasteboardExternalFilePath = newValue}
  }
  /// Returns true if `pasteboardExternalFilePath` has been explicitly set.
  var hasPasteboardExternalFilePath: Bool {return _storage._pasteboardExternalFilePath != nil}
  /// Clears the value of `pasteboardExternalFilePath`. Subsequent reads from it will return its default value.
  mutating func clearPasteboardExternalFilePath() {_uniqueStorage()._pasteboardExternalFilePath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum DownloadPriority: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case high = 0
    case `default` = 1

    init() {
      self = .high
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSP_DataMetadataMap: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dataMetadataEntries: [TSP_DataMetadataMap.DataMetadataMapEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct DataMetadataMapEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dataIdentifier: UInt64 {
      get {return _dataIdentifier ?? 0}
      set {_dataIdentifier = newValue}
    }
    /// Returns true if `dataIdentifier` has been explicitly set.
    var hasDataIdentifier: Bool {return self._dataIdentifier != nil}
    /// Clears the value of `dataIdentifier`. Subsequent reads from it will return its default value.
    mutating func clearDataIdentifier() {self._dataIdentifier = nil}

    var dataMetadata: TSP_Reference {
      get {return _dataMetadata ?? TSP_Reference()}
      set {_dataMetadata = newValue}
    }
    /// Returns true if `dataMetadata` has been explicitly set.
    var hasDataMetadata: Bool {return self._dataMetadata != nil}
    /// Clears the value of `dataMetadata`. Subsequent reads from it will return its default value.
    mutating func clearDataMetadata() {self._dataMetadata = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _dataIdentifier: UInt64? = nil
    fileprivate var _dataMetadata: TSP_Reference? = nil
  }

  init() {}
}

struct TSP_DataMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fallbackColor: TSP_Color {
    get {return _fallbackColor ?? TSP_Color()}
    set {_fallbackColor = newValue}
  }
  /// Returns true if `fallbackColor` has been explicitly set.
  var hasFallbackColor: Bool {return self._fallbackColor != nil}
  /// Clears the value of `fallbackColor`. Subsequent reads from it will return its default value.
  mutating func clearFallbackColor() {self._fallbackColor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fallbackColor: TSP_Color? = nil
}

struct TSP_EncryptionInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var decodedLength: UInt64 {
    get {return _decodedLength ?? 0}
    set {_decodedLength = newValue}
  }
  /// Returns true if `decodedLength` has been explicitly set.
  var hasDecodedLength: Bool {return self._decodedLength != nil}
  /// Clears the value of `decodedLength`. Subsequent reads from it will return its default value.
  mutating func clearDecodedLength() {self._decodedLength = nil}

  var preferredBlockSize: UInt64 {
    get {return _preferredBlockSize ?? 0}
    set {_preferredBlockSize = newValue}
  }
  /// Returns true if `preferredBlockSize` has been explicitly set.
  var hasPreferredBlockSize: Bool {return self._preferredBlockSize != nil}
  /// Clears the value of `preferredBlockSize`. Subsequent reads from it will return its default value.
  mutating func clearPreferredBlockSize() {self._preferredBlockSize = nil}

  var blockInfos: [TSP_EncryptionBlockInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _decodedLength: UInt64? = nil
  fileprivate var _preferredBlockSize: UInt64? = nil
}

struct TSP_EncryptionBlockInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var encodedLength: UInt64 {
    get {return _encodedLength ?? 0}
    set {_encodedLength = newValue}
  }
  /// Returns true if `encodedLength` has been explicitly set.
  var hasEncodedLength: Bool {return self._encodedLength != nil}
  /// Clears the value of `encodedLength`. Subsequent reads from it will return its default value.
  mutating func clearEncodedLength() {self._encodedLength = nil}

  var decodedLength: UInt64 {
    get {return _decodedLength ?? 0}
    set {_decodedLength = newValue}
  }
  /// Returns true if `decodedLength` has been explicitly set.
  var hasDecodedLength: Bool {return self._decodedLength != nil}
  /// Clears the value of `decodedLength`. Subsequent reads from it will return its default value.
  mutating func clearDecodedLength() {self._decodedLength = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _encodedLength: UInt64? = nil
  fileprivate var _decodedLength: UInt64? = nil
}

struct TSP_ViewStateMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: [UInt32] = []

  var versionUuid: TSP_UUID {
    get {return _versionUuid ?? TSP_UUID()}
    set {_versionUuid = newValue}
  }
  /// Returns true if `versionUuid` has been explicitly set.
  var hasVersionUuid: Bool {return self._versionUuid != nil}
  /// Clears the value of `versionUuid`. Subsequent reads from it will return its default value.
  mutating func clearVersionUuid() {self._versionUuid = nil}

  var component: TSP_ComponentInfo {
    get {return _component ?? TSP_ComponentInfo()}
    set {_component = newValue}
  }
  /// Returns true if `component` has been explicitly set.
  var hasComponent: Bool {return self._component != nil}
  /// Clears the value of `component`. Subsequent reads from it will return its default value.
  mutating func clearComponent() {self._component = nil}

  var externalObjectUuidMapEntries: [TSP_ObjectUUIDMapEntry] = []

  var readVersion: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _versionUuid: TSP_UUID? = nil
  fileprivate var _component: TSP_ComponentInfo? = nil
}

struct TSP_ObjectSerializationMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: [UInt32] = []

  var sourceDocumentUuid: TSP_UUID {
    get {return _sourceDocumentUuid ?? TSP_UUID()}
    set {_sourceDocumentUuid = newValue}
  }
  /// Returns true if `sourceDocumentUuid` has been explicitly set.
  var hasSourceDocumentUuid: Bool {return self._sourceDocumentUuid != nil}
  /// Clears the value of `sourceDocumentUuid`. Subsequent reads from it will return its default value.
  mutating func clearSourceDocumentUuid() {self._sourceDocumentUuid = nil}

  var versionUuid: TSP_UUID {
    get {return _versionUuid ?? TSP_UUID()}
    set {_versionUuid = newValue}
  }
  /// Returns true if `versionUuid` has been explicitly set.
  var hasVersionUuid: Bool {return self._versionUuid != nil}
  /// Clears the value of `versionUuid`. Subsequent reads from it will return its default value.
  mutating func clearVersionUuid() {self._versionUuid = nil}

  var component: TSP_ComponentInfo {
    get {return _component ?? TSP_ComponentInfo()}
    set {_component = newValue}
  }
  /// Returns true if `component` has been explicitly set.
  var hasComponent: Bool {return self._component != nil}
  /// Clears the value of `component`. Subsequent reads from it will return its default value.
  mutating func clearComponent() {self._component = nil}

  var datas: [TSP_DataInfo] = []

  var externalObjectUuidMapEntries: [TSP_ObjectUUIDMapEntry] = []

  var dataMetadataMap: TSP_Reference {
    get {return _dataMetadataMap ?? TSP_Reference()}
    set {_dataMetadataMap = newValue}
  }
  /// Returns true if `dataMetadataMap` has been explicitly set.
  var hasDataMetadataMap: Bool {return self._dataMetadataMap != nil}
  /// Clears the value of `dataMetadataMap`. Subsequent reads from it will return its default value.
  mutating func clearDataMetadataMap() {self._dataMetadataMap = nil}

  var readVersion: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sourceDocumentUuid: TSP_UUID? = nil
  fileprivate var _versionUuid: TSP_UUID? = nil
  fileprivate var _component: TSP_ComponentInfo? = nil
  fileprivate var _dataMetadataMap: TSP_Reference? = nil
}

struct TSP_ObjectSerializationDirectory: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [TSP_ObjectSerializationDirectory.Entry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Entry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var locator: String {
      get {return _locator ?? String()}
      set {_locator = newValue}
    }
    /// Returns true if `locator` has been explicitly set.
    var hasLocator: Bool {return self._locator != nil}
    /// Clears the value of `locator`. Subsequent reads from it will return its default value.
    mutating func clearLocator() {self._locator = nil}

    var offset: UInt64 {
      get {return _offset ?? 0}
      set {_offset = newValue}
    }
    /// Returns true if `offset` has been explicitly set.
    var hasOffset: Bool {return self._offset != nil}
    /// Clears the value of `offset`. Subsequent reads from it will return its default value.
    mutating func clearOffset() {self._offset = nil}

    var size: UInt64 {
      get {return _size ?? 0}
      set {_size = newValue}
    }
    /// Returns true if `size` has been explicitly set.
    var hasSize: Bool {return self._size != nil}
    /// Clears the value of `size`. Subsequent reads from it will return its default value.
    mutating func clearSize() {self._size = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _locator: String? = nil
    fileprivate var _offset: UInt64? = nil
    fileprivate var _size: UInt64? = nil
  }

  init() {}
}

struct TSP_DataPropertiesEntryV1: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var digest: Data {
    get {return _digest ?? Data()}
    set {_digest = newValue}
  }
  /// Returns true if `digest` has been explicitly set.
  var hasDigest: Bool {return self._digest != nil}
  /// Clears the value of `digest`. Subsequent reads from it will return its default value.
  mutating func clearDigest() {self._digest = nil}

  var expectsMatchedDigest: Bool {
    get {return _expectsMatchedDigest ?? false}
    set {_expectsMatchedDigest = newValue}
  }
  /// Returns true if `expectsMatchedDigest` has been explicitly set.
  var hasExpectsMatchedDigest: Bool {return self._expectsMatchedDigest != nil}
  /// Clears the value of `expectsMatchedDigest`. Subsequent reads from it will return its default value.
  mutating func clearExpectsMatchedDigest() {self._expectsMatchedDigest = nil}

  var creationTimeIntervalSince1970: Double {
    get {return _creationTimeIntervalSince1970 ?? 0}
    set {_creationTimeIntervalSince1970 = newValue}
  }
  /// Returns true if `creationTimeIntervalSince1970` has been explicitly set.
  var hasCreationTimeIntervalSince1970: Bool {return self._creationTimeIntervalSince1970 != nil}
  /// Clears the value of `creationTimeIntervalSince1970`. Subsequent reads from it will return its default value.
  mutating func clearCreationTimeIntervalSince1970() {self._creationTimeIntervalSince1970 = nil}

  var creationVersion: [UInt32] = []

  var lastMismatchedDigest: Data {
    get {return _lastMismatchedDigest ?? Data()}
    set {_lastMismatchedDigest = newValue}
  }
  /// Returns true if `lastMismatchedDigest` has been explicitly set.
  var hasLastMismatchedDigest: Bool {return self._lastMismatchedDigest != nil}
  /// Clears the value of `lastMismatchedDigest`. Subsequent reads from it will return its default value.
  mutating func clearLastMismatchedDigest() {self._lastMismatchedDigest = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _digest: Data? = nil
  fileprivate var _expectsMatchedDigest: Bool? = nil
  fileprivate var _creationTimeIntervalSince1970: Double? = nil
  fileprivate var _lastMismatchedDigest: Data? = nil
}

struct TSP_DataPropertiesV1: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var properties: [TSP_DataPropertiesEntryV1] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSP_DocumentMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isInCollaborationMode: Bool {
    get {return _isInCollaborationMode ?? false}
    set {_isInCollaborationMode = newValue}
  }
  /// Returns true if `isInCollaborationMode` has been explicitly set.
  var hasIsInCollaborationMode: Bool {return self._isInCollaborationMode != nil}
  /// Clears the value of `isInCollaborationMode`. Subsequent reads from it will return its default value.
  mutating func clearIsInCollaborationMode() {self._isInCollaborationMode = nil}

  var dataPropertiesV1: TSP_DataPropertiesV1 {
    get {return _dataPropertiesV1 ?? TSP_DataPropertiesV1()}
    set {_dataPropertiesV1 = newValue}
  }
  /// Returns true if `dataPropertiesV1` has been explicitly set.
  var hasDataPropertiesV1: Bool {return self._dataPropertiesV1 != nil}
  /// Clears the value of `dataPropertiesV1`. Subsequent reads from it will return its default value.
  mutating func clearDataPropertiesV1() {self._dataPropertiesV1 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _isInCollaborationMode: Bool? = nil
  fileprivate var _dataPropertiesV1: TSP_DataPropertiesV1? = nil
}

struct TSP_SupportMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isInCollaborationMode: Bool {
    get {return _isInCollaborationMode ?? false}
    set {_isInCollaborationMode = newValue}
  }
  /// Returns true if `isInCollaborationMode` has been explicitly set.
  var hasIsInCollaborationMode: Bool {return self._isInCollaborationMode != nil}
  /// Clears the value of `isInCollaborationMode`. Subsequent reads from it will return its default value.
  mutating func clearIsInCollaborationMode() {self._isInCollaborationMode = nil}

  var dataCollaborationProperties: [TSP_SupportMetadata.DataCollaborationProperties] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct DataCollaborationProperties: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var digest: Data {
      get {return _digest ?? Data()}
      set {_digest = newValue}
    }
    /// Returns true if `digest` has been explicitly set.
    var hasDigest: Bool {return self._digest != nil}
    /// Clears the value of `digest`. Subsequent reads from it will return its default value.
    mutating func clearDigest() {self._digest = nil}

    var acknowledgedByServer: Bool {
      get {return _acknowledgedByServer ?? false}
      set {_acknowledgedByServer = newValue}
    }
    /// Returns true if `acknowledgedByServer` has been explicitly set.
    var hasAcknowledgedByServer: Bool {return self._acknowledgedByServer != nil}
    /// Clears the value of `acknowledgedByServer`. Subsequent reads from it will return its default value.
    mutating func clearAcknowledgedByServer() {self._acknowledgedByServer = nil}

    var materializedOnServer: Bool {
      get {return _materializedOnServer ?? false}
      set {_materializedOnServer = newValue}
    }
    /// Returns true if `materializedOnServer` has been explicitly set.
    var hasMaterializedOnServer: Bool {return self._materializedOnServer != nil}
    /// Clears the value of `materializedOnServer`. Subsequent reads from it will return its default value.
    mutating func clearMaterializedOnServer() {self._materializedOnServer = nil}

    var revisionSequenceForMaterializedOnServer: Int32 {
      get {return _revisionSequenceForMaterializedOnServer ?? 0}
      set {_revisionSequenceForMaterializedOnServer = newValue}
    }
    /// Returns true if `revisionSequenceForMaterializedOnServer` has been explicitly set.
    var hasRevisionSequenceForMaterializedOnServer: Bool {return self._revisionSequenceForMaterializedOnServer != nil}
    /// Clears the value of `revisionSequenceForMaterializedOnServer`. Subsequent reads from it will return its default value.
    mutating func clearRevisionSequenceForMaterializedOnServer() {self._revisionSequenceForMaterializedOnServer = nil}

    var uploadStatus: TSP_DataUploadStatus {
      get {return _uploadStatus ?? .pending}
      set {_uploadStatus = newValue}
    }
    /// Returns true if `uploadStatus` has been explicitly set.
    var hasUploadStatus: Bool {return self._uploadStatus != nil}
    /// Clears the value of `uploadStatus`. Subsequent reads from it will return its default value.
    mutating func clearUploadStatus() {self._uploadStatus = nil}

    var isRemoteDataEver: Bool {
      get {return _isRemoteDataEver ?? false}
      set {_isRemoteDataEver = newValue}
    }
    /// Returns true if `isRemoteDataEver` has been explicitly set.
    var hasIsRemoteDataEver: Bool {return self._isRemoteDataEver != nil}
    /// Clears the value of `isRemoteDataEver`. Subsequent reads from it will return its default value.
    mutating func clearIsRemoteDataEver() {self._isRemoteDataEver = nil}

    var revisionSequenceForAcknowledgedByServer: Int32 {
      get {return _revisionSequenceForAcknowledgedByServer ?? 0}
      set {_revisionSequenceForAcknowledgedByServer = newValue}
    }
    /// Returns true if `revisionSequenceForAcknowledgedByServer` has been explicitly set.
    var hasRevisionSequenceForAcknowledgedByServer: Bool {return self._revisionSequenceForAcknowledgedByServer != nil}
    /// Clears the value of `revisionSequenceForAcknowledgedByServer`. Subsequent reads from it will return its default value.
    mutating func clearRevisionSequenceForAcknowledgedByServer() {self._revisionSequenceForAcknowledgedByServer = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _digest: Data? = nil
    fileprivate var _acknowledgedByServer: Bool? = nil
    fileprivate var _materializedOnServer: Bool? = nil
    fileprivate var _revisionSequenceForMaterializedOnServer: Int32? = nil
    fileprivate var _uploadStatus: TSP_DataUploadStatus? = nil
    fileprivate var _isRemoteDataEver: Bool? = nil
    fileprivate var _revisionSequenceForAcknowledgedByServer: Int32? = nil
  }

  init() {}

  fileprivate var _isInCollaborationMode: Bool? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TSP"

extension TSP_ArchiveInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ArchiveInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identifier\0\u{3}message_infos\0\u{3}should_merge\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.messageInfos) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._identifier) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.messageInfos) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._shouldMerge) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    if !self.messageInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messageInfos, fieldNumber: 2)
    }
    try { if let v = self._shouldMerge {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_ArchiveInfo, rhs: TSP_ArchiveInfo) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs.messageInfos != rhs.messageInfos {return false}
    if lhs._shouldMerge != rhs._shouldMerge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_MessageInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}version\0\u{1}length\0\u{3}field_infos\0\u{3}object_references\0\u{3}data_references\0\u{3}base_message_index\0\u{3}diff_merge_version\0\u{3}diff_field_path\0\u{3}fields_to_remove\0\u{3}diff_read_version\0")

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if self._length == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.fieldInfos) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._type) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._length) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.fieldInfos) }()
      case 5: try { try decoder.decodeRepeatedUInt64Field(value: &self.objectReferences) }()
      case 6: try { try decoder.decodeRepeatedUInt64Field(value: &self.dataReferences) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._baseMessageIndex) }()
      case 8: try { try decoder.decodeRepeatedUInt32Field(value: &self.diffMergeVersion) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._diffFieldPath) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.fieldsToRemove) }()
      case 11: try { try decoder.decodeRepeatedUInt32Field(value: &self.diffReadVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.version.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.version, fieldNumber: 2)
    }
    try { if let v = self._length {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    if !self.fieldInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fieldInfos, fieldNumber: 4)
    }
    if !self.objectReferences.isEmpty {
      try visitor.visitRepeatedUInt64Field(value: self.objectReferences, fieldNumber: 5)
    }
    if !self.dataReferences.isEmpty {
      try visitor.visitRepeatedUInt64Field(value: self.dataReferences, fieldNumber: 6)
    }
    try { if let v = self._baseMessageIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    if !self.diffMergeVersion.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.diffMergeVersion, fieldNumber: 8)
    }
    try { if let v = self._diffFieldPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.fieldsToRemove.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fieldsToRemove, fieldNumber: 10)
    }
    if !self.diffReadVersion.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.diffReadVersion, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_MessageInfo, rhs: TSP_MessageInfo) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.version != rhs.version {return false}
    if lhs._length != rhs._length {return false}
    if lhs.fieldInfos != rhs.fieldInfos {return false}
    if lhs.objectReferences != rhs.objectReferences {return false}
    if lhs.dataReferences != rhs.dataReferences {return false}
    if lhs._baseMessageIndex != rhs._baseMessageIndex {return false}
    if lhs.diffMergeVersion != rhs.diffMergeVersion {return false}
    if lhs._diffFieldPath != rhs._diffFieldPath {return false}
    if lhs.fieldsToRemove != rhs.fieldsToRemove {return false}
    if lhs.diffReadVersion != rhs.diffReadVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_FieldInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FieldInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}path\0\u{1}type\0\u{3}unknown_field_rule\0\u{3}object_references\0\u{3}data_references\0\u{3}known_field_rule\0\u{3}known_field_version\0\u{3}known_field_feature_identifier\0")

  public var isInitialized: Bool {
    if self._path == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._path) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._unknownFieldRule) }()
      case 4: try { try decoder.decodeRepeatedUInt64Field(value: &self.objectReferences) }()
      case 5: try { try decoder.decodeRepeatedUInt64Field(value: &self.dataReferences) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._knownFieldRule) }()
      case 7: try { try decoder.decodeRepeatedUInt32Field(value: &self.knownFieldVersion) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._knownFieldFeatureIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._path {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._unknownFieldRule {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    if !self.objectReferences.isEmpty {
      try visitor.visitRepeatedUInt64Field(value: self.objectReferences, fieldNumber: 4)
    }
    if !self.dataReferences.isEmpty {
      try visitor.visitRepeatedUInt64Field(value: self.dataReferences, fieldNumber: 5)
    }
    try { if let v = self._knownFieldRule {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    if !self.knownFieldVersion.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.knownFieldVersion, fieldNumber: 7)
    }
    try { if let v = self._knownFieldFeatureIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_FieldInfo, rhs: TSP_FieldInfo) -> Bool {
    if lhs._path != rhs._path {return false}
    if lhs._type != rhs._type {return false}
    if lhs._unknownFieldRule != rhs._unknownFieldRule {return false}
    if lhs.objectReferences != rhs.objectReferences {return false}
    if lhs.dataReferences != rhs.dataReferences {return false}
    if lhs._knownFieldRule != rhs._knownFieldRule {return false}
    if lhs.knownFieldVersion != rhs.knownFieldVersion {return false}
    if lhs._knownFieldFeatureIdentifier != rhs._knownFieldFeatureIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_FieldInfo.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Value\0\u{1}ObjectReference\0\u{1}DataReference\0\u{1}Message\0")
}

extension TSP_FieldInfo.UnknownFieldRule: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{7f}\u{7f}\u{7f}\u{7f}\u{7f}\u{3}NotSupported\0\u{1}IgnoreAndPreserveUntilModified\0\u{1}IgnoreAndPreserve\0\u{1}MustUnderstand\0")
}

extension TSP_FieldInfo.KnownFieldRule: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0None\0\u{1}PreserveNewerValueUntilModified\0\u{1}PreserveNewerValue\0")
}

extension TSP_FieldPath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FieldPath"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}path\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.path, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_FieldPath, rhs: TSP_FieldPath) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_ComponentInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ComponentInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identifier\0\u{3}preferred_locator\0\u{1}locator\0\u{3}document_read_version\0\u{3}document_write_version\0\u{3}external_references\0\u{3}data_references\0\u{4}\u{3}is_stored_outside_object_archive\0\u{3}object_uuid_map_entries\0\u{3}save_token\0\u{3}feature_infos\0\u{3}component_read_version\0\u{3}component_required_version\0\u{3}compression_algorithm\0\u{3}can_be_dropped\0\u{3}versioned_external_references\0\u{3}is_wasteful\0\u{3}ambiguous_object_identifiers\0\u{3}required_package_identifier\0")

  fileprivate class _StorageClass {
    var _identifier: UInt64? = nil
    var _preferredLocator: String? = nil
    var _locator: String? = nil
    var _documentReadVersion: [UInt32] = []
    var _documentWriteVersion: [UInt32] = []
    var _externalReferences: [TSP_ComponentExternalReference] = []
    var _dataReferences: [TSP_ComponentDataReference] = []
    var _isStoredOutsideObjectArchive: Bool? = nil
    var _objectUuidMapEntries: [TSP_ObjectUUIDMapEntry] = []
    var _saveToken: UInt64? = nil
    var _featureInfos: [TSP_FeatureInfo] = []
    var _componentReadVersion: [UInt32] = []
    var _componentRequiredVersion: [UInt32] = []
    var _compressionAlgorithm: UInt32? = nil
    var _canBeDropped: Bool? = nil
    var _versionedExternalReferences: [TSP_ComponentExternalReference] = []
    var _isWasteful: Bool? = nil
    var _ambiguousObjectIdentifiers: [UInt64] = []
    var _requiredPackageIdentifier: UInt32? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _identifier = source._identifier
      _preferredLocator = source._preferredLocator
      _locator = source._locator
      _documentReadVersion = source._documentReadVersion
      _documentWriteVersion = source._documentWriteVersion
      _externalReferences = source._externalReferences
      _dataReferences = source._dataReferences
      _isStoredOutsideObjectArchive = source._isStoredOutsideObjectArchive
      _objectUuidMapEntries = source._objectUuidMapEntries
      _saveToken = source._saveToken
      _featureInfos = source._featureInfos
      _componentReadVersion = source._componentReadVersion
      _componentRequiredVersion = source._componentRequiredVersion
      _compressionAlgorithm = source._compressionAlgorithm
      _canBeDropped = source._canBeDropped
      _versionedExternalReferences = source._versionedExternalReferences
      _isWasteful = source._isWasteful
      _ambiguousObjectIdentifiers = source._ambiguousObjectIdentifiers
      _requiredPackageIdentifier = source._requiredPackageIdentifier
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._identifier == nil {return false}
      if _storage._preferredLocator == nil {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._externalReferences) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._dataReferences) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._objectUuidMapEntries) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._featureInfos) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._versionedExternalReferences) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._identifier) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._preferredLocator) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._locator) }()
        case 4: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._documentReadVersion) }()
        case 5: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._documentWriteVersion) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._externalReferences) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._dataReferences) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._isStoredOutsideObjectArchive) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._objectUuidMapEntries) }()
        case 12: try { try decoder.decodeSingularUInt64Field(value: &_storage._saveToken) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._featureInfos) }()
        case 14: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._componentReadVersion) }()
        case 15: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._componentRequiredVersion) }()
        case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._compressionAlgorithm) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._canBeDropped) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._versionedExternalReferences) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._isWasteful) }()
        case 20: try { try decoder.decodeRepeatedUInt64Field(value: &_storage._ambiguousObjectIdentifiers) }()
        case 21: try { try decoder.decodeSingularUInt32Field(value: &_storage._requiredPackageIdentifier) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._identifier {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._preferredLocator {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._locator {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      if !_storage._documentReadVersion.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._documentReadVersion, fieldNumber: 4)
      }
      if !_storage._documentWriteVersion.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._documentWriteVersion, fieldNumber: 5)
      }
      if !_storage._externalReferences.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._externalReferences, fieldNumber: 6)
      }
      if !_storage._dataReferences.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._dataReferences, fieldNumber: 7)
      }
      try { if let v = _storage._isStoredOutsideObjectArchive {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      if !_storage._objectUuidMapEntries.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._objectUuidMapEntries, fieldNumber: 11)
      }
      try { if let v = _storage._saveToken {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 12)
      } }()
      if !_storage._featureInfos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._featureInfos, fieldNumber: 13)
      }
      if !_storage._componentReadVersion.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._componentReadVersion, fieldNumber: 14)
      }
      if !_storage._componentRequiredVersion.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._componentRequiredVersion, fieldNumber: 15)
      }
      try { if let v = _storage._compressionAlgorithm {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._canBeDropped {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      } }()
      if !_storage._versionedExternalReferences.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._versionedExternalReferences, fieldNumber: 18)
      }
      try { if let v = _storage._isWasteful {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 19)
      } }()
      if !_storage._ambiguousObjectIdentifiers.isEmpty {
        try visitor.visitRepeatedUInt64Field(value: _storage._ambiguousObjectIdentifiers, fieldNumber: 20)
      }
      try { if let v = _storage._requiredPackageIdentifier {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 21)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_ComponentInfo, rhs: TSP_ComponentInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._identifier != rhs_storage._identifier {return false}
        if _storage._preferredLocator != rhs_storage._preferredLocator {return false}
        if _storage._locator != rhs_storage._locator {return false}
        if _storage._documentReadVersion != rhs_storage._documentReadVersion {return false}
        if _storage._documentWriteVersion != rhs_storage._documentWriteVersion {return false}
        if _storage._externalReferences != rhs_storage._externalReferences {return false}
        if _storage._dataReferences != rhs_storage._dataReferences {return false}
        if _storage._isStoredOutsideObjectArchive != rhs_storage._isStoredOutsideObjectArchive {return false}
        if _storage._objectUuidMapEntries != rhs_storage._objectUuidMapEntries {return false}
        if _storage._saveToken != rhs_storage._saveToken {return false}
        if _storage._featureInfos != rhs_storage._featureInfos {return false}
        if _storage._componentReadVersion != rhs_storage._componentReadVersion {return false}
        if _storage._componentRequiredVersion != rhs_storage._componentRequiredVersion {return false}
        if _storage._compressionAlgorithm != rhs_storage._compressionAlgorithm {return false}
        if _storage._canBeDropped != rhs_storage._canBeDropped {return false}
        if _storage._versionedExternalReferences != rhs_storage._versionedExternalReferences {return false}
        if _storage._isWasteful != rhs_storage._isWasteful {return false}
        if _storage._ambiguousObjectIdentifiers != rhs_storage._ambiguousObjectIdentifiers {return false}
        if _storage._requiredPackageIdentifier != rhs_storage._requiredPackageIdentifier {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_ComponentExternalReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ComponentExternalReference"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}component_identifier\0\u{3}object_identifier\0\u{3}is_weak\0")

  public var isInitialized: Bool {
    if self._componentIdentifier == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._componentIdentifier) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._objectIdentifier) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._isWeak) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._componentIdentifier {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._objectIdentifier {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._isWeak {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_ComponentExternalReference, rhs: TSP_ComponentExternalReference) -> Bool {
    if lhs._componentIdentifier != rhs._componentIdentifier {return false}
    if lhs._objectIdentifier != rhs._objectIdentifier {return false}
    if lhs._isWeak != rhs._isWeak {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_ComponentDataReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ComponentDataReference"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}data_identifier\0\u{3}object_reference_list\0")

  public var isInitialized: Bool {
    if self._dataIdentifier == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.objectReferenceList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._dataIdentifier) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.objectReferenceList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._dataIdentifier {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    if !self.objectReferenceList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objectReferenceList, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_ComponentDataReference, rhs: TSP_ComponentDataReference) -> Bool {
    if lhs._dataIdentifier != rhs._dataIdentifier {return false}
    if lhs.objectReferenceList != rhs.objectReferenceList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_ComponentDataReference.ObjectReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSP_ComponentDataReference.protoMessageName + ".ObjectReference"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}object_identifier\0\u{1}count\0")

  public var isInitialized: Bool {
    if self._objectIdentifier == nil {return false}
    if self._count == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._objectIdentifier) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._objectIdentifier {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._count {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_ComponentDataReference.ObjectReference, rhs: TSP_ComponentDataReference.ObjectReference) -> Bool {
    if lhs._objectIdentifier != rhs._objectIdentifier {return false}
    if lhs._count != rhs._count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_ObjectUUIDMapEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ObjectUUIDMapEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identifier\0\u{1}uuid\0")

  public var isInitialized: Bool {
    if self._identifier == nil {return false}
    if self._uuid == nil {return false}
    if let v = self._uuid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._identifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_ObjectUUIDMapEntry, rhs: TSP_ObjectUUIDMapEntry) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs._uuid != rhs._uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_FeatureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeatureInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identifier\0\u{3}read_version\0\u{3}write_version\0")

  public var isInitialized: Bool {
    if self._identifier == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._identifier) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.readVersion) }()
      case 3: try { try decoder.decodeRepeatedUInt32Field(value: &self.writeVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.readVersion.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.readVersion, fieldNumber: 2)
    }
    if !self.writeVersion.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.writeVersion, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_FeatureInfo, rhs: TSP_FeatureInfo) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs.readVersion != rhs.readVersion {return false}
    if lhs.writeVersion != rhs.writeVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_PackageMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PackageMetadata"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}last_object_identifier\0\u{1}revision\0\u{1}components\0\u{1}datas\0\u{3}read_version\0\u{3}write_version\0\u{3}file_format_version\0\u{3}save_token\0\u{3}preferred_package_type\0\u{3}data_metadata_map\0\u{3}versioned_components\0")

  public var isInitialized: Bool {
    if self._lastObjectIdentifier == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.components) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.datas) {return false}
    if let v = self._dataMetadataMap, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.versionedComponents) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._lastObjectIdentifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._revision) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.components) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.datas) }()
      case 5: try { try decoder.decodeRepeatedUInt32Field(value: &self.readVersion) }()
      case 6: try { try decoder.decodeRepeatedUInt32Field(value: &self.writeVersion) }()
      case 7: try { try decoder.decodeRepeatedUInt32Field(value: &self.fileFormatVersion) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self._saveToken) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self._preferredPackageType) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._dataMetadataMap) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.versionedComponents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lastObjectIdentifier {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._revision {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.components.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.components, fieldNumber: 3)
    }
    if !self.datas.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.datas, fieldNumber: 4)
    }
    if !self.readVersion.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.readVersion, fieldNumber: 5)
    }
    if !self.writeVersion.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.writeVersion, fieldNumber: 6)
    }
    if !self.fileFormatVersion.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.fileFormatVersion, fieldNumber: 7)
    }
    try { if let v = self._saveToken {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._preferredPackageType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._dataMetadataMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    if !self.versionedComponents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.versionedComponents, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_PackageMetadata, rhs: TSP_PackageMetadata) -> Bool {
    if lhs._lastObjectIdentifier != rhs._lastObjectIdentifier {return false}
    if lhs._revision != rhs._revision {return false}
    if lhs.components != rhs.components {return false}
    if lhs.datas != rhs.datas {return false}
    if lhs.readVersion != rhs.readVersion {return false}
    if lhs.writeVersion != rhs.writeVersion {return false}
    if lhs.fileFormatVersion != rhs.fileFormatVersion {return false}
    if lhs._saveToken != rhs._saveToken {return false}
    if lhs._preferredPackageType != rhs._preferredPackageType {return false}
    if lhs._dataMetadataMap != rhs._dataMetadataMap {return false}
    if lhs.versionedComponents != rhs.versionedComponents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_PackageMetadata.PackageType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Default\0\u{1}Directory\0\u{1}SingleFile\0")
}

extension TSP_DocumentRevision: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentRevision"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}sequence_64\0\u{1}identifier\0\u{3}sequence_32\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._sequence64) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._identifier) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._sequence32) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sequence64 {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._identifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sequence32 {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_DocumentRevision, rhs: TSP_DocumentRevision) -> Bool {
    if lhs._sequence32 != rhs._sequence32 {return false}
    if lhs._identifier != rhs._identifier {return false}
    if lhs._sequence64 != rhs._sequence64 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_PasteboardMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PasteboardMetadata"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{3}app_name\0\u{1}datas\0\u{4}\u{2}source_document_uuid\0\u{3}data_metadata_map\0\u{3}read_version\0")

  public var isInitialized: Bool {
    if self._appName == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.datas) {return false}
    if let v = self._sourceDocumentUuid, !v.isInitialized {return false}
    if let v = self._dataMetadataMap, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._appName) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.datas) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._sourceDocumentUuid) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._dataMetadataMap) }()
      case 7: try { try decoder.decodeRepeatedUInt32Field(value: &self.readVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.version.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.version, fieldNumber: 1)
    }
    try { if let v = self._appName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.datas.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.datas, fieldNumber: 3)
    }
    try { if let v = self._sourceDocumentUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._dataMetadataMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.readVersion.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.readVersion, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_PasteboardMetadata, rhs: TSP_PasteboardMetadata) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs._appName != rhs._appName {return false}
    if lhs.datas != rhs.datas {return false}
    if lhs._sourceDocumentUuid != rhs._sourceDocumentUuid {return false}
    if lhs._dataMetadataMap != rhs._dataMetadataMap {return false}
    if lhs.readVersion != rhs.readVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_DataInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identifier\0\u{1}digest\0\u{3}preferred_file_name\0\u{3}file_name\0\u{3}document_resource_locator\0\u{3}source_bookmark_data\0\u{3}remote_url\0\u{3}can_download\0\u{3}download_priority\0\u{1}attributes\0\u{3}encryption_info\0\u{3}last_mismatched_digest\0\u{3}unmaterialized_ranges\0\u{3}remote_data_length\0\u{3}remote_data_has_package_storage\0\u{3}upload_status\0\u{3}remote_data_mtime\0\u{3}materialized_length\0\u{4}Q\u{1}pasteboard_external_file_path\0")

  fileprivate class _StorageClass {
    var _identifier: UInt64? = nil
    var _digest: Data? = nil
    var _preferredFileName: String? = nil
    var _fileName: String? = nil
    var _documentResourceLocator: String? = nil
    var _sourceBookmarkData: Data? = nil
    var _remoteURL: String? = nil
    var _canDownload: Bool? = nil
    var _downloadPriority: TSP_DataInfo.DownloadPriority? = nil
    var _attributes: TSP_DataAttributes? = nil
    var _encryptionInfo: TSP_EncryptionInfo? = nil
    var _lastMismatchedDigest: Data? = nil
    var _unmaterializedRanges: TSP_IndexSet? = nil
    var _remoteDataLength: UInt64? = nil
    var _remoteDataHasPackageStorage: Bool? = nil
    var _uploadStatus: TSP_DataUploadStatus? = nil
    var _remoteDataMtime: Double? = nil
    var _materializedLength: UInt64? = nil
    var _pasteboardExternalFilePath: String? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _identifier = source._identifier
      _digest = source._digest
      _preferredFileName = source._preferredFileName
      _fileName = source._fileName
      _documentResourceLocator = source._documentResourceLocator
      _sourceBookmarkData = source._sourceBookmarkData
      _remoteURL = source._remoteURL
      _canDownload = source._canDownload
      _downloadPriority = source._downloadPriority
      _attributes = source._attributes
      _encryptionInfo = source._encryptionInfo
      _lastMismatchedDigest = source._lastMismatchedDigest
      _unmaterializedRanges = source._unmaterializedRanges
      _remoteDataLength = source._remoteDataLength
      _remoteDataHasPackageStorage = source._remoteDataHasPackageStorage
      _uploadStatus = source._uploadStatus
      _remoteDataMtime = source._remoteDataMtime
      _materializedLength = source._materializedLength
      _pasteboardExternalFilePath = source._pasteboardExternalFilePath
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._identifier == nil {return false}
      if _storage._digest == nil {return false}
      if _storage._preferredFileName == nil {return false}
      if let v = _storage._attributes, !v.isInitialized {return false}
      if let v = _storage._encryptionInfo, !v.isInitialized {return false}
      if let v = _storage._unmaterializedRanges, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._identifier) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._digest) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._preferredFileName) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._fileName) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._documentResourceLocator) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._sourceBookmarkData) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._remoteURL) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._canDownload) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._downloadPriority) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._attributes) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._encryptionInfo) }()
        case 12: try { try decoder.decodeSingularBytesField(value: &_storage._lastMismatchedDigest) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._unmaterializedRanges) }()
        case 14: try { try decoder.decodeSingularUInt64Field(value: &_storage._remoteDataLength) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._remoteDataHasPackageStorage) }()
        case 16: try { try decoder.decodeSingularEnumField(value: &_storage._uploadStatus) }()
        case 17: try { try decoder.decodeSingularDoubleField(value: &_storage._remoteDataMtime) }()
        case 18: try { try decoder.decodeSingularUInt64Field(value: &_storage._materializedLength) }()
        case 99: try { try decoder.decodeSingularStringField(value: &_storage._pasteboardExternalFilePath) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._identifier {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._digest {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._preferredFileName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._fileName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._documentResourceLocator {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._sourceBookmarkData {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._remoteURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._canDownload {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._downloadPriority {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._attributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._encryptionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._lastMismatchedDigest {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._unmaterializedRanges {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._remoteDataLength {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._remoteDataHasPackageStorage {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._uploadStatus {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._remoteDataMtime {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._materializedLength {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._pasteboardExternalFilePath {
        try visitor.visitSingularStringField(value: v, fieldNumber: 99)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_DataInfo, rhs: TSP_DataInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._identifier != rhs_storage._identifier {return false}
        if _storage._digest != rhs_storage._digest {return false}
        if _storage._preferredFileName != rhs_storage._preferredFileName {return false}
        if _storage._fileName != rhs_storage._fileName {return false}
        if _storage._documentResourceLocator != rhs_storage._documentResourceLocator {return false}
        if _storage._sourceBookmarkData != rhs_storage._sourceBookmarkData {return false}
        if _storage._remoteURL != rhs_storage._remoteURL {return false}
        if _storage._canDownload != rhs_storage._canDownload {return false}
        if _storage._downloadPriority != rhs_storage._downloadPriority {return false}
        if _storage._attributes != rhs_storage._attributes {return false}
        if _storage._encryptionInfo != rhs_storage._encryptionInfo {return false}
        if _storage._lastMismatchedDigest != rhs_storage._lastMismatchedDigest {return false}
        if _storage._unmaterializedRanges != rhs_storage._unmaterializedRanges {return false}
        if _storage._remoteDataLength != rhs_storage._remoteDataLength {return false}
        if _storage._remoteDataHasPackageStorage != rhs_storage._remoteDataHasPackageStorage {return false}
        if _storage._uploadStatus != rhs_storage._uploadStatus {return false}
        if _storage._remoteDataMtime != rhs_storage._remoteDataMtime {return false}
        if _storage._materializedLength != rhs_storage._materializedLength {return false}
        if _storage._pasteboardExternalFilePath != rhs_storage._pasteboardExternalFilePath {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_DataInfo.DownloadPriority: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0High\0\u{1}Default\0")
}

extension TSP_DataMetadataMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataMetadataMap"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}data_metadata_entries\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.dataMetadataEntries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataMetadataEntries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataMetadataEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataMetadataEntries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_DataMetadataMap, rhs: TSP_DataMetadataMap) -> Bool {
    if lhs.dataMetadataEntries != rhs.dataMetadataEntries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_DataMetadataMap.DataMetadataMapEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSP_DataMetadataMap.protoMessageName + ".DataMetadataMapEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}data_identifier\0\u{3}data_metadata\0")

  public var isInitialized: Bool {
    if self._dataIdentifier == nil {return false}
    if self._dataMetadata == nil {return false}
    if let v = self._dataMetadata, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._dataIdentifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._dataMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._dataIdentifier {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._dataMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_DataMetadataMap.DataMetadataMapEntry, rhs: TSP_DataMetadataMap.DataMetadataMapEntry) -> Bool {
    if lhs._dataIdentifier != rhs._dataIdentifier {return false}
    if lhs._dataMetadata != rhs._dataMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_DataMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataMetadata"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}fallback_color\0")

  public var isInitialized: Bool {
    if let v = self._fallbackColor, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fallbackColor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fallbackColor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_DataMetadata, rhs: TSP_DataMetadata) -> Bool {
    if lhs._fallbackColor != rhs._fallbackColor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_EncryptionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EncryptionInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}decoded_length\0\u{3}preferred_block_size\0\u{3}block_infos\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.blockInfos) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._decodedLength) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._preferredBlockSize) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.blockInfos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._decodedLength {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._preferredBlockSize {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    if !self.blockInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blockInfos, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_EncryptionInfo, rhs: TSP_EncryptionInfo) -> Bool {
    if lhs._decodedLength != rhs._decodedLength {return false}
    if lhs._preferredBlockSize != rhs._preferredBlockSize {return false}
    if lhs.blockInfos != rhs.blockInfos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_EncryptionBlockInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EncryptionBlockInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}encoded_length\0\u{3}decoded_length\0")

  public var isInitialized: Bool {
    if self._encodedLength == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._encodedLength) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._decodedLength) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._encodedLength {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._decodedLength {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_EncryptionBlockInfo, rhs: TSP_EncryptionBlockInfo) -> Bool {
    if lhs._encodedLength != rhs._encodedLength {return false}
    if lhs._decodedLength != rhs._decodedLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_ViewStateMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ViewStateMetadata"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{2}\u{2}component\0\u{3}version_uuid\0\u{3}external_object_uuid_map_entries\0\u{3}read_version\0")

  public var isInitialized: Bool {
    if self._component == nil {return false}
    if let v = self._versionUuid, !v.isInitialized {return false}
    if let v = self._component, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.externalObjectUuidMapEntries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._component) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._versionUuid) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.externalObjectUuidMapEntries) }()
      case 6: try { try decoder.decodeRepeatedUInt32Field(value: &self.readVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.version.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.version, fieldNumber: 1)
    }
    try { if let v = self._component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._versionUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.externalObjectUuidMapEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.externalObjectUuidMapEntries, fieldNumber: 5)
    }
    if !self.readVersion.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.readVersion, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_ViewStateMetadata, rhs: TSP_ViewStateMetadata) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs._versionUuid != rhs._versionUuid {return false}
    if lhs._component != rhs._component {return false}
    if lhs.externalObjectUuidMapEntries != rhs.externalObjectUuidMapEntries {return false}
    if lhs.readVersion != rhs.readVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_ObjectSerializationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ObjectSerializationMetadata"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{3}source_document_uuid\0\u{3}version_uuid\0\u{1}component\0\u{1}datas\0\u{3}external_object_uuid_map_entries\0\u{3}data_metadata_map\0\u{3}read_version\0")

  public var isInitialized: Bool {
    if self._component == nil {return false}
    if let v = self._sourceDocumentUuid, !v.isInitialized {return false}
    if let v = self._versionUuid, !v.isInitialized {return false}
    if let v = self._component, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.datas) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.externalObjectUuidMapEntries) {return false}
    if let v = self._dataMetadataMap, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sourceDocumentUuid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._versionUuid) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._component) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.datas) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.externalObjectUuidMapEntries) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._dataMetadataMap) }()
      case 8: try { try decoder.decodeRepeatedUInt32Field(value: &self.readVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.version.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.version, fieldNumber: 1)
    }
    try { if let v = self._sourceDocumentUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._versionUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.datas.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.datas, fieldNumber: 5)
    }
    if !self.externalObjectUuidMapEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.externalObjectUuidMapEntries, fieldNumber: 6)
    }
    try { if let v = self._dataMetadataMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.readVersion.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.readVersion, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_ObjectSerializationMetadata, rhs: TSP_ObjectSerializationMetadata) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs._sourceDocumentUuid != rhs._sourceDocumentUuid {return false}
    if lhs._versionUuid != rhs._versionUuid {return false}
    if lhs._component != rhs._component {return false}
    if lhs.datas != rhs.datas {return false}
    if lhs.externalObjectUuidMapEntries != rhs.externalObjectUuidMapEntries {return false}
    if lhs._dataMetadataMap != rhs._dataMetadataMap {return false}
    if lhs.readVersion != rhs.readVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_ObjectSerializationDirectory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ObjectSerializationDirectory"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}entries\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.entries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_ObjectSerializationDirectory, rhs: TSP_ObjectSerializationDirectory) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_ObjectSerializationDirectory.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSP_ObjectSerializationDirectory.protoMessageName + ".Entry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}locator\0\u{1}offset\0\u{1}size\0")

  public var isInitialized: Bool {
    if self._locator == nil {return false}
    if self._offset == nil {return false}
    if self._size == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._locator) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._offset) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._locator {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._offset {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_ObjectSerializationDirectory.Entry, rhs: TSP_ObjectSerializationDirectory.Entry) -> Bool {
    if lhs._locator != rhs._locator {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_DataPropertiesEntryV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataPropertiesEntryV1"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}digest\0\u{3}expects_matched_digest\0\u{3}creation_time_interval_since_1970\0\u{3}creation_version\0\u{3}last_mismatched_digest\0")

  public var isInitialized: Bool {
    if self._digest == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._digest) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._expectsMatchedDigest) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self._creationTimeIntervalSince1970) }()
      case 4: try { try decoder.decodeRepeatedUInt32Field(value: &self.creationVersion) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._lastMismatchedDigest) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._digest {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._expectsMatchedDigest {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._creationTimeIntervalSince1970 {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    } }()
    if !self.creationVersion.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.creationVersion, fieldNumber: 4)
    }
    try { if let v = self._lastMismatchedDigest {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_DataPropertiesEntryV1, rhs: TSP_DataPropertiesEntryV1) -> Bool {
    if lhs._digest != rhs._digest {return false}
    if lhs._expectsMatchedDigest != rhs._expectsMatchedDigest {return false}
    if lhs._creationTimeIntervalSince1970 != rhs._creationTimeIntervalSince1970 {return false}
    if lhs.creationVersion != rhs.creationVersion {return false}
    if lhs._lastMismatchedDigest != rhs._lastMismatchedDigest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_DataPropertiesV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataPropertiesV1"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}properties\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.properties) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.properties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.properties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.properties, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_DataPropertiesV1, rhs: TSP_DataPropertiesV1) -> Bool {
    if lhs.properties != rhs.properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_DocumentMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentMetadata"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}is_in_collaboration_mode\0\u{4}\u{2}data_properties_v1\0")

  public var isInitialized: Bool {
    if let v = self._dataPropertiesV1, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._isInCollaborationMode) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._dataPropertiesV1) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._isInCollaborationMode {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._dataPropertiesV1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_DocumentMetadata, rhs: TSP_DocumentMetadata) -> Bool {
    if lhs._isInCollaborationMode != rhs._isInCollaborationMode {return false}
    if lhs._dataPropertiesV1 != rhs._dataPropertiesV1 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_SupportMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SupportMetadata"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}is_in_collaboration_mode\0\u{3}data_collaboration_properties\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.dataCollaborationProperties) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._isInCollaborationMode) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.dataCollaborationProperties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._isInCollaborationMode {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    if !self.dataCollaborationProperties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataCollaborationProperties, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_SupportMetadata, rhs: TSP_SupportMetadata) -> Bool {
    if lhs._isInCollaborationMode != rhs._isInCollaborationMode {return false}
    if lhs.dataCollaborationProperties != rhs.dataCollaborationProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_SupportMetadata.DataCollaborationProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSP_SupportMetadata.protoMessageName + ".DataCollaborationProperties"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}digest\0\u{3}acknowledged_by_server\0\u{3}materialized_on_server\0\u{3}upload_status\0\u{3}revision_sequence_for_materialized_on_server\0\u{3}is_remote_data_ever\0\u{3}revision_sequence_for_acknowledged_by_server\0")

  public var isInitialized: Bool {
    if self._digest == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._digest) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._acknowledgedByServer) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._materializedOnServer) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._uploadStatus) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._revisionSequenceForMaterializedOnServer) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._isRemoteDataEver) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self._revisionSequenceForAcknowledgedByServer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._digest {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._acknowledgedByServer {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._materializedOnServer {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._uploadStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._revisionSequenceForMaterializedOnServer {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._isRemoteDataEver {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._revisionSequenceForAcknowledgedByServer {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_SupportMetadata.DataCollaborationProperties, rhs: TSP_SupportMetadata.DataCollaborationProperties) -> Bool {
    if lhs._digest != rhs._digest {return false}
    if lhs._acknowledgedByServer != rhs._acknowledgedByServer {return false}
    if lhs._materializedOnServer != rhs._materializedOnServer {return false}
    if lhs._revisionSequenceForMaterializedOnServer != rhs._revisionSequenceForMaterializedOnServer {return false}
    if lhs._uploadStatus != rhs._uploadStatus {return false}
    if lhs._isRemoteDataEver != rhs._isRemoteDataEver {return false}
    if lhs._revisionSequenceForAcknowledgedByServer != rhs._revisionSequenceForAcknowledgedByServer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
