// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TSPMessages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum TSP_DataUploadStatus: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case pending = 0
  case reserved = 1
  case unableToReserve = 2
  case corrupted = 3
  case documentMayExceedDocumentSizeLimit = 4
  case expired = 5

  init() {
    self = .pending
  }

}

enum TSP_SpotlightMetadataType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case none = 0
  case text = 1
  case author = 2
  case font = 3
  case table = 4
  case sheet = 5
  case chart = 6
  case media = 7

  init() {
    self = .none
  }

}

struct TSP_Reference: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var identifier: UInt64 {
    get {return _identifier ?? 0}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {self._identifier = nil}

  var deprecatedType: Int32 {
    get {return _deprecatedType ?? 0}
    set {_deprecatedType = newValue}
  }
  /// Returns true if `deprecatedType` has been explicitly set.
  var hasDeprecatedType: Bool {return self._deprecatedType != nil}
  /// Clears the value of `deprecatedType`. Subsequent reads from it will return its default value.
  mutating func clearDeprecatedType() {self._deprecatedType = nil}

  var deprecatedIsExternal: Bool {
    get {return _deprecatedIsExternal ?? false}
    set {_deprecatedIsExternal = newValue}
  }
  /// Returns true if `deprecatedIsExternal` has been explicitly set.
  var hasDeprecatedIsExternal: Bool {return self._deprecatedIsExternal != nil}
  /// Clears the value of `deprecatedIsExternal`. Subsequent reads from it will return its default value.
  mutating func clearDeprecatedIsExternal() {self._deprecatedIsExternal = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _identifier: UInt64? = nil
  fileprivate var _deprecatedType: Int32? = nil
  fileprivate var _deprecatedIsExternal: Bool? = nil
}

struct TSP_DataReference: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var identifier: UInt64 {
    get {return _identifier ?? 0}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {self._identifier = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _identifier: UInt64? = nil
}

struct TSP_SparseReferenceArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var count: UInt32 {
    get {return _count ?? 0}
    set {_count = newValue}
  }
  /// Returns true if `count` has been explicitly set.
  var hasCount: Bool {return self._count != nil}
  /// Clears the value of `count`. Subsequent reads from it will return its default value.
  mutating func clearCount() {self._count = nil}

  var entries: [TSP_SparseReferenceArray.Entry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Entry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var index: UInt32 {
      get {return _index ?? 0}
      set {_index = newValue}
    }
    /// Returns true if `index` has been explicitly set.
    var hasIndex: Bool {return self._index != nil}
    /// Clears the value of `index`. Subsequent reads from it will return its default value.
    mutating func clearIndex() {self._index = nil}

    var reference: TSP_Reference {
      get {return _reference ?? TSP_Reference()}
      set {_reference = newValue}
    }
    /// Returns true if `reference` has been explicitly set.
    var hasReference: Bool {return self._reference != nil}
    /// Clears the value of `reference`. Subsequent reads from it will return its default value.
    mutating func clearReference() {self._reference = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _index: UInt32? = nil
    fileprivate var _reference: TSP_Reference? = nil
  }

  init() {}

  fileprivate var _count: UInt32? = nil
}

struct TSP_Point: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Float {
    get {return _x ?? 0}
    set {_x = newValue}
  }
  /// Returns true if `x` has been explicitly set.
  var hasX: Bool {return self._x != nil}
  /// Clears the value of `x`. Subsequent reads from it will return its default value.
  mutating func clearX() {self._x = nil}

  var y: Float {
    get {return _y ?? 0}
    set {_y = newValue}
  }
  /// Returns true if `y` has been explicitly set.
  var hasY: Bool {return self._y != nil}
  /// Clears the value of `y`. Subsequent reads from it will return its default value.
  mutating func clearY() {self._y = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _x: Float? = nil
  fileprivate var _y: Float? = nil
}

struct TSP_Pose3D: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var yaw: Float {
    get {return _yaw ?? 0}
    set {_yaw = newValue}
  }
  /// Returns true if `yaw` has been explicitly set.
  var hasYaw: Bool {return self._yaw != nil}
  /// Clears the value of `yaw`. Subsequent reads from it will return its default value.
  mutating func clearYaw() {self._yaw = nil}

  var pitch: Float {
    get {return _pitch ?? 0}
    set {_pitch = newValue}
  }
  /// Returns true if `pitch` has been explicitly set.
  var hasPitch: Bool {return self._pitch != nil}
  /// Clears the value of `pitch`. Subsequent reads from it will return its default value.
  mutating func clearPitch() {self._pitch = nil}

  var roll: Float {
    get {return _roll ?? 0}
    set {_roll = newValue}
  }
  /// Returns true if `roll` has been explicitly set.
  var hasRoll: Bool {return self._roll != nil}
  /// Clears the value of `roll`. Subsequent reads from it will return its default value.
  mutating func clearRoll() {self._roll = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _yaw: Float? = nil
  fileprivate var _pitch: Float? = nil
  fileprivate var _roll: Float? = nil
}

struct TSP_Rect: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var origin: TSP_Point {
    get {return _origin ?? TSP_Point()}
    set {_origin = newValue}
  }
  /// Returns true if `origin` has been explicitly set.
  var hasOrigin: Bool {return self._origin != nil}
  /// Clears the value of `origin`. Subsequent reads from it will return its default value.
  mutating func clearOrigin() {self._origin = nil}

  var size: TSP_Size {
    get {return _size ?? TSP_Size()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _origin: TSP_Point? = nil
  fileprivate var _size: TSP_Size? = nil
}

struct TSP_Size: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var width: Float {
    get {return _width ?? 0}
    set {_width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  var hasWidth: Bool {return self._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  mutating func clearWidth() {self._width = nil}

  var height: Float {
    get {return _height ?? 0}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {self._height = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _width: Float? = nil
  fileprivate var _height: Float? = nil
}

struct TSP_Range: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var location: UInt32 {
    get {return _location ?? 0}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {self._location = nil}

  var length: UInt32 {
    get {return _length ?? 0}
    set {_length = newValue}
  }
  /// Returns true if `length` has been explicitly set.
  var hasLength: Bool {return self._length != nil}
  /// Clears the value of `length`. Subsequent reads from it will return its default value.
  mutating func clearLength() {self._length = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _location: UInt32? = nil
  fileprivate var _length: UInt32? = nil
}

struct TSP_Date: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var seconds: Double {
    get {return _seconds ?? 0}
    set {_seconds = newValue}
  }
  /// Returns true if `seconds` has been explicitly set.
  var hasSeconds: Bool {return self._seconds != nil}
  /// Clears the value of `seconds`. Subsequent reads from it will return its default value.
  mutating func clearSeconds() {self._seconds = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _seconds: Double? = nil
}

struct TSP_IndexSet: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ranges: [TSP_Range] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSP_Color: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var model: TSP_Color.ColorModel {
    get {return _model ?? .rgb}
    set {_model = newValue}
  }
  /// Returns true if `model` has been explicitly set.
  var hasModel: Bool {return self._model != nil}
  /// Clears the value of `model`. Subsequent reads from it will return its default value.
  mutating func clearModel() {self._model = nil}

  var r: Float {
    get {return _r ?? 0}
    set {_r = newValue}
  }
  /// Returns true if `r` has been explicitly set.
  var hasR: Bool {return self._r != nil}
  /// Clears the value of `r`. Subsequent reads from it will return its default value.
  mutating func clearR() {self._r = nil}

  var g: Float {
    get {return _g ?? 0}
    set {_g = newValue}
  }
  /// Returns true if `g` has been explicitly set.
  var hasG: Bool {return self._g != nil}
  /// Clears the value of `g`. Subsequent reads from it will return its default value.
  mutating func clearG() {self._g = nil}

  var b: Float {
    get {return _b ?? 0}
    set {_b = newValue}
  }
  /// Returns true if `b` has been explicitly set.
  var hasB: Bool {return self._b != nil}
  /// Clears the value of `b`. Subsequent reads from it will return its default value.
  mutating func clearB() {self._b = nil}

  var rgbspace: TSP_Color.RGBColorSpace {
    get {return _rgbspace ?? .srgb}
    set {_rgbspace = newValue}
  }
  /// Returns true if `rgbspace` has been explicitly set.
  var hasRgbspace: Bool {return self._rgbspace != nil}
  /// Clears the value of `rgbspace`. Subsequent reads from it will return its default value.
  mutating func clearRgbspace() {self._rgbspace = nil}

  var a: Float {
    get {return _a ?? 1}
    set {_a = newValue}
  }
  /// Returns true if `a` has been explicitly set.
  var hasA: Bool {return self._a != nil}
  /// Clears the value of `a`. Subsequent reads from it will return its default value.
  mutating func clearA() {self._a = nil}

  var c: Float {
    get {return _c ?? 0}
    set {_c = newValue}
  }
  /// Returns true if `c` has been explicitly set.
  var hasC: Bool {return self._c != nil}
  /// Clears the value of `c`. Subsequent reads from it will return its default value.
  mutating func clearC() {self._c = nil}

  var m: Float {
    get {return _m ?? 0}
    set {_m = newValue}
  }
  /// Returns true if `m` has been explicitly set.
  var hasM: Bool {return self._m != nil}
  /// Clears the value of `m`. Subsequent reads from it will return its default value.
  mutating func clearM() {self._m = nil}

  var y: Float {
    get {return _y ?? 0}
    set {_y = newValue}
  }
  /// Returns true if `y` has been explicitly set.
  var hasY: Bool {return self._y != nil}
  /// Clears the value of `y`. Subsequent reads from it will return its default value.
  mutating func clearY() {self._y = nil}

  var k: Float {
    get {return _k ?? 0}
    set {_k = newValue}
  }
  /// Returns true if `k` has been explicitly set.
  var hasK: Bool {return self._k != nil}
  /// Clears the value of `k`. Subsequent reads from it will return its default value.
  mutating func clearK() {self._k = nil}

  var w: Float {
    get {return _w ?? 0}
    set {_w = newValue}
  }
  /// Returns true if `w` has been explicitly set.
  var hasW: Bool {return self._w != nil}
  /// Clears the value of `w`. Subsequent reads from it will return its default value.
  mutating func clearW() {self._w = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ColorModel: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case rgb = 1
    case cmyk = 2
    case white = 3

    init() {
      self = .rgb
    }

  }

  enum RGBColorSpace: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case srgb = 1
    case p3 = 2

    init() {
      self = .srgb
    }

  }

  init() {}

  fileprivate var _model: TSP_Color.ColorModel? = nil
  fileprivate var _r: Float? = nil
  fileprivate var _g: Float? = nil
  fileprivate var _b: Float? = nil
  fileprivate var _rgbspace: TSP_Color.RGBColorSpace? = nil
  fileprivate var _a: Float? = nil
  fileprivate var _c: Float? = nil
  fileprivate var _m: Float? = nil
  fileprivate var _y: Float? = nil
  fileprivate var _k: Float? = nil
  fileprivate var _w: Float? = nil
}

struct TSP_Path: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var elements: [TSP_Path.Element] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ElementType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case moveTo = 1
    case lineTo = 2
    case quadCurveTo = 3
    case curveTo = 4
    case closeSubpath = 5

    init() {
      self = .moveTo
    }

  }

  struct Element: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: TSP_Path.ElementType {
      get {return _type ?? .moveTo}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var points: [TSP_Point] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _type: TSP_Path.ElementType? = nil
  }

  init() {}
}

struct TSP_ReferenceDictionary: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [TSP_ReferenceDictionary.Entry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Entry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var key: TSP_Reference {
      get {return _key ?? TSP_Reference()}
      set {_key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    var hasKey: Bool {return self._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    mutating func clearKey() {self._key = nil}

    var value: TSP_Reference {
      get {return _value ?? TSP_Reference()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _key: TSP_Reference? = nil
    fileprivate var _value: TSP_Reference? = nil
  }

  init() {}
}

struct TSP_UUID: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lower: UInt64 {
    get {return _lower ?? 0}
    set {_lower = newValue}
  }
  /// Returns true if `lower` has been explicitly set.
  var hasLower: Bool {return self._lower != nil}
  /// Clears the value of `lower`. Subsequent reads from it will return its default value.
  mutating func clearLower() {self._lower = nil}

  var upper: UInt64 {
    get {return _upper ?? 0}
    set {_upper = newValue}
  }
  /// Returns true if `upper` has been explicitly set.
  var hasUpper: Bool {return self._upper != nil}
  /// Clears the value of `upper`. Subsequent reads from it will return its default value.
  mutating func clearUpper() {self._upper = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lower: UInt64? = nil
  fileprivate var _upper: UInt64? = nil
}

struct TSP_CFUUIDArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuidBytes: Data {
    get {return _uuidBytes ?? Data()}
    set {_uuidBytes = newValue}
  }
  /// Returns true if `uuidBytes` has been explicitly set.
  var hasUuidBytes: Bool {return self._uuidBytes != nil}
  /// Clears the value of `uuidBytes`. Subsequent reads from it will return its default value.
  mutating func clearUuidBytes() {self._uuidBytes = nil}

  var uuidW0: UInt32 {
    get {return _uuidW0 ?? 0}
    set {_uuidW0 = newValue}
  }
  /// Returns true if `uuidW0` has been explicitly set.
  var hasUuidW0: Bool {return self._uuidW0 != nil}
  /// Clears the value of `uuidW0`. Subsequent reads from it will return its default value.
  mutating func clearUuidW0() {self._uuidW0 = nil}

  var uuidW1: UInt32 {
    get {return _uuidW1 ?? 0}
    set {_uuidW1 = newValue}
  }
  /// Returns true if `uuidW1` has been explicitly set.
  var hasUuidW1: Bool {return self._uuidW1 != nil}
  /// Clears the value of `uuidW1`. Subsequent reads from it will return its default value.
  mutating func clearUuidW1() {self._uuidW1 = nil}

  var uuidW2: UInt32 {
    get {return _uuidW2 ?? 0}
    set {_uuidW2 = newValue}
  }
  /// Returns true if `uuidW2` has been explicitly set.
  var hasUuidW2: Bool {return self._uuidW2 != nil}
  /// Clears the value of `uuidW2`. Subsequent reads from it will return its default value.
  mutating func clearUuidW2() {self._uuidW2 = nil}

  var uuidW3: UInt32 {
    get {return _uuidW3 ?? 0}
    set {_uuidW3 = newValue}
  }
  /// Returns true if `uuidW3` has been explicitly set.
  var hasUuidW3: Bool {return self._uuidW3 != nil}
  /// Clears the value of `uuidW3`. Subsequent reads from it will return its default value.
  mutating func clearUuidW3() {self._uuidW3 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _uuidBytes: Data? = nil
  fileprivate var _uuidW0: UInt32? = nil
  fileprivate var _uuidW1: UInt32? = nil
  fileprivate var _uuidW2: UInt32? = nil
  fileprivate var _uuidW3: UInt32? = nil
}

struct TSP_UUIDSetArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uids: [TSP_UUID] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSP_UUIDMapArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var source: [TSP_UUID] = []

  var target: [TSP_UUID] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSP_UUIDMultiMapArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var source: [TSP_UUID] = []

  var target: [TSP_UUID] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSP_UUIDCoordArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rowUid: TSP_UUID {
    get {return _rowUid ?? TSP_UUID()}
    set {_rowUid = newValue}
  }
  /// Returns true if `rowUid` has been explicitly set.
  var hasRowUid: Bool {return self._rowUid != nil}
  /// Clears the value of `rowUid`. Subsequent reads from it will return its default value.
  mutating func clearRowUid() {self._rowUid = nil}

  var columnUid: TSP_UUID {
    get {return _columnUid ?? TSP_UUID()}
    set {_columnUid = newValue}
  }
  /// Returns true if `columnUid` has been explicitly set.
  var hasColumnUid: Bool {return self._columnUid != nil}
  /// Clears the value of `columnUid`. Subsequent reads from it will return its default value.
  mutating func clearColumnUid() {self._columnUid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rowUid: TSP_UUID? = nil
  fileprivate var _columnUid: TSP_UUID? = nil
}

struct TSP_UUIDRectArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var columnUids: [TSP_UUID] = []

  var rowUids: [TSP_UUID] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSP_SparseUUIDArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var count: UInt32 {
    get {return _count ?? 0}
    set {_count = newValue}
  }
  /// Returns true if `count` has been explicitly set.
  var hasCount: Bool {return self._count != nil}
  /// Clears the value of `count`. Subsequent reads from it will return its default value.
  mutating func clearCount() {self._count = nil}

  var entries: [TSP_SparseUUIDArray.Entry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Entry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var index: UInt32 {
      get {return _index ?? 0}
      set {_index = newValue}
    }
    /// Returns true if `index` has been explicitly set.
    var hasIndex: Bool {return self._index != nil}
    /// Clears the value of `index`. Subsequent reads from it will return its default value.
    mutating func clearIndex() {self._index = nil}

    var uuid: TSP_UUID {
      get {return _uuid ?? TSP_UUID()}
      set {_uuid = newValue}
    }
    /// Returns true if `uuid` has been explicitly set.
    var hasUuid: Bool {return self._uuid != nil}
    /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
    mutating func clearUuid() {self._uuid = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _index: UInt32? = nil
    fileprivate var _uuid: TSP_UUID? = nil
  }

  init() {}

  fileprivate var _count: UInt32? = nil
}

struct TSP_UUIDPath: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuids: [TSP_UUID] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSP_SparseUUIDPathArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var count: UInt32 {
    get {return _count ?? 0}
    set {_count = newValue}
  }
  /// Returns true if `count` has been explicitly set.
  var hasCount: Bool {return self._count != nil}
  /// Clears the value of `count`. Subsequent reads from it will return its default value.
  mutating func clearCount() {self._count = nil}

  var entries: [TSP_SparseUUIDPathArray.Entry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Entry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var index: UInt32 {
      get {return _index ?? 0}
      set {_index = newValue}
    }
    /// Returns true if `index` has been explicitly set.
    var hasIndex: Bool {return self._index != nil}
    /// Clears the value of `index`. Subsequent reads from it will return its default value.
    mutating func clearIndex() {self._index = nil}

    var uuidPath: TSP_UUIDPath {
      get {return _uuidPath ?? TSP_UUIDPath()}
      set {_uuidPath = newValue}
    }
    /// Returns true if `uuidPath` has been explicitly set.
    var hasUuidPath: Bool {return self._uuidPath != nil}
    /// Clears the value of `uuidPath`. Subsequent reads from it will return its default value.
    mutating func clearUuidPath() {self._uuidPath = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _index: UInt32? = nil
    fileprivate var _uuidPath: TSP_UUIDPath? = nil
  }

  init() {}

  fileprivate var _count: UInt32? = nil
}

struct TSP_PasteboardObject: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stylesheet: TSP_Reference {
    get {return _storage._stylesheet ?? TSP_Reference()}
    set {_uniqueStorage()._stylesheet = newValue}
  }
  /// Returns true if `stylesheet` has been explicitly set.
  var hasStylesheet: Bool {return _storage._stylesheet != nil}
  /// Clears the value of `stylesheet`. Subsequent reads from it will return its default value.
  mutating func clearStylesheet() {_uniqueStorage()._stylesheet = nil}

  var drawables: [TSP_Reference] {
    get {return _storage._drawables}
    set {_uniqueStorage()._drawables = newValue}
  }

  var styles: [TSP_Reference] {
    get {return _storage._styles}
    set {_uniqueStorage()._styles = newValue}
  }

  var wpStorage: TSP_Reference {
    get {return _storage._wpStorage ?? TSP_Reference()}
    set {_uniqueStorage()._wpStorage = newValue}
  }
  /// Returns true if `wpStorage` has been explicitly set.
  var hasWpStorage: Bool {return _storage._wpStorage != nil}
  /// Clears the value of `wpStorage`. Subsequent reads from it will return its default value.
  mutating func clearWpStorage() {_uniqueStorage()._wpStorage = nil}

  var guideStorage: TSP_Reference {
    get {return _storage._guideStorage ?? TSP_Reference()}
    set {_uniqueStorage()._guideStorage = newValue}
  }
  /// Returns true if `guideStorage` has been explicitly set.
  var hasGuideStorage: Bool {return _storage._guideStorage != nil}
  /// Clears the value of `guideStorage`. Subsequent reads from it will return its default value.
  mutating func clearGuideStorage() {_uniqueStorage()._guideStorage = nil}

  var appNativeObject: TSP_Reference {
    get {return _storage._appNativeObject ?? TSP_Reference()}
    set {_uniqueStorage()._appNativeObject = newValue}
  }
  /// Returns true if `appNativeObject` has been explicitly set.
  var hasAppNativeObject: Bool {return _storage._appNativeObject != nil}
  /// Clears the value of `appNativeObject`. Subsequent reads from it will return its default value.
  mutating func clearAppNativeObject() {_uniqueStorage()._appNativeObject = nil}

  var isTextPrimary: Bool {
    get {return _storage._isTextPrimary ?? false}
    set {_uniqueStorage()._isTextPrimary = newValue}
  }
  /// Returns true if `isTextPrimary` has been explicitly set.
  var hasIsTextPrimary: Bool {return _storage._isTextPrimary != nil}
  /// Clears the value of `isTextPrimary`. Subsequent reads from it will return its default value.
  mutating func clearIsTextPrimary() {_uniqueStorage()._isTextPrimary = nil}

  var isSmart: Bool {
    get {return _storage._isSmart ?? false}
    set {_uniqueStorage()._isSmart = newValue}
  }
  /// Returns true if `isSmart` has been explicitly set.
  var hasIsSmart: Bool {return _storage._isSmart != nil}
  /// Clears the value of `isSmart`. Subsequent reads from it will return its default value.
  mutating func clearIsSmart() {_uniqueStorage()._isSmart = nil}

  var presets: [TSP_Reference] {
    get {return _storage._presets}
    set {_uniqueStorage()._presets = newValue}
  }

  var topLevelObjects: [TSP_Reference] {
    get {return _storage._topLevelObjects}
    set {_uniqueStorage()._topLevelObjects = newValue}
  }

  var nativeContentDescription: TSP_Reference {
    get {return _storage._nativeContentDescription ?? TSP_Reference()}
    set {_uniqueStorage()._nativeContentDescription = newValue}
  }
  /// Returns true if `nativeContentDescription` has been explicitly set.
  var hasNativeContentDescription: Bool {return _storage._nativeContentDescription != nil}
  /// Clears the value of `nativeContentDescription`. Subsequent reads from it will return its default value.
  mutating func clearNativeContentDescription() {_uniqueStorage()._nativeContentDescription = nil}

  var textRanges: [TSP_Range] {
    get {return _storage._textRanges}
    set {_uniqueStorage()._textRanges = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSP_ObjectCollection: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objects: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSP_ObjectContainer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var identifier: UInt32 {
    get {return _identifier ?? 0}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {self._identifier = nil}

  var objects: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _identifier: UInt32? = nil
}

struct TSP_DataAttributes: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
}

struct TSP_LargeArraySegment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var shouldDelayArchiving: Bool {
    get {return _shouldDelayArchiving ?? false}
    set {_shouldDelayArchiving = newValue}
  }
  /// Returns true if `shouldDelayArchiving` has been explicitly set.
  var hasShouldDelayArchiving: Bool {return self._shouldDelayArchiving != nil}
  /// Clears the value of `shouldDelayArchiving`. Subsequent reads from it will return its default value.
  mutating func clearShouldDelayArchiving() {self._shouldDelayArchiving = nil}

  var delayedArchivingPriority: UInt32 {
    get {return _delayedArchivingPriority ?? 0}
    set {_delayedArchivingPriority = newValue}
  }
  /// Returns true if `delayedArchivingPriority` has been explicitly set.
  var hasDelayedArchivingPriority: Bool {return self._delayedArchivingPriority != nil}
  /// Clears the value of `delayedArchivingPriority`. Subsequent reads from it will return its default value.
  mutating func clearDelayedArchivingPriority() {self._delayedArchivingPriority = nil}

  var packageLocator: String {
    get {return _packageLocator ?? String()}
    set {_packageLocator = newValue}
  }
  /// Returns true if `packageLocator` has been explicitly set.
  var hasPackageLocator: Bool {return self._packageLocator != nil}
  /// Clears the value of `packageLocator`. Subsequent reads from it will return its default value.
  mutating func clearPackageLocator() {self._packageLocator = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _shouldDelayArchiving: Bool? = nil
  fileprivate var _delayedArchivingPriority: UInt32? = nil
  fileprivate var _packageLocator: String? = nil
}

struct TSP_LargeNumberArraySegment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var largeArraySegment: TSP_LargeArraySegment {
    get {return _largeArraySegment ?? TSP_LargeArraySegment()}
    set {_largeArraySegment = newValue}
  }
  /// Returns true if `largeArraySegment` has been explicitly set.
  var hasLargeArraySegment: Bool {return self._largeArraySegment != nil}
  /// Clears the value of `largeArraySegment`. Subsequent reads from it will return its default value.
  mutating func clearLargeArraySegment() {self._largeArraySegment = nil}

  var elements: [Double] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _largeArraySegment: TSP_LargeArraySegment? = nil
}

struct TSP_LargeStringArraySegment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var largeArraySegment: TSP_LargeArraySegment {
    get {return _largeArraySegment ?? TSP_LargeArraySegment()}
    set {_largeArraySegment = newValue}
  }
  /// Returns true if `largeArraySegment` has been explicitly set.
  var hasLargeArraySegment: Bool {return self._largeArraySegment != nil}
  /// Clears the value of `largeArraySegment`. Subsequent reads from it will return its default value.
  mutating func clearLargeArraySegment() {self._largeArraySegment = nil}

  var elements: [TSP_LargeStringArraySegment.OptionalElement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct OptionalElement: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var element: String {
      get {return _element ?? String()}
      set {_element = newValue}
    }
    /// Returns true if `element` has been explicitly set.
    var hasElement: Bool {return self._element != nil}
    /// Clears the value of `element`. Subsequent reads from it will return its default value.
    mutating func clearElement() {self._element = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _element: String? = nil
  }

  init() {}

  fileprivate var _largeArraySegment: TSP_LargeArraySegment? = nil
}

struct TSP_LargeUUIDArraySegment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var largeArraySegment: TSP_LargeArraySegment {
    get {return _largeArraySegment ?? TSP_LargeArraySegment()}
    set {_largeArraySegment = newValue}
  }
  /// Returns true if `largeArraySegment` has been explicitly set.
  var hasLargeArraySegment: Bool {return self._largeArraySegment != nil}
  /// Clears the value of `largeArraySegment`. Subsequent reads from it will return its default value.
  mutating func clearLargeArraySegment() {self._largeArraySegment = nil}

  var elements: [TSP_UUID] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _largeArraySegment: TSP_LargeArraySegment? = nil
}

struct TSP_LargeLazyObjectArraySegment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var largeArraySegment: TSP_LargeArraySegment {
    get {return _largeArraySegment ?? TSP_LargeArraySegment()}
    set {_largeArraySegment = newValue}
  }
  /// Returns true if `largeArraySegment` has been explicitly set.
  var hasLargeArraySegment: Bool {return self._largeArraySegment != nil}
  /// Clears the value of `largeArraySegment`. Subsequent reads from it will return its default value.
  mutating func clearLargeArraySegment() {self._largeArraySegment = nil}

  var elements: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _largeArraySegment: TSP_LargeArraySegment? = nil
}

struct TSP_LargeObjectArraySegment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var largeArraySegment: TSP_LargeArraySegment {
    get {return _largeArraySegment ?? TSP_LargeArraySegment()}
    set {_largeArraySegment = newValue}
  }
  /// Returns true if `largeArraySegment` has been explicitly set.
  var hasLargeArraySegment: Bool {return self._largeArraySegment != nil}
  /// Clears the value of `largeArraySegment`. Subsequent reads from it will return its default value.
  mutating func clearLargeArraySegment() {self._largeArraySegment = nil}

  var elements: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _largeArraySegment: TSP_LargeArraySegment? = nil
}

struct TSP_LargeArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ranges: [TSP_Range] = []

  var segments: [TSP_Reference] = []

  var maxSegmentElementCount: UInt64 {
    get {return _maxSegmentElementCount ?? 0}
    set {_maxSegmentElementCount = newValue}
  }
  /// Returns true if `maxSegmentElementCount` has been explicitly set.
  var hasMaxSegmentElementCount: Bool {return self._maxSegmentElementCount != nil}
  /// Clears the value of `maxSegmentElementCount`. Subsequent reads from it will return its default value.
  mutating func clearMaxSegmentElementCount() {self._maxSegmentElementCount = nil}

  var maxSegmentSize: UInt64 {
    get {return _maxSegmentSize ?? 0}
    set {_maxSegmentSize = newValue}
  }
  /// Returns true if `maxSegmentSize` has been explicitly set.
  var hasMaxSegmentSize: Bool {return self._maxSegmentSize != nil}
  /// Clears the value of `maxSegmentSize`. Subsequent reads from it will return its default value.
  mutating func clearMaxSegmentSize() {self._maxSegmentSize = nil}

  var shouldDelayArchiving: Bool {
    get {return _shouldDelayArchiving ?? false}
    set {_shouldDelayArchiving = newValue}
  }
  /// Returns true if `shouldDelayArchiving` has been explicitly set.
  var hasShouldDelayArchiving: Bool {return self._shouldDelayArchiving != nil}
  /// Clears the value of `shouldDelayArchiving`. Subsequent reads from it will return its default value.
  mutating func clearShouldDelayArchiving() {self._shouldDelayArchiving = nil}

  var delayedArchivingPriority: UInt32 {
    get {return _delayedArchivingPriority ?? 0}
    set {_delayedArchivingPriority = newValue}
  }
  /// Returns true if `delayedArchivingPriority` has been explicitly set.
  var hasDelayedArchivingPriority: Bool {return self._delayedArchivingPriority != nil}
  /// Clears the value of `delayedArchivingPriority`. Subsequent reads from it will return its default value.
  mutating func clearDelayedArchivingPriority() {self._delayedArchivingPriority = nil}

  var storeOutsideObjectArchive: Bool {
    get {return _storeOutsideObjectArchive ?? false}
    set {_storeOutsideObjectArchive = newValue}
  }
  /// Returns true if `storeOutsideObjectArchive` has been explicitly set.
  var hasStoreOutsideObjectArchive: Bool {return self._storeOutsideObjectArchive != nil}
  /// Clears the value of `storeOutsideObjectArchive`. Subsequent reads from it will return its default value.
  mutating func clearStoreOutsideObjectArchive() {self._storeOutsideObjectArchive = nil}

  var estimatedByteSize: UInt64 {
    get {return _estimatedByteSize ?? 0}
    set {_estimatedByteSize = newValue}
  }
  /// Returns true if `estimatedByteSize` has been explicitly set.
  var hasEstimatedByteSize: Bool {return self._estimatedByteSize != nil}
  /// Clears the value of `estimatedByteSize`. Subsequent reads from it will return its default value.
  mutating func clearEstimatedByteSize() {self._estimatedByteSize = nil}

  var maxSegmentCost: UInt64 {
    get {return _maxSegmentCost ?? 0}
    set {_maxSegmentCost = newValue}
  }
  /// Returns true if `maxSegmentCost` has been explicitly set.
  var hasMaxSegmentCost: Bool {return self._maxSegmentCost != nil}
  /// Clears the value of `maxSegmentCost`. Subsequent reads from it will return its default value.
  mutating func clearMaxSegmentCost() {self._maxSegmentCost = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _maxSegmentElementCount: UInt64? = nil
  fileprivate var _maxSegmentSize: UInt64? = nil
  fileprivate var _shouldDelayArchiving: Bool? = nil
  fileprivate var _delayedArchivingPriority: UInt32? = nil
  fileprivate var _storeOutsideObjectArchive: Bool? = nil
  fileprivate var _estimatedByteSize: UInt64? = nil
  fileprivate var _maxSegmentCost: UInt64? = nil
}

struct TSP_LargeNumberArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var largeArray: TSP_LargeArray {
    get {return _largeArray ?? TSP_LargeArray()}
    set {_largeArray = newValue}
  }
  /// Returns true if `largeArray` has been explicitly set.
  var hasLargeArray: Bool {return self._largeArray != nil}
  /// Clears the value of `largeArray`. Subsequent reads from it will return its default value.
  mutating func clearLargeArray() {self._largeArray = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _largeArray: TSP_LargeArray? = nil
}

struct TSP_LargeStringArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var largeArray: TSP_LargeArray {
    get {return _largeArray ?? TSP_LargeArray()}
    set {_largeArray = newValue}
  }
  /// Returns true if `largeArray` has been explicitly set.
  var hasLargeArray: Bool {return self._largeArray != nil}
  /// Clears the value of `largeArray`. Subsequent reads from it will return its default value.
  mutating func clearLargeArray() {self._largeArray = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _largeArray: TSP_LargeArray? = nil
}

struct TSP_LargeLazyObjectArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var largeArray: TSP_LargeArray {
    get {return _largeArray ?? TSP_LargeArray()}
    set {_largeArray = newValue}
  }
  /// Returns true if `largeArray` has been explicitly set.
  var hasLargeArray: Bool {return self._largeArray != nil}
  /// Clears the value of `largeArray`. Subsequent reads from it will return its default value.
  mutating func clearLargeArray() {self._largeArray = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _largeArray: TSP_LargeArray? = nil
}

struct TSP_LargeObjectArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var largeArray: TSP_LargeArray {
    get {return _largeArray ?? TSP_LargeArray()}
    set {_largeArray = newValue}
  }
  /// Returns true if `largeArray` has been explicitly set.
  var hasLargeArray: Bool {return self._largeArray != nil}
  /// Clears the value of `largeArray`. Subsequent reads from it will return its default value.
  mutating func clearLargeArray() {self._largeArray = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _largeArray: TSP_LargeArray? = nil
}

struct TSP_LargeUUIDArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var largeArray: TSP_LargeArray {
    get {return _largeArray ?? TSP_LargeArray()}
    set {_largeArray = newValue}
  }
  /// Returns true if `largeArray` has been explicitly set.
  var hasLargeArray: Bool {return self._largeArray != nil}
  /// Clears the value of `largeArray`. Subsequent reads from it will return its default value.
  mutating func clearLargeArray() {self._largeArray = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _largeArray: TSP_LargeArray? = nil
}

struct TSP_FieldOptions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadataType: TSP_SpotlightMetadataType {
    get {return _metadataType ?? .none}
    set {_metadataType = newValue}
  }
  /// Returns true if `metadataType` has been explicitly set.
  var hasMetadataType: Bool {return self._metadataType != nil}
  /// Clears the value of `metadataType`. Subsequent reads from it will return its default value.
  mutating func clearMetadataType() {self._metadataType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadataType: TSP_SpotlightMetadataType? = nil
}

// MARK: - Extension support defined in TSPMessages.proto.

// MARK: - Extension Properties

// Swift Extensions on the extended Messages to add easy access to the declared
// extension fields. The names are based on the extension field name from the proto
// declaration. To avoid naming collisions, the names are prefixed with the name of
// the scope where the extend directive occurs.

extension SwiftProtobuf.Google_Protobuf_FieldOptions {

  var TSP_fieldOptions: TSP_FieldOptions {
    get {return getExtensionValue(ext: TSP_Extensions_field_options) ?? TSP_FieldOptions()}
    set {setExtensionValue(ext: TSP_Extensions_field_options, value: newValue)}
  }
  /// Returns true if extension `TSP_Extensions_field_options`
  /// has been explicitly set.
  var hasTSP_fieldOptions: Bool {
    return hasExtensionValue(ext: TSP_Extensions_field_options)
  }
  /// Clears the value of extension `TSP_Extensions_field_options`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTSP_fieldOptions() {
    clearExtensionValue(ext: TSP_Extensions_field_options)
  }

}

// MARK: - File's ExtensionMap: TSP_Tspmessages_Extensions

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
let TSP_Tspmessages_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  TSP_Extensions_field_options
]

// Extension Objects - The only reason these might be needed is when manually
// constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
// accessors for the extension fields on the messages directly.

let TSP_Extensions_field_options = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TSP_FieldOptions>, SwiftProtobuf.Google_Protobuf_FieldOptions>(
  _protobuf_fieldNumber: 51234,
  fieldName: "TSP.field_options"
)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TSP"

extension TSP_DataUploadStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DataUploadStatus_Pending\0\u{1}DataUploadStatus_Reserved\0\u{1}DataUploadStatus_UnableToReserve\0\u{1}DataUploadStatus_Corrupted\0\u{1}DataUploadStatus_DocumentMayExceedDocumentSizeLimit\0\u{1}DataUploadStatus_Expired\0")
}

extension TSP_SpotlightMetadataType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0None\0\u{1}Text\0\u{1}Author\0\u{1}Font\0\u{1}Table\0\u{1}Sheet\0\u{1}Chart\0\u{1}Media\0")
}

extension TSP_Reference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Reference"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identifier\0\u{3}deprecated_type\0\u{3}deprecated_is_external\0")

  public var isInitialized: Bool {
    if self._identifier == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._identifier) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._deprecatedType) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._deprecatedIsExternal) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._deprecatedType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._deprecatedIsExternal {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_Reference, rhs: TSP_Reference) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs._deprecatedType != rhs._deprecatedType {return false}
    if lhs._deprecatedIsExternal != rhs._deprecatedIsExternal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_DataReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataReference"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identifier\0")

  public var isInitialized: Bool {
    if self._identifier == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._identifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_DataReference, rhs: TSP_DataReference) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_SparseReferenceArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SparseReferenceArray"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}count\0\u{1}entries\0")

  public var isInitialized: Bool {
    if self._count == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.entries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._count) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._count {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_SparseReferenceArray, rhs: TSP_SparseReferenceArray) -> Bool {
    if lhs._count != rhs._count {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_SparseReferenceArray.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSP_SparseReferenceArray.protoMessageName + ".Entry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}index\0\u{1}reference\0")

  public var isInitialized: Bool {
    if self._index == nil {return false}
    if self._reference == nil {return false}
    if let v = self._reference, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._index) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._reference) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._index {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reference {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_SparseReferenceArray.Entry, rhs: TSP_SparseReferenceArray.Entry) -> Bool {
    if lhs._index != rhs._index {return false}
    if lhs._reference != rhs._reference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_Point: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Point"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}x\0\u{1}y\0")

  public var isInitialized: Bool {
    if self._x == nil {return false}
    if self._y == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._y) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._x {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._y {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_Point, rhs: TSP_Point) -> Bool {
    if lhs._x != rhs._x {return false}
    if lhs._y != rhs._y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_Pose3D: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pose3D"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}yaw\0\u{1}pitch\0\u{1}roll\0")

  public var isInitialized: Bool {
    if self._yaw == nil {return false}
    if self._pitch == nil {return false}
    if self._roll == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._yaw) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._pitch) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._roll) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._yaw {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pitch {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._roll {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_Pose3D, rhs: TSP_Pose3D) -> Bool {
    if lhs._yaw != rhs._yaw {return false}
    if lhs._pitch != rhs._pitch {return false}
    if lhs._roll != rhs._roll {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_Rect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Rect"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}origin\0\u{1}size\0")

  public var isInitialized: Bool {
    if self._origin == nil {return false}
    if self._size == nil {return false}
    if let v = self._origin, !v.isInitialized {return false}
    if let v = self._size, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_Rect, rhs: TSP_Rect) -> Bool {
    if lhs._origin != rhs._origin {return false}
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_Size: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Size"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}width\0\u{1}height\0")

  public var isInitialized: Bool {
    if self._width == nil {return false}
    if self._height == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._width) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._width {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._height {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_Size, rhs: TSP_Size) -> Bool {
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_Range: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Range"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}location\0\u{1}length\0")

  public var isInitialized: Bool {
    if self._location == nil {return false}
    if self._length == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._location) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._length) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._location {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._length {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_Range, rhs: TSP_Range) -> Bool {
    if lhs._location != rhs._location {return false}
    if lhs._length != rhs._length {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_Date: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Date"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seconds\0")

  public var isInitialized: Bool {
    if self._seconds == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._seconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._seconds {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_Date, rhs: TSP_Date) -> Bool {
    if lhs._seconds != rhs._seconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_IndexSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IndexSet"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ranges\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.ranges) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ranges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ranges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranges, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_IndexSet, rhs: TSP_IndexSet) -> Bool {
    if lhs.ranges != rhs.ranges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_Color: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Color"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}model\0\u{2}\u{2}r\0\u{1}g\0\u{1}b\0\u{1}a\0\u{1}c\0\u{1}m\0\u{1}y\0\u{1}k\0\u{1}w\0\u{1}rgbspace\0")

  public var isInitialized: Bool {
    if self._model == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._model) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._r) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._g) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._b) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self._a) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self._c) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self._m) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self._y) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self._k) }()
      case 11: try { try decoder.decodeSingularFloatField(value: &self._w) }()
      case 12: try { try decoder.decodeSingularEnumField(value: &self._rgbspace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._model {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._r {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._g {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._b {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._a {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._c {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._m {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._y {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._k {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._w {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._rgbspace {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_Color, rhs: TSP_Color) -> Bool {
    if lhs._model != rhs._model {return false}
    if lhs._r != rhs._r {return false}
    if lhs._g != rhs._g {return false}
    if lhs._b != rhs._b {return false}
    if lhs._rgbspace != rhs._rgbspace {return false}
    if lhs._a != rhs._a {return false}
    if lhs._c != rhs._c {return false}
    if lhs._m != rhs._m {return false}
    if lhs._y != rhs._y {return false}
    if lhs._k != rhs._k {return false}
    if lhs._w != rhs._w {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_Color.ColorModel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rgb\0\u{1}cmyk\0\u{1}white\0")
}

extension TSP_Color.RGBColorSpace: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}srgb\0\u{1}p3\0")
}

extension TSP_Path: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Path"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}elements\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.elements) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_Path, rhs: TSP_Path) -> Bool {
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_Path.ElementType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}moveTo\0\u{1}lineTo\0\u{1}quadCurveTo\0\u{1}curveTo\0\u{1}closeSubpath\0")
}

extension TSP_Path.Element: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSP_Path.protoMessageName + ".Element"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}points\0")

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.points) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.points) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_Path.Element, rhs: TSP_Path.Element) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.points != rhs.points {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_ReferenceDictionary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReferenceDictionary"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}entries\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.entries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_ReferenceDictionary, rhs: TSP_ReferenceDictionary) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_ReferenceDictionary.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSP_ReferenceDictionary.protoMessageName + ".Entry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}value\0")

  public var isInitialized: Bool {
    if self._key == nil {return false}
    if self._value == nil {return false}
    if let v = self._key, !v.isInitialized {return false}
    if let v = self._value, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_ReferenceDictionary.Entry, rhs: TSP_ReferenceDictionary.Entry) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_UUID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UUID"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}lower\0\u{1}upper\0")

  public var isInitialized: Bool {
    if self._lower == nil {return false}
    if self._upper == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._lower) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._upper) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lower {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._upper {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_UUID, rhs: TSP_UUID) -> Bool {
    if lhs._lower != rhs._lower {return false}
    if lhs._upper != rhs._upper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_CFUUIDArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CFUUIDArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}uuid_bytes\0\u{3}uuid_w0\0\u{3}uuid_w1\0\u{3}uuid_w2\0\u{3}uuid_w3\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._uuidBytes) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._uuidW0) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._uuidW1) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._uuidW2) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._uuidW3) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuidBytes {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._uuidW0 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._uuidW1 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._uuidW2 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._uuidW3 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_CFUUIDArchive, rhs: TSP_CFUUIDArchive) -> Bool {
    if lhs._uuidBytes != rhs._uuidBytes {return false}
    if lhs._uuidW0 != rhs._uuidW0 {return false}
    if lhs._uuidW1 != rhs._uuidW1 {return false}
    if lhs._uuidW2 != rhs._uuidW2 {return false}
    if lhs._uuidW3 != rhs._uuidW3 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_UUIDSetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UUIDSetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uids\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.uids) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.uids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_UUIDSetArchive, rhs: TSP_UUIDSetArchive) -> Bool {
    if lhs.uids != rhs.uids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_UUIDMapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UUIDMapArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}source\0\u{1}target\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.source) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.target) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.source) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.target) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.source.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.source, fieldNumber: 1)
    }
    if !self.target.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.target, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_UUIDMapArchive, rhs: TSP_UUIDMapArchive) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_UUIDMultiMapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UUIDMultiMapArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}source\0\u{1}target\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.source) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.target) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.source) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.target) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.source.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.source, fieldNumber: 1)
    }
    if !self.target.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.target, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_UUIDMultiMapArchive, rhs: TSP_UUIDMultiMapArchive) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_UUIDCoordArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UUIDCoordArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}row_uid\0\u{3}column_uid\0")

  public var isInitialized: Bool {
    if self._rowUid == nil {return false}
    if self._columnUid == nil {return false}
    if let v = self._rowUid, !v.isInitialized {return false}
    if let v = self._columnUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rowUid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._columnUid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rowUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._columnUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_UUIDCoordArchive, rhs: TSP_UUIDCoordArchive) -> Bool {
    if lhs._rowUid != rhs._rowUid {return false}
    if lhs._columnUid != rhs._columnUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_UUIDRectArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UUIDRectArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}column_uids\0\u{3}row_uids\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.columnUids) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rowUids) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.columnUids) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rowUids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.columnUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.columnUids, fieldNumber: 1)
    }
    if !self.rowUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rowUids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_UUIDRectArchive, rhs: TSP_UUIDRectArchive) -> Bool {
    if lhs.columnUids != rhs.columnUids {return false}
    if lhs.rowUids != rhs.rowUids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_SparseUUIDArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SparseUUIDArray"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}count\0\u{1}entries\0")

  public var isInitialized: Bool {
    if self._count == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.entries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._count) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._count {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_SparseUUIDArray, rhs: TSP_SparseUUIDArray) -> Bool {
    if lhs._count != rhs._count {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_SparseUUIDArray.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSP_SparseUUIDArray.protoMessageName + ".Entry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}index\0\u{1}uuid\0")

  public var isInitialized: Bool {
    if self._index == nil {return false}
    if self._uuid == nil {return false}
    if let v = self._uuid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._index) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._index {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_SparseUUIDArray.Entry, rhs: TSP_SparseUUIDArray.Entry) -> Bool {
    if lhs._index != rhs._index {return false}
    if lhs._uuid != rhs._uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_UUIDPath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UUIDPath"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uuids\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.uuids) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.uuids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uuids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_UUIDPath, rhs: TSP_UUIDPath) -> Bool {
    if lhs.uuids != rhs.uuids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_SparseUUIDPathArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SparseUUIDPathArray"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}count\0\u{1}entries\0")

  public var isInitialized: Bool {
    if self._count == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.entries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._count) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._count {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_SparseUUIDPathArray, rhs: TSP_SparseUUIDPathArray) -> Bool {
    if lhs._count != rhs._count {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_SparseUUIDPathArray.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSP_SparseUUIDPathArray.protoMessageName + ".Entry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}index\0\u{3}uuid_path\0")

  public var isInitialized: Bool {
    if self._index == nil {return false}
    if self._uuidPath == nil {return false}
    if let v = self._uuidPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._index) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._uuidPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._index {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._uuidPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_SparseUUIDPathArray.Entry, rhs: TSP_SparseUUIDPathArray.Entry) -> Bool {
    if lhs._index != rhs._index {return false}
    if lhs._uuidPath != rhs._uuidPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_PasteboardObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PasteboardObject"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}stylesheet\0\u{1}drawables\0\u{1}styles\0\u{4}\u{2}wp_storage\0\u{3}app_native_object\0\u{3}is_text_primary\0\u{3}is_smart\0\u{3}guide_storage\0\u{1}presets\0\u{3}top_level_objects\0\u{3}native_content_description\0\u{3}text_ranges\0")

  fileprivate class _StorageClass {
    var _stylesheet: TSP_Reference? = nil
    var _drawables: [TSP_Reference] = []
    var _styles: [TSP_Reference] = []
    var _wpStorage: TSP_Reference? = nil
    var _guideStorage: TSP_Reference? = nil
    var _appNativeObject: TSP_Reference? = nil
    var _isTextPrimary: Bool? = nil
    var _isSmart: Bool? = nil
    var _presets: [TSP_Reference] = []
    var _topLevelObjects: [TSP_Reference] = []
    var _nativeContentDescription: TSP_Reference? = nil
    var _textRanges: [TSP_Range] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _stylesheet = source._stylesheet
      _drawables = source._drawables
      _styles = source._styles
      _wpStorage = source._wpStorage
      _guideStorage = source._guideStorage
      _appNativeObject = source._appNativeObject
      _isTextPrimary = source._isTextPrimary
      _isSmart = source._isSmart
      _presets = source._presets
      _topLevelObjects = source._topLevelObjects
      _nativeContentDescription = source._nativeContentDescription
      _textRanges = source._textRanges
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._stylesheet, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._drawables) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._styles) {return false}
      if let v = _storage._wpStorage, !v.isInitialized {return false}
      if let v = _storage._guideStorage, !v.isInitialized {return false}
      if let v = _storage._appNativeObject, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._presets) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._topLevelObjects) {return false}
      if let v = _storage._nativeContentDescription, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._textRanges) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._stylesheet) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._drawables) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._styles) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._wpStorage) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._appNativeObject) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._isTextPrimary) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._isSmart) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._guideStorage) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._presets) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._topLevelObjects) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._nativeContentDescription) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._textRanges) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._stylesheet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._drawables.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._drawables, fieldNumber: 2)
      }
      if !_storage._styles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._styles, fieldNumber: 3)
      }
      try { if let v = _storage._wpStorage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._appNativeObject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._isTextPrimary {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._isSmart {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._guideStorage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._presets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._presets, fieldNumber: 10)
      }
      if !_storage._topLevelObjects.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._topLevelObjects, fieldNumber: 11)
      }
      try { if let v = _storage._nativeContentDescription {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._textRanges.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._textRanges, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_PasteboardObject, rhs: TSP_PasteboardObject) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._stylesheet != rhs_storage._stylesheet {return false}
        if _storage._drawables != rhs_storage._drawables {return false}
        if _storage._styles != rhs_storage._styles {return false}
        if _storage._wpStorage != rhs_storage._wpStorage {return false}
        if _storage._guideStorage != rhs_storage._guideStorage {return false}
        if _storage._appNativeObject != rhs_storage._appNativeObject {return false}
        if _storage._isTextPrimary != rhs_storage._isTextPrimary {return false}
        if _storage._isSmart != rhs_storage._isSmart {return false}
        if _storage._presets != rhs_storage._presets {return false}
        if _storage._topLevelObjects != rhs_storage._topLevelObjects {return false}
        if _storage._nativeContentDescription != rhs_storage._nativeContentDescription {return false}
        if _storage._textRanges != rhs_storage._textRanges {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_ObjectCollection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ObjectCollection"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}objects\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.objects) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.objects) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objects, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_ObjectCollection, rhs: TSP_ObjectCollection) -> Bool {
    if lhs.objects != rhs.objects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_ObjectContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ObjectContainer"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identifier\0\u{1}objects\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.objects) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._identifier) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.objects) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.objects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objects, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_ObjectContainer, rhs: TSP_ObjectContainer) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs.objects != rhs.objects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_DataAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataAttributes"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      if (100 <= fieldNumber && fieldNumber < 536870912) {
        try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TSP_DataAttributes.self, fieldNumber: fieldNumber)
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 100, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_DataAttributes, rhs: TSP_DataAttributes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TSP_LargeArraySegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LargeArraySegment"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}should_delay_archiving\0\u{3}delayed_archiving_priority\0\u{3}package_locator\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._shouldDelayArchiving) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._delayedArchivingPriority) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._packageLocator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._shouldDelayArchiving {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._delayedArchivingPriority {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._packageLocator {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_LargeArraySegment, rhs: TSP_LargeArraySegment) -> Bool {
    if lhs._shouldDelayArchiving != rhs._shouldDelayArchiving {return false}
    if lhs._delayedArchivingPriority != rhs._delayedArchivingPriority {return false}
    if lhs._packageLocator != rhs._packageLocator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_LargeNumberArraySegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LargeNumberArraySegment"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}large_array_segment\0\u{1}elements\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._largeArraySegment) }()
      case 2: try { try decoder.decodeRepeatedDoubleField(value: &self.elements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._largeArraySegment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.elements.isEmpty {
      try visitor.visitRepeatedDoubleField(value: self.elements, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_LargeNumberArraySegment, rhs: TSP_LargeNumberArraySegment) -> Bool {
    if lhs._largeArraySegment != rhs._largeArraySegment {return false}
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_LargeStringArraySegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LargeStringArraySegment"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}large_array_segment\0\u{1}elements\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._largeArraySegment) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._largeArraySegment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_LargeStringArraySegment, rhs: TSP_LargeStringArraySegment) -> Bool {
    if lhs._largeArraySegment != rhs._largeArraySegment {return false}
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_LargeStringArraySegment.OptionalElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSP_LargeStringArraySegment.protoMessageName + ".OptionalElement"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}element\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._element) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._element {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_LargeStringArraySegment.OptionalElement, rhs: TSP_LargeStringArraySegment.OptionalElement) -> Bool {
    if lhs._element != rhs._element {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_LargeUUIDArraySegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LargeUUIDArraySegment"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}large_array_segment\0\u{1}elements\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.elements) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._largeArraySegment) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._largeArraySegment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_LargeUUIDArraySegment, rhs: TSP_LargeUUIDArraySegment) -> Bool {
    if lhs._largeArraySegment != rhs._largeArraySegment {return false}
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_LargeLazyObjectArraySegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LargeLazyObjectArraySegment"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}large_array_segment\0\u{1}elements\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.elements) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._largeArraySegment) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._largeArraySegment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_LargeLazyObjectArraySegment, rhs: TSP_LargeLazyObjectArraySegment) -> Bool {
    if lhs._largeArraySegment != rhs._largeArraySegment {return false}
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_LargeObjectArraySegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LargeObjectArraySegment"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}large_array_segment\0\u{1}elements\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.elements) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._largeArraySegment) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._largeArraySegment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_LargeObjectArraySegment, rhs: TSP_LargeObjectArraySegment) -> Bool {
    if lhs._largeArraySegment != rhs._largeArraySegment {return false}
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_LargeArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LargeArray"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ranges\0\u{1}segments\0\u{3}max_segment_element_count\0\u{3}max_segment_size\0\u{3}should_delay_archiving\0\u{3}delayed_archiving_priority\0\u{3}store_outside_object_archive\0\u{3}estimated_byte_size\0\u{3}max_segment_cost\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.ranges) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.segments) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ranges) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.segments) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._maxSegmentElementCount) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._maxSegmentSize) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._shouldDelayArchiving) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._delayedArchivingPriority) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._storeOutsideObjectArchive) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self._estimatedByteSize) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self._maxSegmentCost) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.ranges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranges, fieldNumber: 1)
    }
    if !self.segments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.segments, fieldNumber: 2)
    }
    try { if let v = self._maxSegmentElementCount {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._maxSegmentSize {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._shouldDelayArchiving {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._delayedArchivingPriority {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._storeOutsideObjectArchive {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._estimatedByteSize {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._maxSegmentCost {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_LargeArray, rhs: TSP_LargeArray) -> Bool {
    if lhs.ranges != rhs.ranges {return false}
    if lhs.segments != rhs.segments {return false}
    if lhs._maxSegmentElementCount != rhs._maxSegmentElementCount {return false}
    if lhs._maxSegmentSize != rhs._maxSegmentSize {return false}
    if lhs._shouldDelayArchiving != rhs._shouldDelayArchiving {return false}
    if lhs._delayedArchivingPriority != rhs._delayedArchivingPriority {return false}
    if lhs._storeOutsideObjectArchive != rhs._storeOutsideObjectArchive {return false}
    if lhs._estimatedByteSize != rhs._estimatedByteSize {return false}
    if lhs._maxSegmentCost != rhs._maxSegmentCost {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_LargeNumberArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LargeNumberArray"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}large_array\0")

  public var isInitialized: Bool {
    if let v = self._largeArray, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._largeArray) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._largeArray {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_LargeNumberArray, rhs: TSP_LargeNumberArray) -> Bool {
    if lhs._largeArray != rhs._largeArray {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_LargeStringArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LargeStringArray"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}large_array\0")

  public var isInitialized: Bool {
    if let v = self._largeArray, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._largeArray) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._largeArray {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_LargeStringArray, rhs: TSP_LargeStringArray) -> Bool {
    if lhs._largeArray != rhs._largeArray {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_LargeLazyObjectArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LargeLazyObjectArray"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}large_array\0")

  public var isInitialized: Bool {
    if let v = self._largeArray, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._largeArray) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._largeArray {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_LargeLazyObjectArray, rhs: TSP_LargeLazyObjectArray) -> Bool {
    if lhs._largeArray != rhs._largeArray {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_LargeObjectArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LargeObjectArray"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}large_array\0")

  public var isInitialized: Bool {
    if let v = self._largeArray, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._largeArray) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._largeArray {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_LargeObjectArray, rhs: TSP_LargeObjectArray) -> Bool {
    if lhs._largeArray != rhs._largeArray {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_LargeUUIDArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LargeUUIDArray"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}large_array\0")

  public var isInitialized: Bool {
    if let v = self._largeArray, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._largeArray) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._largeArray {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_LargeUUIDArray, rhs: TSP_LargeUUIDArray) -> Bool {
    if lhs._largeArray != rhs._largeArray {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSP_FieldOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FieldOptions"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}metadata_type\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._metadataType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadataType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSP_FieldOptions, rhs: TSP_FieldOptions) -> Bool {
    if lhs._metadataType != rhs._metadataType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
