// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TSWPCommandArchives.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum TSWP_ObjectPropertyType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case kObjectPropertyTypeBool = 0
  case kObjectPropertyTypeFloat = 1
  case kObjectPropertyTypeInteger = 2
  case kObjectPropertyTypeString = 3
  case kObjectPropertyTypeIDPath = 4
  case kObjectPropertyTypeFill = 5
  case kObjectPropertyTypeColor = 6
  case kObjectPropertyTypeShadow = 7

  init() {
    self = .kObjectPropertyTypeBool
  }

}

struct TSWP_DummyCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var foo: UInt32 {
    get {return _foo ?? 0}
    set {_foo = newValue}
  }
  /// Returns true if `foo` has been explicitly set.
  var hasFoo: Bool {return self._foo != nil}
  /// Clears the value of `foo`. Subsequent reads from it will return its default value.
  mutating func clearFoo() {self._foo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _foo: UInt32? = nil
}

struct TSWP_TextCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var storage: TSP_Reference {
    get {return _storage._storage ?? TSP_Reference()}
    set {_uniqueStorage()._storage = newValue}
  }
  /// Returns true if `storage` has been explicitly set.
  var hasStorage: Bool {return _storage._storage != nil}
  /// Clears the value of `storage`. Subsequent reads from it will return its default value.
  mutating func clearStorage() {_uniqueStorage()._storage = nil}

  var undoTransaction: TSWP_UndoTransaction {
    get {return _storage._undoTransaction ?? TSWP_UndoTransaction()}
    set {_uniqueStorage()._undoTransaction = newValue}
  }
  /// Returns true if `undoTransaction` has been explicitly set.
  var hasUndoTransaction: Bool {return _storage._undoTransaction != nil}
  /// Clears the value of `undoTransaction`. Subsequent reads from it will return its default value.
  mutating func clearUndoTransaction() {_uniqueStorage()._undoTransaction = nil}

  var restoreRangeLocation: UInt32 {
    get {return _storage._restoreRangeLocation ?? 0}
    set {_uniqueStorage()._restoreRangeLocation = newValue}
  }
  /// Returns true if `restoreRangeLocation` has been explicitly set.
  var hasRestoreRangeLocation: Bool {return _storage._restoreRangeLocation != nil}
  /// Clears the value of `restoreRangeLocation`. Subsequent reads from it will return its default value.
  mutating func clearRestoreRangeLocation() {_uniqueStorage()._restoreRangeLocation = nil}

  var restoreRangeLength: UInt32 {
    get {return _storage._restoreRangeLength ?? 0}
    set {_uniqueStorage()._restoreRangeLength = newValue}
  }
  /// Returns true if `restoreRangeLength` has been explicitly set.
  var hasRestoreRangeLength: Bool {return _storage._restoreRangeLength != nil}
  /// Clears the value of `restoreRangeLength`. Subsequent reads from it will return its default value.
  mutating func clearRestoreRangeLength() {_uniqueStorage()._restoreRangeLength = nil}

  var redoRestoreRangeLocation: UInt32 {
    get {return _storage._redoRestoreRangeLocation ?? 0}
    set {_uniqueStorage()._redoRestoreRangeLocation = newValue}
  }
  /// Returns true if `redoRestoreRangeLocation` has been explicitly set.
  var hasRedoRestoreRangeLocation: Bool {return _storage._redoRestoreRangeLocation != nil}
  /// Clears the value of `redoRestoreRangeLocation`. Subsequent reads from it will return its default value.
  mutating func clearRedoRestoreRangeLocation() {_uniqueStorage()._redoRestoreRangeLocation = nil}

  var redoRestoreRangeLength: UInt32 {
    get {return _storage._redoRestoreRangeLength ?? 0}
    set {_uniqueStorage()._redoRestoreRangeLength = newValue}
  }
  /// Returns true if `redoRestoreRangeLength` has been explicitly set.
  var hasRedoRestoreRangeLength: Bool {return _storage._redoRestoreRangeLength != nil}
  /// Clears the value of `redoRestoreRangeLength`. Subsequent reads from it will return its default value.
  mutating func clearRedoRestoreRangeLength() {_uniqueStorage()._redoRestoreRangeLength = nil}

  var textCommandFlags: UInt32 {
    get {return _storage._textCommandFlags ?? 0}
    set {_uniqueStorage()._textCommandFlags = newValue}
  }
  /// Returns true if `textCommandFlags` has been explicitly set.
  var hasTextCommandFlags: Bool {return _storage._textCommandFlags != nil}
  /// Clears the value of `textCommandFlags`. Subsequent reads from it will return its default value.
  mutating func clearTextCommandFlags() {_uniqueStorage()._textCommandFlags = nil}

  var kind: TSWP_TextCommandArchive.Kind {
    get {return _storage._kind ?? .kKindContained}
    set {_uniqueStorage()._kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return _storage._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {_uniqueStorage()._kind = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Kind: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kKindContained = 0
    case kKindReplaceText = 1
    case kKindPaste = 2
    case kKindParagraphStyle = 3
    case kKindListStyle = 4
    case kKindIndentParagraphLevel = 5
    case kKindDragText = 6
    case kKindPasteStyle = 7
    case kKindApplyChangesInRange = 8
    case kKindInsertCitationField = 10
    case kKindInsertBibliographyEntry = 11
    case kKindFormatCitationFields = 12
    case kKindInsertTocsmartField = 13
    case kKindInsertDateTimeFieldDeprecated = 14
    case kKindUpdateDateTimeField = 15
    case kKindSetParagraphFirstTopicNumber = 16
    case kKindCharacterStyle = 17
    case kKindRevertStylesDeprecated = 18
    case kKindSetParagraphBidi = 19

    init() {
      self = .kKindContained
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_StorageActionCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var storage: TSP_UUIDPath {
    get {return _storage._storage ?? TSP_UUIDPath()}
    set {_uniqueStorage()._storage = newValue}
  }
  /// Returns true if `storage` has been explicitly set.
  var hasStorage: Bool {return _storage._storage != nil}
  /// Clears the value of `storage`. Subsequent reads from it will return its default value.
  mutating func clearStorage() {_uniqueStorage()._storage = nil}

  var undoTransaction: TSWP_UndoTransaction {
    get {return _storage._undoTransaction ?? TSWP_UndoTransaction()}
    set {_uniqueStorage()._undoTransaction = newValue}
  }
  /// Returns true if `undoTransaction` has been explicitly set.
  var hasUndoTransaction: Bool {return _storage._undoTransaction != nil}
  /// Clears the value of `undoTransaction`. Subsequent reads from it will return its default value.
  mutating func clearUndoTransaction() {_uniqueStorage()._undoTransaction = nil}

  var textCommandFlags: UInt32 {
    get {return _storage._textCommandFlags ?? 0}
    set {_uniqueStorage()._textCommandFlags = newValue}
  }
  /// Returns true if `textCommandFlags` has been explicitly set.
  var hasTextCommandFlags: Bool {return _storage._textCommandFlags != nil}
  /// Clears the value of `textCommandFlags`. Subsequent reads from it will return its default value.
  mutating func clearTextCommandFlags() {_uniqueStorage()._textCommandFlags = nil}

  var kind: TSWP_StorageActionCommandArchive.Kind {
    get {return _storage._kind ?? .kKindContained}
    set {_uniqueStorage()._kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return _storage._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {_uniqueStorage()._kind = nil}

  var customFormatKeys: [TSP_UUID] {
    get {return _storage._customFormatKeys}
    set {_uniqueStorage()._customFormatKeys = newValue}
  }

  var isForwardInverseCommand: Bool {
    get {return _storage._isForwardInverseCommand ?? false}
    set {_uniqueStorage()._isForwardInverseCommand = newValue}
  }
  /// Returns true if `isForwardInverseCommand` has been explicitly set.
  var hasIsForwardInverseCommand: Bool {return _storage._isForwardInverseCommand != nil}
  /// Clears the value of `isForwardInverseCommand`. Subsequent reads from it will return its default value.
  mutating func clearIsForwardInverseCommand() {_uniqueStorage()._isForwardInverseCommand = nil}

  var coalesceable: Bool {
    get {return _storage._coalesceable ?? false}
    set {_uniqueStorage()._coalesceable = newValue}
  }
  /// Returns true if `coalesceable` has been explicitly set.
  var hasCoalesceable: Bool {return _storage._coalesceable != nil}
  /// Clears the value of `coalesceable`. Subsequent reads from it will return its default value.
  mutating func clearCoalesceable() {_uniqueStorage()._coalesceable = nil}

  var coalescingText: Bool {
    get {return _storage._coalescingText ?? false}
    set {_uniqueStorage()._coalescingText = newValue}
  }
  /// Returns true if `coalescingText` has been explicitly set.
  var hasCoalescingText: Bool {return _storage._coalescingText != nil}
  /// Clears the value of `coalescingText`. Subsequent reads from it will return its default value.
  mutating func clearCoalescingText() {_uniqueStorage()._coalescingText = nil}

  var shouldMigrateStyles: Bool {
    get {return _storage._shouldMigrateStyles ?? false}
    set {_uniqueStorage()._shouldMigrateStyles = newValue}
  }
  /// Returns true if `shouldMigrateStyles` has been explicitly set.
  var hasShouldMigrateStyles: Bool {return _storage._shouldMigrateStyles != nil}
  /// Clears the value of `shouldMigrateStyles`. Subsequent reads from it will return its default value.
  mutating func clearShouldMigrateStyles() {_uniqueStorage()._shouldMigrateStyles = nil}

  var changedDataReferenceRecord: TSK_DataReferenceRecord {
    get {return _storage._changedDataReferenceRecord ?? TSK_DataReferenceRecord()}
    set {_uniqueStorage()._changedDataReferenceRecord = newValue}
  }
  /// Returns true if `changedDataReferenceRecord` has been explicitly set.
  var hasChangedDataReferenceRecord: Bool {return _storage._changedDataReferenceRecord != nil}
  /// Clears the value of `changedDataReferenceRecord`. Subsequent reads from it will return its default value.
  mutating func clearChangedDataReferenceRecord() {_uniqueStorage()._changedDataReferenceRecord = nil}

  var coalescingProperty: String {
    get {return _storage._coalescingProperty ?? String()}
    set {_uniqueStorage()._coalescingProperty = newValue}
  }
  /// Returns true if `coalescingProperty` has been explicitly set.
  var hasCoalescingProperty: Bool {return _storage._coalescingProperty != nil}
  /// Clears the value of `coalescingProperty`. Subsequent reads from it will return its default value.
  mutating func clearCoalescingProperty() {_uniqueStorage()._coalescingProperty = nil}

  var wpKind: TSWP_StorageArchive.KindType {
    get {return _storage._wpKind ?? .body}
    set {_uniqueStorage()._wpKind = newValue}
  }
  /// Returns true if `wpKind` has been explicitly set.
  var hasWpKind: Bool {return _storage._wpKind != nil}
  /// Clears the value of `wpKind`. Subsequent reads from it will return its default value.
  mutating func clearWpKind() {_uniqueStorage()._wpKind = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Kind: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kKindContained = 0
    case kKindReplaceText = 1
    case kKindPaste = 2
    case kKindParagraphStyle = 3
    case kKindListStyle = 4
    case kKindIndentParagraphLevel = 5
    case kKindDragText = 6
    case kKindPasteStyle = 7
    case kKindApplyChangesInRange = 8
    case kKindInsertCitationField = 10
    case kKindInsertBibliographyEntry = 11
    case kKindFormatCitationFields = 12
    case kKindInsertTocsmartField = 13
    case kKindInsertDateTimeField = 14
    case kKindUpdateDateTimeField = 15
    case kKindSetParagraphFirstTopicNumber = 16
    case kKindCharacterStyle = 17
    case kKindRevertStyles = 18
    case kKindSetParagraphBidi = 19
    case kKindFormatText = 20
    case kKindInsertAttachment = 21
    case kKindCreateHyperlink = 22
    case kKindModifyHyperlink = 23
    case kKindRemoveHyperlink = 24
    case kKindApplyHighlightText = 25
    case kKindPropagateStyleChanges = 26
    case kKindMovedAnchoredDrawableInline = 27
    case kKindMoveDrawablesAttached = 28
    case kKindMoveMoveDrawablesFloating = 29
    case kKindMoveInlineDrawableAnchored = 30
    case kKindAnchorAttachment = 31
    case kKindBookmark = 32
    case kKindReplaceSection = 33
    case kKindApplyPencilAnnotation = 34
    case kKindApplyRuby = 35
    case kKindModifyRuby = 36
    case kKindRemoveRuby = 37
    case kKindTateChuYoko = 38
    case kKindDropCapStyle = 39
    case kKindMergeField = 40
    case kKindModifyMergeField = 41
    case kKindMergeFieldTypeReplace = 42
    case kKindApplyPlaceholderText = 43

    init() {
      self = .kKindContained
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_SetColumnStyleCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var storage: TSP_Reference {
    get {return _storage._storage ?? TSP_Reference()}
    set {_uniqueStorage()._storage = newValue}
  }
  /// Returns true if `storage` has been explicitly set.
  var hasStorage: Bool {return _storage._storage != nil}
  /// Clears the value of `storage`. Subsequent reads from it will return its default value.
  mutating func clearStorage() {_uniqueStorage()._storage = nil}

  var undoTransaction: TSWP_UndoTransaction {
    get {return _storage._undoTransaction ?? TSWP_UndoTransaction()}
    set {_uniqueStorage()._undoTransaction = newValue}
  }
  /// Returns true if `undoTransaction` has been explicitly set.
  var hasUndoTransaction: Bool {return _storage._undoTransaction != nil}
  /// Clears the value of `undoTransaction`. Subsequent reads from it will return its default value.
  mutating func clearUndoTransaction() {_uniqueStorage()._undoTransaction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_ReplaceAllUsesOfStyleCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var storage: TSP_Reference {
    get {return _storage._storage ?? TSP_Reference()}
    set {_uniqueStorage()._storage = newValue}
  }
  /// Returns true if `storage` has been explicitly set.
  var hasStorage: Bool {return _storage._storage != nil}
  /// Clears the value of `storage`. Subsequent reads from it will return its default value.
  mutating func clearStorage() {_uniqueStorage()._storage = nil}

  var undoTransaction: TSWP_UndoTransaction {
    get {return _storage._undoTransaction ?? TSWP_UndoTransaction()}
    set {_uniqueStorage()._undoTransaction = newValue}
  }
  /// Returns true if `undoTransaction` has been explicitly set.
  var hasUndoTransaction: Bool {return _storage._undoTransaction != nil}
  /// Clears the value of `undoTransaction`. Subsequent reads from it will return its default value.
  mutating func clearUndoTransaction() {_uniqueStorage()._undoTransaction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_InsertColumnsCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var storage: TSP_Reference {
    get {return _storage._storage ?? TSP_Reference()}
    set {_uniqueStorage()._storage = newValue}
  }
  /// Returns true if `storage` has been explicitly set.
  var hasStorage: Bool {return _storage._storage != nil}
  /// Clears the value of `storage`. Subsequent reads from it will return its default value.
  mutating func clearStorage() {_uniqueStorage()._storage = nil}

  var columnIndex: UInt32 {
    get {return _storage._columnIndex ?? 0}
    set {_uniqueStorage()._columnIndex = newValue}
  }
  /// Returns true if `columnIndex` has been explicitly set.
  var hasColumnIndex: Bool {return _storage._columnIndex != nil}
  /// Clears the value of `columnIndex`. Subsequent reads from it will return its default value.
  mutating func clearColumnIndex() {_uniqueStorage()._columnIndex = nil}

  var columnCount: UInt32 {
    get {return _storage._columnCount ?? 0}
    set {_uniqueStorage()._columnCount = newValue}
  }
  /// Returns true if `columnCount` has been explicitly set.
  var hasColumnCount: Bool {return _storage._columnCount != nil}
  /// Clears the value of `columnCount`. Subsequent reads from it will return its default value.
  mutating func clearColumnCount() {_uniqueStorage()._columnCount = nil}

  var undoTransaction: TSWP_UndoTransaction {
    get {return _storage._undoTransaction ?? TSWP_UndoTransaction()}
    set {_uniqueStorage()._undoTransaction = newValue}
  }
  /// Returns true if `undoTransaction` has been explicitly set.
  var hasUndoTransaction: Bool {return _storage._undoTransaction != nil}
  /// Clears the value of `undoTransaction`. Subsequent reads from it will return its default value.
  mutating func clearUndoTransaction() {_uniqueStorage()._undoTransaction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_InsertRowsCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var storage: TSP_Reference {
    get {return _storage._storage ?? TSP_Reference()}
    set {_uniqueStorage()._storage = newValue}
  }
  /// Returns true if `storage` has been explicitly set.
  var hasStorage: Bool {return _storage._storage != nil}
  /// Clears the value of `storage`. Subsequent reads from it will return its default value.
  mutating func clearStorage() {_uniqueStorage()._storage = nil}

  var rowIndex: UInt32 {
    get {return _storage._rowIndex ?? 0}
    set {_uniqueStorage()._rowIndex = newValue}
  }
  /// Returns true if `rowIndex` has been explicitly set.
  var hasRowIndex: Bool {return _storage._rowIndex != nil}
  /// Clears the value of `rowIndex`. Subsequent reads from it will return its default value.
  mutating func clearRowIndex() {_uniqueStorage()._rowIndex = nil}

  var rowCount: UInt32 {
    get {return _storage._rowCount ?? 0}
    set {_uniqueStorage()._rowCount = newValue}
  }
  /// Returns true if `rowCount` has been explicitly set.
  var hasRowCount: Bool {return _storage._rowCount != nil}
  /// Clears the value of `rowCount`. Subsequent reads from it will return its default value.
  mutating func clearRowCount() {_uniqueStorage()._rowCount = nil}

  var undoTransaction: TSWP_UndoTransaction {
    get {return _storage._undoTransaction ?? TSWP_UndoTransaction()}
    set {_uniqueStorage()._undoTransaction = newValue}
  }
  /// Returns true if `undoTransaction` has been explicitly set.
  var hasUndoTransaction: Bool {return _storage._undoTransaction != nil}
  /// Clears the value of `undoTransaction`. Subsequent reads from it will return its default value.
  mutating func clearUndoTransaction() {_uniqueStorage()._undoTransaction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_RemoveColumnsCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var storage: TSP_Reference {
    get {return _storage._storage ?? TSP_Reference()}
    set {_uniqueStorage()._storage = newValue}
  }
  /// Returns true if `storage` has been explicitly set.
  var hasStorage: Bool {return _storage._storage != nil}
  /// Clears the value of `storage`. Subsequent reads from it will return its default value.
  mutating func clearStorage() {_uniqueStorage()._storage = nil}

  var columnIndex: UInt32 {
    get {return _storage._columnIndex ?? 0}
    set {_uniqueStorage()._columnIndex = newValue}
  }
  /// Returns true if `columnIndex` has been explicitly set.
  var hasColumnIndex: Bool {return _storage._columnIndex != nil}
  /// Clears the value of `columnIndex`. Subsequent reads from it will return its default value.
  mutating func clearColumnIndex() {_uniqueStorage()._columnIndex = nil}

  var columnCount: UInt32 {
    get {return _storage._columnCount ?? 0}
    set {_uniqueStorage()._columnCount = newValue}
  }
  /// Returns true if `columnCount` has been explicitly set.
  var hasColumnCount: Bool {return _storage._columnCount != nil}
  /// Clears the value of `columnCount`. Subsequent reads from it will return its default value.
  mutating func clearColumnCount() {_uniqueStorage()._columnCount = nil}

  var undoTransaction: TSWP_UndoTransaction {
    get {return _storage._undoTransaction ?? TSWP_UndoTransaction()}
    set {_uniqueStorage()._undoTransaction = newValue}
  }
  /// Returns true if `undoTransaction` has been explicitly set.
  var hasUndoTransaction: Bool {return _storage._undoTransaction != nil}
  /// Clears the value of `undoTransaction`. Subsequent reads from it will return its default value.
  mutating func clearUndoTransaction() {_uniqueStorage()._undoTransaction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_RemoveRowsCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var storage: TSP_Reference {
    get {return _storage._storage ?? TSP_Reference()}
    set {_uniqueStorage()._storage = newValue}
  }
  /// Returns true if `storage` has been explicitly set.
  var hasStorage: Bool {return _storage._storage != nil}
  /// Clears the value of `storage`. Subsequent reads from it will return its default value.
  mutating func clearStorage() {_uniqueStorage()._storage = nil}

  var rowIndex: UInt32 {
    get {return _storage._rowIndex ?? 0}
    set {_uniqueStorage()._rowIndex = newValue}
  }
  /// Returns true if `rowIndex` has been explicitly set.
  var hasRowIndex: Bool {return _storage._rowIndex != nil}
  /// Clears the value of `rowIndex`. Subsequent reads from it will return its default value.
  mutating func clearRowIndex() {_uniqueStorage()._rowIndex = nil}

  var rowCount: UInt32 {
    get {return _storage._rowCount ?? 0}
    set {_uniqueStorage()._rowCount = newValue}
  }
  /// Returns true if `rowCount` has been explicitly set.
  var hasRowCount: Bool {return _storage._rowCount != nil}
  /// Clears the value of `rowCount`. Subsequent reads from it will return its default value.
  mutating func clearRowCount() {_uniqueStorage()._rowCount = nil}

  var undoTransaction: TSWP_UndoTransaction {
    get {return _storage._undoTransaction ?? TSWP_UndoTransaction()}
    set {_uniqueStorage()._undoTransaction = newValue}
  }
  /// Returns true if `undoTransaction` has been explicitly set.
  var hasUndoTransaction: Bool {return _storage._undoTransaction != nil}
  /// Clears the value of `undoTransaction`. Subsequent reads from it will return its default value.
  mutating func clearUndoTransaction() {_uniqueStorage()._undoTransaction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_MergeCellsCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var storage: TSP_Reference {
    get {return _storage._storage ?? TSP_Reference()}
    set {_uniqueStorage()._storage = newValue}
  }
  /// Returns true if `storage` has been explicitly set.
  var hasStorage: Bool {return _storage._storage != nil}
  /// Clears the value of `storage`. Subsequent reads from it will return its default value.
  mutating func clearStorage() {_uniqueStorage()._storage = nil}

  var row: UInt32 {
    get {return _storage._row ?? 0}
    set {_uniqueStorage()._row = newValue}
  }
  /// Returns true if `row` has been explicitly set.
  var hasRow: Bool {return _storage._row != nil}
  /// Clears the value of `row`. Subsequent reads from it will return its default value.
  mutating func clearRow() {_uniqueStorage()._row = nil}

  var column: UInt32 {
    get {return _storage._column ?? 0}
    set {_uniqueStorage()._column = newValue}
  }
  /// Returns true if `column` has been explicitly set.
  var hasColumn: Bool {return _storage._column != nil}
  /// Clears the value of `column`. Subsequent reads from it will return its default value.
  mutating func clearColumn() {_uniqueStorage()._column = nil}

  var rowCount: UInt32 {
    get {return _storage._rowCount ?? 0}
    set {_uniqueStorage()._rowCount = newValue}
  }
  /// Returns true if `rowCount` has been explicitly set.
  var hasRowCount: Bool {return _storage._rowCount != nil}
  /// Clears the value of `rowCount`. Subsequent reads from it will return its default value.
  mutating func clearRowCount() {_uniqueStorage()._rowCount = nil}

  var columnCount: UInt32 {
    get {return _storage._columnCount ?? 0}
    set {_uniqueStorage()._columnCount = newValue}
  }
  /// Returns true if `columnCount` has been explicitly set.
  var hasColumnCount: Bool {return _storage._columnCount != nil}
  /// Clears the value of `columnCount`. Subsequent reads from it will return its default value.
  mutating func clearColumnCount() {_uniqueStorage()._columnCount = nil}

  var undoTransaction: TSWP_UndoTransaction {
    get {return _storage._undoTransaction ?? TSWP_UndoTransaction()}
    set {_uniqueStorage()._undoTransaction = newValue}
  }
  /// Returns true if `undoTransaction` has been explicitly set.
  var hasUndoTransaction: Bool {return _storage._undoTransaction != nil}
  /// Clears the value of `undoTransaction`. Subsequent reads from it will return its default value.
  mutating func clearUndoTransaction() {_uniqueStorage()._undoTransaction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_ApplyPlaceholderTextCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var storage: TSP_Reference {
    get {return _storage._storage ?? TSP_Reference()}
    set {_uniqueStorage()._storage = newValue}
  }
  /// Returns true if `storage` has been explicitly set.
  var hasStorage: Bool {return _storage._storage != nil}
  /// Clears the value of `storage`. Subsequent reads from it will return its default value.
  mutating func clearStorage() {_uniqueStorage()._storage = nil}

  var selectionRangeLocation: UInt32 {
    get {return _storage._selectionRangeLocation ?? 0}
    set {_uniqueStorage()._selectionRangeLocation = newValue}
  }
  /// Returns true if `selectionRangeLocation` has been explicitly set.
  var hasSelectionRangeLocation: Bool {return _storage._selectionRangeLocation != nil}
  /// Clears the value of `selectionRangeLocation`. Subsequent reads from it will return its default value.
  mutating func clearSelectionRangeLocation() {_uniqueStorage()._selectionRangeLocation = nil}

  var selectionRangeLength: UInt32 {
    get {return _storage._selectionRangeLength ?? 0}
    set {_uniqueStorage()._selectionRangeLength = newValue}
  }
  /// Returns true if `selectionRangeLength` has been explicitly set.
  var hasSelectionRangeLength: Bool {return _storage._selectionRangeLength != nil}
  /// Clears the value of `selectionRangeLength`. Subsequent reads from it will return its default value.
  mutating func clearSelectionRangeLength() {_uniqueStorage()._selectionRangeLength = nil}

  var undoTransaction: TSWP_UndoTransaction {
    get {return _storage._undoTransaction ?? TSWP_UndoTransaction()}
    set {_uniqueStorage()._undoTransaction = newValue}
  }
  /// Returns true if `undoTransaction` has been explicitly set.
  var hasUndoTransaction: Bool {return _storage._undoTransaction != nil}
  /// Clears the value of `undoTransaction`. Subsequent reads from it will return its default value.
  mutating func clearUndoTransaction() {_uniqueStorage()._undoTransaction = nil}

  var scriptTag: String {
    get {return _storage._scriptTag ?? String()}
    set {_uniqueStorage()._scriptTag = newValue}
  }
  /// Returns true if `scriptTag` has been explicitly set.
  var hasScriptTag: Bool {return _storage._scriptTag != nil}
  /// Clears the value of `scriptTag`. Subsequent reads from it will return its default value.
  mutating func clearScriptTag() {_uniqueStorage()._scriptTag = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_UpdateDateTimeFieldCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_TextCommandArchive {
    get {return _super ?? TSWP_TextCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var dateTimeField: TSP_Reference {
    get {return _dateTimeField ?? TSP_Reference()}
    set {_dateTimeField = newValue}
  }
  /// Returns true if `dateTimeField` has been explicitly set.
  var hasDateTimeField: Bool {return self._dateTimeField != nil}
  /// Clears the value of `dateTimeField`. Subsequent reads from it will return its default value.
  mutating func clearDateTimeField() {self._dateTimeField = nil}

  var date: TSP_Date {
    get {return _date ?? TSP_Date()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {self._date = nil}

  var dateStyle: TSWP_DateTimeSmartFieldArchive.DateTimeFormatterStyle {
    get {return _dateStyle ?? .kDateTimeFormatterStyleNone}
    set {_dateStyle = newValue}
  }
  /// Returns true if `dateStyle` has been explicitly set.
  var hasDateStyle: Bool {return self._dateStyle != nil}
  /// Clears the value of `dateStyle`. Subsequent reads from it will return its default value.
  mutating func clearDateStyle() {self._dateStyle = nil}

  var timeStyle: TSWP_DateTimeSmartFieldArchive.DateTimeFormatterStyle {
    get {return _timeStyle ?? .kDateTimeFormatterStyleNone}
    set {_timeStyle = newValue}
  }
  /// Returns true if `timeStyle` has been explicitly set.
  var hasTimeStyle: Bool {return self._timeStyle != nil}
  /// Clears the value of `timeStyle`. Subsequent reads from it will return its default value.
  mutating func clearTimeStyle() {self._timeStyle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_TextCommandArchive? = nil
  fileprivate var _dateTimeField: TSP_Reference? = nil
  fileprivate var _date: TSP_Date? = nil
  fileprivate var _dateStyle: TSWP_DateTimeSmartFieldArchive.DateTimeFormatterStyle? = nil
  fileprivate var _timeStyle: TSWP_DateTimeSmartFieldArchive.DateTimeFormatterStyle? = nil
}

struct TSWP_ApplyRubyTextCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var storage: TSP_Reference {
    get {return _storage._storage ?? TSP_Reference()}
    set {_uniqueStorage()._storage = newValue}
  }
  /// Returns true if `storage` has been explicitly set.
  var hasStorage: Bool {return _storage._storage != nil}
  /// Clears the value of `storage`. Subsequent reads from it will return its default value.
  mutating func clearStorage() {_uniqueStorage()._storage = nil}

  var selectionRangeLocation: UInt32 {
    get {return _storage._selectionRangeLocation ?? 0}
    set {_uniqueStorage()._selectionRangeLocation = newValue}
  }
  /// Returns true if `selectionRangeLocation` has been explicitly set.
  var hasSelectionRangeLocation: Bool {return _storage._selectionRangeLocation != nil}
  /// Clears the value of `selectionRangeLocation`. Subsequent reads from it will return its default value.
  mutating func clearSelectionRangeLocation() {_uniqueStorage()._selectionRangeLocation = nil}

  var selectionRangeLength: UInt32 {
    get {return _storage._selectionRangeLength ?? 0}
    set {_uniqueStorage()._selectionRangeLength = newValue}
  }
  /// Returns true if `selectionRangeLength` has been explicitly set.
  var hasSelectionRangeLength: Bool {return _storage._selectionRangeLength != nil}
  /// Clears the value of `selectionRangeLength`. Subsequent reads from it will return its default value.
  mutating func clearSelectionRangeLength() {_uniqueStorage()._selectionRangeLength = nil}

  var rubyText: String {
    get {return _storage._rubyText ?? String()}
    set {_uniqueStorage()._rubyText = newValue}
  }
  /// Returns true if `rubyText` has been explicitly set.
  var hasRubyText: Bool {return _storage._rubyText != nil}
  /// Clears the value of `rubyText`. Subsequent reads from it will return its default value.
  mutating func clearRubyText() {_uniqueStorage()._rubyText = nil}

  var undoTransaction: TSWP_UndoTransaction {
    get {return _storage._undoTransaction ?? TSWP_UndoTransaction()}
    set {_uniqueStorage()._undoTransaction = newValue}
  }
  /// Returns true if `undoTransaction` has been explicitly set.
  var hasUndoTransaction: Bool {return _storage._undoTransaction != nil}
  /// Clears the value of `undoTransaction`. Subsequent reads from it will return its default value.
  mutating func clearUndoTransaction() {_uniqueStorage()._undoTransaction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_ModifyRubyTextCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var rubyField: TSP_Reference {
    get {return _storage._rubyField ?? TSP_Reference()}
    set {_uniqueStorage()._rubyField = newValue}
  }
  /// Returns true if `rubyField` has been explicitly set.
  var hasRubyField: Bool {return _storage._rubyField != nil}
  /// Clears the value of `rubyField`. Subsequent reads from it will return its default value.
  mutating func clearRubyField() {_uniqueStorage()._rubyField = nil}

  var rubyText: String {
    get {return _storage._rubyText ?? String()}
    set {_uniqueStorage()._rubyText = newValue}
  }
  /// Returns true if `rubyText` has been explicitly set.
  var hasRubyText: Bool {return _storage._rubyText != nil}
  /// Clears the value of `rubyText`. Subsequent reads from it will return its default value.
  mutating func clearRubyText() {_uniqueStorage()._rubyText = nil}

  var baseText: String {
    get {return _storage._baseText ?? String()}
    set {_uniqueStorage()._baseText = newValue}
  }
  /// Returns true if `baseText` has been explicitly set.
  var hasBaseText: Bool {return _storage._baseText != nil}
  /// Clears the value of `baseText`. Subsequent reads from it will return its default value.
  mutating func clearBaseText() {_uniqueStorage()._baseText = nil}

  var undoTransaction: TSWP_UndoTransaction {
    get {return _storage._undoTransaction ?? TSWP_UndoTransaction()}
    set {_uniqueStorage()._undoTransaction = newValue}
  }
  /// Returns true if `undoTransaction` has been explicitly set.
  var hasUndoTransaction: Bool {return _storage._undoTransaction != nil}
  /// Clears the value of `undoTransaction`. Subsequent reads from it will return its default value.
  mutating func clearUndoTransaction() {_uniqueStorage()._undoTransaction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_ModifyTOCSettingsBaseCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var oldTocSettings: TSP_Reference {
    get {return _storage._oldTocSettings ?? TSP_Reference()}
    set {_uniqueStorage()._oldTocSettings = newValue}
  }
  /// Returns true if `oldTocSettings` has been explicitly set.
  var hasOldTocSettings: Bool {return _storage._oldTocSettings != nil}
  /// Clears the value of `oldTocSettings`. Subsequent reads from it will return its default value.
  mutating func clearOldTocSettings() {_uniqueStorage()._oldTocSettings = nil}

  var newTocSettings: TSP_Reference {
    get {return _storage._newTocSettings ?? TSP_Reference()}
    set {_uniqueStorage()._newTocSettings = newValue}
  }
  /// Returns true if `newTocSettings` has been explicitly set.
  var hasNewTocSettings: Bool {return _storage._newTocSettings != nil}
  /// Clears the value of `newTocSettings`. Subsequent reads from it will return its default value.
  mutating func clearNewTocSettings() {_uniqueStorage()._newTocSettings = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_ModifyTOCSettingsForTOCInfoCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_ModifyTOCSettingsBaseCommandArchive {
    get {return _super ?? TSWP_ModifyTOCSettingsBaseCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var tocInfoUuidPath: TSP_UUIDPath {
    get {return _tocInfoUuidPath ?? TSP_UUIDPath()}
    set {_tocInfoUuidPath = newValue}
  }
  /// Returns true if `tocInfoUuidPath` has been explicitly set.
  var hasTocInfoUuidPath: Bool {return self._tocInfoUuidPath != nil}
  /// Clears the value of `tocInfoUuidPath`. Subsequent reads from it will return its default value.
  mutating func clearTocInfoUuidPath() {self._tocInfoUuidPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_ModifyTOCSettingsBaseCommandArchive? = nil
  fileprivate var _tocInfoUuidPath: TSP_UUIDPath? = nil
}

struct TSWP_ModifyTOCSettingsPresetForThemeCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_ModifyTOCSettingsBaseCommandArchive {
    get {return _super ?? TSWP_ModifyTOCSettingsBaseCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var theme: TSP_Reference {
    get {return _theme ?? TSP_Reference()}
    set {_theme = newValue}
  }
  /// Returns true if `theme` has been explicitly set.
  var hasTheme: Bool {return self._theme != nil}
  /// Clears the value of `theme`. Subsequent reads from it will return its default value.
  mutating func clearTheme() {self._theme = nil}

  var presetIndex: UInt32 {
    get {return _presetIndex ?? 0}
    set {_presetIndex = newValue}
  }
  /// Returns true if `presetIndex` has been explicitly set.
  var hasPresetIndex: Bool {return self._presetIndex != nil}
  /// Clears the value of `presetIndex`. Subsequent reads from it will return its default value.
  mutating func clearPresetIndex() {self._presetIndex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_ModifyTOCSettingsBaseCommandArchive? = nil
  fileprivate var _theme: TSP_Reference? = nil
  fileprivate var _presetIndex: UInt32? = nil
}

struct TSWP_AnchorAttachmentCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_StorageActionCommandArchive {
    get {return _super ?? TSWP_StorageActionCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var attachment: TSP_Reference {
    get {return _attachment ?? TSP_Reference()}
    set {_attachment = newValue}
  }
  /// Returns true if `attachment` has been explicitly set.
  var hasAttachment: Bool {return self._attachment != nil}
  /// Clears the value of `attachment`. Subsequent reads from it will return its default value.
  mutating func clearAttachment() {self._attachment = nil}

  var hOffsetType: UInt32 {
    get {return _hOffsetType ?? 0}
    set {_hOffsetType = newValue}
  }
  /// Returns true if `hOffsetType` has been explicitly set.
  var hasHOffsetType: Bool {return self._hOffsetType != nil}
  /// Clears the value of `hOffsetType`. Subsequent reads from it will return its default value.
  mutating func clearHOffsetType() {self._hOffsetType = nil}

  var hOffset: Float {
    get {return _hOffset ?? 0}
    set {_hOffset = newValue}
  }
  /// Returns true if `hOffset` has been explicitly set.
  var hasHOffset: Bool {return self._hOffset != nil}
  /// Clears the value of `hOffset`. Subsequent reads from it will return its default value.
  mutating func clearHOffset() {self._hOffset = nil}

  var vOffsetType: UInt32 {
    get {return _vOffsetType ?? 0}
    set {_vOffsetType = newValue}
  }
  /// Returns true if `vOffsetType` has been explicitly set.
  var hasVOffsetType: Bool {return self._vOffsetType != nil}
  /// Clears the value of `vOffsetType`. Subsequent reads from it will return its default value.
  mutating func clearVOffsetType() {self._vOffsetType = nil}

  var vOffset: Float {
    get {return _vOffset ?? 0}
    set {_vOffset = newValue}
  }
  /// Returns true if `vOffset` has been explicitly set.
  var hasVOffset: Bool {return self._vOffset != nil}
  /// Clears the value of `vOffset`. Subsequent reads from it will return its default value.
  mutating func clearVOffset() {self._vOffset = nil}

  var isHtmlWrap: Bool {
    get {return _isHtmlWrap ?? false}
    set {_isHtmlWrap = newValue}
  }
  /// Returns true if `isHtmlWrap` has been explicitly set.
  var hasIsHtmlWrap: Bool {return self._isHtmlWrap != nil}
  /// Clears the value of `isHtmlWrap`. Subsequent reads from it will return its default value.
  mutating func clearIsHtmlWrap() {self._isHtmlWrap = nil}

  var undoHOffsetType: UInt32 {
    get {return _undoHOffsetType ?? 0}
    set {_undoHOffsetType = newValue}
  }
  /// Returns true if `undoHOffsetType` has been explicitly set.
  var hasUndoHOffsetType: Bool {return self._undoHOffsetType != nil}
  /// Clears the value of `undoHOffsetType`. Subsequent reads from it will return its default value.
  mutating func clearUndoHOffsetType() {self._undoHOffsetType = nil}

  var undoHOffset: Float {
    get {return _undoHOffset ?? 0}
    set {_undoHOffset = newValue}
  }
  /// Returns true if `undoHOffset` has been explicitly set.
  var hasUndoHOffset: Bool {return self._undoHOffset != nil}
  /// Clears the value of `undoHOffset`. Subsequent reads from it will return its default value.
  mutating func clearUndoHOffset() {self._undoHOffset = nil}

  var undoVOffsetType: UInt32 {
    get {return _undoVOffsetType ?? 0}
    set {_undoVOffsetType = newValue}
  }
  /// Returns true if `undoVOffsetType` has been explicitly set.
  var hasUndoVOffsetType: Bool {return self._undoVOffsetType != nil}
  /// Clears the value of `undoVOffsetType`. Subsequent reads from it will return its default value.
  mutating func clearUndoVOffsetType() {self._undoVOffsetType = nil}

  var undoVOffset: Float {
    get {return _undoVOffset ?? 0}
    set {_undoVOffset = newValue}
  }
  /// Returns true if `undoVOffset` has been explicitly set.
  var hasUndoVOffset: Bool {return self._undoVOffset != nil}
  /// Clears the value of `undoVOffset`. Subsequent reads from it will return its default value.
  mutating func clearUndoVOffset() {self._undoVOffset = nil}

  var undoIsHtmlWrap: Bool {
    get {return _undoIsHtmlWrap ?? false}
    set {_undoIsHtmlWrap = newValue}
  }
  /// Returns true if `undoIsHtmlWrap` has been explicitly set.
  var hasUndoIsHtmlWrap: Bool {return self._undoIsHtmlWrap != nil}
  /// Clears the value of `undoIsHtmlWrap`. Subsequent reads from it will return its default value.
  mutating func clearUndoIsHtmlWrap() {self._undoIsHtmlWrap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_StorageActionCommandArchive? = nil
  fileprivate var _attachment: TSP_Reference? = nil
  fileprivate var _hOffsetType: UInt32? = nil
  fileprivate var _hOffset: Float? = nil
  fileprivate var _vOffsetType: UInt32? = nil
  fileprivate var _vOffset: Float? = nil
  fileprivate var _isHtmlWrap: Bool? = nil
  fileprivate var _undoHOffsetType: UInt32? = nil
  fileprivate var _undoHOffset: Float? = nil
  fileprivate var _undoVOffsetType: UInt32? = nil
  fileprivate var _undoVOffset: Float? = nil
  fileprivate var _undoIsHtmlWrap: Bool? = nil
}

struct TSWP_TextApplyThemeCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_ApplyThemeChildCommandArchive {
    get {return _storage._super ?? TSS_ApplyThemeChildCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var storage: TSP_Reference {
    get {return _storage._storage ?? TSP_Reference()}
    set {_uniqueStorage()._storage = newValue}
  }
  /// Returns true if `storage` has been explicitly set.
  var hasStorage: Bool {return _storage._storage != nil}
  /// Clears the value of `storage`. Subsequent reads from it will return its default value.
  mutating func clearStorage() {_uniqueStorage()._storage = nil}

  var undoTransaction: TSWP_UndoTransaction {
    get {return _storage._undoTransaction ?? TSWP_UndoTransaction()}
    set {_uniqueStorage()._undoTransaction = newValue}
  }
  /// Returns true if `undoTransaction` has been explicitly set.
  var hasUndoTransaction: Bool {return _storage._undoTransaction != nil}
  /// Clears the value of `undoTransaction`. Subsequent reads from it will return its default value.
  mutating func clearUndoTransaction() {_uniqueStorage()._undoTransaction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_MoveColumnsCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var storage: TSP_Reference {
    get {return _storage._storage ?? TSP_Reference()}
    set {_uniqueStorage()._storage = newValue}
  }
  /// Returns true if `storage` has been explicitly set.
  var hasStorage: Bool {return _storage._storage != nil}
  /// Clears the value of `storage`. Subsequent reads from it will return its default value.
  mutating func clearStorage() {_uniqueStorage()._storage = nil}

  var srcIndex: UInt32 {
    get {return _storage._srcIndex ?? 0}
    set {_uniqueStorage()._srcIndex = newValue}
  }
  /// Returns true if `srcIndex` has been explicitly set.
  var hasSrcIndex: Bool {return _storage._srcIndex != nil}
  /// Clears the value of `srcIndex`. Subsequent reads from it will return its default value.
  mutating func clearSrcIndex() {_uniqueStorage()._srcIndex = nil}

  var dstIndex: UInt32 {
    get {return _storage._dstIndex ?? 0}
    set {_uniqueStorage()._dstIndex = newValue}
  }
  /// Returns true if `dstIndex` has been explicitly set.
  var hasDstIndex: Bool {return _storage._dstIndex != nil}
  /// Clears the value of `dstIndex`. Subsequent reads from it will return its default value.
  mutating func clearDstIndex() {_uniqueStorage()._dstIndex = nil}

  var count: UInt32 {
    get {return _storage._count ?? 0}
    set {_uniqueStorage()._count = newValue}
  }
  /// Returns true if `count` has been explicitly set.
  var hasCount: Bool {return _storage._count != nil}
  /// Clears the value of `count`. Subsequent reads from it will return its default value.
  mutating func clearCount() {_uniqueStorage()._count = nil}

  var undoTransaction: TSWP_UndoTransaction {
    get {return _storage._undoTransaction ?? TSWP_UndoTransaction()}
    set {_uniqueStorage()._undoTransaction = newValue}
  }
  /// Returns true if `undoTransaction` has been explicitly set.
  var hasUndoTransaction: Bool {return _storage._undoTransaction != nil}
  /// Clears the value of `undoTransaction`. Subsequent reads from it will return its default value.
  mutating func clearUndoTransaction() {_uniqueStorage()._undoTransaction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_MoveRowsCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var storage: TSP_Reference {
    get {return _storage._storage ?? TSP_Reference()}
    set {_uniqueStorage()._storage = newValue}
  }
  /// Returns true if `storage` has been explicitly set.
  var hasStorage: Bool {return _storage._storage != nil}
  /// Clears the value of `storage`. Subsequent reads from it will return its default value.
  mutating func clearStorage() {_uniqueStorage()._storage = nil}

  var srcIndex: UInt32 {
    get {return _storage._srcIndex ?? 0}
    set {_uniqueStorage()._srcIndex = newValue}
  }
  /// Returns true if `srcIndex` has been explicitly set.
  var hasSrcIndex: Bool {return _storage._srcIndex != nil}
  /// Clears the value of `srcIndex`. Subsequent reads from it will return its default value.
  mutating func clearSrcIndex() {_uniqueStorage()._srcIndex = nil}

  var dstIndex: UInt32 {
    get {return _storage._dstIndex ?? 0}
    set {_uniqueStorage()._dstIndex = newValue}
  }
  /// Returns true if `dstIndex` has been explicitly set.
  var hasDstIndex: Bool {return _storage._dstIndex != nil}
  /// Clears the value of `dstIndex`. Subsequent reads from it will return its default value.
  mutating func clearDstIndex() {_uniqueStorage()._dstIndex = nil}

  var count: UInt32 {
    get {return _storage._count ?? 0}
    set {_uniqueStorage()._count = newValue}
  }
  /// Returns true if `count` has been explicitly set.
  var hasCount: Bool {return _storage._count != nil}
  /// Clears the value of `count`. Subsequent reads from it will return its default value.
  mutating func clearCount() {_uniqueStorage()._count = nil}

  var undoTransaction: TSWP_UndoTransaction {
    get {return _storage._undoTransaction ?? TSWP_UndoTransaction()}
    set {_uniqueStorage()._undoTransaction = newValue}
  }
  /// Returns true if `undoTransaction` has been explicitly set.
  var hasUndoTransaction: Bool {return _storage._undoTransaction != nil}
  /// Clears the value of `undoTransaction`. Subsequent reads from it will return its default value.
  mutating func clearUndoTransaction() {_uniqueStorage()._undoTransaction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_ShapeApplyPresetCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_BaseApplyPresetCommandArchive {
    get {return _super ?? TSD_BaseApplyPresetCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var undoStyle: TSP_Reference {
    get {return _undoStyle ?? TSP_Reference()}
    set {_undoStyle = newValue}
  }
  /// Returns true if `undoStyle` has been explicitly set.
  var hasUndoStyle: Bool {return self._undoStyle != nil}
  /// Clears the value of `undoStyle`. Subsequent reads from it will return its default value.
  mutating func clearUndoStyle() {self._undoStyle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_BaseApplyPresetCommandArchive? = nil
  fileprivate var _undoStyle: TSP_Reference? = nil
}

struct TSWP_StyleBaseCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var theme: TSP_Reference {
    get {return _storage._theme ?? TSP_Reference()}
    set {_uniqueStorage()._theme = newValue}
  }
  /// Returns true if `theme` has been explicitly set.
  var hasTheme: Bool {return _storage._theme != nil}
  /// Clears the value of `theme`. Subsequent reads from it will return its default value.
  mutating func clearTheme() {_uniqueStorage()._theme = nil}

  var style: TSP_Reference {
    get {return _storage._style ?? TSP_Reference()}
    set {_uniqueStorage()._style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  var hasStyle: Bool {return _storage._style != nil}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  mutating func clearStyle() {_uniqueStorage()._style = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_StyleCreateCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_StyleBaseCommandArchive {
    get {return _super ?? TSWP_StyleBaseCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var presetIndex: UInt32 {
    get {return _presetIndex ?? 0}
    set {_presetIndex = newValue}
  }
  /// Returns true if `presetIndex` has been explicitly set.
  var hasPresetIndex: Bool {return self._presetIndex != nil}
  /// Clears the value of `presetIndex`. Subsequent reads from it will return its default value.
  mutating func clearPresetIndex() {self._presetIndex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_StyleBaseCommandArchive? = nil
  fileprivate var _presetIndex: UInt32? = nil
}

struct TSWP_StyleRenameCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_StyleBaseCommandArchive {
    get {return _super ?? TSWP_StyleBaseCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var updatedName: String {
    get {return _updatedName ?? String()}
    set {_updatedName = newValue}
  }
  /// Returns true if `updatedName` has been explicitly set.
  var hasUpdatedName: Bool {return self._updatedName != nil}
  /// Clears the value of `updatedName`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedName() {self._updatedName = nil}

  var oldName: String {
    get {return _oldName ?? String()}
    set {_oldName = newValue}
  }
  /// Returns true if `oldName` has been explicitly set.
  var hasOldName: Bool {return self._oldName != nil}
  /// Clears the value of `oldName`. Subsequent reads from it will return its default value.
  mutating func clearOldName() {self._oldName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_StyleBaseCommandArchive? = nil
  fileprivate var _updatedName: String? = nil
  fileprivate var _oldName: String? = nil
}

struct TSWP_StyleUpdateCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_StyleBaseCommandArchive {
    get {return _super ?? TSWP_StyleBaseCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var originalStyle: TSP_Reference {
    get {return _originalStyle ?? TSP_Reference()}
    set {_originalStyle = newValue}
  }
  /// Returns true if `originalStyle` has been explicitly set.
  var hasOriginalStyle: Bool {return self._originalStyle != nil}
  /// Clears the value of `originalStyle`. Subsequent reads from it will return its default value.
  mutating func clearOriginalStyle() {self._originalStyle = nil}

  var updatedStyle: TSP_Reference {
    get {return _updatedStyle ?? TSP_Reference()}
    set {_updatedStyle = newValue}
  }
  /// Returns true if `updatedStyle` has been explicitly set.
  var hasUpdatedStyle: Bool {return self._updatedStyle != nil}
  /// Clears the value of `updatedStyle`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedStyle() {self._updatedStyle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_StyleBaseCommandArchive? = nil
  fileprivate var _originalStyle: TSP_Reference? = nil
  fileprivate var _updatedStyle: TSP_Reference? = nil
}

struct TSWP_StyleDeleteCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_StyleBaseCommandArchive {
    get {return _super ?? TSWP_StyleBaseCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var oldPresetIndex: UInt32 {
    get {return _oldPresetIndex ?? 0}
    set {_oldPresetIndex = newValue}
  }
  /// Returns true if `oldPresetIndex` has been explicitly set.
  var hasOldPresetIndex: Bool {return self._oldPresetIndex != nil}
  /// Clears the value of `oldPresetIndex`. Subsequent reads from it will return its default value.
  mutating func clearOldPresetIndex() {self._oldPresetIndex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_StyleBaseCommandArchive? = nil
  fileprivate var _oldPresetIndex: UInt32? = nil
}

struct TSWP_StyleReorderCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_StyleBaseCommandArchive {
    get {return _super ?? TSWP_StyleBaseCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var oldPresetIndex: UInt32 {
    get {return _oldPresetIndex ?? 0}
    set {_oldPresetIndex = newValue}
  }
  /// Returns true if `oldPresetIndex` has been explicitly set.
  var hasOldPresetIndex: Bool {return self._oldPresetIndex != nil}
  /// Clears the value of `oldPresetIndex`. Subsequent reads from it will return its default value.
  mutating func clearOldPresetIndex() {self._oldPresetIndex = nil}

  var newPresetIndex: UInt32 {
    get {return _newPresetIndex ?? 0}
    set {_newPresetIndex = newValue}
  }
  /// Returns true if `newPresetIndex` has been explicitly set.
  var hasNewPresetIndex: Bool {return self._newPresetIndex != nil}
  /// Clears the value of `newPresetIndex`. Subsequent reads from it will return its default value.
  mutating func clearNewPresetIndex() {self._newPresetIndex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_StyleBaseCommandArchive? = nil
  fileprivate var _oldPresetIndex: UInt32? = nil
  fileprivate var _newPresetIndex: UInt32? = nil
}

struct TSWP_StyleUpdatePropertyMapCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_StyleUpdatePropertyMapCommandArchive {
    get {return _super ?? TSS_StyleUpdatePropertyMapCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSS_StyleUpdatePropertyMapCommandArchive? = nil
}

struct TSWP_ShapeStyleSetValueCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_BaseStyleSetValueCommandArchive {
    get {return _storage._super ?? TSD_BaseStyleSetValueCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var change: TSWPSOS_ShapeStylePropertyChangeSetArchive {
    get {return _storage._change ?? TSWPSOS_ShapeStylePropertyChangeSetArchive()}
    set {_uniqueStorage()._change = newValue}
  }
  /// Returns true if `change` has been explicitly set.
  var hasChange: Bool {return _storage._change != nil}
  /// Clears the value of `change`. Subsequent reads from it will return its default value.
  mutating func clearChange() {_uniqueStorage()._change = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_SelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var storageUuidPath: TSP_UUIDPath {
    get {return _storageUuidPath ?? TSP_UUIDPath()}
    set {_storageUuidPath = newValue}
  }
  /// Returns true if `storageUuidPath` has been explicitly set.
  var hasStorageUuidPath: Bool {return self._storageUuidPath != nil}
  /// Clears the value of `storageUuidPath`. Subsequent reads from it will return its default value.
  mutating func clearStorageUuidPath() {self._storageUuidPath = nil}

  var selection: TSP_Reference {
    get {return _selection ?? TSP_Reference()}
    set {_selection = newValue}
  }
  /// Returns true if `selection` has been explicitly set.
  var hasSelection: Bool {return self._selection != nil}
  /// Clears the value of `selection`. Subsequent reads from it will return its default value.
  mutating func clearSelection() {self._selection = nil}

  var transformedToNoop: Bool {
    get {return _transformedToNoop ?? false}
    set {_transformedToNoop = newValue}
  }
  /// Returns true if `transformedToNoop` has been explicitly set.
  var hasTransformedToNoop: Bool {return self._transformedToNoop != nil}
  /// Clears the value of `transformedToNoop`. Subsequent reads from it will return its default value.
  mutating func clearTransformedToNoop() {self._transformedToNoop = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storageUuidPath: TSP_UUIDPath? = nil
  fileprivate var _selection: TSP_Reference? = nil
  fileprivate var _transformedToNoop: Bool? = nil
}

struct TSWP_PencilAnnotationSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var storageUuidPath: TSP_UUIDPath {
    get {return _storageUuidPath ?? TSP_UUIDPath()}
    set {_storageUuidPath = newValue}
  }
  /// Returns true if `storageUuidPath` has been explicitly set.
  var hasStorageUuidPath: Bool {return self._storageUuidPath != nil}
  /// Clears the value of `storageUuidPath`. Subsequent reads from it will return its default value.
  mutating func clearStorageUuidPath() {self._storageUuidPath = nil}

  var textPencilAnnotationUuid: String {
    get {return _textPencilAnnotationUuid ?? String()}
    set {_textPencilAnnotationUuid = newValue}
  }
  /// Returns true if `textPencilAnnotationUuid` has been explicitly set.
  var hasTextPencilAnnotationUuid: Bool {return self._textPencilAnnotationUuid != nil}
  /// Clears the value of `textPencilAnnotationUuid`. Subsequent reads from it will return its default value.
  mutating func clearTextPencilAnnotationUuid() {self._textPencilAnnotationUuid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storageUuidPath: TSP_UUIDPath? = nil
  fileprivate var _textPencilAnnotationUuid: String? = nil
}

struct TSWP_ShapeSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_ShapeSelectionTransformerArchive {
    get {return _super ?? TSD_ShapeSelectionTransformerArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var storageUuidPath: TSP_UUIDPath {
    get {return _storageUuidPath ?? TSP_UUIDPath()}
    set {_storageUuidPath = newValue}
  }
  /// Returns true if `storageUuidPath` has been explicitly set.
  var hasStorageUuidPath: Bool {return self._storageUuidPath != nil}
  /// Clears the value of `storageUuidPath`. Subsequent reads from it will return its default value.
  mutating func clearStorageUuidPath() {self._storageUuidPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_ShapeSelectionTransformerArchive? = nil
  fileprivate var _storageUuidPath: TSP_UUIDPath? = nil
}

struct TSWP_ShapeContentDescription: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_DrawableContentDescription {
    get {return _super ?? TSD_DrawableContentDescription()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var textRangeLocation: UInt32 {
    get {return _textRangeLocation ?? 0}
    set {_textRangeLocation = newValue}
  }
  /// Returns true if `textRangeLocation` has been explicitly set.
  var hasTextRangeLocation: Bool {return self._textRangeLocation != nil}
  /// Clears the value of `textRangeLocation`. Subsequent reads from it will return its default value.
  mutating func clearTextRangeLocation() {self._textRangeLocation = nil}

  var textRangeLength: UInt32 {
    get {return _textRangeLength ?? 0}
    set {_textRangeLength = newValue}
  }
  /// Returns true if `textRangeLength` has been explicitly set.
  var hasTextRangeLength: Bool {return self._textRangeLength != nil}
  /// Clears the value of `textRangeLength`. Subsequent reads from it will return its default value.
  mutating func clearTextRangeLength() {self._textRangeLength = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_DrawableContentDescription? = nil
  fileprivate var _textRangeLocation: UInt32? = nil
  fileprivate var _textRangeLength: UInt32? = nil
}

struct TSWP_ObjectPropertyArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  var type: TSWP_ObjectPropertyType {
    get {return _storage._type ?? .kObjectPropertyTypeBool}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  var boolValue: Bool {
    get {return _storage._boolValue ?? false}
    set {_uniqueStorage()._boolValue = newValue}
  }
  /// Returns true if `boolValue` has been explicitly set.
  var hasBoolValue: Bool {return _storage._boolValue != nil}
  /// Clears the value of `boolValue`. Subsequent reads from it will return its default value.
  mutating func clearBoolValue() {_uniqueStorage()._boolValue = nil}

  var floatValue: Float {
    get {return _storage._floatValue ?? 0}
    set {_uniqueStorage()._floatValue = newValue}
  }
  /// Returns true if `floatValue` has been explicitly set.
  var hasFloatValue: Bool {return _storage._floatValue != nil}
  /// Clears the value of `floatValue`. Subsequent reads from it will return its default value.
  mutating func clearFloatValue() {_uniqueStorage()._floatValue = nil}

  var integerValue: Int32 {
    get {return _storage._integerValue ?? 0}
    set {_uniqueStorage()._integerValue = newValue}
  }
  /// Returns true if `integerValue` has been explicitly set.
  var hasIntegerValue: Bool {return _storage._integerValue != nil}
  /// Clears the value of `integerValue`. Subsequent reads from it will return its default value.
  mutating func clearIntegerValue() {_uniqueStorage()._integerValue = nil}

  var stringValue: String {
    get {return _storage._stringValue ?? String()}
    set {_uniqueStorage()._stringValue = newValue}
  }
  /// Returns true if `stringValue` has been explicitly set.
  var hasStringValue: Bool {return _storage._stringValue != nil}
  /// Clears the value of `stringValue`. Subsequent reads from it will return its default value.
  mutating func clearStringValue() {_uniqueStorage()._stringValue = nil}

  var idPathValue: TSP_UUIDPath {
    get {return _storage._idPathValue ?? TSP_UUIDPath()}
    set {_uniqueStorage()._idPathValue = newValue}
  }
  /// Returns true if `idPathValue` has been explicitly set.
  var hasIDPathValue: Bool {return _storage._idPathValue != nil}
  /// Clears the value of `idPathValue`. Subsequent reads from it will return its default value.
  mutating func clearIDPathValue() {_uniqueStorage()._idPathValue = nil}

  var fillValue: TSD_FillArchive {
    get {return _storage._fillValue ?? TSD_FillArchive()}
    set {_uniqueStorage()._fillValue = newValue}
  }
  /// Returns true if `fillValue` has been explicitly set.
  var hasFillValue: Bool {return _storage._fillValue != nil}
  /// Clears the value of `fillValue`. Subsequent reads from it will return its default value.
  mutating func clearFillValue() {_uniqueStorage()._fillValue = nil}

  var colorValue: TSP_Color {
    get {return _storage._colorValue ?? TSP_Color()}
    set {_uniqueStorage()._colorValue = newValue}
  }
  /// Returns true if `colorValue` has been explicitly set.
  var hasColorValue: Bool {return _storage._colorValue != nil}
  /// Clears the value of `colorValue`. Subsequent reads from it will return its default value.
  mutating func clearColorValue() {_uniqueStorage()._colorValue = nil}

  var shadowValue: TSD_ShadowArchive {
    get {return _storage._shadowValue ?? TSD_ShadowArchive()}
    set {_uniqueStorage()._shadowValue = newValue}
  }
  /// Returns true if `shadowValue` has been explicitly set.
  var hasShadowValue: Bool {return _storage._shadowValue != nil}
  /// Clears the value of `shadowValue`. Subsequent reads from it will return its default value.
  mutating func clearShadowValue() {_uniqueStorage()._shadowValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_SetObjectPropertiesCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var objectUuidPath: TSP_UUIDPath {
    get {return _objectUuidPath ?? TSP_UUIDPath()}
    set {_objectUuidPath = newValue}
  }
  /// Returns true if `objectUuidPath` has been explicitly set.
  var hasObjectUuidPath: Bool {return self._objectUuidPath != nil}
  /// Clears the value of `objectUuidPath`. Subsequent reads from it will return its default value.
  mutating func clearObjectUuidPath() {self._objectUuidPath = nil}

  var properties: [TSWP_ObjectPropertyArchive] = []

  var actionString: String {
    get {return _actionString ?? String()}
    set {_actionString = newValue}
  }
  /// Returns true if `actionString` has been explicitly set.
  var hasActionString: Bool {return self._actionString != nil}
  /// Clears the value of `actionString`. Subsequent reads from it will return its default value.
  mutating func clearActionString() {self._actionString = nil}

  var oldProperties: [TSWP_ObjectPropertyArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _objectUuidPath: TSP_UUIDPath? = nil
  fileprivate var _actionString: String? = nil
}

struct TSWP_UpdateFlowInfoCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var commandMode: TSWP_UpdateFlowInfoCommandArchive.Mode {
    get {return _storage._commandMode ?? .kModeRearrange}
    set {_uniqueStorage()._commandMode = newValue}
  }
  /// Returns true if `commandMode` has been explicitly set.
  var hasCommandMode: Bool {return _storage._commandMode != nil}
  /// Clears the value of `commandMode`. Subsequent reads from it will return its default value.
  mutating func clearCommandMode() {_uniqueStorage()._commandMode = nil}

  var flowInfoUuidPath: TSP_UUIDPath {
    get {return _storage._flowInfoUuidPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._flowInfoUuidPath = newValue}
  }
  /// Returns true if `flowInfoUuidPath` has been explicitly set.
  var hasFlowInfoUuidPath: Bool {return _storage._flowInfoUuidPath != nil}
  /// Clears the value of `flowInfoUuidPath`. Subsequent reads from it will return its default value.
  mutating func clearFlowInfoUuidPath() {_uniqueStorage()._flowInfoUuidPath = nil}

  var textBoxIDPathToAddOrRemove: TSP_UUIDPath {
    get {return _storage._textBoxIDPathToAddOrRemove ?? TSP_UUIDPath()}
    set {_uniqueStorage()._textBoxIDPathToAddOrRemove = newValue}
  }
  /// Returns true if `textBoxIDPathToAddOrRemove` has been explicitly set.
  var hasTextBoxIDPathToAddOrRemove: Bool {return _storage._textBoxIDPathToAddOrRemove != nil}
  /// Clears the value of `textBoxIDPathToAddOrRemove`. Subsequent reads from it will return its default value.
  mutating func clearTextBoxIDPathToAddOrRemove() {_uniqueStorage()._textBoxIDPathToAddOrRemove = nil}

  var textBoxIDPathsAtStart: [TSP_UUIDPath] {
    get {return _storage._textBoxIDPathsAtStart}
    set {_uniqueStorage()._textBoxIDPathsAtStart = newValue}
  }

  var suggestedTextBoxIDPathsAtEnd: [TSP_UUIDPath] {
    get {return _storage._suggestedTextBoxIDPathsAtEnd}
    set {_uniqueStorage()._suggestedTextBoxIDPathsAtEnd = newValue}
  }

  var undoTextBoxesToRestore: [TSP_Reference] {
    get {return _storage._undoTextBoxesToRestore}
    set {_uniqueStorage()._undoTextBoxesToRestore = newValue}
  }

  var undoAddedShapeInfo: TSP_Reference {
    get {return _storage._undoAddedShapeInfo ?? TSP_Reference()}
    set {_uniqueStorage()._undoAddedShapeInfo = newValue}
  }
  /// Returns true if `undoAddedShapeInfo` has been explicitly set.
  var hasUndoAddedShapeInfo: Bool {return _storage._undoAddedShapeInfo != nil}
  /// Clears the value of `undoAddedShapeInfo`. Subsequent reads from it will return its default value.
  mutating func clearUndoAddedShapeInfo() {_uniqueStorage()._undoAddedShapeInfo = nil}

  var undoRemovedShapeInfo: TSP_Reference {
    get {return _storage._undoRemovedShapeInfo ?? TSP_Reference()}
    set {_uniqueStorage()._undoRemovedShapeInfo = newValue}
  }
  /// Returns true if `undoRemovedShapeInfo` has been explicitly set.
  var hasUndoRemovedShapeInfo: Bool {return _storage._undoRemovedShapeInfo != nil}
  /// Clears the value of `undoRemovedShapeInfo`. Subsequent reads from it will return its default value.
  mutating func clearUndoRemovedShapeInfo() {_uniqueStorage()._undoRemovedShapeInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Mode: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kModeRearrange = 0
    case kModeAdd = 1
    case kModeRemove = 2
    case kModeCompensate = 3

    init() {
      self = .kModeRearrange
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_AddFlowInfoCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var flowInfoToAdd: TSP_Reference {
    get {return _storage._flowInfoToAdd ?? TSP_Reference()}
    set {_uniqueStorage()._flowInfoToAdd = newValue}
  }
  /// Returns true if `flowInfoToAdd` has been explicitly set.
  var hasFlowInfoToAdd: Bool {return _storage._flowInfoToAdd != nil}
  /// Clears the value of `flowInfoToAdd`. Subsequent reads from it will return its default value.
  mutating func clearFlowInfoToAdd() {_uniqueStorage()._flowInfoToAdd = nil}

  var flowInfoArchive: TSP_Reference {
    get {return _storage._flowInfoArchive ?? TSP_Reference()}
    set {_uniqueStorage()._flowInfoArchive = newValue}
  }
  /// Returns true if `flowInfoArchive` has been explicitly set.
  var hasFlowInfoArchive: Bool {return _storage._flowInfoArchive != nil}
  /// Clears the value of `flowInfoArchive`. Subsequent reads from it will return its default value.
  mutating func clearFlowInfoArchive() {_uniqueStorage()._flowInfoArchive = nil}

  var undoUserInterfaceIdentifierToRestore: UInt32 {
    get {return _storage._undoUserInterfaceIdentifierToRestore ?? 0}
    set {_uniqueStorage()._undoUserInterfaceIdentifierToRestore = newValue}
  }
  /// Returns true if `undoUserInterfaceIdentifierToRestore` has been explicitly set.
  var hasUndoUserInterfaceIdentifierToRestore: Bool {return _storage._undoUserInterfaceIdentifierToRestore != nil}
  /// Clears the value of `undoUserInterfaceIdentifierToRestore`. Subsequent reads from it will return its default value.
  mutating func clearUndoUserInterfaceIdentifierToRestore() {_uniqueStorage()._undoUserInterfaceIdentifierToRestore = nil}

  var undoNextUserInterfaceIdentifierToRestore: UInt32 {
    get {return _storage._undoNextUserInterfaceIdentifierToRestore ?? 0}
    set {_uniqueStorage()._undoNextUserInterfaceIdentifierToRestore = newValue}
  }
  /// Returns true if `undoNextUserInterfaceIdentifierToRestore` has been explicitly set.
  var hasUndoNextUserInterfaceIdentifierToRestore: Bool {return _storage._undoNextUserInterfaceIdentifierToRestore != nil}
  /// Clears the value of `undoNextUserInterfaceIdentifierToRestore`. Subsequent reads from it will return its default value.
  mutating func clearUndoNextUserInterfaceIdentifierToRestore() {_uniqueStorage()._undoNextUserInterfaceIdentifierToRestore = nil}

  var workingUndoObject: TSP_Reference {
    get {return _storage._workingUndoObject ?? TSP_Reference()}
    set {_uniqueStorage()._workingUndoObject = newValue}
  }
  /// Returns true if `workingUndoObject` has been explicitly set.
  var hasWorkingUndoObject: Bool {return _storage._workingUndoObject != nil}
  /// Clears the value of `workingUndoObject`. Subsequent reads from it will return its default value.
  mutating func clearWorkingUndoObject() {_uniqueStorage()._workingUndoObject = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_RemoveFlowInfoCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var flowInfoUuidPath: TSP_UUIDPath {
    get {return _storage._flowInfoUuidPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._flowInfoUuidPath = newValue}
  }
  /// Returns true if `flowInfoUuidPath` has been explicitly set.
  var hasFlowInfoUuidPath: Bool {return _storage._flowInfoUuidPath != nil}
  /// Clears the value of `flowInfoUuidPath`. Subsequent reads from it will return its default value.
  mutating func clearFlowInfoUuidPath() {_uniqueStorage()._flowInfoUuidPath = nil}

  var undoObject: TSP_Reference {
    get {return _storage._undoObject ?? TSP_Reference()}
    set {_uniqueStorage()._undoObject = newValue}
  }
  /// Returns true if `undoObject` has been explicitly set.
  var hasUndoObject: Bool {return _storage._undoObject != nil}
  /// Clears the value of `undoObject`. Subsequent reads from it will return its default value.
  mutating func clearUndoObject() {_uniqueStorage()._undoObject = nil}

  var undoUserInterfaceIdentifierToRestore: UInt32 {
    get {return _storage._undoUserInterfaceIdentifierToRestore ?? 0}
    set {_uniqueStorage()._undoUserInterfaceIdentifierToRestore = newValue}
  }
  /// Returns true if `undoUserInterfaceIdentifierToRestore` has been explicitly set.
  var hasUndoUserInterfaceIdentifierToRestore: Bool {return _storage._undoUserInterfaceIdentifierToRestore != nil}
  /// Clears the value of `undoUserInterfaceIdentifierToRestore`. Subsequent reads from it will return its default value.
  mutating func clearUndoUserInterfaceIdentifierToRestore() {_uniqueStorage()._undoUserInterfaceIdentifierToRestore = nil}

  var undoNextUserInterfaceIdentifierToRestore: UInt32 {
    get {return _storage._undoNextUserInterfaceIdentifierToRestore ?? 0}
    set {_uniqueStorage()._undoNextUserInterfaceIdentifierToRestore = newValue}
  }
  /// Returns true if `undoNextUserInterfaceIdentifierToRestore` has been explicitly set.
  var hasUndoNextUserInterfaceIdentifierToRestore: Bool {return _storage._undoNextUserInterfaceIdentifierToRestore != nil}
  /// Clears the value of `undoNextUserInterfaceIdentifierToRestore`. Subsequent reads from it will return its default value.
  mutating func clearUndoNextUserInterfaceIdentifierToRestore() {_uniqueStorage()._undoNextUserInterfaceIdentifierToRestore = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_TextCommentReplyCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var storageUuidPath: TSP_UUIDPath {
    get {return _storage._storageUuidPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._storageUuidPath = newValue}
  }
  /// Returns true if `storageUuidPath` has been explicitly set.
  var hasStorageUuidPath: Bool {return _storage._storageUuidPath != nil}
  /// Clears the value of `storageUuidPath`. Subsequent reads from it will return its default value.
  mutating func clearStorageUuidPath() {_uniqueStorage()._storageUuidPath = nil}

  var annotationUuid: String {
    get {return _storage._annotationUuid ?? String()}
    set {_uniqueStorage()._annotationUuid = newValue}
  }
  /// Returns true if `annotationUuid` has been explicitly set.
  var hasAnnotationUuid: Bool {return _storage._annotationUuid != nil}
  /// Clears the value of `annotationUuid`. Subsequent reads from it will return its default value.
  mutating func clearAnnotationUuid() {_uniqueStorage()._annotationUuid = nil}

  var forwardComment: TSP_Reference {
    get {return _storage._forwardComment ?? TSP_Reference()}
    set {_uniqueStorage()._forwardComment = newValue}
  }
  /// Returns true if `forwardComment` has been explicitly set.
  var hasForwardComment: Bool {return _storage._forwardComment != nil}
  /// Clears the value of `forwardComment`. Subsequent reads from it will return its default value.
  mutating func clearForwardComment() {_uniqueStorage()._forwardComment = nil}

  var inverseComment: TSP_Reference {
    get {return _storage._inverseComment ?? TSP_Reference()}
    set {_uniqueStorage()._inverseComment = newValue}
  }
  /// Returns true if `inverseComment` has been explicitly set.
  var hasInverseComment: Bool {return _storage._inverseComment != nil}
  /// Clears the value of `inverseComment`. Subsequent reads from it will return its default value.
  mutating func clearInverseComment() {_uniqueStorage()._inverseComment = nil}

  var forwardVariant: TSD_CommentCommandVariant {
    get {return _storage._forwardVariant ?? .baseComment}
    set {_uniqueStorage()._forwardVariant = newValue}
  }
  /// Returns true if `forwardVariant` has been explicitly set.
  var hasForwardVariant: Bool {return _storage._forwardVariant != nil}
  /// Clears the value of `forwardVariant`. Subsequent reads from it will return its default value.
  mutating func clearForwardVariant() {_uniqueStorage()._forwardVariant = nil}

  var inverseVariant: TSD_CommentCommandVariant {
    get {return _storage._inverseVariant ?? .baseComment}
    set {_uniqueStorage()._inverseVariant = newValue}
  }
  /// Returns true if `inverseVariant` has been explicitly set.
  var hasInverseVariant: Bool {return _storage._inverseVariant != nil}
  /// Clears the value of `inverseVariant`. Subsequent reads from it will return its default value.
  mutating func clearInverseVariant() {_uniqueStorage()._inverseVariant = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_ContainedObjectsCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var target: TSP_Reference {
    get {return _storage._target ?? TSP_Reference()}
    set {_uniqueStorage()._target = newValue}
  }
  /// Returns true if `target` has been explicitly set.
  var hasTarget: Bool {return _storage._target != nil}
  /// Clears the value of `target`. Subsequent reads from it will return its default value.
  mutating func clearTarget() {_uniqueStorage()._target = nil}

  var objects: [TSP_Reference] {
    get {return _storage._objects}
    set {_uniqueStorage()._objects = newValue}
  }

  var undoObjectForCommit: TSP_Reference {
    get {return _storage._undoObjectForCommit ?? TSP_Reference()}
    set {_uniqueStorage()._undoObjectForCommit = newValue}
  }
  /// Returns true if `undoObjectForCommit` has been explicitly set.
  var hasUndoObjectForCommit: Bool {return _storage._undoObjectForCommit != nil}
  /// Clears the value of `undoObjectForCommit`. Subsequent reads from it will return its default value.
  mutating func clearUndoObjectForCommit() {_uniqueStorage()._undoObjectForCommit = nil}

  var undoObjectForMakeInverse: TSP_Reference {
    get {return _storage._undoObjectForMakeInverse ?? TSP_Reference()}
    set {_uniqueStorage()._undoObjectForMakeInverse = newValue}
  }
  /// Returns true if `undoObjectForMakeInverse` has been explicitly set.
  var hasUndoObjectForMakeInverse: Bool {return _storage._undoObjectForMakeInverse != nil}
  /// Clears the value of `undoObjectForMakeInverse`. Subsequent reads from it will return its default value.
  mutating func clearUndoObjectForMakeInverse() {_uniqueStorage()._undoObjectForMakeInverse = nil}

  var addBehaviorArgs: TSWP_ContainedObjectsCommandArchive.AddBehaviorArgs {
    get {return _storage._addBehaviorArgs ?? TSWP_ContainedObjectsCommandArchive.AddBehaviorArgs()}
    set {_uniqueStorage()._addBehaviorArgs = newValue}
  }
  /// Returns true if `addBehaviorArgs` has been explicitly set.
  var hasAddBehaviorArgs: Bool {return _storage._addBehaviorArgs != nil}
  /// Clears the value of `addBehaviorArgs`. Subsequent reads from it will return its default value.
  mutating func clearAddBehaviorArgs() {_uniqueStorage()._addBehaviorArgs = nil}

  var removeBehaviorArgs: TSWP_ContainedObjectsCommandArchive.RemoveBehaviorArgs {
    get {return _storage._removeBehaviorArgs ?? TSWP_ContainedObjectsCommandArchive.RemoveBehaviorArgs()}
    set {_uniqueStorage()._removeBehaviorArgs = newValue}
  }
  /// Returns true if `removeBehaviorArgs` has been explicitly set.
  var hasRemoveBehaviorArgs: Bool {return _storage._removeBehaviorArgs != nil}
  /// Clears the value of `removeBehaviorArgs`. Subsequent reads from it will return its default value.
  mutating func clearRemoveBehaviorArgs() {_uniqueStorage()._removeBehaviorArgs = nil}

  var rearrangeBehaviorArgs: TSWP_ContainedObjectsCommandArchive.RearrangeBehaviorArgs {
    get {return _storage._rearrangeBehaviorArgs ?? TSWP_ContainedObjectsCommandArchive.RearrangeBehaviorArgs()}
    set {_uniqueStorage()._rearrangeBehaviorArgs = newValue}
  }
  /// Returns true if `rearrangeBehaviorArgs` has been explicitly set.
  var hasRearrangeBehaviorArgs: Bool {return _storage._rearrangeBehaviorArgs != nil}
  /// Clears the value of `rearrangeBehaviorArgs`. Subsequent reads from it will return its default value.
  mutating func clearRearrangeBehaviorArgs() {_uniqueStorage()._rearrangeBehaviorArgs = nil}

  var containerName: String {
    get {return _storage._containerName ?? String()}
    set {_uniqueStorage()._containerName = newValue}
  }
  /// Returns true if `containerName` has been explicitly set.
  var hasContainerName: Bool {return _storage._containerName != nil}
  /// Clears the value of `containerName`. Subsequent reads from it will return its default value.
  mutating func clearContainerName() {_uniqueStorage()._containerName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct AddBehaviorArgs: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var argsList: [TSCK_AddIdOperationArgs] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct RemoveBehaviorArgs: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var argsList: [TSCK_RemoveIdOperationArgs] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct RearrangeBehaviorArgs: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var argsList: [TSCK_RearrangeIdOperationArgs] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_EquationInfoGeometryCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_MediaInfoGeometryCommandArchive {
    get {return _super ?? TSD_MediaInfoGeometryCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_MediaInfoGeometryCommandArchive? = nil
}

struct TSWP_CharacterStyleChangePropertyCommand_GArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_StorageActionCommandArchive {
    get {return _super ?? TSWP_StorageActionCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var rangeList: [TSP_Range] = []

  var rangeListUndefined: Bool {
    get {return _rangeListUndefined ?? false}
    set {_rangeListUndefined = newValue}
  }
  /// Returns true if `rangeListUndefined` has been explicitly set.
  var hasRangeListUndefined: Bool {return self._rangeListUndefined != nil}
  /// Clears the value of `rangeListUndefined`. Subsequent reads from it will return its default value.
  mutating func clearRangeListUndefined() {self._rangeListUndefined = nil}

  var changeList: [TSWPSOS_CharacterStylePropertyChangeSetArchive] = []

  var changeListUndefined: Bool {
    get {return _changeListUndefined ?? false}
    set {_changeListUndefined = newValue}
  }
  /// Returns true if `changeListUndefined` has been explicitly set.
  var hasChangeListUndefined: Bool {return self._changeListUndefined != nil}
  /// Clears the value of `changeListUndefined`. Subsequent reads from it will return its default value.
  mutating func clearChangeListUndefined() {self._changeListUndefined = nil}

  var disableCharacterStylePromotion: Bool {
    get {return _disableCharacterStylePromotion ?? false}
    set {_disableCharacterStylePromotion = newValue}
  }
  /// Returns true if `disableCharacterStylePromotion` has been explicitly set.
  var hasDisableCharacterStylePromotion: Bool {return self._disableCharacterStylePromotion != nil}
  /// Clears the value of `disableCharacterStylePromotion`. Subsequent reads from it will return its default value.
  mutating func clearDisableCharacterStylePromotion() {self._disableCharacterStylePromotion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_StorageActionCommandArchive? = nil
  fileprivate var _rangeListUndefined: Bool? = nil
  fileprivate var _changeListUndefined: Bool? = nil
  fileprivate var _disableCharacterStylePromotion: Bool? = nil
}

struct TSWP_ParagraphStyleChangePropertyCommand_GArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_StorageActionCommandArchive {
    get {return _super ?? TSWP_StorageActionCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var rangeList: [TSP_Range] = []

  var rangeListUndefined: Bool {
    get {return _rangeListUndefined ?? false}
    set {_rangeListUndefined = newValue}
  }
  /// Returns true if `rangeListUndefined` has been explicitly set.
  var hasRangeListUndefined: Bool {return self._rangeListUndefined != nil}
  /// Clears the value of `rangeListUndefined`. Subsequent reads from it will return its default value.
  mutating func clearRangeListUndefined() {self._rangeListUndefined = nil}

  var changeList: [TSWPSOS_ParagraphStylePropertyChangeSetArchive] = []

  var changeListUndefined: Bool {
    get {return _changeListUndefined ?? false}
    set {_changeListUndefined = newValue}
  }
  /// Returns true if `changeListUndefined` has been explicitly set.
  var hasChangeListUndefined: Bool {return self._changeListUndefined != nil}
  /// Clears the value of `changeListUndefined`. Subsequent reads from it will return its default value.
  mutating func clearChangeListUndefined() {self._changeListUndefined = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_StorageActionCommandArchive? = nil
  fileprivate var _rangeListUndefined: Bool? = nil
  fileprivate var _changeListUndefined: Bool? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TSWP"

extension TSWP_ObjectPropertyType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kObjectPropertyTypeBool\0\u{1}kObjectPropertyTypeFloat\0\u{1}kObjectPropertyTypeInteger\0\u{1}kObjectPropertyTypeString\0\u{1}kObjectPropertyTypeIdPath\0\u{1}kObjectPropertyTypeFill\0\u{1}kObjectPropertyTypeColor\0\u{1}kObjectPropertyTypeShadow\0")
}

extension TSWP_DummyCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DummyCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}foo\0")

  public var isInitialized: Bool {
    if self._foo == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._foo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._foo {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_DummyCommandArchive, rhs: TSWP_DummyCommandArchive) -> Bool {
    if lhs._foo != rhs._foo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_TextCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TextCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}storage\0\u{3}undo_transaction\0\u{3}restore_range_location\0\u{3}restore_range_length\0\u{3}redo_restore_range_location\0\u{3}redo_restore_range_length\0\u{4}\u{2}text_command_flags\0\u{1}kind\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _storage: TSP_Reference? = nil
    var _undoTransaction: TSWP_UndoTransaction? = nil
    var _restoreRangeLocation: UInt32? = nil
    var _restoreRangeLength: UInt32? = nil
    var _redoRestoreRangeLocation: UInt32? = nil
    var _redoRestoreRangeLength: UInt32? = nil
    var _textCommandFlags: UInt32? = nil
    var _kind: TSWP_TextCommandArchive.Kind? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _storage = source._storage
      _undoTransaction = source._undoTransaction
      _restoreRangeLocation = source._restoreRangeLocation
      _restoreRangeLength = source._restoreRangeLength
      _redoRestoreRangeLocation = source._redoRestoreRangeLocation
      _redoRestoreRangeLength = source._redoRestoreRangeLength
      _textCommandFlags = source._textCommandFlags
      _kind = source._kind
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._storage, !v.isInitialized {return false}
      if let v = _storage._undoTransaction, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._storage) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._undoTransaction) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._restoreRangeLocation) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._restoreRangeLength) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._redoRestoreRangeLocation) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._redoRestoreRangeLength) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._textCommandFlags) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._kind) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._storage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._undoTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._restoreRangeLocation {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._restoreRangeLength {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._redoRestoreRangeLocation {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._redoRestoreRangeLength {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._textCommandFlags {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._kind {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_TextCommandArchive, rhs: TSWP_TextCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._storage != rhs_storage._storage {return false}
        if _storage._undoTransaction != rhs_storage._undoTransaction {return false}
        if _storage._restoreRangeLocation != rhs_storage._restoreRangeLocation {return false}
        if _storage._restoreRangeLength != rhs_storage._restoreRangeLength {return false}
        if _storage._redoRestoreRangeLocation != rhs_storage._redoRestoreRangeLocation {return false}
        if _storage._redoRestoreRangeLength != rhs_storage._redoRestoreRangeLength {return false}
        if _storage._textCommandFlags != rhs_storage._textCommandFlags {return false}
        if _storage._kind != rhs_storage._kind {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_TextCommandArchive.Kind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kKindContained\0\u{1}kKindReplaceText\0\u{1}kKindPaste\0\u{1}kKindParagraphStyle\0\u{1}kKindListStyle\0\u{1}kKindIndentParagraphLevel\0\u{1}kKindDragText\0\u{1}kKindPasteStyle\0\u{1}kKindApplyChangesInRange\0\u{2}\u{2}kKindInsertCitationField\0\u{1}kKindInsertBibliographyEntry\0\u{1}kKindFormatCitationFields\0\u{1}kKindInsertTOCSmartField\0\u{1}kKindInsertDateTimeField_DEPRECATED\0\u{1}kKindUpdateDateTimeField\0\u{1}kKindSetParagraphFirstTopicNumber\0\u{1}kKindCharacterStyle\0\u{1}kKindRevertStyles_DEPRECATED\0\u{1}kKindSetParagraphBidi\0")
}

extension TSWP_StorageActionCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StorageActionCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}storage\0\u{3}undo_transaction\0\u{3}text_command_flags\0\u{1}kind\0\u{3}custom_format_keys\0\u{3}is_forward_inverse_command\0\u{1}coalesceable\0\u{3}coalescing_text\0\u{3}should_migrate_styles\0\u{3}changed_data_reference_record\0\u{3}coalescing_property\0\u{3}wp_kind\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _storage: TSP_UUIDPath? = nil
    var _undoTransaction: TSWP_UndoTransaction? = nil
    var _textCommandFlags: UInt32? = nil
    var _kind: TSWP_StorageActionCommandArchive.Kind? = nil
    var _customFormatKeys: [TSP_UUID] = []
    var _isForwardInverseCommand: Bool? = nil
    var _coalesceable: Bool? = nil
    var _coalescingText: Bool? = nil
    var _shouldMigrateStyles: Bool? = nil
    var _changedDataReferenceRecord: TSK_DataReferenceRecord? = nil
    var _coalescingProperty: String? = nil
    var _wpKind: TSWP_StorageArchive.KindType? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _storage = source._storage
      _undoTransaction = source._undoTransaction
      _textCommandFlags = source._textCommandFlags
      _kind = source._kind
      _customFormatKeys = source._customFormatKeys
      _isForwardInverseCommand = source._isForwardInverseCommand
      _coalesceable = source._coalesceable
      _coalescingText = source._coalescingText
      _shouldMigrateStyles = source._shouldMigrateStyles
      _changedDataReferenceRecord = source._changedDataReferenceRecord
      _coalescingProperty = source._coalescingProperty
      _wpKind = source._wpKind
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._storage, !v.isInitialized {return false}
      if let v = _storage._undoTransaction, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._customFormatKeys) {return false}
      if let v = _storage._changedDataReferenceRecord, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._storage) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._undoTransaction) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._textCommandFlags) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._kind) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._customFormatKeys) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._isForwardInverseCommand) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._coalesceable) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._coalescingText) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._shouldMigrateStyles) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._changedDataReferenceRecord) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._coalescingProperty) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._wpKind) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._storage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._undoTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._textCommandFlags {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._kind {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
      } }()
      if !_storage._customFormatKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._customFormatKeys, fieldNumber: 6)
      }
      try { if let v = _storage._isForwardInverseCommand {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._coalesceable {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._coalescingText {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._shouldMigrateStyles {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._changedDataReferenceRecord {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._coalescingProperty {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._wpKind {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_StorageActionCommandArchive, rhs: TSWP_StorageActionCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._storage != rhs_storage._storage {return false}
        if _storage._undoTransaction != rhs_storage._undoTransaction {return false}
        if _storage._textCommandFlags != rhs_storage._textCommandFlags {return false}
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._customFormatKeys != rhs_storage._customFormatKeys {return false}
        if _storage._isForwardInverseCommand != rhs_storage._isForwardInverseCommand {return false}
        if _storage._coalesceable != rhs_storage._coalesceable {return false}
        if _storage._coalescingText != rhs_storage._coalescingText {return false}
        if _storage._shouldMigrateStyles != rhs_storage._shouldMigrateStyles {return false}
        if _storage._changedDataReferenceRecord != rhs_storage._changedDataReferenceRecord {return false}
        if _storage._coalescingProperty != rhs_storage._coalescingProperty {return false}
        if _storage._wpKind != rhs_storage._wpKind {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_StorageActionCommandArchive.Kind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kKindContained\0\u{1}kKindReplaceText\0\u{1}kKindPaste\0\u{1}kKindParagraphStyle\0\u{1}kKindListStyle\0\u{1}kKindIndentParagraphLevel\0\u{1}kKindDragText\0\u{1}kKindPasteStyle\0\u{1}kKindApplyChangesInRange\0\u{2}\u{2}kKindInsertCitationField\0\u{1}kKindInsertBibliographyEntry\0\u{1}kKindFormatCitationFields\0\u{1}kKindInsertTOCSmartField\0\u{1}kKindInsertDateTimeField\0\u{1}kKindUpdateDateTimeField\0\u{1}kKindSetParagraphFirstTopicNumber\0\u{1}kKindCharacterStyle\0\u{1}kKindRevertStyles\0\u{1}kKindSetParagraphBidi\0\u{1}kKindFormatText\0\u{1}kKindInsertAttachment\0\u{1}kKindCreateHyperlink\0\u{1}kKindModifyHyperlink\0\u{1}kKindRemoveHyperlink\0\u{1}kKindApplyHighlightText\0\u{1}kKindPropagateStyleChanges\0\u{1}kKindMovedAnchoredDrawableInline\0\u{1}kKindMoveDrawablesAttached\0\u{1}kKindMoveMoveDrawablesFloating\0\u{1}kKindMoveInlineDrawableAnchored\0\u{1}kKindAnchorAttachment\0\u{1}kKindBookmark\0\u{1}kKindReplaceSection\0\u{1}kKindApplyPencilAnnotation\0\u{1}kKindApplyRuby\0\u{1}kKindModifyRuby\0\u{1}kKindRemoveRuby\0\u{1}kKindTateChuYoko\0\u{1}kKindDropCapStyle\0\u{1}kKindMergeField\0\u{1}kKindModifyMergeField\0\u{1}kKindMergeFieldTypeReplace\0\u{1}kKindApplyPlaceholderText\0")
}

extension TSWP_SetColumnStyleCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetColumnStyleCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}storage\0\u{3}undo_transaction\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _storage: TSP_Reference? = nil
    var _undoTransaction: TSWP_UndoTransaction? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _storage = source._storage
      _undoTransaction = source._undoTransaction
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._storage, !v.isInitialized {return false}
      if let v = _storage._undoTransaction, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._storage) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._undoTransaction) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._storage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._undoTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_SetColumnStyleCommandArchive, rhs: TSWP_SetColumnStyleCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._storage != rhs_storage._storage {return false}
        if _storage._undoTransaction != rhs_storage._undoTransaction {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ReplaceAllUsesOfStyleCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReplaceAllUsesOfStyleCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}storage\0\u{3}undo_transaction\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _storage: TSP_Reference? = nil
    var _undoTransaction: TSWP_UndoTransaction? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _storage = source._storage
      _undoTransaction = source._undoTransaction
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._storage, !v.isInitialized {return false}
      if let v = _storage._undoTransaction, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._storage) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._undoTransaction) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._storage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._undoTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ReplaceAllUsesOfStyleCommandArchive, rhs: TSWP_ReplaceAllUsesOfStyleCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._storage != rhs_storage._storage {return false}
        if _storage._undoTransaction != rhs_storage._undoTransaction {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_InsertColumnsCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InsertColumnsCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}storage\0\u{3}column_index\0\u{3}column_count\0\u{3}undo_transaction\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _storage: TSP_Reference? = nil
    var _columnIndex: UInt32? = nil
    var _columnCount: UInt32? = nil
    var _undoTransaction: TSWP_UndoTransaction? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _storage = source._storage
      _columnIndex = source._columnIndex
      _columnCount = source._columnCount
      _undoTransaction = source._undoTransaction
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._storage, !v.isInitialized {return false}
      if let v = _storage._undoTransaction, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._storage) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._columnIndex) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._columnCount) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._undoTransaction) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._storage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._columnIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._columnCount {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._undoTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_InsertColumnsCommandArchive, rhs: TSWP_InsertColumnsCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._storage != rhs_storage._storage {return false}
        if _storage._columnIndex != rhs_storage._columnIndex {return false}
        if _storage._columnCount != rhs_storage._columnCount {return false}
        if _storage._undoTransaction != rhs_storage._undoTransaction {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_InsertRowsCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InsertRowsCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}storage\0\u{3}row_index\0\u{3}row_count\0\u{3}undo_transaction\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _storage: TSP_Reference? = nil
    var _rowIndex: UInt32? = nil
    var _rowCount: UInt32? = nil
    var _undoTransaction: TSWP_UndoTransaction? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _storage = source._storage
      _rowIndex = source._rowIndex
      _rowCount = source._rowCount
      _undoTransaction = source._undoTransaction
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._storage, !v.isInitialized {return false}
      if let v = _storage._undoTransaction, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._storage) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._rowIndex) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._rowCount) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._undoTransaction) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._storage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._rowIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._rowCount {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._undoTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_InsertRowsCommandArchive, rhs: TSWP_InsertRowsCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._storage != rhs_storage._storage {return false}
        if _storage._rowIndex != rhs_storage._rowIndex {return false}
        if _storage._rowCount != rhs_storage._rowCount {return false}
        if _storage._undoTransaction != rhs_storage._undoTransaction {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_RemoveColumnsCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveColumnsCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}storage\0\u{3}column_index\0\u{3}column_count\0\u{3}undo_transaction\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _storage: TSP_Reference? = nil
    var _columnIndex: UInt32? = nil
    var _columnCount: UInt32? = nil
    var _undoTransaction: TSWP_UndoTransaction? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _storage = source._storage
      _columnIndex = source._columnIndex
      _columnCount = source._columnCount
      _undoTransaction = source._undoTransaction
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._storage, !v.isInitialized {return false}
      if let v = _storage._undoTransaction, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._storage) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._columnIndex) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._columnCount) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._undoTransaction) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._storage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._columnIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._columnCount {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._undoTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_RemoveColumnsCommandArchive, rhs: TSWP_RemoveColumnsCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._storage != rhs_storage._storage {return false}
        if _storage._columnIndex != rhs_storage._columnIndex {return false}
        if _storage._columnCount != rhs_storage._columnCount {return false}
        if _storage._undoTransaction != rhs_storage._undoTransaction {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_RemoveRowsCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveRowsCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}storage\0\u{3}row_index\0\u{3}row_count\0\u{3}undo_transaction\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _storage: TSP_Reference? = nil
    var _rowIndex: UInt32? = nil
    var _rowCount: UInt32? = nil
    var _undoTransaction: TSWP_UndoTransaction? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _storage = source._storage
      _rowIndex = source._rowIndex
      _rowCount = source._rowCount
      _undoTransaction = source._undoTransaction
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._storage, !v.isInitialized {return false}
      if let v = _storage._undoTransaction, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._storage) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._rowIndex) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._rowCount) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._undoTransaction) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._storage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._rowIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._rowCount {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._undoTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_RemoveRowsCommandArchive, rhs: TSWP_RemoveRowsCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._storage != rhs_storage._storage {return false}
        if _storage._rowIndex != rhs_storage._rowIndex {return false}
        if _storage._rowCount != rhs_storage._rowCount {return false}
        if _storage._undoTransaction != rhs_storage._undoTransaction {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_MergeCellsCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MergeCellsCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}storage\0\u{1}row\0\u{1}column\0\u{3}row_count\0\u{3}column_count\0\u{3}undo_transaction\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _storage: TSP_Reference? = nil
    var _row: UInt32? = nil
    var _column: UInt32? = nil
    var _rowCount: UInt32? = nil
    var _columnCount: UInt32? = nil
    var _undoTransaction: TSWP_UndoTransaction? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _storage = source._storage
      _row = source._row
      _column = source._column
      _rowCount = source._rowCount
      _columnCount = source._columnCount
      _undoTransaction = source._undoTransaction
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._storage, !v.isInitialized {return false}
      if let v = _storage._undoTransaction, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._storage) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._row) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._column) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._rowCount) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._columnCount) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._undoTransaction) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._storage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._row {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._column {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._rowCount {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._columnCount {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._undoTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_MergeCellsCommandArchive, rhs: TSWP_MergeCellsCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._storage != rhs_storage._storage {return false}
        if _storage._row != rhs_storage._row {return false}
        if _storage._column != rhs_storage._column {return false}
        if _storage._rowCount != rhs_storage._rowCount {return false}
        if _storage._columnCount != rhs_storage._columnCount {return false}
        if _storage._undoTransaction != rhs_storage._undoTransaction {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ApplyPlaceholderTextCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ApplyPlaceholderTextCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}storage\0\u{3}selection_range_location\0\u{3}selection_range_length\0\u{3}undo_transaction\0\u{3}script_tag\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _storage: TSP_Reference? = nil
    var _selectionRangeLocation: UInt32? = nil
    var _selectionRangeLength: UInt32? = nil
    var _undoTransaction: TSWP_UndoTransaction? = nil
    var _scriptTag: String? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _storage = source._storage
      _selectionRangeLocation = source._selectionRangeLocation
      _selectionRangeLength = source._selectionRangeLength
      _undoTransaction = source._undoTransaction
      _scriptTag = source._scriptTag
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._storage, !v.isInitialized {return false}
      if let v = _storage._undoTransaction, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._storage) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._selectionRangeLocation) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._selectionRangeLength) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._undoTransaction) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._scriptTag) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._storage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._selectionRangeLocation {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._selectionRangeLength {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._undoTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._scriptTag {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ApplyPlaceholderTextCommandArchive, rhs: TSWP_ApplyPlaceholderTextCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._storage != rhs_storage._storage {return false}
        if _storage._selectionRangeLocation != rhs_storage._selectionRangeLocation {return false}
        if _storage._selectionRangeLength != rhs_storage._selectionRangeLength {return false}
        if _storage._undoTransaction != rhs_storage._undoTransaction {return false}
        if _storage._scriptTag != rhs_storage._scriptTag {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_UpdateDateTimeFieldCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateDateTimeFieldCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}date_time_field\0\u{1}date\0\u{3}date_style\0\u{3}time_style\0")

  public var isInitialized: Bool {
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._dateTimeField, !v.isInitialized {return false}
    if let v = self._date, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._dateTimeField) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._dateStyle) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._timeStyle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._dateTimeField {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._dateStyle {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._timeStyle {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_UpdateDateTimeFieldCommandArchive, rhs: TSWP_UpdateDateTimeFieldCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._dateTimeField != rhs._dateTimeField {return false}
    if lhs._date != rhs._date {return false}
    if lhs._dateStyle != rhs._dateStyle {return false}
    if lhs._timeStyle != rhs._timeStyle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ApplyRubyTextCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ApplyRubyTextCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}storage\0\u{3}selection_range_location\0\u{3}selection_range_length\0\u{3}ruby_text\0\u{3}undo_transaction\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _storage: TSP_Reference? = nil
    var _selectionRangeLocation: UInt32? = nil
    var _selectionRangeLength: UInt32? = nil
    var _rubyText: String? = nil
    var _undoTransaction: TSWP_UndoTransaction? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _storage = source._storage
      _selectionRangeLocation = source._selectionRangeLocation
      _selectionRangeLength = source._selectionRangeLength
      _rubyText = source._rubyText
      _undoTransaction = source._undoTransaction
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._storage, !v.isInitialized {return false}
      if let v = _storage._undoTransaction, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._storage) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._selectionRangeLocation) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._selectionRangeLength) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._rubyText) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._undoTransaction) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._storage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._selectionRangeLocation {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._selectionRangeLength {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._rubyText {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._undoTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ApplyRubyTextCommandArchive, rhs: TSWP_ApplyRubyTextCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._storage != rhs_storage._storage {return false}
        if _storage._selectionRangeLocation != rhs_storage._selectionRangeLocation {return false}
        if _storage._selectionRangeLength != rhs_storage._selectionRangeLength {return false}
        if _storage._rubyText != rhs_storage._rubyText {return false}
        if _storage._undoTransaction != rhs_storage._undoTransaction {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ModifyRubyTextCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModifyRubyTextCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}ruby_field\0\u{3}ruby_text\0\u{3}base_text\0\u{3}undo_transaction\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _rubyField: TSP_Reference? = nil
    var _rubyText: String? = nil
    var _baseText: String? = nil
    var _undoTransaction: TSWP_UndoTransaction? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _rubyField = source._rubyField
      _rubyText = source._rubyText
      _baseText = source._baseText
      _undoTransaction = source._undoTransaction
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._rubyField, !v.isInitialized {return false}
      if let v = _storage._undoTransaction, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._rubyField) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._rubyText) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._baseText) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._undoTransaction) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._rubyField {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._rubyText {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._baseText {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._undoTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ModifyRubyTextCommandArchive, rhs: TSWP_ModifyRubyTextCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._rubyField != rhs_storage._rubyField {return false}
        if _storage._rubyText != rhs_storage._rubyText {return false}
        if _storage._baseText != rhs_storage._baseText {return false}
        if _storage._undoTransaction != rhs_storage._undoTransaction {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ModifyTOCSettingsBaseCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModifyTOCSettingsBaseCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}old_toc_settings\0\u{3}new_toc_settings\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _oldTocSettings: TSP_Reference? = nil
    var _newTocSettings: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _oldTocSettings = source._oldTocSettings
      _newTocSettings = source._newTocSettings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._oldTocSettings, !v.isInitialized {return false}
      if let v = _storage._newTocSettings, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._oldTocSettings) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._newTocSettings) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._oldTocSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._newTocSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ModifyTOCSettingsBaseCommandArchive, rhs: TSWP_ModifyTOCSettingsBaseCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._oldTocSettings != rhs_storage._oldTocSettings {return false}
        if _storage._newTocSettings != rhs_storage._newTocSettings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ModifyTOCSettingsForTOCInfoCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModifyTOCSettingsForTOCInfoCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}toc_info_uuid_path\0")

  public var isInitialized: Bool {
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._tocInfoUuidPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tocInfoUuidPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tocInfoUuidPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ModifyTOCSettingsForTOCInfoCommandArchive, rhs: TSWP_ModifyTOCSettingsForTOCInfoCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._tocInfoUuidPath != rhs._tocInfoUuidPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ModifyTOCSettingsPresetForThemeCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModifyTOCSettingsPresetForThemeCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}theme\0\u{3}preset_index\0")

  public var isInitialized: Bool {
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._theme, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._theme) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._presetIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._theme {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._presetIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ModifyTOCSettingsPresetForThemeCommandArchive, rhs: TSWP_ModifyTOCSettingsPresetForThemeCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._theme != rhs._theme {return false}
    if lhs._presetIndex != rhs._presetIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_AnchorAttachmentCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AnchorAttachmentCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}attachment\0\u{3}h_offset_type\0\u{3}h_offset\0\u{3}v_offset_type\0\u{3}v_offset\0\u{3}is_html_wrap\0\u{3}undo_h_offset_type\0\u{3}undo_h_offset\0\u{3}undo_v_offset_type\0\u{3}undo_v_offset\0\u{3}undo_is_html_wrap\0")

  public var isInitialized: Bool {
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._attachment, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._attachment) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._hOffsetType) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._hOffset) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._vOffsetType) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self._vOffset) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._isHtmlWrap) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._undoHOffsetType) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self._undoHOffset) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._undoVOffsetType) }()
      case 11: try { try decoder.decodeSingularFloatField(value: &self._undoVOffset) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self._undoIsHtmlWrap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._attachment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hOffsetType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._hOffset {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._vOffsetType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._vOffset {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._isHtmlWrap {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._undoHOffsetType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._undoHOffset {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._undoVOffsetType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._undoVOffset {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._undoIsHtmlWrap {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_AnchorAttachmentCommandArchive, rhs: TSWP_AnchorAttachmentCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._attachment != rhs._attachment {return false}
    if lhs._hOffsetType != rhs._hOffsetType {return false}
    if lhs._hOffset != rhs._hOffset {return false}
    if lhs._vOffsetType != rhs._vOffsetType {return false}
    if lhs._vOffset != rhs._vOffset {return false}
    if lhs._isHtmlWrap != rhs._isHtmlWrap {return false}
    if lhs._undoHOffsetType != rhs._undoHOffsetType {return false}
    if lhs._undoHOffset != rhs._undoHOffset {return false}
    if lhs._undoVOffsetType != rhs._undoVOffsetType {return false}
    if lhs._undoVOffset != rhs._undoVOffset {return false}
    if lhs._undoIsHtmlWrap != rhs._undoIsHtmlWrap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_TextApplyThemeCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TextApplyThemeCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}storage\0\u{4}\u{4}undo_transaction\0")

  fileprivate class _StorageClass {
    var _super: TSS_ApplyThemeChildCommandArchive? = nil
    var _storage: TSP_Reference? = nil
    var _undoTransaction: TSWP_UndoTransaction? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _storage = source._storage
      _undoTransaction = source._undoTransaction
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._storage, !v.isInitialized {return false}
      if let v = _storage._undoTransaction, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._storage) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._undoTransaction) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._storage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._undoTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_TextApplyThemeCommandArchive, rhs: TSWP_TextApplyThemeCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._storage != rhs_storage._storage {return false}
        if _storage._undoTransaction != rhs_storage._undoTransaction {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_MoveColumnsCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MoveColumnsCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}storage\0\u{3}src_index\0\u{3}dst_index\0\u{1}count\0\u{3}undo_transaction\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _storage: TSP_Reference? = nil
    var _srcIndex: UInt32? = nil
    var _dstIndex: UInt32? = nil
    var _count: UInt32? = nil
    var _undoTransaction: TSWP_UndoTransaction? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _storage = source._storage
      _srcIndex = source._srcIndex
      _dstIndex = source._dstIndex
      _count = source._count
      _undoTransaction = source._undoTransaction
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._storage, !v.isInitialized {return false}
      if let v = _storage._undoTransaction, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._storage) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._srcIndex) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._dstIndex) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._count) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._undoTransaction) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._storage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._srcIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._dstIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._count {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._undoTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_MoveColumnsCommandArchive, rhs: TSWP_MoveColumnsCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._storage != rhs_storage._storage {return false}
        if _storage._srcIndex != rhs_storage._srcIndex {return false}
        if _storage._dstIndex != rhs_storage._dstIndex {return false}
        if _storage._count != rhs_storage._count {return false}
        if _storage._undoTransaction != rhs_storage._undoTransaction {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_MoveRowsCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MoveRowsCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}storage\0\u{3}src_index\0\u{3}dst_index\0\u{1}count\0\u{3}undo_transaction\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _storage: TSP_Reference? = nil
    var _srcIndex: UInt32? = nil
    var _dstIndex: UInt32? = nil
    var _count: UInt32? = nil
    var _undoTransaction: TSWP_UndoTransaction? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _storage = source._storage
      _srcIndex = source._srcIndex
      _dstIndex = source._dstIndex
      _count = source._count
      _undoTransaction = source._undoTransaction
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._storage, !v.isInitialized {return false}
      if let v = _storage._undoTransaction, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._storage) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._srcIndex) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._dstIndex) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._count) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._undoTransaction) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._storage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._srcIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._dstIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._count {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._undoTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_MoveRowsCommandArchive, rhs: TSWP_MoveRowsCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._storage != rhs_storage._storage {return false}
        if _storage._srcIndex != rhs_storage._srcIndex {return false}
        if _storage._dstIndex != rhs_storage._dstIndex {return false}
        if _storage._count != rhs_storage._count {return false}
        if _storage._undoTransaction != rhs_storage._undoTransaction {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ShapeApplyPresetCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShapeApplyPresetCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}undo_style\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._undoStyle, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._undoStyle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._undoStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ShapeApplyPresetCommandArchive, rhs: TSWP_ShapeApplyPresetCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._undoStyle != rhs._undoStyle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_StyleBaseCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StyleBaseCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}theme\0\u{1}style\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _theme: TSP_Reference? = nil
    var _style: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _theme = source._theme
      _style = source._style
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._theme, !v.isInitialized {return false}
      if let v = _storage._style, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._theme) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._style) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._theme {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_StyleBaseCommandArchive, rhs: TSWP_StyleBaseCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._theme != rhs_storage._theme {return false}
        if _storage._style != rhs_storage._style {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_StyleCreateCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StyleCreateCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}preset_index\0")

  public var isInitialized: Bool {
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._presetIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._presetIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_StyleCreateCommandArchive, rhs: TSWP_StyleCreateCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._presetIndex != rhs._presetIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_StyleRenameCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StyleRenameCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}updated_name\0\u{3}old_name\0")

  public var isInitialized: Bool {
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._updatedName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._oldName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updatedName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._oldName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_StyleRenameCommandArchive, rhs: TSWP_StyleRenameCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._updatedName != rhs._updatedName {return false}
    if lhs._oldName != rhs._oldName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_StyleUpdateCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StyleUpdateCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}original_style\0\u{3}updated_style\0")

  public var isInitialized: Bool {
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._originalStyle, !v.isInitialized {return false}
    if let v = self._updatedStyle, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._originalStyle) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updatedStyle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._originalStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._updatedStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_StyleUpdateCommandArchive, rhs: TSWP_StyleUpdateCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._originalStyle != rhs._originalStyle {return false}
    if lhs._updatedStyle != rhs._updatedStyle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_StyleDeleteCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StyleDeleteCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}old_preset_index\0")

  public var isInitialized: Bool {
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._oldPresetIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oldPresetIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_StyleDeleteCommandArchive, rhs: TSWP_StyleDeleteCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._oldPresetIndex != rhs._oldPresetIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_StyleReorderCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StyleReorderCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}old_preset_index\0\u{3}new_preset_index\0")

  public var isInitialized: Bool {
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._oldPresetIndex) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._newPresetIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oldPresetIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newPresetIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_StyleReorderCommandArchive, rhs: TSWP_StyleReorderCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._oldPresetIndex != rhs._oldPresetIndex {return false}
    if lhs._newPresetIndex != rhs._newPresetIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_StyleUpdatePropertyMapCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StyleUpdatePropertyMapCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_StyleUpdatePropertyMapCommandArchive, rhs: TSWP_StyleUpdatePropertyMapCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ShapeStyleSetValueCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShapeStyleSetValueCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{2}\u{3}change\0")

  fileprivate class _StorageClass {
    var _super: TSD_BaseStyleSetValueCommandArchive? = nil
    var _change: TSWPSOS_ShapeStylePropertyChangeSetArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _change = source._change
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._change, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._change) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._change {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ShapeStyleSetValueCommandArchive, rhs: TSWP_ShapeStyleSetValueCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._change != rhs_storage._change {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_SelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}storage_uuid_path\0\u{1}selection\0\u{3}transformed_to_noop\0")

  public var isInitialized: Bool {
    if self._storageUuidPath == nil {return false}
    if self._selection == nil {return false}
    if let v = self._storageUuidPath, !v.isInitialized {return false}
    if let v = self._selection, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._storageUuidPath) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._selection) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._transformedToNoop) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._storageUuidPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._selection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._transformedToNoop {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_SelectionTransformerArchive, rhs: TSWP_SelectionTransformerArchive) -> Bool {
    if lhs._storageUuidPath != rhs._storageUuidPath {return false}
    if lhs._selection != rhs._selection {return false}
    if lhs._transformedToNoop != rhs._transformedToNoop {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_PencilAnnotationSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PencilAnnotationSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}storage_uuid_path\0\u{3}text_pencil_annotation_uuid\0")

  public var isInitialized: Bool {
    if self._storageUuidPath == nil {return false}
    if self._textPencilAnnotationUuid == nil {return false}
    if let v = self._storageUuidPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._storageUuidPath) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._textPencilAnnotationUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._storageUuidPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._textPencilAnnotationUuid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_PencilAnnotationSelectionTransformerArchive, rhs: TSWP_PencilAnnotationSelectionTransformerArchive) -> Bool {
    if lhs._storageUuidPath != rhs._storageUuidPath {return false}
    if lhs._textPencilAnnotationUuid != rhs._textPencilAnnotationUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ShapeSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShapeSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}storage_uuid_path\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._storageUuidPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._storageUuidPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._storageUuidPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ShapeSelectionTransformerArchive, rhs: TSWP_ShapeSelectionTransformerArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._storageUuidPath != rhs._storageUuidPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ShapeContentDescription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShapeContentDescription"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}text_range_location\0\u{3}text_range_length\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._textRangeLocation) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._textRangeLength) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._textRangeLocation {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._textRangeLength {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ShapeContentDescription, rhs: TSWP_ShapeContentDescription) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._textRangeLocation != rhs._textRangeLocation {return false}
    if lhs._textRangeLength != rhs._textRangeLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ObjectPropertyArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ObjectPropertyArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}type\0\u{3}bool_value\0\u{3}float_value\0\u{3}integer_value\0\u{3}string_value\0\u{3}id_path_value\0\u{3}fill_value\0\u{3}color_value\0\u{3}shadow_value\0")

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _type: TSWP_ObjectPropertyType? = nil
    var _boolValue: Bool? = nil
    var _floatValue: Float? = nil
    var _integerValue: Int32? = nil
    var _stringValue: String? = nil
    var _idPathValue: TSP_UUIDPath? = nil
    var _fillValue: TSD_FillArchive? = nil
    var _colorValue: TSP_Color? = nil
    var _shadowValue: TSD_ShadowArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _type = source._type
      _boolValue = source._boolValue
      _floatValue = source._floatValue
      _integerValue = source._integerValue
      _stringValue = source._stringValue
      _idPathValue = source._idPathValue
      _fillValue = source._fillValue
      _colorValue = source._colorValue
      _shadowValue = source._shadowValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._name == nil {return false}
      if _storage._type == nil {return false}
      if let v = _storage._idPathValue, !v.isInitialized {return false}
      if let v = _storage._fillValue, !v.isInitialized {return false}
      if let v = _storage._colorValue, !v.isInitialized {return false}
      if let v = _storage._shadowValue, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._boolValue) }()
        case 4: try { try decoder.decodeSingularFloatField(value: &_storage._floatValue) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._integerValue) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._stringValue) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._idPathValue) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._fillValue) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._colorValue) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._shadowValue) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._boolValue {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._floatValue {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._integerValue {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._stringValue {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._idPathValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._fillValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._colorValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._shadowValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ObjectPropertyArchive, rhs: TSWP_ObjectPropertyArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._boolValue != rhs_storage._boolValue {return false}
        if _storage._floatValue != rhs_storage._floatValue {return false}
        if _storage._integerValue != rhs_storage._integerValue {return false}
        if _storage._stringValue != rhs_storage._stringValue {return false}
        if _storage._idPathValue != rhs_storage._idPathValue {return false}
        if _storage._fillValue != rhs_storage._fillValue {return false}
        if _storage._colorValue != rhs_storage._colorValue {return false}
        if _storage._shadowValue != rhs_storage._shadowValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_SetObjectPropertiesCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetObjectPropertiesCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}object_uuid_path\0\u{1}properties\0\u{3}action_string\0\u{3}old_properties\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._objectUuidPath == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._objectUuidPath, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.properties) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldProperties) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._objectUuidPath) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.properties) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._actionString) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.oldProperties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._objectUuidPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.properties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.properties, fieldNumber: 3)
    }
    try { if let v = self._actionString {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    if !self.oldProperties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldProperties, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_SetObjectPropertiesCommandArchive, rhs: TSWP_SetObjectPropertiesCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._objectUuidPath != rhs._objectUuidPath {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs._actionString != rhs._actionString {return false}
    if lhs.oldProperties != rhs.oldProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_UpdateFlowInfoCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateFlowInfoCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}command_mode\0\u{3}flow_info_uuid_path\0\u{3}text_box_id_path_to_add_or_remove\0\u{3}text_box_id_paths_at_start\0\u{3}suggested_text_box_id_paths_at_end\0\u{3}undo_text_boxes_to_restore\0\u{3}undo_added_shape_info\0\u{3}undo_removed_shape_info\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _commandMode: TSWP_UpdateFlowInfoCommandArchive.Mode? = nil
    var _flowInfoUuidPath: TSP_UUIDPath? = nil
    var _textBoxIDPathToAddOrRemove: TSP_UUIDPath? = nil
    var _textBoxIDPathsAtStart: [TSP_UUIDPath] = []
    var _suggestedTextBoxIDPathsAtEnd: [TSP_UUIDPath] = []
    var _undoTextBoxesToRestore: [TSP_Reference] = []
    var _undoAddedShapeInfo: TSP_Reference? = nil
    var _undoRemovedShapeInfo: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _commandMode = source._commandMode
      _flowInfoUuidPath = source._flowInfoUuidPath
      _textBoxIDPathToAddOrRemove = source._textBoxIDPathToAddOrRemove
      _textBoxIDPathsAtStart = source._textBoxIDPathsAtStart
      _suggestedTextBoxIDPathsAtEnd = source._suggestedTextBoxIDPathsAtEnd
      _undoTextBoxesToRestore = source._undoTextBoxesToRestore
      _undoAddedShapeInfo = source._undoAddedShapeInfo
      _undoRemovedShapeInfo = source._undoRemovedShapeInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._flowInfoUuidPath, !v.isInitialized {return false}
      if let v = _storage._textBoxIDPathToAddOrRemove, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._textBoxIDPathsAtStart) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._suggestedTextBoxIDPathsAtEnd) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._undoTextBoxesToRestore) {return false}
      if let v = _storage._undoAddedShapeInfo, !v.isInitialized {return false}
      if let v = _storage._undoRemovedShapeInfo, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._commandMode) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._flowInfoUuidPath) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._textBoxIDPathToAddOrRemove) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._textBoxIDPathsAtStart) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._suggestedTextBoxIDPathsAtEnd) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._undoTextBoxesToRestore) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._undoAddedShapeInfo) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._undoRemovedShapeInfo) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._commandMode {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._flowInfoUuidPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._textBoxIDPathToAddOrRemove {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._textBoxIDPathsAtStart.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._textBoxIDPathsAtStart, fieldNumber: 5)
      }
      if !_storage._suggestedTextBoxIDPathsAtEnd.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._suggestedTextBoxIDPathsAtEnd, fieldNumber: 6)
      }
      if !_storage._undoTextBoxesToRestore.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._undoTextBoxesToRestore, fieldNumber: 7)
      }
      try { if let v = _storage._undoAddedShapeInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._undoRemovedShapeInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_UpdateFlowInfoCommandArchive, rhs: TSWP_UpdateFlowInfoCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._commandMode != rhs_storage._commandMode {return false}
        if _storage._flowInfoUuidPath != rhs_storage._flowInfoUuidPath {return false}
        if _storage._textBoxIDPathToAddOrRemove != rhs_storage._textBoxIDPathToAddOrRemove {return false}
        if _storage._textBoxIDPathsAtStart != rhs_storage._textBoxIDPathsAtStart {return false}
        if _storage._suggestedTextBoxIDPathsAtEnd != rhs_storage._suggestedTextBoxIDPathsAtEnd {return false}
        if _storage._undoTextBoxesToRestore != rhs_storage._undoTextBoxesToRestore {return false}
        if _storage._undoAddedShapeInfo != rhs_storage._undoAddedShapeInfo {return false}
        if _storage._undoRemovedShapeInfo != rhs_storage._undoRemovedShapeInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_UpdateFlowInfoCommandArchive.Mode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kModeRearrange\0\u{1}kModeAdd\0\u{1}kModeRemove\0\u{1}kModeCompensate\0")
}

extension TSWP_AddFlowInfoCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddFlowInfoCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}flow_info_to_add\0\u{3}flow_info_archive\0\u{3}undo_user_interface_identifier_to_restore\0\u{3}undo_next_user_interface_identifier_to_restore\0\u{3}working_undo_object\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _flowInfoToAdd: TSP_Reference? = nil
    var _flowInfoArchive: TSP_Reference? = nil
    var _undoUserInterfaceIdentifierToRestore: UInt32? = nil
    var _undoNextUserInterfaceIdentifierToRestore: UInt32? = nil
    var _workingUndoObject: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _flowInfoToAdd = source._flowInfoToAdd
      _flowInfoArchive = source._flowInfoArchive
      _undoUserInterfaceIdentifierToRestore = source._undoUserInterfaceIdentifierToRestore
      _undoNextUserInterfaceIdentifierToRestore = source._undoNextUserInterfaceIdentifierToRestore
      _workingUndoObject = source._workingUndoObject
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._flowInfoToAdd, !v.isInitialized {return false}
      if let v = _storage._flowInfoArchive, !v.isInitialized {return false}
      if let v = _storage._workingUndoObject, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._flowInfoToAdd) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._flowInfoArchive) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._undoUserInterfaceIdentifierToRestore) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._undoNextUserInterfaceIdentifierToRestore) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._workingUndoObject) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._flowInfoToAdd {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._flowInfoArchive {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._undoUserInterfaceIdentifierToRestore {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._undoNextUserInterfaceIdentifierToRestore {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._workingUndoObject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_AddFlowInfoCommandArchive, rhs: TSWP_AddFlowInfoCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._flowInfoToAdd != rhs_storage._flowInfoToAdd {return false}
        if _storage._flowInfoArchive != rhs_storage._flowInfoArchive {return false}
        if _storage._undoUserInterfaceIdentifierToRestore != rhs_storage._undoUserInterfaceIdentifierToRestore {return false}
        if _storage._undoNextUserInterfaceIdentifierToRestore != rhs_storage._undoNextUserInterfaceIdentifierToRestore {return false}
        if _storage._workingUndoObject != rhs_storage._workingUndoObject {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_RemoveFlowInfoCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveFlowInfoCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}flow_info_uuid_path\0\u{3}undo_object\0\u{3}undo_user_interface_identifier_to_restore\0\u{3}undo_next_user_interface_identifier_to_restore\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _flowInfoUuidPath: TSP_UUIDPath? = nil
    var _undoObject: TSP_Reference? = nil
    var _undoUserInterfaceIdentifierToRestore: UInt32? = nil
    var _undoNextUserInterfaceIdentifierToRestore: UInt32? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _flowInfoUuidPath = source._flowInfoUuidPath
      _undoObject = source._undoObject
      _undoUserInterfaceIdentifierToRestore = source._undoUserInterfaceIdentifierToRestore
      _undoNextUserInterfaceIdentifierToRestore = source._undoNextUserInterfaceIdentifierToRestore
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._flowInfoUuidPath, !v.isInitialized {return false}
      if let v = _storage._undoObject, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._flowInfoUuidPath) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._undoObject) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._undoUserInterfaceIdentifierToRestore) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._undoNextUserInterfaceIdentifierToRestore) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._flowInfoUuidPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._undoObject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._undoUserInterfaceIdentifierToRestore {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._undoNextUserInterfaceIdentifierToRestore {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_RemoveFlowInfoCommandArchive, rhs: TSWP_RemoveFlowInfoCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._flowInfoUuidPath != rhs_storage._flowInfoUuidPath {return false}
        if _storage._undoObject != rhs_storage._undoObject {return false}
        if _storage._undoUserInterfaceIdentifierToRestore != rhs_storage._undoUserInterfaceIdentifierToRestore {return false}
        if _storage._undoNextUserInterfaceIdentifierToRestore != rhs_storage._undoNextUserInterfaceIdentifierToRestore {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_TextCommentReplyCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TextCommentReplyCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}storage_uuid_path\0\u{3}annotation_uuid\0\u{3}forward_comment\0\u{3}inverse_comment\0\u{3}forward_variant\0\u{3}inverse_variant\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _storageUuidPath: TSP_UUIDPath? = nil
    var _annotationUuid: String? = nil
    var _forwardComment: TSP_Reference? = nil
    var _inverseComment: TSP_Reference? = nil
    var _forwardVariant: TSD_CommentCommandVariant? = nil
    var _inverseVariant: TSD_CommentCommandVariant? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _storageUuidPath = source._storageUuidPath
      _annotationUuid = source._annotationUuid
      _forwardComment = source._forwardComment
      _inverseComment = source._inverseComment
      _forwardVariant = source._forwardVariant
      _inverseVariant = source._inverseVariant
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._storageUuidPath, !v.isInitialized {return false}
      if let v = _storage._forwardComment, !v.isInitialized {return false}
      if let v = _storage._inverseComment, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._storageUuidPath) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._annotationUuid) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._forwardComment) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._inverseComment) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._forwardVariant) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._inverseVariant) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._storageUuidPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._annotationUuid {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._forwardComment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._inverseComment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._forwardVariant {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._inverseVariant {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_TextCommentReplyCommandArchive, rhs: TSWP_TextCommentReplyCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._storageUuidPath != rhs_storage._storageUuidPath {return false}
        if _storage._annotationUuid != rhs_storage._annotationUuid {return false}
        if _storage._forwardComment != rhs_storage._forwardComment {return false}
        if _storage._inverseComment != rhs_storage._inverseComment {return false}
        if _storage._forwardVariant != rhs_storage._forwardVariant {return false}
        if _storage._inverseVariant != rhs_storage._inverseVariant {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ContainedObjectsCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainedObjectsCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}target\0\u{1}objects\0\u{3}undo_object_for_commit\0\u{3}undo_object_for_make_inverse\0\u{3}add_behavior_args\0\u{3}remove_behavior_args\0\u{3}rearrange_behavior_args\0\u{3}container_name\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _target: TSP_Reference? = nil
    var _objects: [TSP_Reference] = []
    var _undoObjectForCommit: TSP_Reference? = nil
    var _undoObjectForMakeInverse: TSP_Reference? = nil
    var _addBehaviorArgs: TSWP_ContainedObjectsCommandArchive.AddBehaviorArgs? = nil
    var _removeBehaviorArgs: TSWP_ContainedObjectsCommandArchive.RemoveBehaviorArgs? = nil
    var _rearrangeBehaviorArgs: TSWP_ContainedObjectsCommandArchive.RearrangeBehaviorArgs? = nil
    var _containerName: String? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _target = source._target
      _objects = source._objects
      _undoObjectForCommit = source._undoObjectForCommit
      _undoObjectForMakeInverse = source._undoObjectForMakeInverse
      _addBehaviorArgs = source._addBehaviorArgs
      _removeBehaviorArgs = source._removeBehaviorArgs
      _rearrangeBehaviorArgs = source._rearrangeBehaviorArgs
      _containerName = source._containerName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._target == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._target, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._objects) {return false}
      if let v = _storage._undoObjectForCommit, !v.isInitialized {return false}
      if let v = _storage._undoObjectForMakeInverse, !v.isInitialized {return false}
      if let v = _storage._addBehaviorArgs, !v.isInitialized {return false}
      if let v = _storage._removeBehaviorArgs, !v.isInitialized {return false}
      if let v = _storage._rearrangeBehaviorArgs, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._target) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._objects) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._undoObjectForCommit) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._undoObjectForMakeInverse) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._addBehaviorArgs) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._removeBehaviorArgs) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._rearrangeBehaviorArgs) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._containerName) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._target {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._objects.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._objects, fieldNumber: 3)
      }
      try { if let v = _storage._undoObjectForCommit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._undoObjectForMakeInverse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._addBehaviorArgs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._removeBehaviorArgs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._rearrangeBehaviorArgs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._containerName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ContainedObjectsCommandArchive, rhs: TSWP_ContainedObjectsCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._target != rhs_storage._target {return false}
        if _storage._objects != rhs_storage._objects {return false}
        if _storage._undoObjectForCommit != rhs_storage._undoObjectForCommit {return false}
        if _storage._undoObjectForMakeInverse != rhs_storage._undoObjectForMakeInverse {return false}
        if _storage._addBehaviorArgs != rhs_storage._addBehaviorArgs {return false}
        if _storage._removeBehaviorArgs != rhs_storage._removeBehaviorArgs {return false}
        if _storage._rearrangeBehaviorArgs != rhs_storage._rearrangeBehaviorArgs {return false}
        if _storage._containerName != rhs_storage._containerName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ContainedObjectsCommandArchive.AddBehaviorArgs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_ContainedObjectsCommandArchive.protoMessageName + ".AddBehaviorArgs"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}args_list\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.argsList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.argsList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.argsList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.argsList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ContainedObjectsCommandArchive.AddBehaviorArgs, rhs: TSWP_ContainedObjectsCommandArchive.AddBehaviorArgs) -> Bool {
    if lhs.argsList != rhs.argsList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ContainedObjectsCommandArchive.RemoveBehaviorArgs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_ContainedObjectsCommandArchive.protoMessageName + ".RemoveBehaviorArgs"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}args_list\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.argsList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.argsList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.argsList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.argsList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ContainedObjectsCommandArchive.RemoveBehaviorArgs, rhs: TSWP_ContainedObjectsCommandArchive.RemoveBehaviorArgs) -> Bool {
    if lhs.argsList != rhs.argsList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ContainedObjectsCommandArchive.RearrangeBehaviorArgs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_ContainedObjectsCommandArchive.protoMessageName + ".RearrangeBehaviorArgs"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}args_list\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.argsList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.argsList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.argsList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.argsList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ContainedObjectsCommandArchive.RearrangeBehaviorArgs, rhs: TSWP_ContainedObjectsCommandArchive.RearrangeBehaviorArgs) -> Bool {
    if lhs.argsList != rhs.argsList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_EquationInfoGeometryCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EquationInfoGeometryCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_EquationInfoGeometryCommandArchive, rhs: TSWP_EquationInfoGeometryCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_CharacterStyleChangePropertyCommand_GArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CharacterStyleChangePropertyCommand_GArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}range_list\0\u{3}range_list_undefined\0\u{3}change_list\0\u{3}change_list_undefined\0\u{3}disable_character_style_promotion\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._disableCharacterStylePromotion == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rangeList) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.changeList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rangeList) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._rangeListUndefined) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.changeList) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._changeListUndefined) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._disableCharacterStylePromotion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.rangeList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rangeList, fieldNumber: 2)
    }
    try { if let v = self._rangeListUndefined {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    if !self.changeList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.changeList, fieldNumber: 4)
    }
    try { if let v = self._changeListUndefined {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._disableCharacterStylePromotion {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_CharacterStyleChangePropertyCommand_GArchive, rhs: TSWP_CharacterStyleChangePropertyCommand_GArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.rangeList != rhs.rangeList {return false}
    if lhs._rangeListUndefined != rhs._rangeListUndefined {return false}
    if lhs.changeList != rhs.changeList {return false}
    if lhs._changeListUndefined != rhs._changeListUndefined {return false}
    if lhs._disableCharacterStylePromotion != rhs._disableCharacterStylePromotion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ParagraphStyleChangePropertyCommand_GArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParagraphStyleChangePropertyCommand_GArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}range_list\0\u{3}range_list_undefined\0\u{3}change_list\0\u{3}change_list_undefined\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rangeList) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.changeList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rangeList) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._rangeListUndefined) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.changeList) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._changeListUndefined) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.rangeList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rangeList, fieldNumber: 2)
    }
    try { if let v = self._rangeListUndefined {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    if !self.changeList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.changeList, fieldNumber: 4)
    }
    try { if let v = self._changeListUndefined {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ParagraphStyleChangePropertyCommand_GArchive, rhs: TSWP_ParagraphStyleChangePropertyCommand_GArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.rangeList != rhs.rangeList {return false}
    if lhs._rangeListUndefined != rhs._rangeListUndefined {return false}
    if lhs.changeList != rhs.changeList {return false}
    if lhs._changeListUndefined != rhs._changeListUndefined {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
