// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: KNCommandArchives.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum KN_AnimationReferent: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case kRelativeToStart = 1
  case kRelativeToEnd = 2

  init() {
    self = .kRelativeToStart
  }

}

struct KN_UIStateCommandGroupArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandGroupArchive {
    get {return _storage._super ?? TSK_CommandGroupArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var uiState: TSP_Reference {
    get {return _storage._uiState ?? TSP_Reference()}
    set {_uniqueStorage()._uiState = newValue}
  }
  /// Returns true if `uiState` has been explicitly set.
  var hasUiState: Bool {return _storage._uiState != nil}
  /// Clears the value of `uiState`. Subsequent reads from it will return its default value.
  mutating func clearUiState() {_uniqueStorage()._uiState = nil}

  var property: String {
    get {return _storage._property ?? String()}
    set {_uniqueStorage()._property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return _storage._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {_uniqueStorage()._property = nil}

  var slideNodesToEdit: [TSP_Reference] {
    get {return _storage._slideNodesToEdit}
    set {_uniqueStorage()._slideNodesToEdit = newValue}
  }

  var templateSlideNodesToApply: [TSP_Reference] {
    get {return _storage._templateSlideNodesToApply}
    set {_uniqueStorage()._templateSlideNodesToApply = newValue}
  }

  var thumbnailSizes: [TSP_Size] {
    get {return _storage._thumbnailSizes}
    set {_uniqueStorage()._thumbnailSizes = newValue}
  }

  var selectedSlideNodes: [TSP_Reference] {
    get {return _storage._selectedSlideNodes}
    set {_uniqueStorage()._selectedSlideNodes = newValue}
  }

  var restoreSelectedSlideNodes: [TSP_Reference] {
    get {return _storage._restoreSelectedSlideNodes}
    set {_uniqueStorage()._restoreSelectedSlideNodes = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandSlideInsertDrawablesArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var slideID: TSP_UUID {
    get {return _storage._slideID ?? TSP_UUID()}
    set {_uniqueStorage()._slideID = newValue}
  }
  /// Returns true if `slideID` has been explicitly set.
  var hasSlideID: Bool {return _storage._slideID != nil}
  /// Clears the value of `slideID`. Subsequent reads from it will return its default value.
  mutating func clearSlideID() {_uniqueStorage()._slideID = nil}

  var drawables: [TSP_Reference] {
    get {return _storage._drawables}
    set {_uniqueStorage()._drawables = newValue}
  }

  var workingDrawables: [TSP_Reference] {
    get {return _storage._workingDrawables}
    set {_uniqueStorage()._workingDrawables = newValue}
  }

  var argsList: KN_MixedIdOperationArgs {
    get {return _storage._argsList ?? KN_MixedIdOperationArgs()}
    set {_uniqueStorage()._argsList = newValue}
  }
  /// Returns true if `argsList` has been explicitly set.
  var hasArgsList: Bool {return _storage._argsList != nil}
  /// Clears the value of `argsList`. Subsequent reads from it will return its default value.
  mutating func clearArgsList() {_uniqueStorage()._argsList = nil}

  var updateGeometryToMatchObjectPlaceholder: Bool {
    get {return _storage._updateGeometryToMatchObjectPlaceholder ?? false}
    set {_uniqueStorage()._updateGeometryToMatchObjectPlaceholder = newValue}
  }
  /// Returns true if `updateGeometryToMatchObjectPlaceholder` has been explicitly set.
  var hasUpdateGeometryToMatchObjectPlaceholder: Bool {return _storage._updateGeometryToMatchObjectPlaceholder != nil}
  /// Clears the value of `updateGeometryToMatchObjectPlaceholder`. Subsequent reads from it will return its default value.
  mutating func clearUpdateGeometryToMatchObjectPlaceholder() {_uniqueStorage()._updateGeometryToMatchObjectPlaceholder = nil}

  var idsOfDrawablesUsingObjectPlaceholderGeometry: [TSP_UUID] {
    get {return _storage._idsOfDrawablesUsingObjectPlaceholderGeometry}
    set {_uniqueStorage()._idsOfDrawablesUsingObjectPlaceholderGeometry = newValue}
  }

  var sagePlaceholderTagsList: [String] {
    get {return _storage._sagePlaceholderTagsList}
    set {_uniqueStorage()._sagePlaceholderTagsList = newValue}
  }

  var instructionalTextList: [String] {
    get {return _storage._instructionalTextList}
    set {_uniqueStorage()._instructionalTextList = newValue}
  }

  var undoArchive: TSP_Reference {
    get {return _storage._undoArchive ?? TSP_Reference()}
    set {_uniqueStorage()._undoArchive = newValue}
  }
  /// Returns true if `undoArchive` has been explicitly set.
  var hasUndoArchive: Bool {return _storage._undoArchive != nil}
  /// Clears the value of `undoArchive`. Subsequent reads from it will return its default value.
  mutating func clearUndoArchive() {_uniqueStorage()._undoArchive = nil}

  var isPasting: Bool {
    get {return _storage._isPasting ?? false}
    set {_uniqueStorage()._isPasting = newValue}
  }
  /// Returns true if `isPasting` has been explicitly set.
  var hasIsPasting: Bool {return _storage._isPasting != nil}
  /// Clears the value of `isPasting`. Subsequent reads from it will return its default value.
  mutating func clearIsPasting() {_uniqueStorage()._isPasting = nil}

  var insertBuildDescriptions: [TSP_Reference] {
    get {return _storage._insertBuildDescriptions}
    set {_uniqueStorage()._insertBuildDescriptions = newValue}
  }

  var workingInsertBuildDescriptions: [TSP_Reference] {
    get {return _storage._workingInsertBuildDescriptions}
    set {_uniqueStorage()._workingInsertBuildDescriptions = newValue}
  }

  var removeBuildDescriptions: [TSP_Reference] {
    get {return _storage._removeBuildDescriptions}
    set {_uniqueStorage()._removeBuildDescriptions = newValue}
  }

  var removeSlideSpecificHyperlinks: Bool {
    get {return _storage._removeSlideSpecificHyperlinks ?? false}
    set {_uniqueStorage()._removeSlideSpecificHyperlinks = newValue}
  }
  /// Returns true if `removeSlideSpecificHyperlinks` has been explicitly set.
  var hasRemoveSlideSpecificHyperlinks: Bool {return _storage._removeSlideSpecificHyperlinks != nil}
  /// Clears the value of `removeSlideSpecificHyperlinks`. Subsequent reads from it will return its default value.
  mutating func clearRemoveSlideSpecificHyperlinks() {_uniqueStorage()._removeSlideSpecificHyperlinks = nil}

  var customFormatKeys: [TSP_UUID] {
    get {return _storage._customFormatKeys}
    set {_uniqueStorage()._customFormatKeys = newValue}
  }

  var savedNextUntitledResolverIndex: UInt32 {
    get {return _storage._savedNextUntitledResolverIndex ?? 0}
    set {_uniqueStorage()._savedNextUntitledResolverIndex = newValue}
  }
  /// Returns true if `savedNextUntitledResolverIndex` has been explicitly set.
  var hasSavedNextUntitledResolverIndex: Bool {return _storage._savedNextUntitledResolverIndex != nil}
  /// Clears the value of `savedNextUntitledResolverIndex`. Subsequent reads from it will return its default value.
  mutating func clearSavedNextUntitledResolverIndex() {_uniqueStorage()._savedNextUntitledResolverIndex = nil}

  var geometryOfObjectPlaceholderForComparisonToRestoreLink: TSD_GeometryArchive {
    get {return _storage._geometryOfObjectPlaceholderForComparisonToRestoreLink ?? TSD_GeometryArchive()}
    set {_uniqueStorage()._geometryOfObjectPlaceholderForComparisonToRestoreLink = newValue}
  }
  /// Returns true if `geometryOfObjectPlaceholderForComparisonToRestoreLink` has been explicitly set.
  var hasGeometryOfObjectPlaceholderForComparisonToRestoreLink: Bool {return _storage._geometryOfObjectPlaceholderForComparisonToRestoreLink != nil}
  /// Clears the value of `geometryOfObjectPlaceholderForComparisonToRestoreLink`. Subsequent reads from it will return its default value.
  mutating func clearGeometryOfObjectPlaceholderForComparisonToRestoreLink() {_uniqueStorage()._geometryOfObjectPlaceholderForComparisonToRestoreLink = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandSlideSetPlaceholdersForTagsArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var slideID: TSP_UUID {
    get {return _storage._slideID ?? TSP_UUID()}
    set {_uniqueStorage()._slideID = newValue}
  }
  /// Returns true if `slideID` has been explicitly set.
  var hasSlideID: Bool {return _storage._slideID != nil}
  /// Clears the value of `slideID`. Subsequent reads from it will return its default value.
  mutating func clearSlideID() {_uniqueStorage()._slideID = nil}

  var infos: [TSP_Reference] {
    get {return _storage._infos}
    set {_uniqueStorage()._infos = newValue}
  }

  var tags: [String] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  var oldInfos: [TSP_Reference] {
    get {return _storage._oldInfos}
    set {_uniqueStorage()._oldInfos = newValue}
  }

  var oldTags: [String] {
    get {return _storage._oldTags}
    set {_uniqueStorage()._oldTags = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandTemplateSlideSetPlaceholderForTagArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: KN_CommandSlideSetPlaceholdersForTagsArchive {
    get {return _super ?? KN_CommandSlideSetPlaceholdersForTagsArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var placeholderID: TSP_UUID {
    get {return _placeholderID ?? TSP_UUID()}
    set {_placeholderID = newValue}
  }
  /// Returns true if `placeholderID` has been explicitly set.
  var hasPlaceholderID: Bool {return self._placeholderID != nil}
  /// Clears the value of `placeholderID`. Subsequent reads from it will return its default value.
  mutating func clearPlaceholderID() {self._placeholderID = nil}

  var tag: String {
    get {return _tag ?? String()}
    set {_tag = newValue}
  }
  /// Returns true if `tag` has been explicitly set.
  var hasTag: Bool {return self._tag != nil}
  /// Clears the value of `tag`. Subsequent reads from it will return its default value.
  mutating func clearTag() {self._tag = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: KN_CommandSlideSetPlaceholdersForTagsArchive? = nil
  fileprivate var _placeholderID: TSP_UUID? = nil
  fileprivate var _tag: String? = nil
}

struct KN_CommandSlidePropagateSetPlaceholderForTagArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: KN_CommandSlideSetPlaceholdersForTagsArchive {
    get {return _super ?? KN_CommandSlideSetPlaceholdersForTagsArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var placeholderID: TSP_UUID {
    get {return _placeholderID ?? TSP_UUID()}
    set {_placeholderID = newValue}
  }
  /// Returns true if `placeholderID` has been explicitly set.
  var hasPlaceholderID: Bool {return self._placeholderID != nil}
  /// Clears the value of `placeholderID`. Subsequent reads from it will return its default value.
  mutating func clearPlaceholderID() {self._placeholderID = nil}

  var originalID: TSP_UUID {
    get {return _originalID ?? TSP_UUID()}
    set {_originalID = newValue}
  }
  /// Returns true if `originalID` has been explicitly set.
  var hasOriginalID: Bool {return self._originalID != nil}
  /// Clears the value of `originalID`. Subsequent reads from it will return its default value.
  mutating func clearOriginalID() {self._originalID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: KN_CommandSlideSetPlaceholdersForTagsArchive? = nil
  fileprivate var _placeholderID: TSP_UUID? = nil
  fileprivate var _originalID: TSP_UUID? = nil
}

struct KN_CommandSlideRemoveDrawableArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var slideID: TSP_UUID {
    get {return _storage._slideID ?? TSP_UUID()}
    set {_uniqueStorage()._slideID = newValue}
  }
  /// Returns true if `slideID` has been explicitly set.
  var hasSlideID: Bool {return _storage._slideID != nil}
  /// Clears the value of `slideID`. Subsequent reads from it will return its default value.
  mutating func clearSlideID() {_uniqueStorage()._slideID = nil}

  var sortedDrawables: [TSP_Reference] {
    get {return _storage._sortedDrawables}
    set {_uniqueStorage()._sortedDrawables = newValue}
  }

  var argsList: KN_MixedIdOperationArgs {
    get {return _storage._argsList ?? KN_MixedIdOperationArgs()}
    set {_uniqueStorage()._argsList = newValue}
  }
  /// Returns true if `argsList` has been explicitly set.
  var hasArgsList: Bool {return _storage._argsList != nil}
  /// Clears the value of `argsList`. Subsequent reads from it will return its default value.
  mutating func clearArgsList() {_uniqueStorage()._argsList = nil}

  var drawableIndexesForUndo: [UInt32] {
    get {return _storage._drawableIndexesForUndo}
    set {_uniqueStorage()._drawableIndexesForUndo = newValue}
  }

  var placeholderTags: [String] {
    get {return _storage._placeholderTags}
    set {_uniqueStorage()._placeholderTags = newValue}
  }

  var instructionalTextList: [String] {
    get {return _storage._instructionalTextList}
    set {_uniqueStorage()._instructionalTextList = newValue}
  }

  var insertBuildDescriptions: [TSP_Reference] {
    get {return _storage._insertBuildDescriptions}
    set {_uniqueStorage()._insertBuildDescriptions = newValue}
  }

  var removeBuildDescriptions: [TSP_Reference] {
    get {return _storage._removeBuildDescriptions}
    set {_uniqueStorage()._removeBuildDescriptions = newValue}
  }

  var drawablesUsingObjectPlaceholderGeometry: [TSP_Reference] {
    get {return _storage._drawablesUsingObjectPlaceholderGeometry}
    set {_uniqueStorage()._drawablesUsingObjectPlaceholderGeometry = newValue}
  }

  var inverseInsertHyperlinkCommands: [TSP_Reference] {
    get {return _storage._inverseInsertHyperlinkCommands}
    set {_uniqueStorage()._inverseInsertHyperlinkCommands = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandSlideMoveDrawableZOrderArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var oldOrderedInfos: [TSP_Reference] = []

  var argsList: [TSCK_RearrangeIdOperationArgs] = []

  var slideID: TSP_UUID {
    get {return _slideID ?? TSP_UUID()}
    set {_slideID = newValue}
  }
  /// Returns true if `slideID` has been explicitly set.
  var hasSlideID: Bool {return self._slideID != nil}
  /// Clears the value of `slideID`. Subsequent reads from it will return its default value.
  mutating func clearSlideID() {self._slideID = nil}

  var oldOrderedInfosOnSlideForUndo: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideID: TSP_UUID? = nil
}

struct KN_CommandSlideNodeSetPropertyArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideNodeIDPath: TSP_UUIDPath {
    get {return _slideNodeIDPath ?? TSP_UUIDPath()}
    set {_slideNodeIDPath = newValue}
  }
  /// Returns true if `slideNodeIDPath` has been explicitly set.
  var hasSlideNodeIDPath: Bool {return self._slideNodeIDPath != nil}
  /// Clears the value of `slideNodeIDPath`. Subsequent reads from it will return its default value.
  mutating func clearSlideNodeIDPath() {self._slideNodeIDPath = nil}

  var property: String {
    get {return _property ?? String()}
    set {_property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return self._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {self._property = nil}

  var oldValue: Bool {
    get {return _oldValue ?? false}
    set {_oldValue = newValue}
  }
  /// Returns true if `oldValue` has been explicitly set.
  var hasOldValue: Bool {return self._oldValue != nil}
  /// Clears the value of `oldValue`. Subsequent reads from it will return its default value.
  mutating func clearOldValue() {self._oldValue = nil}

  var value: Bool {
    get {return _value ?? false}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideNodeIDPath: TSP_UUIDPath? = nil
  fileprivate var _property: String? = nil
  fileprivate var _oldValue: Bool? = nil
  fileprivate var _value: Bool? = nil
}

struct KN_CommandSlideNodeSetViewStatePropertyArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideNodeIDPath: TSP_UUIDPath {
    get {return _slideNodeIDPath ?? TSP_UUIDPath()}
    set {_slideNodeIDPath = newValue}
  }
  /// Returns true if `slideNodeIDPath` has been explicitly set.
  var hasSlideNodeIDPath: Bool {return self._slideNodeIDPath != nil}
  /// Clears the value of `slideNodeIDPath`. Subsequent reads from it will return its default value.
  mutating func clearSlideNodeIDPath() {self._slideNodeIDPath = nil}

  var property: String {
    get {return _property ?? String()}
    set {_property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return self._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {self._property = nil}

  var oldValue: Bool {
    get {return _oldValue ?? false}
    set {_oldValue = newValue}
  }
  /// Returns true if `oldValue` has been explicitly set.
  var hasOldValue: Bool {return self._oldValue != nil}
  /// Clears the value of `oldValue`. Subsequent reads from it will return its default value.
  mutating func clearOldValue() {self._oldValue = nil}

  var value: Bool {
    get {return _value ?? false}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideNodeIDPath: TSP_UUIDPath? = nil
  fileprivate var _property: String? = nil
  fileprivate var _oldValue: Bool? = nil
  fileprivate var _value: Bool? = nil
}

struct KN_CommandSlideSetBackgroundFillArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideIDPath: TSP_UUIDPath {
    get {return _slideIDPath ?? TSP_UUIDPath()}
    set {_slideIDPath = newValue}
  }
  /// Returns true if `slideIDPath` has been explicitly set.
  var hasSlideIDPath: Bool {return self._slideIDPath != nil}
  /// Clears the value of `slideIDPath`. Subsequent reads from it will return its default value.
  mutating func clearSlideIDPath() {self._slideIDPath = nil}

  var oldFill: TSD_FillArchive {
    get {return _oldFill ?? TSD_FillArchive()}
    set {_oldFill = newValue}
  }
  /// Returns true if `oldFill` has been explicitly set.
  var hasOldFill: Bool {return self._oldFill != nil}
  /// Clears the value of `oldFill`. Subsequent reads from it will return its default value.
  mutating func clearOldFill() {self._oldFill = nil}

  var newFill: TSD_FillArchive {
    get {return _newFill ?? TSD_FillArchive()}
    set {_newFill = newValue}
  }
  /// Returns true if `newFill` has been explicitly set.
  var hasNewFill: Bool {return self._newFill != nil}
  /// Clears the value of `newFill`. Subsequent reads from it will return its default value.
  mutating func clearNewFill() {self._newFill = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideIDPath: TSP_UUIDPath? = nil
  fileprivate var _oldFill: TSD_FillArchive? = nil
  fileprivate var _newFill: TSD_FillArchive? = nil
}

struct KN_CommandSlideSetStyleArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var slideIDPath: TSP_UUIDPath {
    get {return _storage._slideIDPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._slideIDPath = newValue}
  }
  /// Returns true if `slideIDPath` has been explicitly set.
  var hasSlideIDPath: Bool {return _storage._slideIDPath != nil}
  /// Clears the value of `slideIDPath`. Subsequent reads from it will return its default value.
  mutating func clearSlideIDPath() {_uniqueStorage()._slideIDPath = nil}

  var slideStyle: TSP_Reference {
    get {return _storage._slideStyle ?? TSP_Reference()}
    set {_uniqueStorage()._slideStyle = newValue}
  }
  /// Returns true if `slideStyle` has been explicitly set.
  var hasSlideStyle: Bool {return _storage._slideStyle != nil}
  /// Clears the value of `slideStyle`. Subsequent reads from it will return its default value.
  mutating func clearSlideStyle() {_uniqueStorage()._slideStyle = nil}

  var oldSlideStyle: TSP_Reference {
    get {return _storage._oldSlideStyle ?? TSP_Reference()}
    set {_uniqueStorage()._oldSlideStyle = newValue}
  }
  /// Returns true if `oldSlideStyle` has been explicitly set.
  var hasOldSlideStyle: Bool {return _storage._oldSlideStyle != nil}
  /// Clears the value of `oldSlideStyle`. Subsequent reads from it will return its default value.
  mutating func clearOldSlideStyle() {_uniqueStorage()._oldSlideStyle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandShowMarkOutOfSyncRecordingArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var show: TSP_Reference {
    get {return _storage._show ?? TSP_Reference()}
    set {_uniqueStorage()._show = newValue}
  }
  /// Returns true if `show` has been explicitly set.
  var hasShow: Bool {return _storage._show != nil}
  /// Clears the value of `show`. Subsequent reads from it will return its default value.
  mutating func clearShow() {_uniqueStorage()._show = nil}

  var oldRecording: TSP_Reference {
    get {return _storage._oldRecording ?? TSP_Reference()}
    set {_uniqueStorage()._oldRecording = newValue}
  }
  /// Returns true if `oldRecording` has been explicitly set.
  var hasOldRecording: Bool {return _storage._oldRecording != nil}
  /// Clears the value of `oldRecording`. Subsequent reads from it will return its default value.
  mutating func clearOldRecording() {_uniqueStorage()._oldRecording = nil}

  var oldIsRecordingOutOfSync: Bool {
    get {return _storage._oldIsRecordingOutOfSync ?? false}
    set {_uniqueStorage()._oldIsRecordingOutOfSync = newValue}
  }
  /// Returns true if `oldIsRecordingOutOfSync` has been explicitly set.
  var hasOldIsRecordingOutOfSync: Bool {return _storage._oldIsRecordingOutOfSync != nil}
  /// Clears the value of `oldIsRecordingOutOfSync`. Subsequent reads from it will return its default value.
  mutating func clearOldIsRecordingOutOfSync() {_uniqueStorage()._oldIsRecordingOutOfSync = nil}

  var newIsRecordingOutOfSync: Bool {
    get {return _storage._newIsRecordingOutOfSync ?? false}
    set {_uniqueStorage()._newIsRecordingOutOfSync = newValue}
  }
  /// Returns true if `newIsRecordingOutOfSync` has been explicitly set.
  var hasNewIsRecordingOutOfSync: Bool {return _storage._newIsRecordingOutOfSync != nil}
  /// Clears the value of `newIsRecordingOutOfSync`. Subsequent reads from it will return its default value.
  mutating func clearNewIsRecordingOutOfSync() {_uniqueStorage()._newIsRecordingOutOfSync = nil}

  var oldModificationDate: TSP_Date {
    get {return _storage._oldModificationDate ?? TSP_Date()}
    set {_uniqueStorage()._oldModificationDate = newValue}
  }
  /// Returns true if `oldModificationDate` has been explicitly set.
  var hasOldModificationDate: Bool {return _storage._oldModificationDate != nil}
  /// Clears the value of `oldModificationDate`. Subsequent reads from it will return its default value.
  mutating func clearOldModificationDate() {_uniqueStorage()._oldModificationDate = nil}

  var newModificationDate: TSP_Date {
    get {return _storage._newModificationDate ?? TSP_Date()}
    set {_uniqueStorage()._newModificationDate = newValue}
  }
  /// Returns true if `newModificationDate` has been explicitly set.
  var hasNewModificationDate: Bool {return _storage._newModificationDate != nil}
  /// Clears the value of `newModificationDate`. Subsequent reads from it will return its default value.
  mutating func clearNewModificationDate() {_uniqueStorage()._newModificationDate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandShowMarkOutOfSyncRecordingIfNeededArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var outOfSyncToken: TSP_UUID {
    get {return _outOfSyncToken ?? TSP_UUID()}
    set {_outOfSyncToken = newValue}
  }
  /// Returns true if `outOfSyncToken` has been explicitly set.
  var hasOutOfSyncToken: Bool {return self._outOfSyncToken != nil}
  /// Clears the value of `outOfSyncToken`. Subsequent reads from it will return its default value.
  mutating func clearOutOfSyncToken() {self._outOfSyncToken = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _outOfSyncToken: TSP_UUID? = nil
}

struct KN_CommandShowRemoveRecordingArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var show: TSP_Reference {
    get {return _storage._show ?? TSP_Reference()}
    set {_uniqueStorage()._show = newValue}
  }
  /// Returns true if `show` has been explicitly set.
  var hasShow: Bool {return _storage._show != nil}
  /// Clears the value of `show`. Subsequent reads from it will return its default value.
  mutating func clearShow() {_uniqueStorage()._show = nil}

  var oldRecording: TSP_Reference {
    get {return _storage._oldRecording ?? TSP_Reference()}
    set {_uniqueStorage()._oldRecording = newValue}
  }
  /// Returns true if `oldRecording` has been explicitly set.
  var hasOldRecording: Bool {return _storage._oldRecording != nil}
  /// Clears the value of `oldRecording`. Subsequent reads from it will return its default value.
  mutating func clearOldRecording() {_uniqueStorage()._oldRecording = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandShowReplaceRecordingArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var show: TSP_Reference {
    get {return _storage._show ?? TSP_Reference()}
    set {_uniqueStorage()._show = newValue}
  }
  /// Returns true if `show` has been explicitly set.
  var hasShow: Bool {return _storage._show != nil}
  /// Clears the value of `show`. Subsequent reads from it will return its default value.
  mutating func clearShow() {_uniqueStorage()._show = nil}

  var replacementRecording: TSP_Reference {
    get {return _storage._replacementRecording ?? TSP_Reference()}
    set {_uniqueStorage()._replacementRecording = newValue}
  }
  /// Returns true if `replacementRecording` has been explicitly set.
  var hasReplacementRecording: Bool {return _storage._replacementRecording != nil}
  /// Clears the value of `replacementRecording`. Subsequent reads from it will return its default value.
  mutating func clearReplacementRecording() {_uniqueStorage()._replacementRecording = nil}

  var oldRecording: TSP_Reference {
    get {return _storage._oldRecording ?? TSP_Reference()}
    set {_uniqueStorage()._oldRecording = newValue}
  }
  /// Returns true if `oldRecording` has been explicitly set.
  var hasOldRecording: Bool {return _storage._oldRecording != nil}
  /// Clears the value of `oldRecording`. Subsequent reads from it will return its default value.
  mutating func clearOldRecording() {_uniqueStorage()._oldRecording = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandShowSetValueArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var show: TSP_Reference {
    get {return _storage._show ?? TSP_Reference()}
    set {_uniqueStorage()._show = newValue}
  }
  /// Returns true if `show` has been explicitly set.
  var hasShow: Bool {return _storage._show != nil}
  /// Clears the value of `show`. Subsequent reads from it will return its default value.
  mutating func clearShow() {_uniqueStorage()._show = nil}

  var property: String {
    get {return _storage._property ?? String()}
    set {_uniqueStorage()._property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return _storage._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {_uniqueStorage()._property = nil}

  var oldValue: KN_CommandShowSetValueArchive.PropertyValue {
    get {return _storage._oldValue ?? KN_CommandShowSetValueArchive.PropertyValue()}
    set {_uniqueStorage()._oldValue = newValue}
  }
  /// Returns true if `oldValue` has been explicitly set.
  var hasOldValue: Bool {return _storage._oldValue != nil}
  /// Clears the value of `oldValue`. Subsequent reads from it will return its default value.
  mutating func clearOldValue() {_uniqueStorage()._oldValue = nil}

  var newValue: KN_CommandShowSetValueArchive.PropertyValue {
    get {return _storage._newValue ?? KN_CommandShowSetValueArchive.PropertyValue()}
    set {_uniqueStorage()._newValue = newValue}
  }
  /// Returns true if `newValue` has been explicitly set.
  var hasNewValue: Bool {return _storage._newValue != nil}
  /// Clears the value of `newValue`. Subsequent reads from it will return its default value.
  mutating func clearNewValue() {_uniqueStorage()._newValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PropertyValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var boolValue: Bool {
      get {return _boolValue ?? false}
      set {_boolValue = newValue}
    }
    /// Returns true if `boolValue` has been explicitly set.
    var hasBoolValue: Bool {return self._boolValue != nil}
    /// Clears the value of `boolValue`. Subsequent reads from it will return its default value.
    mutating func clearBoolValue() {self._boolValue = nil}

    var doubleValue: Double {
      get {return _doubleValue ?? 0}
      set {_doubleValue = newValue}
    }
    /// Returns true if `doubleValue` has been explicitly set.
    var hasDoubleValue: Bool {return self._doubleValue != nil}
    /// Clears the value of `doubleValue`. Subsequent reads from it will return its default value.
    mutating func clearDoubleValue() {self._doubleValue = nil}

    var showModeValue: KN_ShowArchive.KNShowMode {
      get {return _showModeValue ?? .kKnshowModeNormal}
      set {_showModeValue = newValue}
    }
    /// Returns true if `showModeValue` has been explicitly set.
    var hasShowModeValue: Bool {return self._showModeValue != nil}
    /// Clears the value of `showModeValue`. Subsequent reads from it will return its default value.
    mutating func clearShowModeValue() {self._showModeValue = nil}

    var sizeValue: TSP_Size {
      get {return _sizeValue ?? TSP_Size()}
      set {_sizeValue = newValue}
    }
    /// Returns true if `sizeValue` has been explicitly set.
    var hasSizeValue: Bool {return self._sizeValue != nil}
    /// Clears the value of `sizeValue`. Subsequent reads from it will return its default value.
    mutating func clearSizeValue() {self._sizeValue = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _boolValue: Bool? = nil
    fileprivate var _doubleValue: Double? = nil
    fileprivate var _showModeValue: KN_ShowArchive.KNShowMode? = nil
    fileprivate var _sizeValue: TSP_Size? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandShowInsertSlideArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var slideNodesBeingInserted: [TSP_Reference] {
    get {return _storage._slideNodesBeingInserted}
    set {_uniqueStorage()._slideNodesBeingInserted = newValue}
  }

  var workingSlideNodesBeingInserted: [TSP_Reference] {
    get {return _storage._workingSlideNodesBeingInserted}
    set {_uniqueStorage()._workingSlideNodesBeingInserted = newValue}
  }

  var insertedArgsList: [TSCK_AddIdOperationArgs] {
    get {return _storage._insertedArgsList}
    set {_uniqueStorage()._insertedArgsList = newValue}
  }

  var idsOfSlideNodesWithDepthChanges: [TSP_UUID] {
    get {return _storage._idsOfSlideNodesWithDepthChanges}
    set {_uniqueStorage()._idsOfSlideNodesWithDepthChanges = newValue}
  }

  var depthsOfSlideNodesWithDepthChanges: [UInt32] {
    get {return _storage._depthsOfSlideNodesWithDepthChanges}
    set {_uniqueStorage()._depthsOfSlideNodesWithDepthChanges = newValue}
  }

  var oldDepthsOfSlideNodesWithDepthChanges: [UInt32] {
    get {return _storage._oldDepthsOfSlideNodesWithDepthChanges}
    set {_uniqueStorage()._oldDepthsOfSlideNodesWithDepthChanges = newValue}
  }

  var slideNodesForDepthFixUp: [TSP_Reference] {
    get {return _storage._slideNodesForDepthFixUp}
    set {_uniqueStorage()._slideNodesForDepthFixUp = newValue}
  }

  var depthsOfSlideNodesForDepthFixUp: [UInt32] {
    get {return _storage._depthsOfSlideNodesForDepthFixUp}
    set {_uniqueStorage()._depthsOfSlideNodesForDepthFixUp = newValue}
  }

  var oldDepthsOfSlideNodesForDepthFixUp: [UInt32] {
    get {return _storage._oldDepthsOfSlideNodesForDepthFixUp}
    set {_uniqueStorage()._oldDepthsOfSlideNodesForDepthFixUp = newValue}
  }

  var kind: KN_CommandShowInsertSlideArchive.Kind {
    get {return _storage._kind ?? .kKindInsertSlide}
    set {_uniqueStorage()._kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return _storage._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {_uniqueStorage()._kind = nil}

  var templateSlideNodesBeingInserted: [TSP_Reference] {
    get {return _storage._templateSlideNodesBeingInserted}
    set {_uniqueStorage()._templateSlideNodesBeingInserted = newValue}
  }

  var customFormatKeys: [TSP_UUID] {
    get {return _storage._customFormatKeys}
    set {_uniqueStorage()._customFormatKeys = newValue}
  }

  var collapsedStateOfSlideNodesBeingInserted: [Bool] {
    get {return _storage._collapsedStateOfSlideNodesBeingInserted}
    set {_uniqueStorage()._collapsedStateOfSlideNodesBeingInserted = newValue}
  }

  var undoArchive: TSP_Reference {
    get {return _storage._undoArchive ?? TSP_Reference()}
    set {_uniqueStorage()._undoArchive = newValue}
  }
  /// Returns true if `undoArchive` has been explicitly set.
  var hasUndoArchive: Bool {return _storage._undoArchive != nil}
  /// Clears the value of `undoArchive`. Subsequent reads from it will return its default value.
  mutating func clearUndoArchive() {_uniqueStorage()._undoArchive = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Kind: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kKindInsertSlide = 0
    case kKindInsertSlideForPaste = 1
    case kKindInsertSlideForDuplicate = 2

    init() {
      self = .kKindInsertSlide
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandShowMoveSlideArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var slideNodesBeingMovedLinearly: [TSP_Reference] {
    get {return _storage._slideNodesBeingMovedLinearly}
    set {_uniqueStorage()._slideNodesBeingMovedLinearly = newValue}
  }

  var rearrangedArgsList: [TSCK_RearrangeIdOperationArgs] {
    get {return _storage._rearrangedArgsList}
    set {_uniqueStorage()._rearrangedArgsList = newValue}
  }

  var idsOfSlideNodesWithDepthChanges: [TSP_UUID] {
    get {return _storage._idsOfSlideNodesWithDepthChanges}
    set {_uniqueStorage()._idsOfSlideNodesWithDepthChanges = newValue}
  }

  var depthsOfSlideNodesWithDepthChanges: [UInt32] {
    get {return _storage._depthsOfSlideNodesWithDepthChanges}
    set {_uniqueStorage()._depthsOfSlideNodesWithDepthChanges = newValue}
  }

  var oldDepthsOfSlideNodesWithDepthChanges: [UInt32] {
    get {return _storage._oldDepthsOfSlideNodesWithDepthChanges}
    set {_uniqueStorage()._oldDepthsOfSlideNodesWithDepthChanges = newValue}
  }

  var slideNodesForDepthFixUp: [TSP_Reference] {
    get {return _storage._slideNodesForDepthFixUp}
    set {_uniqueStorage()._slideNodesForDepthFixUp = newValue}
  }

  var depthsOfSlideNodesForDepthFixUp: [UInt32] {
    get {return _storage._depthsOfSlideNodesForDepthFixUp}
    set {_uniqueStorage()._depthsOfSlideNodesForDepthFixUp = newValue}
  }

  var oldDepthsOfSlideNodesForDepthFixUp: [UInt32] {
    get {return _storage._oldDepthsOfSlideNodesForDepthFixUp}
    set {_uniqueStorage()._oldDepthsOfSlideNodesForDepthFixUp = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandShowRemoveSlideArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var slideNodesBeingRemoved: [TSP_Reference] {
    get {return _storage._slideNodesBeingRemoved}
    set {_uniqueStorage()._slideNodesBeingRemoved = newValue}
  }

  var removedArgsList: [TSCK_RemoveIdOperationArgs] {
    get {return _storage._removedArgsList}
    set {_uniqueStorage()._removedArgsList = newValue}
  }

  var idsOfSlideNodesWithDepthChanges: [TSP_UUID] {
    get {return _storage._idsOfSlideNodesWithDepthChanges}
    set {_uniqueStorage()._idsOfSlideNodesWithDepthChanges = newValue}
  }

  var depthsOfSlideNodesWithDepthChanges: [UInt32] {
    get {return _storage._depthsOfSlideNodesWithDepthChanges}
    set {_uniqueStorage()._depthsOfSlideNodesWithDepthChanges = newValue}
  }

  var oldDepthsOfSlideNodesWithDepthChanges: [UInt32] {
    get {return _storage._oldDepthsOfSlideNodesWithDepthChanges}
    set {_uniqueStorage()._oldDepthsOfSlideNodesWithDepthChanges = newValue}
  }

  var slideNodesForDepthFixUp: [TSP_Reference] {
    get {return _storage._slideNodesForDepthFixUp}
    set {_uniqueStorage()._slideNodesForDepthFixUp = newValue}
  }

  var depthsOfSlideNodesForDepthFixUp: [UInt32] {
    get {return _storage._depthsOfSlideNodesForDepthFixUp}
    set {_uniqueStorage()._depthsOfSlideNodesForDepthFixUp = newValue}
  }

  var oldDepthsOfSlideNodesForDepthFixUp: [UInt32] {
    get {return _storage._oldDepthsOfSlideNodesForDepthFixUp}
    set {_uniqueStorage()._oldDepthsOfSlideNodesForDepthFixUp = newValue}
  }

  var collapsedStateOfSlideNodesBeingRemoved: [Bool] {
    get {return _storage._collapsedStateOfSlideNodesBeingRemoved}
    set {_uniqueStorage()._collapsedStateOfSlideNodesBeingRemoved = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandShowChangeThemeArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var show: TSP_Reference {
    get {return _storage._show ?? TSP_Reference()}
    set {_uniqueStorage()._show = newValue}
  }
  /// Returns true if `show` has been explicitly set.
  var hasShow: Bool {return _storage._show != nil}
  /// Clears the value of `show`. Subsequent reads from it will return its default value.
  mutating func clearShow() {_uniqueStorage()._show = nil}

  var theme: TSP_Reference {
    get {return _storage._theme ?? TSP_Reference()}
    set {_uniqueStorage()._theme = newValue}
  }
  /// Returns true if `theme` has been explicitly set.
  var hasTheme: Bool {return _storage._theme != nil}
  /// Clears the value of `theme`. Subsequent reads from it will return its default value.
  mutating func clearTheme() {_uniqueStorage()._theme = nil}

  var oldTheme: TSP_Reference {
    get {return _storage._oldTheme ?? TSP_Reference()}
    set {_uniqueStorage()._oldTheme = newValue}
  }
  /// Returns true if `oldTheme` has been explicitly set.
  var hasOldTheme: Bool {return _storage._oldTheme != nil}
  /// Clears the value of `oldTheme`. Subsequent reads from it will return its default value.
  mutating func clearOldTheme() {_uniqueStorage()._oldTheme = nil}

  var templateIdentifier: String {
    get {return _storage._templateIdentifier ?? String()}
    set {_uniqueStorage()._templateIdentifier = newValue}
  }
  /// Returns true if `templateIdentifier` has been explicitly set.
  var hasTemplateIdentifier: Bool {return _storage._templateIdentifier != nil}
  /// Clears the value of `templateIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearTemplateIdentifier() {_uniqueStorage()._templateIdentifier = nil}

  var oldTemplateIdentifier: String {
    get {return _storage._oldTemplateIdentifier ?? String()}
    set {_uniqueStorage()._oldTemplateIdentifier = newValue}
  }
  /// Returns true if `oldTemplateIdentifier` has been explicitly set.
  var hasOldTemplateIdentifier: Bool {return _storage._oldTemplateIdentifier != nil}
  /// Clears the value of `oldTemplateIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearOldTemplateIdentifier() {_uniqueStorage()._oldTemplateIdentifier = nil}

  var identifierToStyleMap: KN_CommandShowChangeThemeArchive.IdentifierToStyleMap {
    get {return _storage._identifierToStyleMap ?? KN_CommandShowChangeThemeArchive.IdentifierToStyleMap()}
    set {_uniqueStorage()._identifierToStyleMap = newValue}
  }
  /// Returns true if `identifierToStyleMap` has been explicitly set.
  var hasIdentifierToStyleMap: Bool {return _storage._identifierToStyleMap != nil}
  /// Clears the value of `identifierToStyleMap`. Subsequent reads from it will return its default value.
  mutating func clearIdentifierToStyleMap() {_uniqueStorage()._identifierToStyleMap = nil}

  var oldIdentifierToStyleMap: KN_CommandShowChangeThemeArchive.IdentifierToStyleMap {
    get {return _storage._oldIdentifierToStyleMap ?? KN_CommandShowChangeThemeArchive.IdentifierToStyleMap()}
    set {_uniqueStorage()._oldIdentifierToStyleMap = newValue}
  }
  /// Returns true if `oldIdentifierToStyleMap` has been explicitly set.
  var hasOldIdentifierToStyleMap: Bool {return _storage._oldIdentifierToStyleMap != nil}
  /// Clears the value of `oldIdentifierToStyleMap`. Subsequent reads from it will return its default value.
  mutating func clearOldIdentifierToStyleMap() {_uniqueStorage()._oldIdentifierToStyleMap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct IdentifierToStyleMap: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var styles: [TSS_StylesheetArchive.IdentifiedStyleEntry] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandShowChangeSlideSizeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var size: TSP_Size {
    get {return _size ?? TSP_Size()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _size: TSP_Size? = nil
}

struct KN_CommandSetThemeCustomEffectTimingCurveArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var pathSource: TSD_PathSourceArchive {
    get {return _pathSource ?? TSD_PathSourceArchive()}
    set {_pathSource = newValue}
  }
  /// Returns true if `pathSource` has been explicitly set.
  var hasPathSource: Bool {return self._pathSource != nil}
  /// Clears the value of `pathSource`. Subsequent reads from it will return its default value.
  mutating func clearPathSource() {self._pathSource = nil}

  var oldPathSource: TSD_PathSourceArchive {
    get {return _oldPathSource ?? TSD_PathSourceArchive()}
    set {_oldPathSource = newValue}
  }
  /// Returns true if `oldPathSource` has been explicitly set.
  var hasOldPathSource: Bool {return self._oldPathSource != nil}
  /// Clears the value of `oldPathSource`. Subsequent reads from it will return its default value.
  mutating func clearOldPathSource() {self._oldPathSource = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _name: String? = nil
  fileprivate var _pathSource: TSD_PathSourceArchive? = nil
  fileprivate var _oldPathSource: TSD_PathSourceArchive? = nil
}

struct KN_CommandMoveTemplatesArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_ContainerReorderChildrenCommandArchive {
    get {return _storage._super ?? TSD_ContainerReorderChildrenCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var templateSlides: [TSP_Reference] {
    get {return _storage._templateSlides}
    set {_uniqueStorage()._templateSlides = newValue}
  }

  var previousIndexesKeys: [TSP_Reference] {
    get {return _storage._previousIndexesKeys}
    set {_uniqueStorage()._previousIndexesKeys = newValue}
  }

  var previousIndexesValues: [UInt32] {
    get {return _storage._previousIndexesValues}
    set {_uniqueStorage()._previousIndexesValues = newValue}
  }

  var finalTemplateArrangement: [TSP_Reference] {
    get {return _storage._finalTemplateArrangement}
    set {_uniqueStorage()._finalTemplateArrangement = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandInsertTemplateArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var undoTemplateChangeCommands: [TSP_Reference] = []

  var setInsertedSlideAsDefaultTemplateSlide: Bool {
    get {return _setInsertedSlideAsDefaultTemplateSlide ?? false}
    set {_setInsertedSlideAsDefaultTemplateSlide = newValue}
  }
  /// Returns true if `setInsertedSlideAsDefaultTemplateSlide` has been explicitly set.
  var hasSetInsertedSlideAsDefaultTemplateSlide: Bool {return self._setInsertedSlideAsDefaultTemplateSlide != nil}
  /// Clears the value of `setInsertedSlideAsDefaultTemplateSlide`. Subsequent reads from it will return its default value.
  mutating func clearSetInsertedSlideAsDefaultTemplateSlide() {self._setInsertedSlideAsDefaultTemplateSlide = nil}

  var undoReplacementTemplateSlideNode: TSP_Reference {
    get {return _undoReplacementTemplateSlideNode ?? TSP_Reference()}
    set {_undoReplacementTemplateSlideNode = newValue}
  }
  /// Returns true if `undoReplacementTemplateSlideNode` has been explicitly set.
  var hasUndoReplacementTemplateSlideNode: Bool {return self._undoReplacementTemplateSlideNode != nil}
  /// Clears the value of `undoReplacementTemplateSlideNode`. Subsequent reads from it will return its default value.
  mutating func clearUndoReplacementTemplateSlideNode() {self._undoReplacementTemplateSlideNode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _setInsertedSlideAsDefaultTemplateSlide: Bool? = nil
  fileprivate var _undoReplacementTemplateSlideNode: TSP_Reference? = nil
}

struct KN_CommandPrimitiveInsertTemplateArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_ContainerInsertChildrenCommandArchive {
    get {return _super ?? TSD_ContainerInsertChildrenCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var wasInsertedWithDrop: Bool {
    get {return _wasInsertedWithDrop ?? false}
    set {_wasInsertedWithDrop = newValue}
  }
  /// Returns true if `wasInsertedWithDrop` has been explicitly set.
  var hasWasInsertedWithDrop: Bool {return self._wasInsertedWithDrop != nil}
  /// Clears the value of `wasInsertedWithDrop`. Subsequent reads from it will return its default value.
  mutating func clearWasInsertedWithDrop() {self._wasInsertedWithDrop = nil}

  var customFormatKeys: [TSP_UUID] = []

  var previousClassicThemeRecords: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_ContainerInsertChildrenCommandArchive? = nil
  fileprivate var _wasInsertedWithDrop: Bool? = nil
}

struct KN_CommandRemoveTemplateArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var replacementTemplateSlideNode: TSP_Reference {
    get {return _replacementTemplateSlideNode ?? TSP_Reference()}
    set {_replacementTemplateSlideNode = newValue}
  }
  /// Returns true if `replacementTemplateSlideNode` has been explicitly set.
  var hasReplacementTemplateSlideNode: Bool {return self._replacementTemplateSlideNode != nil}
  /// Clears the value of `replacementTemplateSlideNode`. Subsequent reads from it will return its default value.
  mutating func clearReplacementTemplateSlideNode() {self._replacementTemplateSlideNode = nil}

  var templateChangeCommands: [TSP_Reference] = []

  var defaultTemplateSlideNodeWasReplaced: Bool {
    get {return _defaultTemplateSlideNodeWasReplaced ?? false}
    set {_defaultTemplateSlideNodeWasReplaced = newValue}
  }
  /// Returns true if `defaultTemplateSlideNodeWasReplaced` has been explicitly set.
  var hasDefaultTemplateSlideNodeWasReplaced: Bool {return self._defaultTemplateSlideNodeWasReplaced != nil}
  /// Clears the value of `defaultTemplateSlideNodeWasReplaced`. Subsequent reads from it will return its default value.
  mutating func clearDefaultTemplateSlideNodeWasReplaced() {self._defaultTemplateSlideNodeWasReplaced = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _replacementTemplateSlideNode: TSP_Reference? = nil
  fileprivate var _defaultTemplateSlideNodeWasReplaced: Bool? = nil
}

struct KN_CommandPrimitiveRemoveTemplateArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_ContainerRemoveChildrenCommandArchive {
    get {return _super ?? TSD_ContainerRemoveChildrenCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var previousClassicThemeRecords: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_ContainerRemoveChildrenCommandArchive? = nil
}

struct KN_CommandSlideInsertBuildArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var insertBuildDescription: TSP_Reference {
    get {return _storage._insertBuildDescription ?? TSP_Reference()}
    set {_uniqueStorage()._insertBuildDescription = newValue}
  }
  /// Returns true if `insertBuildDescription` has been explicitly set.
  var hasInsertBuildDescription: Bool {return _storage._insertBuildDescription != nil}
  /// Clears the value of `insertBuildDescription`. Subsequent reads from it will return its default value.
  mutating func clearInsertBuildDescription() {_uniqueStorage()._insertBuildDescription = nil}

  var identifierForChunkToInsertAfter: KN_BuildChunkIdentifierArchive {
    get {return _storage._identifierForChunkToInsertAfter ?? KN_BuildChunkIdentifierArchive()}
    set {_uniqueStorage()._identifierForChunkToInsertAfter = newValue}
  }
  /// Returns true if `identifierForChunkToInsertAfter` has been explicitly set.
  var hasIdentifierForChunkToInsertAfter: Bool {return _storage._identifierForChunkToInsertAfter != nil}
  /// Clears the value of `identifierForChunkToInsertAfter`. Subsequent reads from it will return its default value.
  mutating func clearIdentifierForChunkToInsertAfter() {_uniqueStorage()._identifierForChunkToInsertAfter = nil}

  var shouldCreateChunks: Bool {
    get {return _storage._shouldCreateChunks ?? false}
    set {_uniqueStorage()._shouldCreateChunks = newValue}
  }
  /// Returns true if `shouldCreateChunks` has been explicitly set.
  var hasShouldCreateChunks: Bool {return _storage._shouldCreateChunks != nil}
  /// Clears the value of `shouldCreateChunks`. Subsequent reads from it will return its default value.
  mutating func clearShouldCreateChunks() {_uniqueStorage()._shouldCreateChunks = nil}

  var oldTuplesToUpdate: [TSP_Reference] {
    get {return _storage._oldTuplesToUpdate}
    set {_uniqueStorage()._oldTuplesToUpdate = newValue}
  }

  var wasInitializedOverTheWire: Bool {
    get {return _storage._wasInitializedOverTheWire ?? false}
    set {_uniqueStorage()._wasInitializedOverTheWire = newValue}
  }
  /// Returns true if `wasInitializedOverTheWire` has been explicitly set.
  var hasWasInitializedOverTheWire: Bool {return _storage._wasInitializedOverTheWire != nil}
  /// Clears the value of `wasInitializedOverTheWire`. Subsequent reads from it will return its default value.
  mutating func clearWasInitializedOverTheWire() {_uniqueStorage()._wasInitializedOverTheWire = nil}

  var hasBeenCommitted_p: Bool {
    get {return _storage._hasBeenCommitted_p ?? false}
    set {_uniqueStorage()._hasBeenCommitted_p = newValue}
  }
  /// Returns true if `hasBeenCommitted_p` has been explicitly set.
  var hasHasBeenCommitted_p: Bool {return _storage._hasBeenCommitted_p != nil}
  /// Clears the value of `hasBeenCommitted_p`. Subsequent reads from it will return its default value.
  mutating func clearHasBeenCommitted_p() {_uniqueStorage()._hasBeenCommitted_p = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_InsertBuildDescriptionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var slideID: TSP_UUID {
    get {return _slideID ?? TSP_UUID()}
    set {_slideID = newValue}
  }
  /// Returns true if `slideID` has been explicitly set.
  var hasSlideID: Bool {return self._slideID != nil}
  /// Clears the value of `slideID`. Subsequent reads from it will return its default value.
  mutating func clearSlideID() {self._slideID = nil}

  var buildToInsert: TSP_Reference {
    get {return _buildToInsert ?? TSP_Reference()}
    set {_buildToInsert = newValue}
  }
  /// Returns true if `buildToInsert` has been explicitly set.
  var hasBuildToInsert: Bool {return self._buildToInsert != nil}
  /// Clears the value of `buildToInsert`. Subsequent reads from it will return its default value.
  mutating func clearBuildToInsert() {self._buildToInsert = nil}

  var chunksToInsert: [TSP_Reference] = []

  var shouldAssignChunkIdentifiers: Bool {
    get {return _shouldAssignChunkIdentifiers ?? false}
    set {_shouldAssignChunkIdentifiers = newValue}
  }
  /// Returns true if `shouldAssignChunkIdentifiers` has been explicitly set.
  var hasShouldAssignChunkIdentifiers: Bool {return self._shouldAssignChunkIdentifiers != nil}
  /// Clears the value of `shouldAssignChunkIdentifiers`. Subsequent reads from it will return its default value.
  mutating func clearShouldAssignChunkIdentifiers() {self._shouldAssignChunkIdentifiers = nil}

  var identifersForChunksToInsertAfter: [KN_BuildChunkIdentifierArchive] = []

  var tuplesToUpdate: [TSP_Reference] = []

  var fallbackChunkIdentifiers: [KN_BuildChunkIdentifierArchive] = []

  var isForPaste: Bool {
    get {return _isForPaste ?? false}
    set {_isForPaste = newValue}
  }
  /// Returns true if `isForPaste` has been explicitly set.
  var hasIsForPaste: Bool {return self._isForPaste != nil}
  /// Clears the value of `isForPaste`. Subsequent reads from it will return its default value.
  mutating func clearIsForPaste() {self._isForPaste = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _slideID: TSP_UUID? = nil
  fileprivate var _buildToInsert: TSP_Reference? = nil
  fileprivate var _shouldAssignChunkIdentifiers: Bool? = nil
  fileprivate var _isForPaste: Bool? = nil
}

struct KN_UndoObjectArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_UndoObjectArchive {
    get {return _super ?? TSD_UndoObjectArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_UndoObjectArchive? = nil
}

struct KN_CommandSlideRemoveBuildArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var removeBuildDescription: TSP_Reference {
    get {return _storage._removeBuildDescription ?? TSP_Reference()}
    set {_uniqueStorage()._removeBuildDescription = newValue}
  }
  /// Returns true if `removeBuildDescription` has been explicitly set.
  var hasRemoveBuildDescription: Bool {return _storage._removeBuildDescription != nil}
  /// Clears the value of `removeBuildDescription`. Subsequent reads from it will return its default value.
  mutating func clearRemoveBuildDescription() {_uniqueStorage()._removeBuildDescription = nil}

  var build: TSP_Reference {
    get {return _storage._build ?? TSP_Reference()}
    set {_uniqueStorage()._build = newValue}
  }
  /// Returns true if `build` has been explicitly set.
  var hasBuild: Bool {return _storage._build != nil}
  /// Clears the value of `build`. Subsequent reads from it will return its default value.
  mutating func clearBuild() {_uniqueStorage()._build = nil}

  var chunksToInsert: [TSP_Reference] {
    get {return _storage._chunksToInsert}
    set {_uniqueStorage()._chunksToInsert = newValue}
  }

  var identifiersForChunksToInsertAfter: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._identifiersForChunksToInsertAfter}
    set {_uniqueStorage()._identifiersForChunksToInsertAfter = newValue}
  }

  var oldTuplesToUpdate: [TSP_Reference] {
    get {return _storage._oldTuplesToUpdate}
    set {_uniqueStorage()._oldTuplesToUpdate = newValue}
  }

  var fallbackChunkIdentifiers: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._fallbackChunkIdentifiers}
    set {_uniqueStorage()._fallbackChunkIdentifiers = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_RemoveBuildDescriptionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var slideID: TSP_UUID {
    get {return _slideID ?? TSP_UUID()}
    set {_slideID = newValue}
  }
  /// Returns true if `slideID` has been explicitly set.
  var hasSlideID: Bool {return self._slideID != nil}
  /// Clears the value of `slideID`. Subsequent reads from it will return its default value.
  mutating func clearSlideID() {self._slideID = nil}

  var buildID: TSP_UUID {
    get {return _buildID ?? TSP_UUID()}
    set {_buildID = newValue}
  }
  /// Returns true if `buildID` has been explicitly set.
  var hasBuildID: Bool {return self._buildID != nil}
  /// Clears the value of `buildID`. Subsequent reads from it will return its default value.
  mutating func clearBuildID() {self._buildID = nil}

  var shouldRemoveChunks: Bool {
    get {return _shouldRemoveChunks ?? false}
    set {_shouldRemoveChunks = newValue}
  }
  /// Returns true if `shouldRemoveChunks` has been explicitly set.
  var hasShouldRemoveChunks: Bool {return self._shouldRemoveChunks != nil}
  /// Clears the value of `shouldRemoveChunks`. Subsequent reads from it will return its default value.
  mutating func clearShouldRemoveChunks() {self._shouldRemoveChunks = nil}

  var shouldRemoveChunkIdentifiers: Bool {
    get {return _shouldRemoveChunkIdentifiers ?? false}
    set {_shouldRemoveChunkIdentifiers = newValue}
  }
  /// Returns true if `shouldRemoveChunkIdentifiers` has been explicitly set.
  var hasShouldRemoveChunkIdentifiers: Bool {return self._shouldRemoveChunkIdentifiers != nil}
  /// Clears the value of `shouldRemoveChunkIdentifiers`. Subsequent reads from it will return its default value.
  mutating func clearShouldRemoveChunkIdentifiers() {self._shouldRemoveChunkIdentifiers = nil}

  var tuplesToUpdate: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _slideID: TSP_UUID? = nil
  fileprivate var _buildID: TSP_UUID? = nil
  fileprivate var _shouldRemoveChunks: Bool? = nil
  fileprivate var _shouldRemoveChunkIdentifiers: Bool? = nil
}

struct KN_CommandSlideInsertBuildChunkArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var slideID: TSP_UUID {
    get {return _storage._slideID ?? TSP_UUID()}
    set {_uniqueStorage()._slideID = newValue}
  }
  /// Returns true if `slideID` has been explicitly set.
  var hasSlideID: Bool {return _storage._slideID != nil}
  /// Clears the value of `slideID`. Subsequent reads from it will return its default value.
  mutating func clearSlideID() {_uniqueStorage()._slideID = nil}

  var chunkToInsert: TSP_Reference {
    get {return _storage._chunkToInsert ?? TSP_Reference()}
    set {_uniqueStorage()._chunkToInsert = newValue}
  }
  /// Returns true if `chunkToInsert` has been explicitly set.
  var hasChunkToInsert: Bool {return _storage._chunkToInsert != nil}
  /// Clears the value of `chunkToInsert`. Subsequent reads from it will return its default value.
  mutating func clearChunkToInsert() {_uniqueStorage()._chunkToInsert = nil}

  var identifierForChunkToInsertAfter: KN_BuildChunkIdentifierArchive {
    get {return _storage._identifierForChunkToInsertAfter ?? KN_BuildChunkIdentifierArchive()}
    set {_uniqueStorage()._identifierForChunkToInsertAfter = newValue}
  }
  /// Returns true if `identifierForChunkToInsertAfter` has been explicitly set.
  var hasIdentifierForChunkToInsertAfter: Bool {return _storage._identifierForChunkToInsertAfter != nil}
  /// Clears the value of `identifierForChunkToInsertAfter`. Subsequent reads from it will return its default value.
  mutating func clearIdentifierForChunkToInsertAfter() {_uniqueStorage()._identifierForChunkToInsertAfter = nil}

  var tuplesToUpdate: [TSP_Reference] {
    get {return _storage._tuplesToUpdate}
    set {_uniqueStorage()._tuplesToUpdate = newValue}
  }

  var oldTuplesToUpdate: [TSP_Reference] {
    get {return _storage._oldTuplesToUpdate}
    set {_uniqueStorage()._oldTuplesToUpdate = newValue}
  }

  var needsSelectionUpdate: Bool {
    get {return _storage._needsSelectionUpdate ?? false}
    set {_uniqueStorage()._needsSelectionUpdate = newValue}
  }
  /// Returns true if `needsSelectionUpdate` has been explicitly set.
  var hasNeedsSelectionUpdate: Bool {return _storage._needsSelectionUpdate != nil}
  /// Clears the value of `needsSelectionUpdate`. Subsequent reads from it will return its default value.
  mutating func clearNeedsSelectionUpdate() {_uniqueStorage()._needsSelectionUpdate = nil}

  var shouldAssignChunkIdentifier: Bool {
    get {return _storage._shouldAssignChunkIdentifier ?? false}
    set {_uniqueStorage()._shouldAssignChunkIdentifier = newValue}
  }
  /// Returns true if `shouldAssignChunkIdentifier` has been explicitly set.
  var hasShouldAssignChunkIdentifier: Bool {return _storage._shouldAssignChunkIdentifier != nil}
  /// Clears the value of `shouldAssignChunkIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearShouldAssignChunkIdentifier() {_uniqueStorage()._shouldAssignChunkIdentifier = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandSlideRemoveBuildChunkArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var slideID: TSP_UUID {
    get {return _storage._slideID ?? TSP_UUID()}
    set {_uniqueStorage()._slideID = newValue}
  }
  /// Returns true if `slideID` has been explicitly set.
  var hasSlideID: Bool {return _storage._slideID != nil}
  /// Clears the value of `slideID`. Subsequent reads from it will return its default value.
  mutating func clearSlideID() {_uniqueStorage()._slideID = nil}

  var removedChunk: TSP_Reference {
    get {return _storage._removedChunk ?? TSP_Reference()}
    set {_uniqueStorage()._removedChunk = newValue}
  }
  /// Returns true if `removedChunk` has been explicitly set.
  var hasRemovedChunk: Bool {return _storage._removedChunk != nil}
  /// Clears the value of `removedChunk`. Subsequent reads from it will return its default value.
  mutating func clearRemovedChunk() {_uniqueStorage()._removedChunk = nil}

  var identifierForChunkToRemove: KN_BuildChunkIdentifierArchive {
    get {return _storage._identifierForChunkToRemove ?? KN_BuildChunkIdentifierArchive()}
    set {_uniqueStorage()._identifierForChunkToRemove = newValue}
  }
  /// Returns true if `identifierForChunkToRemove` has been explicitly set.
  var hasIdentifierForChunkToRemove: Bool {return _storage._identifierForChunkToRemove != nil}
  /// Clears the value of `identifierForChunkToRemove`. Subsequent reads from it will return its default value.
  mutating func clearIdentifierForChunkToRemove() {_uniqueStorage()._identifierForChunkToRemove = nil}

  var identifierForChunkToInsertAfter: KN_BuildChunkIdentifierArchive {
    get {return _storage._identifierForChunkToInsertAfter ?? KN_BuildChunkIdentifierArchive()}
    set {_uniqueStorage()._identifierForChunkToInsertAfter = newValue}
  }
  /// Returns true if `identifierForChunkToInsertAfter` has been explicitly set.
  var hasIdentifierForChunkToInsertAfter: Bool {return _storage._identifierForChunkToInsertAfter != nil}
  /// Clears the value of `identifierForChunkToInsertAfter`. Subsequent reads from it will return its default value.
  mutating func clearIdentifierForChunkToInsertAfter() {_uniqueStorage()._identifierForChunkToInsertAfter = nil}

  var tuplesToUpdate: [TSP_Reference] {
    get {return _storage._tuplesToUpdate}
    set {_uniqueStorage()._tuplesToUpdate = newValue}
  }

  var oldTuplesToUpdate: [TSP_Reference] {
    get {return _storage._oldTuplesToUpdate}
    set {_uniqueStorage()._oldTuplesToUpdate = newValue}
  }

  var needsSelectionUpdate: Bool {
    get {return _storage._needsSelectionUpdate ?? false}
    set {_uniqueStorage()._needsSelectionUpdate = newValue}
  }
  /// Returns true if `needsSelectionUpdate` has been explicitly set.
  var hasNeedsSelectionUpdate: Bool {return _storage._needsSelectionUpdate != nil}
  /// Clears the value of `needsSelectionUpdate`. Subsequent reads from it will return its default value.
  mutating func clearNeedsSelectionUpdate() {_uniqueStorage()._needsSelectionUpdate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandSlideMoveBuildChunksArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var identifiersForChunksToMove: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._identifiersForChunksToMove}
    set {_uniqueStorage()._identifiersForChunksToMove = newValue}
  }

  var identifiersForChunksToMoveAfter: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._identifiersForChunksToMoveAfter}
    set {_uniqueStorage()._identifiersForChunksToMoveAfter = newValue}
  }

  var identifiersForChunksToMoveAfterForUndo: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._identifiersForChunksToMoveAfterForUndo}
    set {_uniqueStorage()._identifiersForChunksToMoveAfterForUndo = newValue}
  }

  var tuplesToUpdate: [TSP_Reference] {
    get {return _storage._tuplesToUpdate}
    set {_uniqueStorage()._tuplesToUpdate = newValue}
  }

  var oldTuplesToUpdate: [TSP_Reference] {
    get {return _storage._oldTuplesToUpdate}
    set {_uniqueStorage()._oldTuplesToUpdate = newValue}
  }

  var identifiersForChunksToMoveIncludingClusteredInactiveChunks: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._identifiersForChunksToMoveIncludingClusteredInactiveChunks}
    set {_uniqueStorage()._identifiersForChunksToMoveIncludingClusteredInactiveChunks = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandBuildSetValueArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var tuple: TSP_Reference {
    get {return _storage._tuple ?? TSP_Reference()}
    set {_uniqueStorage()._tuple = newValue}
  }
  /// Returns true if `tuple` has been explicitly set.
  var hasTuple: Bool {return _storage._tuple != nil}
  /// Clears the value of `tuple`. Subsequent reads from it will return its default value.
  mutating func clearTuple() {_uniqueStorage()._tuple = nil}

  var chunksToAdd: [TSP_Reference] {
    get {return _storage._chunksToAdd}
    set {_uniqueStorage()._chunksToAdd = newValue}
  }

  var identifiersForChunksToInsertAfter: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._identifiersForChunksToInsertAfter}
    set {_uniqueStorage()._identifiersForChunksToInsertAfter = newValue}
  }

  var identifiersForChunksToRemove: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._identifiersForChunksToRemove}
    set {_uniqueStorage()._identifiersForChunksToRemove = newValue}
  }

  var tuplesToUpdate: [TSP_Reference] {
    get {return _storage._tuplesToUpdate}
    set {_uniqueStorage()._tuplesToUpdate = newValue}
  }

  var oldTupleForMainProperty: TSP_Reference {
    get {return _storage._oldTupleForMainProperty ?? TSP_Reference()}
    set {_uniqueStorage()._oldTupleForMainProperty = newValue}
  }
  /// Returns true if `oldTupleForMainProperty` has been explicitly set.
  var hasOldTupleForMainProperty: Bool {return _storage._oldTupleForMainProperty != nil}
  /// Clears the value of `oldTupleForMainProperty`. Subsequent reads from it will return its default value.
  mutating func clearOldTupleForMainProperty() {_uniqueStorage()._oldTupleForMainProperty = nil}

  var oldTuplesToUpdateForSubCommands: [TSP_Reference] {
    get {return _storage._oldTuplesToUpdateForSubCommands}
    set {_uniqueStorage()._oldTuplesToUpdateForSubCommands = newValue}
  }

  var identifiersForAddedChunks: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._identifiersForAddedChunks}
    set {_uniqueStorage()._identifiersForAddedChunks = newValue}
  }

  var generatedIdentifiers: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._generatedIdentifiers}
    set {_uniqueStorage()._generatedIdentifiers = newValue}
  }

  var removedChunks: [TSP_Reference] {
    get {return _storage._removedChunks}
    set {_uniqueStorage()._removedChunks = newValue}
  }

  var identifiersForChunksPriorToRemovedChunks: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._identifiersForChunksPriorToRemovedChunks}
    set {_uniqueStorage()._identifiersForChunksPriorToRemovedChunks = newValue}
  }

  var oldChunkIDSeed: UInt32 {
    get {return _storage._oldChunkIDSeed ?? 0}
    set {_uniqueStorage()._oldChunkIDSeed = newValue}
  }
  /// Returns true if `oldChunkIDSeed` has been explicitly set.
  var hasOldChunkIDSeed: Bool {return _storage._oldChunkIDSeed != nil}
  /// Clears the value of `oldChunkIDSeed`. Subsequent reads from it will return its default value.
  mutating func clearOldChunkIDSeed() {_uniqueStorage()._oldChunkIDSeed = nil}

  var oldChunkIdentifiers: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._oldChunkIdentifiers}
    set {_uniqueStorage()._oldChunkIdentifiers = newValue}
  }

  var chunksRemovedDuringUndo: [TSP_Reference] {
    get {return _storage._chunksRemovedDuringUndo}
    set {_uniqueStorage()._chunksRemovedDuringUndo = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandBuildUpdateChunkReferentsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var buildID: TSP_UUID {
    get {return _buildID ?? TSP_UUID()}
    set {_buildID = newValue}
  }
  /// Returns true if `buildID` has been explicitly set.
  var hasBuildID: Bool {return self._buildID != nil}
  /// Clears the value of `buildID`. Subsequent reads from it will return its default value.
  mutating func clearBuildID() {self._buildID = nil}

  var tuplesToUpdate: [TSP_Reference] = []

  var oldTuplesToUpdate: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _buildID: TSP_UUID? = nil
}

struct KN_CommandBuildUpdateChunkCountArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var slideID: TSP_UUID {
    get {return _storage._slideID ?? TSP_UUID()}
    set {_uniqueStorage()._slideID = newValue}
  }
  /// Returns true if `slideID` has been explicitly set.
  var hasSlideID: Bool {return _storage._slideID != nil}
  /// Clears the value of `slideID`. Subsequent reads from it will return its default value.
  mutating func clearSlideID() {_uniqueStorage()._slideID = nil}

  var drawableIds: [TSP_UUID] {
    get {return _storage._drawableIds}
    set {_uniqueStorage()._drawableIds = newValue}
  }

  var expectedDeliveryStyleTuples: [TSP_Reference] {
    get {return _storage._expectedDeliveryStyleTuples}
    set {_uniqueStorage()._expectedDeliveryStyleTuples = newValue}
  }

  var chunksToAdd: [TSP_Reference] {
    get {return _storage._chunksToAdd}
    set {_uniqueStorage()._chunksToAdd = newValue}
  }

  var identifiersForChunksToInsertAfter: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._identifiersForChunksToInsertAfter}
    set {_uniqueStorage()._identifiersForChunksToInsertAfter = newValue}
  }

  var identifiersForChunksToRemove: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._identifiersForChunksToRemove}
    set {_uniqueStorage()._identifiersForChunksToRemove = newValue}
  }

  var tuplesToUpdate: [TSP_Reference] {
    get {return _storage._tuplesToUpdate}
    set {_uniqueStorage()._tuplesToUpdate = newValue}
  }

  var needsAsyncProcessChangesSelectionUpdate: Bool {
    get {return _storage._needsAsyncProcessChangesSelectionUpdate ?? false}
    set {_uniqueStorage()._needsAsyncProcessChangesSelectionUpdate = newValue}
  }
  /// Returns true if `needsAsyncProcessChangesSelectionUpdate` has been explicitly set.
  var hasNeedsAsyncProcessChangesSelectionUpdate: Bool {return _storage._needsAsyncProcessChangesSelectionUpdate != nil}
  /// Clears the value of `needsAsyncProcessChangesSelectionUpdate`. Subsequent reads from it will return its default value.
  mutating func clearNeedsAsyncProcessChangesSelectionUpdate() {_uniqueStorage()._needsAsyncProcessChangesSelectionUpdate = nil}

  var oldTuplesToUpdate: [TSP_Reference] {
    get {return _storage._oldTuplesToUpdate}
    set {_uniqueStorage()._oldTuplesToUpdate = newValue}
  }

  var identifiersForAddedChunks: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._identifiersForAddedChunks}
    set {_uniqueStorage()._identifiersForAddedChunks = newValue}
  }

  var generatedIdentifiers: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._generatedIdentifiers}
    set {_uniqueStorage()._generatedIdentifiers = newValue}
  }

  var removedChunks: [TSP_Reference] {
    get {return _storage._removedChunks}
    set {_uniqueStorage()._removedChunks = newValue}
  }

  var identifiersForChunksPriorToRemovedChunks: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._identifiersForChunksPriorToRemovedChunks}
    set {_uniqueStorage()._identifiersForChunksPriorToRemovedChunks = newValue}
  }

  var oldDeliveryStyleTuples: [TSP_Reference] {
    get {return _storage._oldDeliveryStyleTuples}
    set {_uniqueStorage()._oldDeliveryStyleTuples = newValue}
  }

  var oldChunkIDSeeds: [UInt32] {
    get {return _storage._oldChunkIDSeeds}
    set {_uniqueStorage()._oldChunkIDSeeds = newValue}
  }

  var oldChunkIdentifiers: [KN_BuildChunkIdentifierArchive] {
    get {return _storage._oldChunkIdentifiers}
    set {_uniqueStorage()._oldChunkIdentifiers = newValue}
  }

  var workingBuilds: [TSP_Reference] {
    get {return _storage._workingBuilds}
    set {_uniqueStorage()._workingBuilds = newValue}
  }

  var chunksRemovedDuringUndo: [TSP_Reference] {
    get {return _storage._chunksRemovedDuringUndo}
    set {_uniqueStorage()._chunksRemovedDuringUndo = newValue}
  }

  var chunksAddedDuringUndo: [TSP_Reference] {
    get {return _storage._chunksAddedDuringUndo}
    set {_uniqueStorage()._chunksAddedDuringUndo = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandBuildChunkSetValueArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var tuplesToUpdate: [TSP_Reference] = []

  var oldTuplesToUpdate: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
}

struct KN_CommandTransitionSetValueArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideNodeIDPath: TSP_UUIDPath {
    get {return _slideNodeIDPath ?? TSP_UUIDPath()}
    set {_slideNodeIDPath = newValue}
  }
  /// Returns true if `slideNodeIDPath` has been explicitly set.
  var hasSlideNodeIDPath: Bool {return self._slideNodeIDPath != nil}
  /// Clears the value of `slideNodeIDPath`. Subsequent reads from it will return its default value.
  mutating func clearSlideNodeIDPath() {self._slideNodeIDPath = nil}

  var oldAttributes: KN_TransitionAttributesArchive {
    get {return _oldAttributes ?? KN_TransitionAttributesArchive()}
    set {_oldAttributes = newValue}
  }
  /// Returns true if `oldAttributes` has been explicitly set.
  var hasOldAttributes: Bool {return self._oldAttributes != nil}
  /// Clears the value of `oldAttributes`. Subsequent reads from it will return its default value.
  mutating func clearOldAttributes() {self._oldAttributes = nil}

  var attributes: KN_TransitionAttributesArchive {
    get {return _attributes ?? KN_TransitionAttributesArchive()}
    set {_attributes = newValue}
  }
  /// Returns true if `attributes` has been explicitly set.
  var hasAttributes: Bool {return self._attributes != nil}
  /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
  mutating func clearAttributes() {self._attributes = nil}

  var property: String {
    get {return _property ?? String()}
    set {_property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return self._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {self._property = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideNodeIDPath: TSP_UUIDPath? = nil
  fileprivate var _oldAttributes: KN_TransitionAttributesArchive? = nil
  fileprivate var _attributes: KN_TransitionAttributesArchive? = nil
  fileprivate var _property: String? = nil
}

struct KN_CommandShowSetSlideNumberVisibilityArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideNumbersVisible: Bool {
    get {return _slideNumbersVisible ?? false}
    set {_slideNumbersVisible = newValue}
  }
  /// Returns true if `slideNumbersVisible` has been explicitly set.
  var hasSlideNumbersVisible: Bool {return self._slideNumbersVisible != nil}
  /// Clears the value of `slideNumbersVisible`. Subsequent reads from it will return its default value.
  mutating func clearSlideNumbersVisible() {self._slideNumbersVisible = nil}

  var idsOfSlideNodesToSkip: [TSP_UUID] = []

  var idsOfSlideNodesAlreadyCorrect: [TSP_UUID] = []

  var isUndo: Bool {
    get {return _isUndo ?? false}
    set {_isUndo = newValue}
  }
  /// Returns true if `isUndo` has been explicitly set.
  var hasIsUndo: Bool {return self._isUndo != nil}
  /// Clears the value of `isUndo`. Subsequent reads from it will return its default value.
  mutating func clearIsUndo() {self._isUndo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideNumbersVisible: Bool? = nil
  fileprivate var _isUndo: Bool? = nil
}

struct KN_CommandTemplateSetThumbnailTextArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var templateID: TSP_UUID {
    get {return _templateID ?? TSP_UUID()}
    set {_templateID = newValue}
  }
  /// Returns true if `templateID` has been explicitly set.
  var hasTemplateID: Bool {return self._templateID != nil}
  /// Clears the value of `templateID`. Subsequent reads from it will return its default value.
  mutating func clearTemplateID() {self._templateID = nil}

  var isBody: Bool {
    get {return _isBody ?? false}
    set {_isBody = newValue}
  }
  /// Returns true if `isBody` has been explicitly set.
  var hasIsBody: Bool {return self._isBody != nil}
  /// Clears the value of `isBody`. Subsequent reads from it will return its default value.
  mutating func clearIsBody() {self._isBody = nil}

  var newText: String {
    get {return _newText ?? String()}
    set {_newText = newValue}
  }
  /// Returns true if `newText` has been explicitly set.
  var hasNewText: Bool {return self._newText != nil}
  /// Clears the value of `newText`. Subsequent reads from it will return its default value.
  mutating func clearNewText() {self._newText = nil}

  var oldText: String {
    get {return _oldText ?? String()}
    set {_oldText = newValue}
  }
  /// Returns true if `oldText` has been explicitly set.
  var hasOldText: Bool {return self._oldText != nil}
  /// Clears the value of `oldText`. Subsequent reads from it will return its default value.
  mutating func clearOldText() {self._oldText = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _templateID: TSP_UUID? = nil
  fileprivate var _isBody: Bool? = nil
  fileprivate var _newText: String? = nil
  fileprivate var _oldText: String? = nil
}

struct KN_CommandTemplateSetBodyStylesArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var templateID: TSP_UUID {
    get {return _storage._templateID ?? TSP_UUID()}
    set {_uniqueStorage()._templateID = newValue}
  }
  /// Returns true if `templateID` has been explicitly set.
  var hasTemplateID: Bool {return _storage._templateID != nil}
  /// Clears the value of `templateID`. Subsequent reads from it will return its default value.
  mutating func clearTemplateID() {_uniqueStorage()._templateID = nil}

  var newParagraphStyles: [TSP_Reference] {
    get {return _storage._newParagraphStyles}
    set {_uniqueStorage()._newParagraphStyles = newValue}
  }

  var newListStyles: [TSP_Reference] {
    get {return _storage._newListStyles}
    set {_uniqueStorage()._newListStyles = newValue}
  }

  var oldParagraphStyles: [TSP_Reference] {
    get {return _storage._oldParagraphStyles}
    set {_uniqueStorage()._oldParagraphStyles = newValue}
  }

  var oldListStyles: [TSP_Reference] {
    get {return _storage._oldListStyles}
    set {_uniqueStorage()._oldListStyles = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandChangeTemplateSlideArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var slideIDPath: TSP_UUIDPath {
    get {return _storage._slideIDPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._slideIDPath = newValue}
  }
  /// Returns true if `slideIDPath` has been explicitly set.
  var hasSlideIDPath: Bool {return _storage._slideIDPath != nil}
  /// Clears the value of `slideIDPath`. Subsequent reads from it will return its default value.
  mutating func clearSlideIDPath() {_uniqueStorage()._slideIDPath = nil}

  var templateSlideNode: TSP_Reference {
    get {return _storage._templateSlideNode ?? TSP_Reference()}
    set {_uniqueStorage()._templateSlideNode = newValue}
  }
  /// Returns true if `templateSlideNode` has been explicitly set.
  var hasTemplateSlideNode: Bool {return _storage._templateSlideNode != nil}
  /// Clears the value of `templateSlideNode`. Subsequent reads from it will return its default value.
  mutating func clearTemplateSlideNode() {_uniqueStorage()._templateSlideNode = nil}

  var oldTemplateSlideNode: TSP_Reference {
    get {return _storage._oldTemplateSlideNode ?? TSP_Reference()}
    set {_uniqueStorage()._oldTemplateSlideNode = newValue}
  }
  /// Returns true if `oldTemplateSlideNode` has been explicitly set.
  var hasOldTemplateSlideNode: Bool {return _storage._oldTemplateSlideNode != nil}
  /// Clears the value of `oldTemplateSlideNode`. Subsequent reads from it will return its default value.
  mutating func clearOldTemplateSlideNode() {_uniqueStorage()._oldTemplateSlideNode = nil}

  var isUndoRedo: Bool {
    get {return _storage._isUndoRedo ?? false}
    set {_uniqueStorage()._isUndoRedo = newValue}
  }
  /// Returns true if `isUndoRedo` has been explicitly set.
  var hasIsUndoRedo: Bool {return _storage._isUndoRedo != nil}
  /// Clears the value of `isUndoRedo`. Subsequent reads from it will return its default value.
  mutating func clearIsUndoRedo() {_uniqueStorage()._isUndoRedo = nil}

  var targetPrototype: TSP_Reference {
    get {return _storage._targetPrototype ?? TSP_Reference()}
    set {_uniqueStorage()._targetPrototype = newValue}
  }
  /// Returns true if `targetPrototype` has been explicitly set.
  var hasTargetPrototype: Bool {return _storage._targetPrototype != nil}
  /// Clears the value of `targetPrototype`. Subsequent reads from it will return its default value.
  mutating func clearTargetPrototype() {_uniqueStorage()._targetPrototype = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandSlidePrimitiveSetTemplateArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var slideIDPath: TSP_UUIDPath {
    get {return _storage._slideIDPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._slideIDPath = newValue}
  }
  /// Returns true if `slideIDPath` has been explicitly set.
  var hasSlideIDPath: Bool {return _storage._slideIDPath != nil}
  /// Clears the value of `slideIDPath`. Subsequent reads from it will return its default value.
  mutating func clearSlideIDPath() {_uniqueStorage()._slideIDPath = nil}

  var templateID: TSP_UUID {
    get {return _storage._templateID ?? TSP_UUID()}
    set {_uniqueStorage()._templateID = newValue}
  }
  /// Returns true if `templateID` has been explicitly set.
  var hasTemplateID: Bool {return _storage._templateID != nil}
  /// Clears the value of `templateID`. Subsequent reads from it will return its default value.
  mutating func clearTemplateID() {_uniqueStorage()._templateID = nil}

  var oldTemplateSlideNode: TSP_Reference {
    get {return _storage._oldTemplateSlideNode ?? TSP_Reference()}
    set {_uniqueStorage()._oldTemplateSlideNode = newValue}
  }
  /// Returns true if `oldTemplateSlideNode` has been explicitly set.
  var hasOldTemplateSlideNode: Bool {return _storage._oldTemplateSlideNode != nil}
  /// Clears the value of `oldTemplateSlideNode`. Subsequent reads from it will return its default value.
  mutating func clearOldTemplateSlideNode() {_uniqueStorage()._oldTemplateSlideNode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandSlideResetTemplateBackgroundObjectsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideIDPath: TSP_UUIDPath {
    get {return _slideIDPath ?? TSP_UUIDPath()}
    set {_slideIDPath = newValue}
  }
  /// Returns true if `slideIDPath` has been explicitly set.
  var hasSlideIDPath: Bool {return self._slideIDPath != nil}
  /// Clears the value of `slideIDPath`. Subsequent reads from it will return its default value.
  mutating func clearSlideIDPath() {self._slideIDPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideIDPath: TSP_UUIDPath? = nil
}

struct KN_CommandShowSetSoundtrack: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var show: TSP_Reference {
    get {return _storage._show ?? TSP_Reference()}
    set {_uniqueStorage()._show = newValue}
  }
  /// Returns true if `show` has been explicitly set.
  var hasShow: Bool {return _storage._show != nil}
  /// Clears the value of `show`. Subsequent reads from it will return its default value.
  mutating func clearShow() {_uniqueStorage()._show = nil}

  var soundtrack: TSP_Reference {
    get {return _storage._soundtrack ?? TSP_Reference()}
    set {_uniqueStorage()._soundtrack = newValue}
  }
  /// Returns true if `soundtrack` has been explicitly set.
  var hasSoundtrack: Bool {return _storage._soundtrack != nil}
  /// Clears the value of `soundtrack`. Subsequent reads from it will return its default value.
  mutating func clearSoundtrack() {_uniqueStorage()._soundtrack = nil}

  var oldSoundtrack: TSP_Reference {
    get {return _storage._oldSoundtrack ?? TSP_Reference()}
    set {_uniqueStorage()._oldSoundtrack = newValue}
  }
  /// Returns true if `oldSoundtrack` has been explicitly set.
  var hasOldSoundtrack: Bool {return _storage._oldSoundtrack != nil}
  /// Clears the value of `oldSoundtrack`. Subsequent reads from it will return its default value.
  mutating func clearOldSoundtrack() {_uniqueStorage()._oldSoundtrack = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandSoundtrackSetValue: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var soundtrackID: TSP_UUID {
    get {return _storage._soundtrackID ?? TSP_UUID()}
    set {_uniqueStorage()._soundtrackID = newValue}
  }
  /// Returns true if `soundtrackID` has been explicitly set.
  var hasSoundtrackID: Bool {return _storage._soundtrackID != nil}
  /// Clears the value of `soundtrackID`. Subsequent reads from it will return its default value.
  mutating func clearSoundtrackID() {_uniqueStorage()._soundtrackID = nil}

  var property: String {
    get {return _storage._property ?? String()}
    set {_uniqueStorage()._property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return _storage._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {_uniqueStorage()._property = nil}

  var oldValue: KN_CommandSoundtrackSetValue.PropertyValue {
    get {return _storage._oldValue ?? KN_CommandSoundtrackSetValue.PropertyValue()}
    set {_uniqueStorage()._oldValue = newValue}
  }
  /// Returns true if `oldValue` has been explicitly set.
  var hasOldValue: Bool {return _storage._oldValue != nil}
  /// Clears the value of `oldValue`. Subsequent reads from it will return its default value.
  mutating func clearOldValue() {_uniqueStorage()._oldValue = nil}

  var newValue: KN_CommandSoundtrackSetValue.PropertyValue {
    get {return _storage._newValue ?? KN_CommandSoundtrackSetValue.PropertyValue()}
    set {_uniqueStorage()._newValue = newValue}
  }
  /// Returns true if `newValue` has been explicitly set.
  var hasNewValue: Bool {return _storage._newValue != nil}
  /// Clears the value of `newValue`. Subsequent reads from it will return its default value.
  mutating func clearNewValue() {_uniqueStorage()._newValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PropertyValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var doubleValue: Double {
      get {return _doubleValue ?? 0}
      set {_doubleValue = newValue}
    }
    /// Returns true if `doubleValue` has been explicitly set.
    var hasDoubleValue: Bool {return self._doubleValue != nil}
    /// Clears the value of `doubleValue`. Subsequent reads from it will return its default value.
    mutating func clearDoubleValue() {self._doubleValue = nil}

    var modeValue: KN_Soundtrack.SoundtrackMode {
      get {return _modeValue ?? .kKnsoundtrackModePlayOnce}
      set {_modeValue = newValue}
    }
    /// Returns true if `modeValue` has been explicitly set.
    var hasModeValue: Bool {return self._modeValue != nil}
    /// Clears the value of `modeValue`. Subsequent reads from it will return its default value.
    mutating func clearModeValue() {self._modeValue = nil}

    var mediaReferenceValues: [TSP_DataReference] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _doubleValue: Double? = nil
    fileprivate var _modeValue: KN_Soundtrack.SoundtrackMode? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandSlideUpdateTemplateDrawables: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var slideID: TSP_UUID {
    get {return _slideID ?? TSP_UUID()}
    set {_slideID = newValue}
  }
  /// Returns true if `slideID` has been explicitly set.
  var hasSlideID: Bool {return self._slideID != nil}
  /// Clears the value of `slideID`. Subsequent reads from it will return its default value.
  mutating func clearSlideID() {self._slideID = nil}

  var idPlacementOperationArgs: [TSCK_IdPlacementOperationArgs] = []

  var oldChildInfosForUndo: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _slideID: TSP_UUID? = nil
}

struct KN_ChartInfoGeometryCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoGeometryCommandArchive {
    get {return _super ?? TSD_InfoGeometryCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var previousLegendOffset: TSP_Point {
    get {return _previousLegendOffset ?? TSP_Point()}
    set {_previousLegendOffset = newValue}
  }
  /// Returns true if `previousLegendOffset` has been explicitly set.
  var hasPreviousLegendOffset: Bool {return self._previousLegendOffset != nil}
  /// Clears the value of `previousLegendOffset`. Subsequent reads from it will return its default value.
  mutating func clearPreviousLegendOffset() {self._previousLegendOffset = nil}

  var previousLegendSize: TSP_Size {
    get {return _previousLegendSize ?? TSP_Size()}
    set {_previousLegendSize = newValue}
  }
  /// Returns true if `previousLegendSize` has been explicitly set.
  var hasPreviousLegendSize: Bool {return self._previousLegendSize != nil}
  /// Clears the value of `previousLegendSize`. Subsequent reads from it will return its default value.
  mutating func clearPreviousLegendSize() {self._previousLegendSize = nil}

  var adjustedLegendOffset: TSP_Point {
    get {return _adjustedLegendOffset ?? TSP_Point()}
    set {_adjustedLegendOffset = newValue}
  }
  /// Returns true if `adjustedLegendOffset` has been explicitly set.
  var hasAdjustedLegendOffset: Bool {return self._adjustedLegendOffset != nil}
  /// Clears the value of `adjustedLegendOffset`. Subsequent reads from it will return its default value.
  mutating func clearAdjustedLegendOffset() {self._adjustedLegendOffset = nil}

  var adjustedLegendSize: TSP_Size {
    get {return _adjustedLegendSize ?? TSP_Size()}
    set {_adjustedLegendSize = newValue}
  }
  /// Returns true if `adjustedLegendSize` has been explicitly set.
  var hasAdjustedLegendSize: Bool {return self._adjustedLegendSize != nil}
  /// Clears the value of `adjustedLegendSize`. Subsequent reads from it will return its default value.
  mutating func clearAdjustedLegendSize() {self._adjustedLegendSize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_InfoGeometryCommandArchive? = nil
  fileprivate var _previousLegendOffset: TSP_Point? = nil
  fileprivate var _previousLegendSize: TSP_Size? = nil
  fileprivate var _adjustedLegendOffset: TSP_Point? = nil
  fileprivate var _adjustedLegendSize: TSP_Size? = nil
}

struct KN_CanvasSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transformerHelper: TSD_InfoCollectionSelectionTransformerHelperArchive {
    get {return _transformerHelper ?? TSD_InfoCollectionSelectionTransformerHelperArchive()}
    set {_transformerHelper = newValue}
  }
  /// Returns true if `transformerHelper` has been explicitly set.
  var hasTransformerHelper: Bool {return self._transformerHelper != nil}
  /// Clears the value of `transformerHelper`. Subsequent reads from it will return its default value.
  mutating func clearTransformerHelper() {self._transformerHelper = nil}

  var buildChunkIds: [KN_BuildChunkIdentifierArchive] = []

  var actionBuildIds: [TSP_UUID] = []

  var originallySelectedDrawableUuids: [TSP_UUID] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transformerHelper: TSD_InfoCollectionSelectionTransformerHelperArchive? = nil
}

struct KN_ActionGhostSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct KN_DocumentSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var documentSelection: TSP_Reference {
    get {return _documentSelection ?? TSP_Reference()}
    set {_documentSelection = newValue}
  }
  /// Returns true if `documentSelection` has been explicitly set.
  var hasDocumentSelection: Bool {return self._documentSelection != nil}
  /// Clears the value of `documentSelection`. Subsequent reads from it will return its default value.
  mutating func clearDocumentSelection() {self._documentSelection = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _documentSelection: TSP_Reference? = nil
}

struct KN_NoteCanvasSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transformerHelper: TSD_InfoCollectionSelectionTransformerHelperArchive {
    get {return _transformerHelper ?? TSD_InfoCollectionSelectionTransformerHelperArchive()}
    set {_transformerHelper = newValue}
  }
  /// Returns true if `transformerHelper` has been explicitly set.
  var hasTransformerHelper: Bool {return self._transformerHelper != nil}
  /// Clears the value of `transformerHelper`. Subsequent reads from it will return its default value.
  mutating func clearTransformerHelper() {self._transformerHelper = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transformerHelper: TSD_InfoCollectionSelectionTransformerHelperArchive? = nil
}

struct KN_OutlineCanvasSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var canvasSelectionTransformer: TSP_Reference {
    get {return _canvasSelectionTransformer ?? TSP_Reference()}
    set {_canvasSelectionTransformer = newValue}
  }
  /// Returns true if `canvasSelectionTransformer` has been explicitly set.
  var hasCanvasSelectionTransformer: Bool {return self._canvasSelectionTransformer != nil}
  /// Clears the value of `canvasSelectionTransformer`. Subsequent reads from it will return its default value.
  mutating func clearCanvasSelectionTransformer() {self._canvasSelectionTransformer = nil}

  var storageUuidPath: TSP_UUIDPath {
    get {return _storageUuidPath ?? TSP_UUIDPath()}
    set {_storageUuidPath = newValue}
  }
  /// Returns true if `storageUuidPath` has been explicitly set.
  var hasStorageUuidPath: Bool {return self._storageUuidPath != nil}
  /// Clears the value of `storageUuidPath`. Subsequent reads from it will return its default value.
  mutating func clearStorageUuidPath() {self._storageUuidPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _canvasSelectionTransformer: TSP_Reference? = nil
  fileprivate var _storageUuidPath: TSP_UUIDPath? = nil
}

struct KN_SlideCollectionSelectionTransformerHelperArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var slideNodes: [TSP_UUIDPath] = []

  var slideNodeToEdit: TSP_UUIDPath {
    get {return _slideNodeToEdit ?? TSP_UUIDPath()}
    set {_slideNodeToEdit = newValue}
  }
  /// Returns true if `slideNodeToEdit` has been explicitly set.
  var hasSlideNodeToEdit: Bool {return self._slideNodeToEdit != nil}
  /// Clears the value of `slideNodeToEdit`. Subsequent reads from it will return its default value.
  mutating func clearSlideNodeToEdit() {self._slideNodeToEdit = nil}

  var slideCollectionIsTheme: Bool {
    get {return _slideCollectionIsTheme ?? false}
    set {_slideCollectionIsTheme = newValue}
  }
  /// Returns true if `slideCollectionIsTheme` has been explicitly set.
  var hasSlideCollectionIsTheme: Bool {return self._slideCollectionIsTheme != nil}
  /// Clears the value of `slideCollectionIsTheme`. Subsequent reads from it will return its default value.
  mutating func clearSlideCollectionIsTheme() {self._slideCollectionIsTheme = nil}

  var previousPrimarySelectedIndex: UInt32 {
    get {return _previousPrimarySelectedIndex ?? 0}
    set {_previousPrimarySelectedIndex = newValue}
  }
  /// Returns true if `previousPrimarySelectedIndex` has been explicitly set.
  var hasPreviousPrimarySelectedIndex: Bool {return self._previousPrimarySelectedIndex != nil}
  /// Clears the value of `previousPrimarySelectedIndex`. Subsequent reads from it will return its default value.
  mutating func clearPreviousPrimarySelectedIndex() {self._previousPrimarySelectedIndex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _slideNodeToEdit: TSP_UUIDPath? = nil
  fileprivate var _slideCollectionIsTheme: Bool? = nil
  fileprivate var _previousPrimarySelectedIndex: UInt32? = nil
}

struct KN_SlideCollectionSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transformerHelper: KN_SlideCollectionSelectionTransformerHelperArchive {
    get {return _transformerHelper ?? KN_SlideCollectionSelectionTransformerHelperArchive()}
    set {_transformerHelper = newValue}
  }
  /// Returns true if `transformerHelper` has been explicitly set.
  var hasTransformerHelper: Bool {return self._transformerHelper != nil}
  /// Clears the value of `transformerHelper`. Subsequent reads from it will return its default value.
  mutating func clearTransformerHelper() {self._transformerHelper = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transformerHelper: KN_SlideCollectionSelectionTransformerHelperArchive? = nil
}

struct KN_OutlineSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transformerHelper: KN_SlideCollectionSelectionTransformerHelperArchive {
    get {return _transformerHelper ?? KN_SlideCollectionSelectionTransformerHelperArchive()}
    set {_transformerHelper = newValue}
  }
  /// Returns true if `transformerHelper` has been explicitly set.
  var hasTransformerHelper: Bool {return self._transformerHelper != nil}
  /// Clears the value of `transformerHelper`. Subsequent reads from it will return its default value.
  mutating func clearTransformerHelper() {self._transformerHelper = nil}

  var canHaveRangeInSelectedParagraph: Bool {
    get {return _canHaveRangeInSelectedParagraph ?? false}
    set {_canHaveRangeInSelectedParagraph = newValue}
  }
  /// Returns true if `canHaveRangeInSelectedParagraph` has been explicitly set.
  var hasCanHaveRangeInSelectedParagraph: Bool {return self._canHaveRangeInSelectedParagraph != nil}
  /// Clears the value of `canHaveRangeInSelectedParagraph`. Subsequent reads from it will return its default value.
  mutating func clearCanHaveRangeInSelectedParagraph() {self._canHaveRangeInSelectedParagraph = nil}

  var selectionRangeAddresses: [TSK_RangeAddress] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transformerHelper: KN_SlideCollectionSelectionTransformerHelperArchive? = nil
  fileprivate var _canHaveRangeInSelectedParagraph: Bool? = nil
}

struct KN_CommandLiveVideoInfoApplyPreset: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_BaseApplyPresetCommandArchive {
    get {return _super ?? TSD_BaseApplyPresetCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_BaseApplyPresetCommandArchive? = nil
}

struct KN_CommandLiveVideoInfoSetSource: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var liveVideoInfoIDPath: TSP_UUIDPath {
    get {return _storage._liveVideoInfoIDPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._liveVideoInfoIDPath = newValue}
  }
  /// Returns true if `liveVideoInfoIDPath` has been explicitly set.
  var hasLiveVideoInfoIDPath: Bool {return _storage._liveVideoInfoIDPath != nil}
  /// Clears the value of `liveVideoInfoIDPath`. Subsequent reads from it will return its default value.
  mutating func clearLiveVideoInfoIDPath() {_uniqueStorage()._liveVideoInfoIDPath = nil}

  var sourceID: TSP_UUID {
    get {return _storage._sourceID ?? TSP_UUID()}
    set {_uniqueStorage()._sourceID = newValue}
  }
  /// Returns true if `sourceID` has been explicitly set.
  var hasSourceID: Bool {return _storage._sourceID != nil}
  /// Clears the value of `sourceID`. Subsequent reads from it will return its default value.
  mutating func clearSourceID() {_uniqueStorage()._sourceID = nil}

  var localCollaborationCommandUsageToken: TSP_UUID {
    get {return _storage._localCollaborationCommandUsageToken ?? TSP_UUID()}
    set {_uniqueStorage()._localCollaborationCommandUsageToken = newValue}
  }
  /// Returns true if `localCollaborationCommandUsageToken` has been explicitly set.
  var hasLocalCollaborationCommandUsageToken: Bool {return _storage._localCollaborationCommandUsageToken != nil}
  /// Clears the value of `localCollaborationCommandUsageToken`. Subsequent reads from it will return its default value.
  mutating func clearLocalCollaborationCommandUsageToken() {_uniqueStorage()._localCollaborationCommandUsageToken = nil}

  var workingSourceOldCollaborationCommandUsageState: KN_LiveVideoSourceCollaborationCommandUsageState {
    get {return _storage._workingSourceOldCollaborationCommandUsageState ?? KN_LiveVideoSourceCollaborationCommandUsageState()}
    set {_uniqueStorage()._workingSourceOldCollaborationCommandUsageState = newValue}
  }
  /// Returns true if `workingSourceOldCollaborationCommandUsageState` has been explicitly set.
  var hasWorkingSourceOldCollaborationCommandUsageState: Bool {return _storage._workingSourceOldCollaborationCommandUsageState != nil}
  /// Clears the value of `workingSourceOldCollaborationCommandUsageState`. Subsequent reads from it will return its default value.
  mutating func clearWorkingSourceOldCollaborationCommandUsageState() {_uniqueStorage()._workingSourceOldCollaborationCommandUsageState = nil}

  var oldSource: TSP_Reference {
    get {return _storage._oldSource ?? TSP_Reference()}
    set {_uniqueStorage()._oldSource = newValue}
  }
  /// Returns true if `oldSource` has been explicitly set.
  var hasOldSource: Bool {return _storage._oldSource != nil}
  /// Clears the value of `oldSource`. Subsequent reads from it will return its default value.
  mutating func clearOldSource() {_uniqueStorage()._oldSource = nil}

  var oldSourceID: TSP_UUID {
    get {return _storage._oldSourceID ?? TSP_UUID()}
    set {_uniqueStorage()._oldSourceID = newValue}
  }
  /// Returns true if `oldSourceID` has been explicitly set.
  var hasOldSourceID: Bool {return _storage._oldSourceID != nil}
  /// Clears the value of `oldSourceID`. Subsequent reads from it will return its default value.
  mutating func clearOldSourceID() {_uniqueStorage()._oldSourceID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandLiveVideoInfoSetValue: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var liveVideoInfoIDPath: TSP_UUIDPath {
    get {return _storage._liveVideoInfoIDPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._liveVideoInfoIDPath = newValue}
  }
  /// Returns true if `liveVideoInfoIDPath` has been explicitly set.
  var hasLiveVideoInfoIDPath: Bool {return _storage._liveVideoInfoIDPath != nil}
  /// Clears the value of `liveVideoInfoIDPath`. Subsequent reads from it will return its default value.
  mutating func clearLiveVideoInfoIDPath() {_uniqueStorage()._liveVideoInfoIDPath = nil}

  var property: KN_CommandLiveVideoInfoSetValue.Property {
    get {return _storage._property ?? .scale}
    set {_uniqueStorage()._property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return _storage._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {_uniqueStorage()._property = nil}

  var value: KN_CommandLiveVideoInfoSetValue.PropertyValue {
    get {return _storage._value ?? KN_CommandLiveVideoInfoSetValue.PropertyValue()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {_uniqueStorage()._value = nil}

  var oldValue: KN_CommandLiveVideoInfoSetValue.PropertyValue {
    get {return _storage._oldValue ?? KN_CommandLiveVideoInfoSetValue.PropertyValue()}
    set {_uniqueStorage()._oldValue = newValue}
  }
  /// Returns true if `oldValue` has been explicitly set.
  var hasOldValue: Bool {return _storage._oldValue != nil}
  /// Clears the value of `oldValue`. Subsequent reads from it will return its default value.
  mutating func clearOldValue() {_uniqueStorage()._oldValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Property: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case scale = 0
    case normalizedOffset = 1
    case maskKind = 2
    case maskCornerRadius = 3
    case isPlaceholder = 4
    case backgroundKind = 5
    case backgroundFill = 6

    init() {
      self = .scale
    }

  }

  struct PropertyValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var scale: Double {
      get {return _scale ?? 0}
      set {_scale = newValue}
    }
    /// Returns true if `scale` has been explicitly set.
    var hasScale: Bool {return self._scale != nil}
    /// Clears the value of `scale`. Subsequent reads from it will return its default value.
    mutating func clearScale() {self._scale = nil}

    var normalizedOffset: TSP_Point {
      get {return _normalizedOffset ?? TSP_Point()}
      set {_normalizedOffset = newValue}
    }
    /// Returns true if `normalizedOffset` has been explicitly set.
    var hasNormalizedOffset: Bool {return self._normalizedOffset != nil}
    /// Clears the value of `normalizedOffset`. Subsequent reads from it will return its default value.
    mutating func clearNormalizedOffset() {self._normalizedOffset = nil}

    var maskKind: Int32 {
      get {return _maskKind ?? 0}
      set {_maskKind = newValue}
    }
    /// Returns true if `maskKind` has been explicitly set.
    var hasMaskKind: Bool {return self._maskKind != nil}
    /// Clears the value of `maskKind`. Subsequent reads from it will return its default value.
    mutating func clearMaskKind() {self._maskKind = nil}

    var maskCornerRadius: Double {
      get {return _maskCornerRadius ?? 0}
      set {_maskCornerRadius = newValue}
    }
    /// Returns true if `maskCornerRadius` has been explicitly set.
    var hasMaskCornerRadius: Bool {return self._maskCornerRadius != nil}
    /// Clears the value of `maskCornerRadius`. Subsequent reads from it will return its default value.
    mutating func clearMaskCornerRadius() {self._maskCornerRadius = nil}

    var isPlaceholder: Bool {
      get {return _isPlaceholder ?? false}
      set {_isPlaceholder = newValue}
    }
    /// Returns true if `isPlaceholder` has been explicitly set.
    var hasIsPlaceholder: Bool {return self._isPlaceholder != nil}
    /// Clears the value of `isPlaceholder`. Subsequent reads from it will return its default value.
    mutating func clearIsPlaceholder() {self._isPlaceholder = nil}

    var backgroundKind: Int32 {
      get {return _backgroundKind ?? 0}
      set {_backgroundKind = newValue}
    }
    /// Returns true if `backgroundKind` has been explicitly set.
    var hasBackgroundKind: Bool {return self._backgroundKind != nil}
    /// Clears the value of `backgroundKind`. Subsequent reads from it will return its default value.
    mutating func clearBackgroundKind() {self._backgroundKind = nil}

    var backgroundFill: TSD_FillArchive {
      get {return _backgroundFill ?? TSD_FillArchive()}
      set {_backgroundFill = newValue}
    }
    /// Returns true if `backgroundFill` has been explicitly set.
    var hasBackgroundFill: Bool {return self._backgroundFill != nil}
    /// Clears the value of `backgroundFill`. Subsequent reads from it will return its default value.
    mutating func clearBackgroundFill() {self._backgroundFill = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _scale: Double? = nil
    fileprivate var _normalizedOffset: TSP_Point? = nil
    fileprivate var _maskKind: Int32? = nil
    fileprivate var _maskCornerRadius: Double? = nil
    fileprivate var _isPlaceholder: Bool? = nil
    fileprivate var _backgroundKind: Int32? = nil
    fileprivate var _backgroundFill: TSD_FillArchive? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandLiveVideoSourceSetValue: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var liveVideoSourceID: TSP_UUID {
    get {return _storage._liveVideoSourceID ?? TSP_UUID()}
    set {_uniqueStorage()._liveVideoSourceID = newValue}
  }
  /// Returns true if `liveVideoSourceID` has been explicitly set.
  var hasLiveVideoSourceID: Bool {return _storage._liveVideoSourceID != nil}
  /// Clears the value of `liveVideoSourceID`. Subsequent reads from it will return its default value.
  mutating func clearLiveVideoSourceID() {_uniqueStorage()._liveVideoSourceID = nil}

  var property: KN_CommandLiveVideoSourceSetValue.Property {
    get {return _storage._property ?? .sourceName}
    set {_uniqueStorage()._property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return _storage._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {_uniqueStorage()._property = nil}

  var value: KN_CommandLiveVideoSourceSetValue.PropertyValue {
    get {return _storage._value ?? KN_CommandLiveVideoSourceSetValue.PropertyValue()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {_uniqueStorage()._value = nil}

  var oldValue: KN_CommandLiveVideoSourceSetValue.PropertyValue {
    get {return _storage._oldValue ?? KN_CommandLiveVideoSourceSetValue.PropertyValue()}
    set {_uniqueStorage()._oldValue = newValue}
  }
  /// Returns true if `oldValue` has been explicitly set.
  var hasOldValue: Bool {return _storage._oldValue != nil}
  /// Clears the value of `oldValue`. Subsequent reads from it will return its default value.
  mutating func clearOldValue() {_uniqueStorage()._oldValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Property: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case sourceName = 0
    case captureDeviceDescription = 1
    case posterImageData = 2
    case symbolAbbreviationText = 3
    case symbolImageIdentifier = 4
    case symbolTintColorIdentifier = 5

    init() {
      self = .sourceName
    }

  }

  struct PropertyValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var captureDeviceDescription: KN_LiveVideoCaptureDeviceDescription {
      get {return _captureDeviceDescription ?? KN_LiveVideoCaptureDeviceDescription()}
      set {_captureDeviceDescription = newValue}
    }
    /// Returns true if `captureDeviceDescription` has been explicitly set.
    var hasCaptureDeviceDescription: Bool {return self._captureDeviceDescription != nil}
    /// Clears the value of `captureDeviceDescription`. Subsequent reads from it will return its default value.
    mutating func clearCaptureDeviceDescription() {self._captureDeviceDescription = nil}

    var posterImageData: TSP_DataReference {
      get {return _posterImageData ?? TSP_DataReference()}
      set {_posterImageData = newValue}
    }
    /// Returns true if `posterImageData` has been explicitly set.
    var hasPosterImageData: Bool {return self._posterImageData != nil}
    /// Clears the value of `posterImageData`. Subsequent reads from it will return its default value.
    mutating func clearPosterImageData() {self._posterImageData = nil}

    var symbolAbbreviationText: String {
      get {return _symbolAbbreviationText ?? String()}
      set {_symbolAbbreviationText = newValue}
    }
    /// Returns true if `symbolAbbreviationText` has been explicitly set.
    var hasSymbolAbbreviationText: Bool {return self._symbolAbbreviationText != nil}
    /// Clears the value of `symbolAbbreviationText`. Subsequent reads from it will return its default value.
    mutating func clearSymbolAbbreviationText() {self._symbolAbbreviationText = nil}

    var symbolImageIdentifier: Int32 {
      get {return _symbolImageIdentifier ?? 0}
      set {_symbolImageIdentifier = newValue}
    }
    /// Returns true if `symbolImageIdentifier` has been explicitly set.
    var hasSymbolImageIdentifier: Bool {return self._symbolImageIdentifier != nil}
    /// Clears the value of `symbolImageIdentifier`. Subsequent reads from it will return its default value.
    mutating func clearSymbolImageIdentifier() {self._symbolImageIdentifier = nil}

    var symbolTintColorIdentifier: Int32 {
      get {return _symbolTintColorIdentifier ?? 0}
      set {_symbolTintColorIdentifier = newValue}
    }
    /// Returns true if `symbolTintColorIdentifier` has been explicitly set.
    var hasSymbolTintColorIdentifier: Bool {return self._symbolTintColorIdentifier != nil}
    /// Clears the value of `symbolTintColorIdentifier`. Subsequent reads from it will return its default value.
    mutating func clearSymbolTintColorIdentifier() {self._symbolTintColorIdentifier = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _name: String? = nil
    fileprivate var _captureDeviceDescription: KN_LiveVideoCaptureDeviceDescription? = nil
    fileprivate var _posterImageData: TSP_DataReference? = nil
    fileprivate var _symbolAbbreviationText: String? = nil
    fileprivate var _symbolImageIdentifier: Int32? = nil
    fileprivate var _symbolTintColorIdentifier: Int32? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandLiveVideoStyleSetValue: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_BaseStyleSetValueCommandArchive {
    get {return _storage._super ?? TSD_BaseStyleSetValueCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var change: TSDSOS_MediaStylePropertyChangeSetArchive {
    get {return _storage._change ?? TSDSOS_MediaStylePropertyChangeSetArchive()}
    set {_uniqueStorage()._change = newValue}
  }
  /// Returns true if `change` has been explicitly set.
  var hasChange: Bool {return _storage._change != nil}
  /// Clears the value of `change`. Subsequent reads from it will return its default value.
  mutating func clearChange() {_uniqueStorage()._change = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandThemeAddLiveVideoSource: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var liveVideoSource: TSP_Reference {
    get {return _liveVideoSource ?? TSP_Reference()}
    set {_liveVideoSource = newValue}
  }
  /// Returns true if `liveVideoSource` has been explicitly set.
  var hasLiveVideoSource: Bool {return self._liveVideoSource != nil}
  /// Clears the value of `liveVideoSource`. Subsequent reads from it will return its default value.
  mutating func clearLiveVideoSource() {self._liveVideoSource = nil}

  var isImplicit: Bool {
    get {return _isImplicit ?? false}
    set {_isImplicit = newValue}
  }
  /// Returns true if `isImplicit` has been explicitly set.
  var hasIsImplicit: Bool {return self._isImplicit != nil}
  /// Clears the value of `isImplicit`. Subsequent reads from it will return its default value.
  mutating func clearIsImplicit() {self._isImplicit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _liveVideoSource: TSP_Reference? = nil
  fileprivate var _isImplicit: Bool? = nil
}

struct KN_CommandThemeRemoveLiveVideoSource: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var liveVideoSourceID: TSP_UUID {
    get {return _storage._liveVideoSourceID ?? TSP_UUID()}
    set {_uniqueStorage()._liveVideoSourceID = newValue}
  }
  /// Returns true if `liveVideoSourceID` has been explicitly set.
  var hasLiveVideoSourceID: Bool {return _storage._liveVideoSourceID != nil}
  /// Clears the value of `liveVideoSourceID`. Subsequent reads from it will return its default value.
  mutating func clearLiveVideoSourceID() {_uniqueStorage()._liveVideoSourceID = nil}

  var isImplicit: Bool {
    get {return _storage._isImplicit ?? false}
    set {_uniqueStorage()._isImplicit = newValue}
  }
  /// Returns true if `isImplicit` has been explicitly set.
  var hasIsImplicit: Bool {return _storage._isImplicit != nil}
  /// Clears the value of `isImplicit`. Subsequent reads from it will return its default value.
  mutating func clearIsImplicit() {_uniqueStorage()._isImplicit = nil}

  var removedLiveVideoSource: TSP_Reference {
    get {return _storage._removedLiveVideoSource ?? TSP_Reference()}
    set {_uniqueStorage()._removedLiveVideoSource = newValue}
  }
  /// Returns true if `removedLiveVideoSource` has been explicitly set.
  var hasRemovedLiveVideoSource: Bool {return _storage._removedLiveVideoSource != nil}
  /// Clears the value of `removedLiveVideoSource`. Subsequent reads from it will return its default value.
  mutating func clearRemovedLiveVideoSource() {_uniqueStorage()._removedLiveVideoSource = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandMotionBackgroundStyleSetValueArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var slideIDPath: TSP_UUIDPath {
    get {return _storage._slideIDPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._slideIDPath = newValue}
  }
  /// Returns true if `slideIDPath` has been explicitly set.
  var hasSlideIDPath: Bool {return _storage._slideIDPath != nil}
  /// Clears the value of `slideIDPath`. Subsequent reads from it will return its default value.
  mutating func clearSlideIDPath() {_uniqueStorage()._slideIDPath = nil}

  var oldStyle: TSP_Reference {
    get {return _storage._oldStyle ?? TSP_Reference()}
    set {_uniqueStorage()._oldStyle = newValue}
  }
  /// Returns true if `oldStyle` has been explicitly set.
  var hasOldStyle: Bool {return _storage._oldStyle != nil}
  /// Clears the value of `oldStyle`. Subsequent reads from it will return its default value.
  mutating func clearOldStyle() {_uniqueStorage()._oldStyle = nil}

  var oldSlideStyle: TSP_Reference {
    get {return _storage._oldSlideStyle ?? TSP_Reference()}
    set {_uniqueStorage()._oldSlideStyle = newValue}
  }
  /// Returns true if `oldSlideStyle` has been explicitly set.
  var hasOldSlideStyle: Bool {return _storage._oldSlideStyle != nil}
  /// Clears the value of `oldSlideStyle`. Subsequent reads from it will return its default value.
  mutating func clearOldSlideStyle() {_uniqueStorage()._oldSlideStyle = nil}

  var change: KNSOS_MotionBackgroundStylePropertyChangeSetArchive {
    get {return _storage._change ?? KNSOS_MotionBackgroundStylePropertyChangeSetArchive()}
    set {_uniqueStorage()._change = newValue}
  }
  /// Returns true if `change` has been explicitly set.
  var hasChange: Bool {return _storage._change != nil}
  /// Clears the value of `change`. Subsequent reads from it will return its default value.
  mutating func clearChange() {_uniqueStorage()._change = nil}

  var undoPropertyChange: KNSOS_MotionBackgroundStylePropertyChangeSetArchive {
    get {return _storage._undoPropertyChange ?? KNSOS_MotionBackgroundStylePropertyChangeSetArchive()}
    set {_uniqueStorage()._undoPropertyChange = newValue}
  }
  /// Returns true if `undoPropertyChange` has been explicitly set.
  var hasUndoPropertyChange: Bool {return _storage._undoPropertyChange != nil}
  /// Clears the value of `undoPropertyChange`. Subsequent reads from it will return its default value.
  mutating func clearUndoPropertyChange() {_uniqueStorage()._undoPropertyChange = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct KN_CommandMotionBackgroundStyleUpdatePosterFrameDataArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var motionBackgroundStyle: TSP_Reference {
    get {return _motionBackgroundStyle ?? TSP_Reference()}
    set {_motionBackgroundStyle = newValue}
  }
  /// Returns true if `motionBackgroundStyle` has been explicitly set.
  var hasMotionBackgroundStyle: Bool {return self._motionBackgroundStyle != nil}
  /// Clears the value of `motionBackgroundStyle`. Subsequent reads from it will return its default value.
  mutating func clearMotionBackgroundStyle() {self._motionBackgroundStyle = nil}

  var posterImageData: TSP_DataReference {
    get {return _posterImageData ?? TSP_DataReference()}
    set {_posterImageData = newValue}
  }
  /// Returns true if `posterImageData` has been explicitly set.
  var hasPosterImageData: Bool {return self._posterImageData != nil}
  /// Clears the value of `posterImageData`. Subsequent reads from it will return its default value.
  mutating func clearPosterImageData() {self._posterImageData = nil}

  var oldPosterImageData: TSP_DataReference {
    get {return _oldPosterImageData ?? TSP_DataReference()}
    set {_oldPosterImageData = newValue}
  }
  /// Returns true if `oldPosterImageData` has been explicitly set.
  var hasOldPosterImageData: Bool {return self._oldPosterImageData != nil}
  /// Clears the value of `oldPosterImageData`. Subsequent reads from it will return its default value.
  mutating func clearOldPosterImageData() {self._oldPosterImageData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _motionBackgroundStyle: TSP_Reference? = nil
  fileprivate var _posterImageData: TSP_DataReference? = nil
  fileprivate var _oldPosterImageData: TSP_DataReference? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "KN"

extension KN_AnimationReferent: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}kRelativeToStart\0\u{1}kRelativeToEnd\0")
}

extension KN_UIStateCommandGroupArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIStateCommandGroupArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}uiState\0\u{1}property\0\u{1}slideNodesToEdit\0\u{3}template_slide_nodes_to_apply\0\u{1}thumbnailSizes\0\u{1}selectedSlideNodes\0\u{1}restoreSelectedSlideNodes\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandGroupArchive? = nil
    var _uiState: TSP_Reference? = nil
    var _property: String? = nil
    var _slideNodesToEdit: [TSP_Reference] = []
    var _templateSlideNodesToApply: [TSP_Reference] = []
    var _thumbnailSizes: [TSP_Size] = []
    var _selectedSlideNodes: [TSP_Reference] = []
    var _restoreSelectedSlideNodes: [TSP_Reference] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _uiState = source._uiState
      _property = source._property
      _slideNodesToEdit = source._slideNodesToEdit
      _templateSlideNodesToApply = source._templateSlideNodesToApply
      _thumbnailSizes = source._thumbnailSizes
      _selectedSlideNodes = source._selectedSlideNodes
      _restoreSelectedSlideNodes = source._restoreSelectedSlideNodes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._uiState == nil {return false}
      if _storage._property == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._uiState, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._slideNodesToEdit) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._templateSlideNodesToApply) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._thumbnailSizes) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._selectedSlideNodes) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._restoreSelectedSlideNodes) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._uiState) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._property) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._slideNodesToEdit) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._templateSlideNodesToApply) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._thumbnailSizes) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._selectedSlideNodes) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._restoreSelectedSlideNodes) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._uiState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._property {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      if !_storage._slideNodesToEdit.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._slideNodesToEdit, fieldNumber: 4)
      }
      if !_storage._templateSlideNodesToApply.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._templateSlideNodesToApply, fieldNumber: 5)
      }
      if !_storage._thumbnailSizes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._thumbnailSizes, fieldNumber: 6)
      }
      if !_storage._selectedSlideNodes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._selectedSlideNodes, fieldNumber: 7)
      }
      if !_storage._restoreSelectedSlideNodes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._restoreSelectedSlideNodes, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_UIStateCommandGroupArchive, rhs: KN_UIStateCommandGroupArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._uiState != rhs_storage._uiState {return false}
        if _storage._property != rhs_storage._property {return false}
        if _storage._slideNodesToEdit != rhs_storage._slideNodesToEdit {return false}
        if _storage._templateSlideNodesToApply != rhs_storage._templateSlideNodesToApply {return false}
        if _storage._thumbnailSizes != rhs_storage._thumbnailSizes {return false}
        if _storage._selectedSlideNodes != rhs_storage._selectedSlideNodes {return false}
        if _storage._restoreSelectedSlideNodes != rhs_storage._restoreSelectedSlideNodes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideInsertDrawablesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideInsertDrawablesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}slide_id\0\u{1}drawables\0\u{3}args_list\0\u{3}update_geometry_to_match_object_placeholder\0\u{3}ids_of_drawables_using_object_placeholder_geometry\0\u{3}sage_placeholder_tags_list\0\u{3}undo_archive\0\u{3}is_pasting\0\u{3}insert_build_descriptions\0\u{3}remove_build_descriptions\0\u{3}remove_slide_specific_hyperlinks\0\u{3}custom_format_keys\0\u{4}\u{3}saved_next_untitled_resolver_index\0\u{3}geometry_of_object_placeholder_for_comparison_to_restore_link\0\u{3}working_drawables\0\u{3}working_insert_build_descriptions\0\u{3}instructional_text_list\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _slideID: TSP_UUID? = nil
    var _drawables: [TSP_Reference] = []
    var _workingDrawables: [TSP_Reference] = []
    var _argsList: KN_MixedIdOperationArgs? = nil
    var _updateGeometryToMatchObjectPlaceholder: Bool? = nil
    var _idsOfDrawablesUsingObjectPlaceholderGeometry: [TSP_UUID] = []
    var _sagePlaceholderTagsList: [String] = []
    var _instructionalTextList: [String] = []
    var _undoArchive: TSP_Reference? = nil
    var _isPasting: Bool? = nil
    var _insertBuildDescriptions: [TSP_Reference] = []
    var _workingInsertBuildDescriptions: [TSP_Reference] = []
    var _removeBuildDescriptions: [TSP_Reference] = []
    var _removeSlideSpecificHyperlinks: Bool? = nil
    var _customFormatKeys: [TSP_UUID] = []
    var _savedNextUntitledResolverIndex: UInt32? = nil
    var _geometryOfObjectPlaceholderForComparisonToRestoreLink: TSD_GeometryArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _slideID = source._slideID
      _drawables = source._drawables
      _workingDrawables = source._workingDrawables
      _argsList = source._argsList
      _updateGeometryToMatchObjectPlaceholder = source._updateGeometryToMatchObjectPlaceholder
      _idsOfDrawablesUsingObjectPlaceholderGeometry = source._idsOfDrawablesUsingObjectPlaceholderGeometry
      _sagePlaceholderTagsList = source._sagePlaceholderTagsList
      _instructionalTextList = source._instructionalTextList
      _undoArchive = source._undoArchive
      _isPasting = source._isPasting
      _insertBuildDescriptions = source._insertBuildDescriptions
      _workingInsertBuildDescriptions = source._workingInsertBuildDescriptions
      _removeBuildDescriptions = source._removeBuildDescriptions
      _removeSlideSpecificHyperlinks = source._removeSlideSpecificHyperlinks
      _customFormatKeys = source._customFormatKeys
      _savedNextUntitledResolverIndex = source._savedNextUntitledResolverIndex
      _geometryOfObjectPlaceholderForComparisonToRestoreLink = source._geometryOfObjectPlaceholderForComparisonToRestoreLink
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._slideID == nil {return false}
      if _storage._updateGeometryToMatchObjectPlaceholder == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._slideID, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._drawables) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._workingDrawables) {return false}
      if let v = _storage._argsList, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._idsOfDrawablesUsingObjectPlaceholderGeometry) {return false}
      if let v = _storage._undoArchive, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._insertBuildDescriptions) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._workingInsertBuildDescriptions) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._removeBuildDescriptions) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._customFormatKeys) {return false}
      if let v = _storage._geometryOfObjectPlaceholderForComparisonToRestoreLink, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._slideID) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._drawables) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._argsList) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._updateGeometryToMatchObjectPlaceholder) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._idsOfDrawablesUsingObjectPlaceholderGeometry) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._sagePlaceholderTagsList) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._undoArchive) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._isPasting) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._insertBuildDescriptions) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._removeBuildDescriptions) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._removeSlideSpecificHyperlinks) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._customFormatKeys) }()
        case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._savedNextUntitledResolverIndex) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._geometryOfObjectPlaceholderForComparisonToRestoreLink) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._workingDrawables) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._workingInsertBuildDescriptions) }()
        case 20: try { try decoder.decodeRepeatedStringField(value: &_storage._instructionalTextList) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._slideID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._drawables.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._drawables, fieldNumber: 3)
      }
      try { if let v = _storage._argsList {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._updateGeometryToMatchObjectPlaceholder {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      if !_storage._idsOfDrawablesUsingObjectPlaceholderGeometry.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._idsOfDrawablesUsingObjectPlaceholderGeometry, fieldNumber: 6)
      }
      if !_storage._sagePlaceholderTagsList.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._sagePlaceholderTagsList, fieldNumber: 7)
      }
      try { if let v = _storage._undoArchive {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._isPasting {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
      if !_storage._insertBuildDescriptions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._insertBuildDescriptions, fieldNumber: 10)
      }
      if !_storage._removeBuildDescriptions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._removeBuildDescriptions, fieldNumber: 11)
      }
      try { if let v = _storage._removeSlideSpecificHyperlinks {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      } }()
      if !_storage._customFormatKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._customFormatKeys, fieldNumber: 13)
      }
      try { if let v = _storage._savedNextUntitledResolverIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._geometryOfObjectPlaceholderForComparisonToRestoreLink {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._workingDrawables.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._workingDrawables, fieldNumber: 18)
      }
      if !_storage._workingInsertBuildDescriptions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._workingInsertBuildDescriptions, fieldNumber: 19)
      }
      if !_storage._instructionalTextList.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._instructionalTextList, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideInsertDrawablesArchive, rhs: KN_CommandSlideInsertDrawablesArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._slideID != rhs_storage._slideID {return false}
        if _storage._drawables != rhs_storage._drawables {return false}
        if _storage._workingDrawables != rhs_storage._workingDrawables {return false}
        if _storage._argsList != rhs_storage._argsList {return false}
        if _storage._updateGeometryToMatchObjectPlaceholder != rhs_storage._updateGeometryToMatchObjectPlaceholder {return false}
        if _storage._idsOfDrawablesUsingObjectPlaceholderGeometry != rhs_storage._idsOfDrawablesUsingObjectPlaceholderGeometry {return false}
        if _storage._sagePlaceholderTagsList != rhs_storage._sagePlaceholderTagsList {return false}
        if _storage._instructionalTextList != rhs_storage._instructionalTextList {return false}
        if _storage._undoArchive != rhs_storage._undoArchive {return false}
        if _storage._isPasting != rhs_storage._isPasting {return false}
        if _storage._insertBuildDescriptions != rhs_storage._insertBuildDescriptions {return false}
        if _storage._workingInsertBuildDescriptions != rhs_storage._workingInsertBuildDescriptions {return false}
        if _storage._removeBuildDescriptions != rhs_storage._removeBuildDescriptions {return false}
        if _storage._removeSlideSpecificHyperlinks != rhs_storage._removeSlideSpecificHyperlinks {return false}
        if _storage._customFormatKeys != rhs_storage._customFormatKeys {return false}
        if _storage._savedNextUntitledResolverIndex != rhs_storage._savedNextUntitledResolverIndex {return false}
        if _storage._geometryOfObjectPlaceholderForComparisonToRestoreLink != rhs_storage._geometryOfObjectPlaceholderForComparisonToRestoreLink {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideSetPlaceholdersForTagsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideSetPlaceholdersForTagsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}slide_id\0\u{1}infos\0\u{1}tags\0\u{3}old_tags\0\u{3}old_infos\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _slideID: TSP_UUID? = nil
    var _infos: [TSP_Reference] = []
    var _tags: [String] = []
    var _oldInfos: [TSP_Reference] = []
    var _oldTags: [String] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _slideID = source._slideID
      _infos = source._infos
      _tags = source._tags
      _oldInfos = source._oldInfos
      _oldTags = source._oldTags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._slideID == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._slideID, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._infos) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._oldInfos) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._slideID) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._infos) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._tags) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._oldTags) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._oldInfos) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._slideID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._infos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._infos, fieldNumber: 3)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tags, fieldNumber: 4)
      }
      if !_storage._oldTags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._oldTags, fieldNumber: 5)
      }
      if !_storage._oldInfos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oldInfos, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideSetPlaceholdersForTagsArchive, rhs: KN_CommandSlideSetPlaceholdersForTagsArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._slideID != rhs_storage._slideID {return false}
        if _storage._infos != rhs_storage._infos {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._oldInfos != rhs_storage._oldInfos {return false}
        if _storage._oldTags != rhs_storage._oldTags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandTemplateSlideSetPlaceholderForTagArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandTemplateSlideSetPlaceholderForTagArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}placeholder_id\0\u{1}tag\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._placeholderID == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._placeholderID, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._placeholderID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._tag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._placeholderID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._tag {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandTemplateSlideSetPlaceholderForTagArchive, rhs: KN_CommandTemplateSlideSetPlaceholderForTagArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._placeholderID != rhs._placeholderID {return false}
    if lhs._tag != rhs._tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlidePropagateSetPlaceholderForTagArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlidePropagateSetPlaceholderForTagArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}placeholder_id\0\u{3}original_id\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._placeholderID == nil {return false}
    if self._originalID == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._placeholderID, !v.isInitialized {return false}
    if let v = self._originalID, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._placeholderID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._originalID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._placeholderID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._originalID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlidePropagateSetPlaceholderForTagArchive, rhs: KN_CommandSlidePropagateSetPlaceholderForTagArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._placeholderID != rhs._placeholderID {return false}
    if lhs._originalID != rhs._originalID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideRemoveDrawableArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideRemoveDrawableArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}slide_id\0\u{1}sortedDrawables\0\u{3}args_list\0\u{1}placeholderTags\0\u{3}insert_build_descriptions\0\u{3}remove_build_descriptions\0\u{3}drawables_using_object_placeholder_geometry\0\u{3}inverse_insert_hyperlink_commands\0\u{3}drawable_indexes_for_undo\0\u{3}instructional_text_list\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _slideID: TSP_UUID? = nil
    var _sortedDrawables: [TSP_Reference] = []
    var _argsList: KN_MixedIdOperationArgs? = nil
    var _drawableIndexesForUndo: [UInt32] = []
    var _placeholderTags: [String] = []
    var _instructionalTextList: [String] = []
    var _insertBuildDescriptions: [TSP_Reference] = []
    var _removeBuildDescriptions: [TSP_Reference] = []
    var _drawablesUsingObjectPlaceholderGeometry: [TSP_Reference] = []
    var _inverseInsertHyperlinkCommands: [TSP_Reference] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _slideID = source._slideID
      _sortedDrawables = source._sortedDrawables
      _argsList = source._argsList
      _drawableIndexesForUndo = source._drawableIndexesForUndo
      _placeholderTags = source._placeholderTags
      _instructionalTextList = source._instructionalTextList
      _insertBuildDescriptions = source._insertBuildDescriptions
      _removeBuildDescriptions = source._removeBuildDescriptions
      _drawablesUsingObjectPlaceholderGeometry = source._drawablesUsingObjectPlaceholderGeometry
      _inverseInsertHyperlinkCommands = source._inverseInsertHyperlinkCommands
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._slideID == nil {return false}
      if _storage._argsList == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._slideID, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._sortedDrawables) {return false}
      if let v = _storage._argsList, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._insertBuildDescriptions) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._removeBuildDescriptions) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._drawablesUsingObjectPlaceholderGeometry) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._inverseInsertHyperlinkCommands) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._slideID) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._sortedDrawables) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._argsList) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._placeholderTags) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._insertBuildDescriptions) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._removeBuildDescriptions) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._drawablesUsingObjectPlaceholderGeometry) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._inverseInsertHyperlinkCommands) }()
        case 10: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._drawableIndexesForUndo) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._instructionalTextList) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._slideID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._sortedDrawables.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sortedDrawables, fieldNumber: 3)
      }
      try { if let v = _storage._argsList {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._placeholderTags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._placeholderTags, fieldNumber: 5)
      }
      if !_storage._insertBuildDescriptions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._insertBuildDescriptions, fieldNumber: 6)
      }
      if !_storage._removeBuildDescriptions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._removeBuildDescriptions, fieldNumber: 7)
      }
      if !_storage._drawablesUsingObjectPlaceholderGeometry.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._drawablesUsingObjectPlaceholderGeometry, fieldNumber: 8)
      }
      if !_storage._inverseInsertHyperlinkCommands.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._inverseInsertHyperlinkCommands, fieldNumber: 9)
      }
      if !_storage._drawableIndexesForUndo.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._drawableIndexesForUndo, fieldNumber: 10)
      }
      if !_storage._instructionalTextList.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._instructionalTextList, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideRemoveDrawableArchive, rhs: KN_CommandSlideRemoveDrawableArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._slideID != rhs_storage._slideID {return false}
        if _storage._sortedDrawables != rhs_storage._sortedDrawables {return false}
        if _storage._argsList != rhs_storage._argsList {return false}
        if _storage._drawableIndexesForUndo != rhs_storage._drawableIndexesForUndo {return false}
        if _storage._placeholderTags != rhs_storage._placeholderTags {return false}
        if _storage._instructionalTextList != rhs_storage._instructionalTextList {return false}
        if _storage._insertBuildDescriptions != rhs_storage._insertBuildDescriptions {return false}
        if _storage._removeBuildDescriptions != rhs_storage._removeBuildDescriptions {return false}
        if _storage._drawablesUsingObjectPlaceholderGeometry != rhs_storage._drawablesUsingObjectPlaceholderGeometry {return false}
        if _storage._inverseInsertHyperlinkCommands != rhs_storage._inverseInsertHyperlinkCommands {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideMoveDrawableZOrderArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideMoveDrawableZOrderArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{3}old_ordered_infos\0\u{4}\u{2}args_list\0\u{3}slide_id\0\u{3}old_ordered_infos_on_slide_for_undo\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._slideID == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldOrderedInfos) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.argsList) {return false}
    if let v = self._slideID, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldOrderedInfosOnSlideForUndo) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.oldOrderedInfos) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.argsList) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._slideID) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.oldOrderedInfosOnSlideForUndo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.oldOrderedInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldOrderedInfos, fieldNumber: 4)
    }
    if !self.argsList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.argsList, fieldNumber: 6)
    }
    try { if let v = self._slideID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.oldOrderedInfosOnSlideForUndo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldOrderedInfosOnSlideForUndo, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideMoveDrawableZOrderArchive, rhs: KN_CommandSlideMoveDrawableZOrderArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.oldOrderedInfos != rhs.oldOrderedInfos {return false}
    if lhs.argsList != rhs.argsList {return false}
    if lhs._slideID != rhs._slideID {return false}
    if lhs.oldOrderedInfosOnSlideForUndo != rhs.oldOrderedInfosOnSlideForUndo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideNodeSetPropertyArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideNodeSetPropertyArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}slide_node_id_path\0\u{1}property\0\u{3}old_value\0\u{1}value\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._slideNodeIDPath == nil {return false}
    if self._property == nil {return false}
    if self._oldValue == nil {return false}
    if self._value == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._slideNodeIDPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._slideNodeIDPath) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._property) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._oldValue) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._slideNodeIDPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._property {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._oldValue {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideNodeSetPropertyArchive, rhs: KN_CommandSlideNodeSetPropertyArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._slideNodeIDPath != rhs._slideNodeIDPath {return false}
    if lhs._property != rhs._property {return false}
    if lhs._oldValue != rhs._oldValue {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideNodeSetViewStatePropertyArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideNodeSetViewStatePropertyArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}slide_node_id_path\0\u{1}property\0\u{3}old_value\0\u{1}value\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._slideNodeIDPath == nil {return false}
    if self._property == nil {return false}
    if self._oldValue == nil {return false}
    if self._value == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._slideNodeIDPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._slideNodeIDPath) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._property) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._oldValue) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._slideNodeIDPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._property {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._oldValue {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideNodeSetViewStatePropertyArchive, rhs: KN_CommandSlideNodeSetViewStatePropertyArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._slideNodeIDPath != rhs._slideNodeIDPath {return false}
    if lhs._property != rhs._property {return false}
    if lhs._oldValue != rhs._oldValue {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideSetBackgroundFillArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideSetBackgroundFillArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}slide_id_path\0\u{3}old_fill\0\u{3}new_fill\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._slideIDPath == nil {return false}
    if self._newFill == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._slideIDPath, !v.isInitialized {return false}
    if let v = self._oldFill, !v.isInitialized {return false}
    if let v = self._newFill, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._slideIDPath) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._oldFill) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._newFill) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._slideIDPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._oldFill {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._newFill {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideSetBackgroundFillArchive, rhs: KN_CommandSlideSetBackgroundFillArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._slideIDPath != rhs._slideIDPath {return false}
    if lhs._oldFill != rhs._oldFill {return false}
    if lhs._newFill != rhs._newFill {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideSetStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideSetStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}slide_id_path\0\u{3}slide_style\0\u{3}old_slide_style\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _slideIDPath: TSP_UUIDPath? = nil
    var _slideStyle: TSP_Reference? = nil
    var _oldSlideStyle: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _slideIDPath = source._slideIDPath
      _slideStyle = source._slideStyle
      _oldSlideStyle = source._oldSlideStyle
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._slideIDPath == nil {return false}
      if _storage._slideStyle == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._slideIDPath, !v.isInitialized {return false}
      if let v = _storage._slideStyle, !v.isInitialized {return false}
      if let v = _storage._oldSlideStyle, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._slideIDPath) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._slideStyle) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._oldSlideStyle) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._slideIDPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._slideStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._oldSlideStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideSetStyleArchive, rhs: KN_CommandSlideSetStyleArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._slideIDPath != rhs_storage._slideIDPath {return false}
        if _storage._slideStyle != rhs_storage._slideStyle {return false}
        if _storage._oldSlideStyle != rhs_storage._oldSlideStyle {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowMarkOutOfSyncRecordingArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowMarkOutOfSyncRecordingArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}show\0\u{3}old_recording\0\u{3}old_is_recording_out_of_sync\0\u{3}new_is_recording_out_of_sync\0\u{3}old_modification_date\0\u{3}new_modification_date\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _show: TSP_Reference? = nil
    var _oldRecording: TSP_Reference? = nil
    var _oldIsRecordingOutOfSync: Bool? = nil
    var _newIsRecordingOutOfSync: Bool? = nil
    var _oldModificationDate: TSP_Date? = nil
    var _newModificationDate: TSP_Date? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _show = source._show
      _oldRecording = source._oldRecording
      _oldIsRecordingOutOfSync = source._oldIsRecordingOutOfSync
      _newIsRecordingOutOfSync = source._newIsRecordingOutOfSync
      _oldModificationDate = source._oldModificationDate
      _newModificationDate = source._newModificationDate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._show == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._show, !v.isInitialized {return false}
      if let v = _storage._oldRecording, !v.isInitialized {return false}
      if let v = _storage._oldModificationDate, !v.isInitialized {return false}
      if let v = _storage._newModificationDate, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._show) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._oldRecording) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._oldIsRecordingOutOfSync) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._newIsRecordingOutOfSync) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._oldModificationDate) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._newModificationDate) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._show {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._oldRecording {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._oldIsRecordingOutOfSync {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._newIsRecordingOutOfSync {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._oldModificationDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._newModificationDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowMarkOutOfSyncRecordingArchive, rhs: KN_CommandShowMarkOutOfSyncRecordingArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._show != rhs_storage._show {return false}
        if _storage._oldRecording != rhs_storage._oldRecording {return false}
        if _storage._oldIsRecordingOutOfSync != rhs_storage._oldIsRecordingOutOfSync {return false}
        if _storage._newIsRecordingOutOfSync != rhs_storage._newIsRecordingOutOfSync {return false}
        if _storage._oldModificationDate != rhs_storage._oldModificationDate {return false}
        if _storage._newModificationDate != rhs_storage._newModificationDate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowMarkOutOfSyncRecordingIfNeededArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowMarkOutOfSyncRecordingIfNeededArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}out_of_sync_token\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._outOfSyncToken, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outOfSyncToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._outOfSyncToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowMarkOutOfSyncRecordingIfNeededArchive, rhs: KN_CommandShowMarkOutOfSyncRecordingIfNeededArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._outOfSyncToken != rhs._outOfSyncToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowRemoveRecordingArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowRemoveRecordingArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}show\0\u{3}old_recording\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _show: TSP_Reference? = nil
    var _oldRecording: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _show = source._show
      _oldRecording = source._oldRecording
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._show == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._show, !v.isInitialized {return false}
      if let v = _storage._oldRecording, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._show) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._oldRecording) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._show {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._oldRecording {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowRemoveRecordingArchive, rhs: KN_CommandShowRemoveRecordingArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._show != rhs_storage._show {return false}
        if _storage._oldRecording != rhs_storage._oldRecording {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowReplaceRecordingArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowReplaceRecordingArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}show\0\u{3}replacement_recording\0\u{4}\u{2}old_recording\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _show: TSP_Reference? = nil
    var _replacementRecording: TSP_Reference? = nil
    var _oldRecording: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _show = source._show
      _replacementRecording = source._replacementRecording
      _oldRecording = source._oldRecording
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._show == nil {return false}
      if _storage._replacementRecording == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._show, !v.isInitialized {return false}
      if let v = _storage._replacementRecording, !v.isInitialized {return false}
      if let v = _storage._oldRecording, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._show) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._replacementRecording) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._oldRecording) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._show {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._replacementRecording {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._oldRecording {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowReplaceRecordingArchive, rhs: KN_CommandShowReplaceRecordingArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._show != rhs_storage._show {return false}
        if _storage._replacementRecording != rhs_storage._replacementRecording {return false}
        if _storage._oldRecording != rhs_storage._oldRecording {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowSetValueArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowSetValueArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}show\0\u{1}property\0\u{3}old_value\0\u{3}new_value\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _show: TSP_Reference? = nil
    var _property: String? = nil
    var _oldValue: KN_CommandShowSetValueArchive.PropertyValue? = nil
    var _newValue: KN_CommandShowSetValueArchive.PropertyValue? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _show = source._show
      _property = source._property
      _oldValue = source._oldValue
      _newValue = source._newValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._show == nil {return false}
      if _storage._property == nil {return false}
      if _storage._oldValue == nil {return false}
      if _storage._newValue == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._show, !v.isInitialized {return false}
      if let v = _storage._oldValue, !v.isInitialized {return false}
      if let v = _storage._newValue, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._show) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._property) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._oldValue) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._newValue) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._show {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._property {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._oldValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._newValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowSetValueArchive, rhs: KN_CommandShowSetValueArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._show != rhs_storage._show {return false}
        if _storage._property != rhs_storage._property {return false}
        if _storage._oldValue != rhs_storage._oldValue {return false}
        if _storage._newValue != rhs_storage._newValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowSetValueArchive.PropertyValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = KN_CommandShowSetValueArchive.protoMessageName + ".PropertyValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}bool_value\0\u{3}double_value\0\u{3}show_mode_value\0\u{3}size_value\0")

  public var isInitialized: Bool {
    if let v = self._sizeValue, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._boolValue) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._doubleValue) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._showModeValue) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._sizeValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._boolValue {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._doubleValue {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._showModeValue {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._sizeValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowSetValueArchive.PropertyValue, rhs: KN_CommandShowSetValueArchive.PropertyValue) -> Bool {
    if lhs._boolValue != rhs._boolValue {return false}
    if lhs._doubleValue != rhs._doubleValue {return false}
    if lhs._showModeValue != rhs._showModeValue {return false}
    if lhs._sizeValue != rhs._sizeValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowInsertSlideArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowInsertSlideArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}slide_nodes_being_inserted\0\u{3}inserted_args_list\0\u{3}ids_of_slide_nodes_with_depth_changes\0\u{3}depths_of_slide_nodes_with_depth_changes\0\u{3}old_depths_of_slide_nodes_with_depth_changes\0\u{3}slide_nodes_for_depth_fix_up\0\u{3}depths_of_slide_nodes_for_depth_fix_up\0\u{3}old_depths_of_slide_nodes_for_depth_fix_up\0\u{1}kind\0\u{3}template_slide_nodes_being_inserted\0\u{3}custom_format_keys\0\u{3}collapsed_state_of_slide_nodes_being_inserted\0\u{3}working_slide_nodes_being_inserted\0\u{3}undo_archive\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _slideNodesBeingInserted: [TSP_Reference] = []
    var _workingSlideNodesBeingInserted: [TSP_Reference] = []
    var _insertedArgsList: [TSCK_AddIdOperationArgs] = []
    var _idsOfSlideNodesWithDepthChanges: [TSP_UUID] = []
    var _depthsOfSlideNodesWithDepthChanges: [UInt32] = []
    var _oldDepthsOfSlideNodesWithDepthChanges: [UInt32] = []
    var _slideNodesForDepthFixUp: [TSP_Reference] = []
    var _depthsOfSlideNodesForDepthFixUp: [UInt32] = []
    var _oldDepthsOfSlideNodesForDepthFixUp: [UInt32] = []
    var _kind: KN_CommandShowInsertSlideArchive.Kind? = nil
    var _templateSlideNodesBeingInserted: [TSP_Reference] = []
    var _customFormatKeys: [TSP_UUID] = []
    var _collapsedStateOfSlideNodesBeingInserted: [Bool] = []
    var _undoArchive: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _slideNodesBeingInserted = source._slideNodesBeingInserted
      _workingSlideNodesBeingInserted = source._workingSlideNodesBeingInserted
      _insertedArgsList = source._insertedArgsList
      _idsOfSlideNodesWithDepthChanges = source._idsOfSlideNodesWithDepthChanges
      _depthsOfSlideNodesWithDepthChanges = source._depthsOfSlideNodesWithDepthChanges
      _oldDepthsOfSlideNodesWithDepthChanges = source._oldDepthsOfSlideNodesWithDepthChanges
      _slideNodesForDepthFixUp = source._slideNodesForDepthFixUp
      _depthsOfSlideNodesForDepthFixUp = source._depthsOfSlideNodesForDepthFixUp
      _oldDepthsOfSlideNodesForDepthFixUp = source._oldDepthsOfSlideNodesForDepthFixUp
      _kind = source._kind
      _templateSlideNodesBeingInserted = source._templateSlideNodesBeingInserted
      _customFormatKeys = source._customFormatKeys
      _collapsedStateOfSlideNodesBeingInserted = source._collapsedStateOfSlideNodesBeingInserted
      _undoArchive = source._undoArchive
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._slideNodesBeingInserted) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._workingSlideNodesBeingInserted) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._insertedArgsList) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._idsOfSlideNodesWithDepthChanges) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._slideNodesForDepthFixUp) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._templateSlideNodesBeingInserted) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._customFormatKeys) {return false}
      if let v = _storage._undoArchive, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._slideNodesBeingInserted) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._insertedArgsList) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._idsOfSlideNodesWithDepthChanges) }()
        case 5: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._depthsOfSlideNodesWithDepthChanges) }()
        case 6: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._oldDepthsOfSlideNodesWithDepthChanges) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._slideNodesForDepthFixUp) }()
        case 8: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._depthsOfSlideNodesForDepthFixUp) }()
        case 9: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._oldDepthsOfSlideNodesForDepthFixUp) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._kind) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._templateSlideNodesBeingInserted) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._customFormatKeys) }()
        case 13: try { try decoder.decodeRepeatedBoolField(value: &_storage._collapsedStateOfSlideNodesBeingInserted) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._workingSlideNodesBeingInserted) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._undoArchive) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._slideNodesBeingInserted.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._slideNodesBeingInserted, fieldNumber: 2)
      }
      if !_storage._insertedArgsList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._insertedArgsList, fieldNumber: 3)
      }
      if !_storage._idsOfSlideNodesWithDepthChanges.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._idsOfSlideNodesWithDepthChanges, fieldNumber: 4)
      }
      if !_storage._depthsOfSlideNodesWithDepthChanges.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._depthsOfSlideNodesWithDepthChanges, fieldNumber: 5)
      }
      if !_storage._oldDepthsOfSlideNodesWithDepthChanges.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._oldDepthsOfSlideNodesWithDepthChanges, fieldNumber: 6)
      }
      if !_storage._slideNodesForDepthFixUp.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._slideNodesForDepthFixUp, fieldNumber: 7)
      }
      if !_storage._depthsOfSlideNodesForDepthFixUp.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._depthsOfSlideNodesForDepthFixUp, fieldNumber: 8)
      }
      if !_storage._oldDepthsOfSlideNodesForDepthFixUp.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._oldDepthsOfSlideNodesForDepthFixUp, fieldNumber: 9)
      }
      try { if let v = _storage._kind {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
      } }()
      if !_storage._templateSlideNodesBeingInserted.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._templateSlideNodesBeingInserted, fieldNumber: 11)
      }
      if !_storage._customFormatKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._customFormatKeys, fieldNumber: 12)
      }
      if !_storage._collapsedStateOfSlideNodesBeingInserted.isEmpty {
        try visitor.visitRepeatedBoolField(value: _storage._collapsedStateOfSlideNodesBeingInserted, fieldNumber: 13)
      }
      if !_storage._workingSlideNodesBeingInserted.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._workingSlideNodesBeingInserted, fieldNumber: 14)
      }
      try { if let v = _storage._undoArchive {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowInsertSlideArchive, rhs: KN_CommandShowInsertSlideArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._slideNodesBeingInserted != rhs_storage._slideNodesBeingInserted {return false}
        if _storage._workingSlideNodesBeingInserted != rhs_storage._workingSlideNodesBeingInserted {return false}
        if _storage._insertedArgsList != rhs_storage._insertedArgsList {return false}
        if _storage._idsOfSlideNodesWithDepthChanges != rhs_storage._idsOfSlideNodesWithDepthChanges {return false}
        if _storage._depthsOfSlideNodesWithDepthChanges != rhs_storage._depthsOfSlideNodesWithDepthChanges {return false}
        if _storage._oldDepthsOfSlideNodesWithDepthChanges != rhs_storage._oldDepthsOfSlideNodesWithDepthChanges {return false}
        if _storage._slideNodesForDepthFixUp != rhs_storage._slideNodesForDepthFixUp {return false}
        if _storage._depthsOfSlideNodesForDepthFixUp != rhs_storage._depthsOfSlideNodesForDepthFixUp {return false}
        if _storage._oldDepthsOfSlideNodesForDepthFixUp != rhs_storage._oldDepthsOfSlideNodesForDepthFixUp {return false}
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._templateSlideNodesBeingInserted != rhs_storage._templateSlideNodesBeingInserted {return false}
        if _storage._customFormatKeys != rhs_storage._customFormatKeys {return false}
        if _storage._collapsedStateOfSlideNodesBeingInserted != rhs_storage._collapsedStateOfSlideNodesBeingInserted {return false}
        if _storage._undoArchive != rhs_storage._undoArchive {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowInsertSlideArchive.Kind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kKindInsertSlide\0\u{1}kKindInsertSlideForPaste\0\u{1}kKindInsertSlideForDuplicate\0")
}

extension KN_CommandShowMoveSlideArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowMoveSlideArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}slide_nodes_being_moved_linearly\0\u{3}rearranged_args_list\0\u{3}ids_of_slide_nodes_with_depth_changes\0\u{3}depths_of_slide_nodes_with_depth_changes\0\u{3}old_depths_of_slide_nodes_with_depth_changes\0\u{3}slide_nodes_for_depth_fix_up\0\u{3}depths_of_slide_nodes_for_depth_fix_up\0\u{3}old_depths_of_slide_nodes_for_depth_fix_up\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _slideNodesBeingMovedLinearly: [TSP_Reference] = []
    var _rearrangedArgsList: [TSCK_RearrangeIdOperationArgs] = []
    var _idsOfSlideNodesWithDepthChanges: [TSP_UUID] = []
    var _depthsOfSlideNodesWithDepthChanges: [UInt32] = []
    var _oldDepthsOfSlideNodesWithDepthChanges: [UInt32] = []
    var _slideNodesForDepthFixUp: [TSP_Reference] = []
    var _depthsOfSlideNodesForDepthFixUp: [UInt32] = []
    var _oldDepthsOfSlideNodesForDepthFixUp: [UInt32] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _slideNodesBeingMovedLinearly = source._slideNodesBeingMovedLinearly
      _rearrangedArgsList = source._rearrangedArgsList
      _idsOfSlideNodesWithDepthChanges = source._idsOfSlideNodesWithDepthChanges
      _depthsOfSlideNodesWithDepthChanges = source._depthsOfSlideNodesWithDepthChanges
      _oldDepthsOfSlideNodesWithDepthChanges = source._oldDepthsOfSlideNodesWithDepthChanges
      _slideNodesForDepthFixUp = source._slideNodesForDepthFixUp
      _depthsOfSlideNodesForDepthFixUp = source._depthsOfSlideNodesForDepthFixUp
      _oldDepthsOfSlideNodesForDepthFixUp = source._oldDepthsOfSlideNodesForDepthFixUp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._slideNodesBeingMovedLinearly) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._rearrangedArgsList) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._idsOfSlideNodesWithDepthChanges) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._slideNodesForDepthFixUp) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._slideNodesBeingMovedLinearly) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._rearrangedArgsList) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._idsOfSlideNodesWithDepthChanges) }()
        case 5: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._depthsOfSlideNodesWithDepthChanges) }()
        case 6: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._oldDepthsOfSlideNodesWithDepthChanges) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._slideNodesForDepthFixUp) }()
        case 8: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._depthsOfSlideNodesForDepthFixUp) }()
        case 9: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._oldDepthsOfSlideNodesForDepthFixUp) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._slideNodesBeingMovedLinearly.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._slideNodesBeingMovedLinearly, fieldNumber: 2)
      }
      if !_storage._rearrangedArgsList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rearrangedArgsList, fieldNumber: 3)
      }
      if !_storage._idsOfSlideNodesWithDepthChanges.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._idsOfSlideNodesWithDepthChanges, fieldNumber: 4)
      }
      if !_storage._depthsOfSlideNodesWithDepthChanges.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._depthsOfSlideNodesWithDepthChanges, fieldNumber: 5)
      }
      if !_storage._oldDepthsOfSlideNodesWithDepthChanges.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._oldDepthsOfSlideNodesWithDepthChanges, fieldNumber: 6)
      }
      if !_storage._slideNodesForDepthFixUp.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._slideNodesForDepthFixUp, fieldNumber: 7)
      }
      if !_storage._depthsOfSlideNodesForDepthFixUp.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._depthsOfSlideNodesForDepthFixUp, fieldNumber: 8)
      }
      if !_storage._oldDepthsOfSlideNodesForDepthFixUp.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._oldDepthsOfSlideNodesForDepthFixUp, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowMoveSlideArchive, rhs: KN_CommandShowMoveSlideArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._slideNodesBeingMovedLinearly != rhs_storage._slideNodesBeingMovedLinearly {return false}
        if _storage._rearrangedArgsList != rhs_storage._rearrangedArgsList {return false}
        if _storage._idsOfSlideNodesWithDepthChanges != rhs_storage._idsOfSlideNodesWithDepthChanges {return false}
        if _storage._depthsOfSlideNodesWithDepthChanges != rhs_storage._depthsOfSlideNodesWithDepthChanges {return false}
        if _storage._oldDepthsOfSlideNodesWithDepthChanges != rhs_storage._oldDepthsOfSlideNodesWithDepthChanges {return false}
        if _storage._slideNodesForDepthFixUp != rhs_storage._slideNodesForDepthFixUp {return false}
        if _storage._depthsOfSlideNodesForDepthFixUp != rhs_storage._depthsOfSlideNodesForDepthFixUp {return false}
        if _storage._oldDepthsOfSlideNodesForDepthFixUp != rhs_storage._oldDepthsOfSlideNodesForDepthFixUp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowRemoveSlideArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowRemoveSlideArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}slide_nodes_being_removed\0\u{3}removed_args_list\0\u{3}ids_of_slide_nodes_with_depth_changes\0\u{3}depths_of_slide_nodes_with_depth_changes\0\u{3}old_depths_of_slide_nodes_with_depth_changes\0\u{3}slide_nodes_for_depth_fix_up\0\u{3}depths_of_slide_nodes_for_depth_fix_up\0\u{3}old_depths_of_slide_nodes_for_depth_fix_up\0\u{4}\u{2}collapsed_state_of_slide_nodes_being_removed\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _slideNodesBeingRemoved: [TSP_Reference] = []
    var _removedArgsList: [TSCK_RemoveIdOperationArgs] = []
    var _idsOfSlideNodesWithDepthChanges: [TSP_UUID] = []
    var _depthsOfSlideNodesWithDepthChanges: [UInt32] = []
    var _oldDepthsOfSlideNodesWithDepthChanges: [UInt32] = []
    var _slideNodesForDepthFixUp: [TSP_Reference] = []
    var _depthsOfSlideNodesForDepthFixUp: [UInt32] = []
    var _oldDepthsOfSlideNodesForDepthFixUp: [UInt32] = []
    var _collapsedStateOfSlideNodesBeingRemoved: [Bool] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _slideNodesBeingRemoved = source._slideNodesBeingRemoved
      _removedArgsList = source._removedArgsList
      _idsOfSlideNodesWithDepthChanges = source._idsOfSlideNodesWithDepthChanges
      _depthsOfSlideNodesWithDepthChanges = source._depthsOfSlideNodesWithDepthChanges
      _oldDepthsOfSlideNodesWithDepthChanges = source._oldDepthsOfSlideNodesWithDepthChanges
      _slideNodesForDepthFixUp = source._slideNodesForDepthFixUp
      _depthsOfSlideNodesForDepthFixUp = source._depthsOfSlideNodesForDepthFixUp
      _oldDepthsOfSlideNodesForDepthFixUp = source._oldDepthsOfSlideNodesForDepthFixUp
      _collapsedStateOfSlideNodesBeingRemoved = source._collapsedStateOfSlideNodesBeingRemoved
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._slideNodesBeingRemoved) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._removedArgsList) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._idsOfSlideNodesWithDepthChanges) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._slideNodesForDepthFixUp) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._slideNodesBeingRemoved) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._removedArgsList) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._idsOfSlideNodesWithDepthChanges) }()
        case 5: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._depthsOfSlideNodesWithDepthChanges) }()
        case 6: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._oldDepthsOfSlideNodesWithDepthChanges) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._slideNodesForDepthFixUp) }()
        case 8: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._depthsOfSlideNodesForDepthFixUp) }()
        case 9: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._oldDepthsOfSlideNodesForDepthFixUp) }()
        case 11: try { try decoder.decodeRepeatedBoolField(value: &_storage._collapsedStateOfSlideNodesBeingRemoved) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._slideNodesBeingRemoved.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._slideNodesBeingRemoved, fieldNumber: 2)
      }
      if !_storage._removedArgsList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._removedArgsList, fieldNumber: 3)
      }
      if !_storage._idsOfSlideNodesWithDepthChanges.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._idsOfSlideNodesWithDepthChanges, fieldNumber: 4)
      }
      if !_storage._depthsOfSlideNodesWithDepthChanges.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._depthsOfSlideNodesWithDepthChanges, fieldNumber: 5)
      }
      if !_storage._oldDepthsOfSlideNodesWithDepthChanges.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._oldDepthsOfSlideNodesWithDepthChanges, fieldNumber: 6)
      }
      if !_storage._slideNodesForDepthFixUp.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._slideNodesForDepthFixUp, fieldNumber: 7)
      }
      if !_storage._depthsOfSlideNodesForDepthFixUp.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._depthsOfSlideNodesForDepthFixUp, fieldNumber: 8)
      }
      if !_storage._oldDepthsOfSlideNodesForDepthFixUp.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._oldDepthsOfSlideNodesForDepthFixUp, fieldNumber: 9)
      }
      if !_storage._collapsedStateOfSlideNodesBeingRemoved.isEmpty {
        try visitor.visitRepeatedBoolField(value: _storage._collapsedStateOfSlideNodesBeingRemoved, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowRemoveSlideArchive, rhs: KN_CommandShowRemoveSlideArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._slideNodesBeingRemoved != rhs_storage._slideNodesBeingRemoved {return false}
        if _storage._removedArgsList != rhs_storage._removedArgsList {return false}
        if _storage._idsOfSlideNodesWithDepthChanges != rhs_storage._idsOfSlideNodesWithDepthChanges {return false}
        if _storage._depthsOfSlideNodesWithDepthChanges != rhs_storage._depthsOfSlideNodesWithDepthChanges {return false}
        if _storage._oldDepthsOfSlideNodesWithDepthChanges != rhs_storage._oldDepthsOfSlideNodesWithDepthChanges {return false}
        if _storage._slideNodesForDepthFixUp != rhs_storage._slideNodesForDepthFixUp {return false}
        if _storage._depthsOfSlideNodesForDepthFixUp != rhs_storage._depthsOfSlideNodesForDepthFixUp {return false}
        if _storage._oldDepthsOfSlideNodesForDepthFixUp != rhs_storage._oldDepthsOfSlideNodesForDepthFixUp {return false}
        if _storage._collapsedStateOfSlideNodesBeingRemoved != rhs_storage._collapsedStateOfSlideNodesBeingRemoved {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowChangeThemeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowChangeThemeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}show\0\u{1}theme\0\u{3}old_theme\0\u{3}template_identifier\0\u{3}old_template_identifier\0\u{3}identifier_to_style_map\0\u{3}old_identifier_to_style_map\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _show: TSP_Reference? = nil
    var _theme: TSP_Reference? = nil
    var _oldTheme: TSP_Reference? = nil
    var _templateIdentifier: String? = nil
    var _oldTemplateIdentifier: String? = nil
    var _identifierToStyleMap: KN_CommandShowChangeThemeArchive.IdentifierToStyleMap? = nil
    var _oldIdentifierToStyleMap: KN_CommandShowChangeThemeArchive.IdentifierToStyleMap? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _show = source._show
      _theme = source._theme
      _oldTheme = source._oldTheme
      _templateIdentifier = source._templateIdentifier
      _oldTemplateIdentifier = source._oldTemplateIdentifier
      _identifierToStyleMap = source._identifierToStyleMap
      _oldIdentifierToStyleMap = source._oldIdentifierToStyleMap
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._show == nil {return false}
      if _storage._theme == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._show, !v.isInitialized {return false}
      if let v = _storage._theme, !v.isInitialized {return false}
      if let v = _storage._oldTheme, !v.isInitialized {return false}
      if let v = _storage._identifierToStyleMap, !v.isInitialized {return false}
      if let v = _storage._oldIdentifierToStyleMap, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._show) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._theme) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._oldTheme) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._templateIdentifier) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._oldTemplateIdentifier) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._identifierToStyleMap) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._oldIdentifierToStyleMap) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._show {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._theme {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._oldTheme {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._templateIdentifier {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._oldTemplateIdentifier {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._identifierToStyleMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._oldIdentifierToStyleMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowChangeThemeArchive, rhs: KN_CommandShowChangeThemeArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._show != rhs_storage._show {return false}
        if _storage._theme != rhs_storage._theme {return false}
        if _storage._oldTheme != rhs_storage._oldTheme {return false}
        if _storage._templateIdentifier != rhs_storage._templateIdentifier {return false}
        if _storage._oldTemplateIdentifier != rhs_storage._oldTemplateIdentifier {return false}
        if _storage._identifierToStyleMap != rhs_storage._identifierToStyleMap {return false}
        if _storage._oldIdentifierToStyleMap != rhs_storage._oldIdentifierToStyleMap {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowChangeThemeArchive.IdentifierToStyleMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = KN_CommandShowChangeThemeArchive.protoMessageName + ".IdentifierToStyleMap"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}styles\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.styles) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.styles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.styles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.styles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowChangeThemeArchive.IdentifierToStyleMap, rhs: KN_CommandShowChangeThemeArchive.IdentifierToStyleMap) -> Bool {
    if lhs.styles != rhs.styles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowChangeSlideSizeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowChangeSlideSizeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}size\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._size == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._size, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowChangeSlideSizeArchive, rhs: KN_CommandShowChangeSlideSizeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSetThemeCustomEffectTimingCurveArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetThemeCustomEffectTimingCurveArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}name\0\u{3}path_source\0\u{3}old_path_source\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._pathSource, !v.isInitialized {return false}
    if let v = self._oldPathSource, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pathSource) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._oldPathSource) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pathSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._oldPathSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSetThemeCustomEffectTimingCurveArchive, rhs: KN_CommandSetThemeCustomEffectTimingCurveArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._name != rhs._name {return false}
    if lhs._pathSource != rhs._pathSource {return false}
    if lhs._oldPathSource != rhs._oldPathSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandMoveTemplatesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandMoveTemplatesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{2}template_slides\0\u{3}previous_indexes_keys\0\u{3}previous_indexes_values\0\u{3}final_template_arrangement\0")

  fileprivate class _StorageClass {
    var _super: TSD_ContainerReorderChildrenCommandArchive? = nil
    var _templateSlides: [TSP_Reference] = []
    var _previousIndexesKeys: [TSP_Reference] = []
    var _previousIndexesValues: [UInt32] = []
    var _finalTemplateArrangement: [TSP_Reference] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _templateSlides = source._templateSlides
      _previousIndexesKeys = source._previousIndexesKeys
      _previousIndexesValues = source._previousIndexesValues
      _finalTemplateArrangement = source._finalTemplateArrangement
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._templateSlides) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._previousIndexesKeys) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._finalTemplateArrangement) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._templateSlides) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._previousIndexesKeys) }()
        case 5: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._previousIndexesValues) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._finalTemplateArrangement) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._templateSlides.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._templateSlides, fieldNumber: 3)
      }
      if !_storage._previousIndexesKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._previousIndexesKeys, fieldNumber: 4)
      }
      if !_storage._previousIndexesValues.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._previousIndexesValues, fieldNumber: 5)
      }
      if !_storage._finalTemplateArrangement.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._finalTemplateArrangement, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandMoveTemplatesArchive, rhs: KN_CommandMoveTemplatesArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._templateSlides != rhs_storage._templateSlides {return false}
        if _storage._previousIndexesKeys != rhs_storage._previousIndexesKeys {return false}
        if _storage._previousIndexesValues != rhs_storage._previousIndexesValues {return false}
        if _storage._finalTemplateArrangement != rhs_storage._finalTemplateArrangement {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandInsertTemplateArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandInsertTemplateArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{6}undo_template_change_commands\0\u{3}set_inserted_slide_as_default_template_slide\0\u{3}undo_replacement_template_slide_node\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._setInsertedSlideAsDefaultTemplateSlide == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.undoTemplateChangeCommands) {return false}
    if let v = self._undoReplacementTemplateSlideNode, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.undoTemplateChangeCommands) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._setInsertedSlideAsDefaultTemplateSlide) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._undoReplacementTemplateSlideNode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.undoTemplateChangeCommands.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.undoTemplateChangeCommands, fieldNumber: 7)
    }
    try { if let v = self._setInsertedSlideAsDefaultTemplateSlide {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._undoReplacementTemplateSlideNode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandInsertTemplateArchive, rhs: KN_CommandInsertTemplateArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.undoTemplateChangeCommands != rhs.undoTemplateChangeCommands {return false}
    if lhs._setInsertedSlideAsDefaultTemplateSlide != rhs._setInsertedSlideAsDefaultTemplateSlide {return false}
    if lhs._undoReplacementTemplateSlideNode != rhs._undoReplacementTemplateSlideNode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandPrimitiveInsertTemplateArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandPrimitiveInsertTemplateArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}was_inserted_with_drop\0\u{3}custom_format_keys\0\u{3}previous_classic_theme_records\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._wasInsertedWithDrop == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.customFormatKeys) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.previousClassicThemeRecords) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._wasInsertedWithDrop) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.customFormatKeys) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.previousClassicThemeRecords) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._wasInsertedWithDrop {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    if !self.customFormatKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customFormatKeys, fieldNumber: 3)
    }
    if !self.previousClassicThemeRecords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.previousClassicThemeRecords, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandPrimitiveInsertTemplateArchive, rhs: KN_CommandPrimitiveInsertTemplateArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._wasInsertedWithDrop != rhs._wasInsertedWithDrop {return false}
    if lhs.customFormatKeys != rhs.customFormatKeys {return false}
    if lhs.previousClassicThemeRecords != rhs.previousClassicThemeRecords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandRemoveTemplateArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandRemoveTemplateArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{4}replacement_template_slide_node\0\u{3}template_change_commands\0\u{3}default_template_slide_node_was_replaced\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._replacementTemplateSlideNode, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.templateChangeCommands) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._replacementTemplateSlideNode) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.templateChangeCommands) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._defaultTemplateSlideNodeWasReplaced) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._replacementTemplateSlideNode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.templateChangeCommands.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.templateChangeCommands, fieldNumber: 6)
    }
    try { if let v = self._defaultTemplateSlideNodeWasReplaced {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandRemoveTemplateArchive, rhs: KN_CommandRemoveTemplateArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._replacementTemplateSlideNode != rhs._replacementTemplateSlideNode {return false}
    if lhs.templateChangeCommands != rhs.templateChangeCommands {return false}
    if lhs._defaultTemplateSlideNodeWasReplaced != rhs._defaultTemplateSlideNodeWasReplaced {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandPrimitiveRemoveTemplateArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandPrimitiveRemoveTemplateArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{2}previous_classic_theme_records\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.previousClassicThemeRecords) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.previousClassicThemeRecords) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.previousClassicThemeRecords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.previousClassicThemeRecords, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandPrimitiveRemoveTemplateArchive, rhs: KN_CommandPrimitiveRemoveTemplateArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.previousClassicThemeRecords != rhs.previousClassicThemeRecords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideInsertBuildArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideInsertBuildArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}insert_build_description\0\u{3}identifier_for_chunk_to_insert_after\0\u{3}should_create_chunks\0\u{3}old_tuples_to_update\0\u{3}was_initialized_over_the_wire\0\u{3}has_been_committed\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _insertBuildDescription: TSP_Reference? = nil
    var _identifierForChunkToInsertAfter: KN_BuildChunkIdentifierArchive? = nil
    var _shouldCreateChunks: Bool? = nil
    var _oldTuplesToUpdate: [TSP_Reference] = []
    var _wasInitializedOverTheWire: Bool? = nil
    var _hasBeenCommitted_p: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _insertBuildDescription = source._insertBuildDescription
      _identifierForChunkToInsertAfter = source._identifierForChunkToInsertAfter
      _shouldCreateChunks = source._shouldCreateChunks
      _oldTuplesToUpdate = source._oldTuplesToUpdate
      _wasInitializedOverTheWire = source._wasInitializedOverTheWire
      _hasBeenCommitted_p = source._hasBeenCommitted_p
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._insertBuildDescription == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._insertBuildDescription, !v.isInitialized {return false}
      if let v = _storage._identifierForChunkToInsertAfter, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._oldTuplesToUpdate) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._insertBuildDescription) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._identifierForChunkToInsertAfter) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._shouldCreateChunks) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._oldTuplesToUpdate) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._wasInitializedOverTheWire) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._hasBeenCommitted_p) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._insertBuildDescription {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._identifierForChunkToInsertAfter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._shouldCreateChunks {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      if !_storage._oldTuplesToUpdate.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oldTuplesToUpdate, fieldNumber: 5)
      }
      try { if let v = _storage._wasInitializedOverTheWire {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._hasBeenCommitted_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideInsertBuildArchive, rhs: KN_CommandSlideInsertBuildArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._insertBuildDescription != rhs_storage._insertBuildDescription {return false}
        if _storage._identifierForChunkToInsertAfter != rhs_storage._identifierForChunkToInsertAfter {return false}
        if _storage._shouldCreateChunks != rhs_storage._shouldCreateChunks {return false}
        if _storage._oldTuplesToUpdate != rhs_storage._oldTuplesToUpdate {return false}
        if _storage._wasInitializedOverTheWire != rhs_storage._wasInitializedOverTheWire {return false}
        if _storage._hasBeenCommitted_p != rhs_storage._hasBeenCommitted_p {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_InsertBuildDescriptionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InsertBuildDescriptionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}slide_id\0\u{3}build_to_insert\0\u{3}chunks_to_insert\0\u{3}should_assign_chunk_identifiers\0\u{3}identifers_for_chunks_to_insert_after\0\u{3}tuples_to_update\0\u{3}fallback_chunk_identifiers\0\u{3}is_for_paste\0")

  public var isInitialized: Bool {
    if self._slideID == nil {return false}
    if self._buildToInsert == nil {return false}
    if self._shouldAssignChunkIdentifiers == nil {return false}
    if self._isForPaste == nil {return false}
    if let v = self._slideID, !v.isInitialized {return false}
    if let v = self._buildToInsert, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.chunksToInsert) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.identifersForChunksToInsertAfter) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.tuplesToUpdate) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.fallbackChunkIdentifiers) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._slideID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._buildToInsert) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.chunksToInsert) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._shouldAssignChunkIdentifiers) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.identifersForChunksToInsertAfter) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.tuplesToUpdate) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.fallbackChunkIdentifiers) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._isForPaste) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._slideID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._buildToInsert {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.chunksToInsert.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chunksToInsert, fieldNumber: 3)
    }
    try { if let v = self._shouldAssignChunkIdentifiers {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    if !self.identifersForChunksToInsertAfter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identifersForChunksToInsertAfter, fieldNumber: 5)
    }
    if !self.tuplesToUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tuplesToUpdate, fieldNumber: 6)
    }
    if !self.fallbackChunkIdentifiers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fallbackChunkIdentifiers, fieldNumber: 7)
    }
    try { if let v = self._isForPaste {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_InsertBuildDescriptionArchive, rhs: KN_InsertBuildDescriptionArchive) -> Bool {
    if lhs._slideID != rhs._slideID {return false}
    if lhs._buildToInsert != rhs._buildToInsert {return false}
    if lhs.chunksToInsert != rhs.chunksToInsert {return false}
    if lhs._shouldAssignChunkIdentifiers != rhs._shouldAssignChunkIdentifiers {return false}
    if lhs.identifersForChunksToInsertAfter != rhs.identifersForChunksToInsertAfter {return false}
    if lhs.tuplesToUpdate != rhs.tuplesToUpdate {return false}
    if lhs.fallbackChunkIdentifiers != rhs.fallbackChunkIdentifiers {return false}
    if lhs._isForPaste != rhs._isForPaste {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_UndoObjectArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UndoObjectArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_UndoObjectArchive, rhs: KN_UndoObjectArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideRemoveBuildArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideRemoveBuildArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}remove_build_description\0\u{1}build\0\u{3}chunks_to_insert\0\u{3}identifiers_for_chunks_to_insert_after\0\u{3}old_tuples_to_update\0\u{3}fallback_chunk_identifiers\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _removeBuildDescription: TSP_Reference? = nil
    var _build: TSP_Reference? = nil
    var _chunksToInsert: [TSP_Reference] = []
    var _identifiersForChunksToInsertAfter: [KN_BuildChunkIdentifierArchive] = []
    var _oldTuplesToUpdate: [TSP_Reference] = []
    var _fallbackChunkIdentifiers: [KN_BuildChunkIdentifierArchive] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _removeBuildDescription = source._removeBuildDescription
      _build = source._build
      _chunksToInsert = source._chunksToInsert
      _identifiersForChunksToInsertAfter = source._identifiersForChunksToInsertAfter
      _oldTuplesToUpdate = source._oldTuplesToUpdate
      _fallbackChunkIdentifiers = source._fallbackChunkIdentifiers
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._removeBuildDescription == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._removeBuildDescription, !v.isInitialized {return false}
      if let v = _storage._build, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._chunksToInsert) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._identifiersForChunksToInsertAfter) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._oldTuplesToUpdate) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._fallbackChunkIdentifiers) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._removeBuildDescription) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._build) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._chunksToInsert) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._identifiersForChunksToInsertAfter) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._oldTuplesToUpdate) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._fallbackChunkIdentifiers) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._removeBuildDescription {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._build {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._chunksToInsert.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chunksToInsert, fieldNumber: 4)
      }
      if !_storage._identifiersForChunksToInsertAfter.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._identifiersForChunksToInsertAfter, fieldNumber: 5)
      }
      if !_storage._oldTuplesToUpdate.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oldTuplesToUpdate, fieldNumber: 6)
      }
      if !_storage._fallbackChunkIdentifiers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._fallbackChunkIdentifiers, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideRemoveBuildArchive, rhs: KN_CommandSlideRemoveBuildArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._removeBuildDescription != rhs_storage._removeBuildDescription {return false}
        if _storage._build != rhs_storage._build {return false}
        if _storage._chunksToInsert != rhs_storage._chunksToInsert {return false}
        if _storage._identifiersForChunksToInsertAfter != rhs_storage._identifiersForChunksToInsertAfter {return false}
        if _storage._oldTuplesToUpdate != rhs_storage._oldTuplesToUpdate {return false}
        if _storage._fallbackChunkIdentifiers != rhs_storage._fallbackChunkIdentifiers {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_RemoveBuildDescriptionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveBuildDescriptionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}slide_id\0\u{3}build_id\0\u{3}should_remove_chunks\0\u{3}should_remove_chunk_identifiers\0\u{3}tuples_to_update\0")

  public var isInitialized: Bool {
    if let v = self._slideID, !v.isInitialized {return false}
    if let v = self._buildID, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.tuplesToUpdate) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._slideID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._buildID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._shouldRemoveChunks) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._shouldRemoveChunkIdentifiers) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.tuplesToUpdate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._slideID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._buildID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._shouldRemoveChunks {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._shouldRemoveChunkIdentifiers {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    if !self.tuplesToUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tuplesToUpdate, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_RemoveBuildDescriptionArchive, rhs: KN_RemoveBuildDescriptionArchive) -> Bool {
    if lhs._slideID != rhs._slideID {return false}
    if lhs._buildID != rhs._buildID {return false}
    if lhs._shouldRemoveChunks != rhs._shouldRemoveChunks {return false}
    if lhs._shouldRemoveChunkIdentifiers != rhs._shouldRemoveChunkIdentifiers {return false}
    if lhs.tuplesToUpdate != rhs.tuplesToUpdate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideInsertBuildChunkArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideInsertBuildChunkArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}slide_id\0\u{3}chunk_to_insert\0\u{3}identifier_for_chunk_to_insert_after\0\u{3}tuples_to_update\0\u{3}old_tuples_to_update\0\u{3}needs_selection_update\0\u{3}should_assign_chunk_identifier\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _slideID: TSP_UUID? = nil
    var _chunkToInsert: TSP_Reference? = nil
    var _identifierForChunkToInsertAfter: KN_BuildChunkIdentifierArchive? = nil
    var _tuplesToUpdate: [TSP_Reference] = []
    var _oldTuplesToUpdate: [TSP_Reference] = []
    var _needsSelectionUpdate: Bool? = nil
    var _shouldAssignChunkIdentifier: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _slideID = source._slideID
      _chunkToInsert = source._chunkToInsert
      _identifierForChunkToInsertAfter = source._identifierForChunkToInsertAfter
      _tuplesToUpdate = source._tuplesToUpdate
      _oldTuplesToUpdate = source._oldTuplesToUpdate
      _needsSelectionUpdate = source._needsSelectionUpdate
      _shouldAssignChunkIdentifier = source._shouldAssignChunkIdentifier
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._slideID == nil {return false}
      if _storage._chunkToInsert == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._slideID, !v.isInitialized {return false}
      if let v = _storage._chunkToInsert, !v.isInitialized {return false}
      if let v = _storage._identifierForChunkToInsertAfter, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._tuplesToUpdate) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._oldTuplesToUpdate) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._slideID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._chunkToInsert) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._identifierForChunkToInsertAfter) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._tuplesToUpdate) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._oldTuplesToUpdate) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._needsSelectionUpdate) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._shouldAssignChunkIdentifier) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._slideID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._chunkToInsert {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._identifierForChunkToInsertAfter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._tuplesToUpdate.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tuplesToUpdate, fieldNumber: 5)
      }
      if !_storage._oldTuplesToUpdate.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oldTuplesToUpdate, fieldNumber: 6)
      }
      try { if let v = _storage._needsSelectionUpdate {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._shouldAssignChunkIdentifier {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideInsertBuildChunkArchive, rhs: KN_CommandSlideInsertBuildChunkArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._slideID != rhs_storage._slideID {return false}
        if _storage._chunkToInsert != rhs_storage._chunkToInsert {return false}
        if _storage._identifierForChunkToInsertAfter != rhs_storage._identifierForChunkToInsertAfter {return false}
        if _storage._tuplesToUpdate != rhs_storage._tuplesToUpdate {return false}
        if _storage._oldTuplesToUpdate != rhs_storage._oldTuplesToUpdate {return false}
        if _storage._needsSelectionUpdate != rhs_storage._needsSelectionUpdate {return false}
        if _storage._shouldAssignChunkIdentifier != rhs_storage._shouldAssignChunkIdentifier {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideRemoveBuildChunkArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideRemoveBuildChunkArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}slide_id\0\u{3}removed_chunk\0\u{3}identifier_for_chunk_to_remove\0\u{3}identifier_for_chunk_to_insert_after\0\u{3}tuples_to_update\0\u{3}old_tuples_to_update\0\u{3}needs_selection_update\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _slideID: TSP_UUID? = nil
    var _removedChunk: TSP_Reference? = nil
    var _identifierForChunkToRemove: KN_BuildChunkIdentifierArchive? = nil
    var _identifierForChunkToInsertAfter: KN_BuildChunkIdentifierArchive? = nil
    var _tuplesToUpdate: [TSP_Reference] = []
    var _oldTuplesToUpdate: [TSP_Reference] = []
    var _needsSelectionUpdate: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _slideID = source._slideID
      _removedChunk = source._removedChunk
      _identifierForChunkToRemove = source._identifierForChunkToRemove
      _identifierForChunkToInsertAfter = source._identifierForChunkToInsertAfter
      _tuplesToUpdate = source._tuplesToUpdate
      _oldTuplesToUpdate = source._oldTuplesToUpdate
      _needsSelectionUpdate = source._needsSelectionUpdate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._slideID == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._slideID, !v.isInitialized {return false}
      if let v = _storage._removedChunk, !v.isInitialized {return false}
      if let v = _storage._identifierForChunkToRemove, !v.isInitialized {return false}
      if let v = _storage._identifierForChunkToInsertAfter, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._tuplesToUpdate) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._oldTuplesToUpdate) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._slideID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._removedChunk) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._identifierForChunkToRemove) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._identifierForChunkToInsertAfter) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._tuplesToUpdate) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._oldTuplesToUpdate) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._needsSelectionUpdate) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._slideID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._removedChunk {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._identifierForChunkToRemove {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._identifierForChunkToInsertAfter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._tuplesToUpdate.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tuplesToUpdate, fieldNumber: 6)
      }
      if !_storage._oldTuplesToUpdate.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oldTuplesToUpdate, fieldNumber: 7)
      }
      try { if let v = _storage._needsSelectionUpdate {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideRemoveBuildChunkArchive, rhs: KN_CommandSlideRemoveBuildChunkArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._slideID != rhs_storage._slideID {return false}
        if _storage._removedChunk != rhs_storage._removedChunk {return false}
        if _storage._identifierForChunkToRemove != rhs_storage._identifierForChunkToRemove {return false}
        if _storage._identifierForChunkToInsertAfter != rhs_storage._identifierForChunkToInsertAfter {return false}
        if _storage._tuplesToUpdate != rhs_storage._tuplesToUpdate {return false}
        if _storage._oldTuplesToUpdate != rhs_storage._oldTuplesToUpdate {return false}
        if _storage._needsSelectionUpdate != rhs_storage._needsSelectionUpdate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideMoveBuildChunksArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideMoveBuildChunksArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}identifiers_for_chunks_to_move\0\u{3}identifiers_for_chunks_to_move_after\0\u{3}identifiers_for_chunks_to_move_after_for_undo\0\u{3}tuples_to_update\0\u{3}old_tuples_to_update\0\u{3}identifiers_for_chunks_to_move_including_clustered_inactive_chunks\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _identifiersForChunksToMove: [KN_BuildChunkIdentifierArchive] = []
    var _identifiersForChunksToMoveAfter: [KN_BuildChunkIdentifierArchive] = []
    var _identifiersForChunksToMoveAfterForUndo: [KN_BuildChunkIdentifierArchive] = []
    var _tuplesToUpdate: [TSP_Reference] = []
    var _oldTuplesToUpdate: [TSP_Reference] = []
    var _identifiersForChunksToMoveIncludingClusteredInactiveChunks: [KN_BuildChunkIdentifierArchive] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _identifiersForChunksToMove = source._identifiersForChunksToMove
      _identifiersForChunksToMoveAfter = source._identifiersForChunksToMoveAfter
      _identifiersForChunksToMoveAfterForUndo = source._identifiersForChunksToMoveAfterForUndo
      _tuplesToUpdate = source._tuplesToUpdate
      _oldTuplesToUpdate = source._oldTuplesToUpdate
      _identifiersForChunksToMoveIncludingClusteredInactiveChunks = source._identifiersForChunksToMoveIncludingClusteredInactiveChunks
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._identifiersForChunksToMove) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._identifiersForChunksToMoveAfter) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._identifiersForChunksToMoveAfterForUndo) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._tuplesToUpdate) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._oldTuplesToUpdate) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._identifiersForChunksToMoveIncludingClusteredInactiveChunks) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._identifiersForChunksToMove) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._identifiersForChunksToMoveAfter) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._identifiersForChunksToMoveAfterForUndo) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._tuplesToUpdate) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._oldTuplesToUpdate) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._identifiersForChunksToMoveIncludingClusteredInactiveChunks) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._identifiersForChunksToMove.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._identifiersForChunksToMove, fieldNumber: 2)
      }
      if !_storage._identifiersForChunksToMoveAfter.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._identifiersForChunksToMoveAfter, fieldNumber: 3)
      }
      if !_storage._identifiersForChunksToMoveAfterForUndo.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._identifiersForChunksToMoveAfterForUndo, fieldNumber: 4)
      }
      if !_storage._tuplesToUpdate.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tuplesToUpdate, fieldNumber: 5)
      }
      if !_storage._oldTuplesToUpdate.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oldTuplesToUpdate, fieldNumber: 6)
      }
      if !_storage._identifiersForChunksToMoveIncludingClusteredInactiveChunks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._identifiersForChunksToMoveIncludingClusteredInactiveChunks, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideMoveBuildChunksArchive, rhs: KN_CommandSlideMoveBuildChunksArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._identifiersForChunksToMove != rhs_storage._identifiersForChunksToMove {return false}
        if _storage._identifiersForChunksToMoveAfter != rhs_storage._identifiersForChunksToMoveAfter {return false}
        if _storage._identifiersForChunksToMoveAfterForUndo != rhs_storage._identifiersForChunksToMoveAfterForUndo {return false}
        if _storage._tuplesToUpdate != rhs_storage._tuplesToUpdate {return false}
        if _storage._oldTuplesToUpdate != rhs_storage._oldTuplesToUpdate {return false}
        if _storage._identifiersForChunksToMoveIncludingClusteredInactiveChunks != rhs_storage._identifiersForChunksToMoveIncludingClusteredInactiveChunks {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandBuildSetValueArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandBuildSetValueArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}tuple\0\u{3}chunks_to_add\0\u{3}identifiers_for_chunks_to_insert_after\0\u{3}identifiers_for_chunks_to_remove\0\u{3}tuples_to_update\0\u{3}old_tuple_for_main_property\0\u{3}old_tuples_to_update_for_sub_commands\0\u{3}identifiers_for_added_chunks\0\u{3}generated_identifiers\0\u{3}removed_chunks\0\u{3}identifiers_for_chunks_prior_to_removed_chunks\0\u{3}old_chunk_ID_seed\0\u{3}old_chunk_identifiers\0\u{3}chunks_removed_during_undo\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _tuple: TSP_Reference? = nil
    var _chunksToAdd: [TSP_Reference] = []
    var _identifiersForChunksToInsertAfter: [KN_BuildChunkIdentifierArchive] = []
    var _identifiersForChunksToRemove: [KN_BuildChunkIdentifierArchive] = []
    var _tuplesToUpdate: [TSP_Reference] = []
    var _oldTupleForMainProperty: TSP_Reference? = nil
    var _oldTuplesToUpdateForSubCommands: [TSP_Reference] = []
    var _identifiersForAddedChunks: [KN_BuildChunkIdentifierArchive] = []
    var _generatedIdentifiers: [KN_BuildChunkIdentifierArchive] = []
    var _removedChunks: [TSP_Reference] = []
    var _identifiersForChunksPriorToRemovedChunks: [KN_BuildChunkIdentifierArchive] = []
    var _oldChunkIDSeed: UInt32? = nil
    var _oldChunkIdentifiers: [KN_BuildChunkIdentifierArchive] = []
    var _chunksRemovedDuringUndo: [TSP_Reference] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _tuple = source._tuple
      _chunksToAdd = source._chunksToAdd
      _identifiersForChunksToInsertAfter = source._identifiersForChunksToInsertAfter
      _identifiersForChunksToRemove = source._identifiersForChunksToRemove
      _tuplesToUpdate = source._tuplesToUpdate
      _oldTupleForMainProperty = source._oldTupleForMainProperty
      _oldTuplesToUpdateForSubCommands = source._oldTuplesToUpdateForSubCommands
      _identifiersForAddedChunks = source._identifiersForAddedChunks
      _generatedIdentifiers = source._generatedIdentifiers
      _removedChunks = source._removedChunks
      _identifiersForChunksPriorToRemovedChunks = source._identifiersForChunksPriorToRemovedChunks
      _oldChunkIDSeed = source._oldChunkIDSeed
      _oldChunkIdentifiers = source._oldChunkIdentifiers
      _chunksRemovedDuringUndo = source._chunksRemovedDuringUndo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._tuple, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._chunksToAdd) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._identifiersForChunksToInsertAfter) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._identifiersForChunksToRemove) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._tuplesToUpdate) {return false}
      if let v = _storage._oldTupleForMainProperty, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._oldTuplesToUpdateForSubCommands) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._identifiersForAddedChunks) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._generatedIdentifiers) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._removedChunks) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._identifiersForChunksPriorToRemovedChunks) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._oldChunkIdentifiers) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._chunksRemovedDuringUndo) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._tuple) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._chunksToAdd) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._identifiersForChunksToInsertAfter) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._identifiersForChunksToRemove) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._tuplesToUpdate) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._oldTupleForMainProperty) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._oldTuplesToUpdateForSubCommands) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._identifiersForAddedChunks) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._generatedIdentifiers) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._removedChunks) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._identifiersForChunksPriorToRemovedChunks) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._oldChunkIDSeed) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._oldChunkIdentifiers) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._chunksRemovedDuringUndo) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._tuple {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._chunksToAdd.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chunksToAdd, fieldNumber: 3)
      }
      if !_storage._identifiersForChunksToInsertAfter.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._identifiersForChunksToInsertAfter, fieldNumber: 4)
      }
      if !_storage._identifiersForChunksToRemove.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._identifiersForChunksToRemove, fieldNumber: 5)
      }
      if !_storage._tuplesToUpdate.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tuplesToUpdate, fieldNumber: 6)
      }
      try { if let v = _storage._oldTupleForMainProperty {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._oldTuplesToUpdateForSubCommands.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oldTuplesToUpdateForSubCommands, fieldNumber: 8)
      }
      if !_storage._identifiersForAddedChunks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._identifiersForAddedChunks, fieldNumber: 9)
      }
      if !_storage._generatedIdentifiers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._generatedIdentifiers, fieldNumber: 10)
      }
      if !_storage._removedChunks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._removedChunks, fieldNumber: 11)
      }
      if !_storage._identifiersForChunksPriorToRemovedChunks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._identifiersForChunksPriorToRemovedChunks, fieldNumber: 12)
      }
      try { if let v = _storage._oldChunkIDSeed {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 13)
      } }()
      if !_storage._oldChunkIdentifiers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oldChunkIdentifiers, fieldNumber: 14)
      }
      if !_storage._chunksRemovedDuringUndo.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chunksRemovedDuringUndo, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandBuildSetValueArchive, rhs: KN_CommandBuildSetValueArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._tuple != rhs_storage._tuple {return false}
        if _storage._chunksToAdd != rhs_storage._chunksToAdd {return false}
        if _storage._identifiersForChunksToInsertAfter != rhs_storage._identifiersForChunksToInsertAfter {return false}
        if _storage._identifiersForChunksToRemove != rhs_storage._identifiersForChunksToRemove {return false}
        if _storage._tuplesToUpdate != rhs_storage._tuplesToUpdate {return false}
        if _storage._oldTupleForMainProperty != rhs_storage._oldTupleForMainProperty {return false}
        if _storage._oldTuplesToUpdateForSubCommands != rhs_storage._oldTuplesToUpdateForSubCommands {return false}
        if _storage._identifiersForAddedChunks != rhs_storage._identifiersForAddedChunks {return false}
        if _storage._generatedIdentifiers != rhs_storage._generatedIdentifiers {return false}
        if _storage._removedChunks != rhs_storage._removedChunks {return false}
        if _storage._identifiersForChunksPriorToRemovedChunks != rhs_storage._identifiersForChunksPriorToRemovedChunks {return false}
        if _storage._oldChunkIDSeed != rhs_storage._oldChunkIDSeed {return false}
        if _storage._oldChunkIdentifiers != rhs_storage._oldChunkIdentifiers {return false}
        if _storage._chunksRemovedDuringUndo != rhs_storage._chunksRemovedDuringUndo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandBuildUpdateChunkReferentsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandBuildUpdateChunkReferentsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}build_id\0\u{3}tuples_to_update\0\u{3}old_tuples_to_update\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._buildID == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._buildID, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.tuplesToUpdate) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldTuplesToUpdate) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._buildID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.tuplesToUpdate) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.oldTuplesToUpdate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._buildID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.tuplesToUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tuplesToUpdate, fieldNumber: 3)
    }
    if !self.oldTuplesToUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldTuplesToUpdate, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandBuildUpdateChunkReferentsArchive, rhs: KN_CommandBuildUpdateChunkReferentsArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._buildID != rhs._buildID {return false}
    if lhs.tuplesToUpdate != rhs.tuplesToUpdate {return false}
    if lhs.oldTuplesToUpdate != rhs.oldTuplesToUpdate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandBuildUpdateChunkCountArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandBuildUpdateChunkCountArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}slide_id\0\u{3}drawable_ids\0\u{3}expected_delivery_style_tuples\0\u{3}chunks_to_add\0\u{3}identifiers_for_chunks_to_insert_after\0\u{3}identifiers_for_chunks_to_remove\0\u{3}tuples_to_update\0\u{3}needs_async_process_changes_selection_update\0\u{3}old_tuples_to_update\0\u{3}identifiers_for_added_chunks\0\u{3}generated_identifiers\0\u{3}removed_chunks\0\u{3}identifiers_for_chunks_prior_to_removed_chunks\0\u{3}old_delivery_style_tuples\0\u{3}old_chunk_ID_seeds\0\u{3}old_chunk_identifiers\0\u{3}working_builds\0\u{3}chunks_removed_during_undo\0\u{3}chunks_added_during_undo\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _slideID: TSP_UUID? = nil
    var _drawableIds: [TSP_UUID] = []
    var _expectedDeliveryStyleTuples: [TSP_Reference] = []
    var _chunksToAdd: [TSP_Reference] = []
    var _identifiersForChunksToInsertAfter: [KN_BuildChunkIdentifierArchive] = []
    var _identifiersForChunksToRemove: [KN_BuildChunkIdentifierArchive] = []
    var _tuplesToUpdate: [TSP_Reference] = []
    var _needsAsyncProcessChangesSelectionUpdate: Bool? = nil
    var _oldTuplesToUpdate: [TSP_Reference] = []
    var _identifiersForAddedChunks: [KN_BuildChunkIdentifierArchive] = []
    var _generatedIdentifiers: [KN_BuildChunkIdentifierArchive] = []
    var _removedChunks: [TSP_Reference] = []
    var _identifiersForChunksPriorToRemovedChunks: [KN_BuildChunkIdentifierArchive] = []
    var _oldDeliveryStyleTuples: [TSP_Reference] = []
    var _oldChunkIDSeeds: [UInt32] = []
    var _oldChunkIdentifiers: [KN_BuildChunkIdentifierArchive] = []
    var _workingBuilds: [TSP_Reference] = []
    var _chunksRemovedDuringUndo: [TSP_Reference] = []
    var _chunksAddedDuringUndo: [TSP_Reference] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _slideID = source._slideID
      _drawableIds = source._drawableIds
      _expectedDeliveryStyleTuples = source._expectedDeliveryStyleTuples
      _chunksToAdd = source._chunksToAdd
      _identifiersForChunksToInsertAfter = source._identifiersForChunksToInsertAfter
      _identifiersForChunksToRemove = source._identifiersForChunksToRemove
      _tuplesToUpdate = source._tuplesToUpdate
      _needsAsyncProcessChangesSelectionUpdate = source._needsAsyncProcessChangesSelectionUpdate
      _oldTuplesToUpdate = source._oldTuplesToUpdate
      _identifiersForAddedChunks = source._identifiersForAddedChunks
      _generatedIdentifiers = source._generatedIdentifiers
      _removedChunks = source._removedChunks
      _identifiersForChunksPriorToRemovedChunks = source._identifiersForChunksPriorToRemovedChunks
      _oldDeliveryStyleTuples = source._oldDeliveryStyleTuples
      _oldChunkIDSeeds = source._oldChunkIDSeeds
      _oldChunkIdentifiers = source._oldChunkIdentifiers
      _workingBuilds = source._workingBuilds
      _chunksRemovedDuringUndo = source._chunksRemovedDuringUndo
      _chunksAddedDuringUndo = source._chunksAddedDuringUndo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._slideID == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._slideID, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._drawableIds) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._expectedDeliveryStyleTuples) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._chunksToAdd) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._identifiersForChunksToInsertAfter) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._identifiersForChunksToRemove) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._tuplesToUpdate) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._oldTuplesToUpdate) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._identifiersForAddedChunks) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._generatedIdentifiers) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._removedChunks) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._identifiersForChunksPriorToRemovedChunks) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._oldDeliveryStyleTuples) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._oldChunkIdentifiers) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._workingBuilds) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._chunksRemovedDuringUndo) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._chunksAddedDuringUndo) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._slideID) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._drawableIds) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._expectedDeliveryStyleTuples) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._chunksToAdd) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._identifiersForChunksToInsertAfter) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._identifiersForChunksToRemove) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._tuplesToUpdate) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._needsAsyncProcessChangesSelectionUpdate) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._oldTuplesToUpdate) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._identifiersForAddedChunks) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._generatedIdentifiers) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._removedChunks) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._identifiersForChunksPriorToRemovedChunks) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._oldDeliveryStyleTuples) }()
        case 16: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._oldChunkIDSeeds) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._oldChunkIdentifiers) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._workingBuilds) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._chunksRemovedDuringUndo) }()
        case 20: try { try decoder.decodeRepeatedMessageField(value: &_storage._chunksAddedDuringUndo) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._slideID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._drawableIds.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._drawableIds, fieldNumber: 3)
      }
      if !_storage._expectedDeliveryStyleTuples.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._expectedDeliveryStyleTuples, fieldNumber: 4)
      }
      if !_storage._chunksToAdd.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chunksToAdd, fieldNumber: 5)
      }
      if !_storage._identifiersForChunksToInsertAfter.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._identifiersForChunksToInsertAfter, fieldNumber: 6)
      }
      if !_storage._identifiersForChunksToRemove.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._identifiersForChunksToRemove, fieldNumber: 7)
      }
      if !_storage._tuplesToUpdate.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tuplesToUpdate, fieldNumber: 8)
      }
      try { if let v = _storage._needsAsyncProcessChangesSelectionUpdate {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
      if !_storage._oldTuplesToUpdate.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oldTuplesToUpdate, fieldNumber: 10)
      }
      if !_storage._identifiersForAddedChunks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._identifiersForAddedChunks, fieldNumber: 11)
      }
      if !_storage._generatedIdentifiers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._generatedIdentifiers, fieldNumber: 12)
      }
      if !_storage._removedChunks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._removedChunks, fieldNumber: 13)
      }
      if !_storage._identifiersForChunksPriorToRemovedChunks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._identifiersForChunksPriorToRemovedChunks, fieldNumber: 14)
      }
      if !_storage._oldDeliveryStyleTuples.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oldDeliveryStyleTuples, fieldNumber: 15)
      }
      if !_storage._oldChunkIDSeeds.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._oldChunkIDSeeds, fieldNumber: 16)
      }
      if !_storage._oldChunkIdentifiers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oldChunkIdentifiers, fieldNumber: 17)
      }
      if !_storage._workingBuilds.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._workingBuilds, fieldNumber: 18)
      }
      if !_storage._chunksRemovedDuringUndo.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chunksRemovedDuringUndo, fieldNumber: 19)
      }
      if !_storage._chunksAddedDuringUndo.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chunksAddedDuringUndo, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandBuildUpdateChunkCountArchive, rhs: KN_CommandBuildUpdateChunkCountArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._slideID != rhs_storage._slideID {return false}
        if _storage._drawableIds != rhs_storage._drawableIds {return false}
        if _storage._expectedDeliveryStyleTuples != rhs_storage._expectedDeliveryStyleTuples {return false}
        if _storage._chunksToAdd != rhs_storage._chunksToAdd {return false}
        if _storage._identifiersForChunksToInsertAfter != rhs_storage._identifiersForChunksToInsertAfter {return false}
        if _storage._identifiersForChunksToRemove != rhs_storage._identifiersForChunksToRemove {return false}
        if _storage._tuplesToUpdate != rhs_storage._tuplesToUpdate {return false}
        if _storage._needsAsyncProcessChangesSelectionUpdate != rhs_storage._needsAsyncProcessChangesSelectionUpdate {return false}
        if _storage._oldTuplesToUpdate != rhs_storage._oldTuplesToUpdate {return false}
        if _storage._identifiersForAddedChunks != rhs_storage._identifiersForAddedChunks {return false}
        if _storage._generatedIdentifiers != rhs_storage._generatedIdentifiers {return false}
        if _storage._removedChunks != rhs_storage._removedChunks {return false}
        if _storage._identifiersForChunksPriorToRemovedChunks != rhs_storage._identifiersForChunksPriorToRemovedChunks {return false}
        if _storage._oldDeliveryStyleTuples != rhs_storage._oldDeliveryStyleTuples {return false}
        if _storage._oldChunkIDSeeds != rhs_storage._oldChunkIDSeeds {return false}
        if _storage._oldChunkIdentifiers != rhs_storage._oldChunkIdentifiers {return false}
        if _storage._workingBuilds != rhs_storage._workingBuilds {return false}
        if _storage._chunksRemovedDuringUndo != rhs_storage._chunksRemovedDuringUndo {return false}
        if _storage._chunksAddedDuringUndo != rhs_storage._chunksAddedDuringUndo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandBuildChunkSetValueArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandBuildChunkSetValueArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}tuples_to_update\0\u{3}old_tuples_to_update\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.tuplesToUpdate) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldTuplesToUpdate) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tuplesToUpdate) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.oldTuplesToUpdate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.tuplesToUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tuplesToUpdate, fieldNumber: 2)
    }
    if !self.oldTuplesToUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldTuplesToUpdate, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandBuildChunkSetValueArchive, rhs: KN_CommandBuildChunkSetValueArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.tuplesToUpdate != rhs.tuplesToUpdate {return false}
    if lhs.oldTuplesToUpdate != rhs.oldTuplesToUpdate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandTransitionSetValueArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandTransitionSetValueArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}slide_node_id_path\0\u{3}old_attributes\0\u{1}attributes\0\u{1}property\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._slideNodeIDPath == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._slideNodeIDPath, !v.isInitialized {return false}
    if let v = self._oldAttributes, !v.isInitialized {return false}
    if let v = self._attributes, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._slideNodeIDPath) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._oldAttributes) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._attributes) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._property) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._slideNodeIDPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._oldAttributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._attributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._property {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandTransitionSetValueArchive, rhs: KN_CommandTransitionSetValueArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._slideNodeIDPath != rhs._slideNodeIDPath {return false}
    if lhs._oldAttributes != rhs._oldAttributes {return false}
    if lhs._attributes != rhs._attributes {return false}
    if lhs._property != rhs._property {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowSetSlideNumberVisibilityArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowSetSlideNumberVisibilityArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{2}slide_numbers_visible\0\u{3}ids_of_slide_nodes_to_skip\0\u{3}ids_of_slide_nodes_already_correct\0\u{3}is_undo\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._slideNumbersVisible == nil {return false}
    if self._isUndo == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.idsOfSlideNodesToSkip) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.idsOfSlideNodesAlreadyCorrect) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._slideNumbersVisible) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.idsOfSlideNodesToSkip) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.idsOfSlideNodesAlreadyCorrect) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._isUndo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._slideNumbersVisible {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    if !self.idsOfSlideNodesToSkip.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.idsOfSlideNodesToSkip, fieldNumber: 4)
    }
    if !self.idsOfSlideNodesAlreadyCorrect.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.idsOfSlideNodesAlreadyCorrect, fieldNumber: 5)
    }
    try { if let v = self._isUndo {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowSetSlideNumberVisibilityArchive, rhs: KN_CommandShowSetSlideNumberVisibilityArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._slideNumbersVisible != rhs._slideNumbersVisible {return false}
    if lhs.idsOfSlideNodesToSkip != rhs.idsOfSlideNodesToSkip {return false}
    if lhs.idsOfSlideNodesAlreadyCorrect != rhs.idsOfSlideNodesAlreadyCorrect {return false}
    if lhs._isUndo != rhs._isUndo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandTemplateSetThumbnailTextArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandTemplateSetThumbnailTextArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}template_id\0\u{3}is_body\0\u{3}new_text\0\u{3}old_text\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._templateID == nil {return false}
    if self._isBody == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._templateID, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._templateID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._isBody) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._newText) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._oldText) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._templateID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._isBody {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._newText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._oldText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandTemplateSetThumbnailTextArchive, rhs: KN_CommandTemplateSetThumbnailTextArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._templateID != rhs._templateID {return false}
    if lhs._isBody != rhs._isBody {return false}
    if lhs._newText != rhs._newText {return false}
    if lhs._oldText != rhs._oldText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandTemplateSetBodyStylesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandTemplateSetBodyStylesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}template_id\0\u{3}new_paragraph_styles\0\u{3}new_list_styles\0\u{3}old_paragraph_styles\0\u{3}old_list_styles\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _templateID: TSP_UUID? = nil
    var _newParagraphStyles: [TSP_Reference] = []
    var _newListStyles: [TSP_Reference] = []
    var _oldParagraphStyles: [TSP_Reference] = []
    var _oldListStyles: [TSP_Reference] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _templateID = source._templateID
      _newParagraphStyles = source._newParagraphStyles
      _newListStyles = source._newListStyles
      _oldParagraphStyles = source._oldParagraphStyles
      _oldListStyles = source._oldListStyles
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._templateID == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._templateID, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._newParagraphStyles) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._newListStyles) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._oldParagraphStyles) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._oldListStyles) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._templateID) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._newParagraphStyles) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._newListStyles) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._oldParagraphStyles) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._oldListStyles) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._templateID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._newParagraphStyles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._newParagraphStyles, fieldNumber: 3)
      }
      if !_storage._newListStyles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._newListStyles, fieldNumber: 4)
      }
      if !_storage._oldParagraphStyles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oldParagraphStyles, fieldNumber: 5)
      }
      if !_storage._oldListStyles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oldListStyles, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandTemplateSetBodyStylesArchive, rhs: KN_CommandTemplateSetBodyStylesArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._templateID != rhs_storage._templateID {return false}
        if _storage._newParagraphStyles != rhs_storage._newParagraphStyles {return false}
        if _storage._newListStyles != rhs_storage._newListStyles {return false}
        if _storage._oldParagraphStyles != rhs_storage._oldParagraphStyles {return false}
        if _storage._oldListStyles != rhs_storage._oldListStyles {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandChangeTemplateSlideArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandChangeTemplateSlideArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}slide_id_path\0\u{3}template_slide_node\0\u{3}old_template_slide_node\0\u{3}is_undo_redo\0\u{3}target_prototype\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _slideIDPath: TSP_UUIDPath? = nil
    var _templateSlideNode: TSP_Reference? = nil
    var _oldTemplateSlideNode: TSP_Reference? = nil
    var _isUndoRedo: Bool? = nil
    var _targetPrototype: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _slideIDPath = source._slideIDPath
      _templateSlideNode = source._templateSlideNode
      _oldTemplateSlideNode = source._oldTemplateSlideNode
      _isUndoRedo = source._isUndoRedo
      _targetPrototype = source._targetPrototype
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._slideIDPath == nil {return false}
      if _storage._templateSlideNode == nil {return false}
      if _storage._isUndoRedo == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._slideIDPath, !v.isInitialized {return false}
      if let v = _storage._templateSlideNode, !v.isInitialized {return false}
      if let v = _storage._oldTemplateSlideNode, !v.isInitialized {return false}
      if let v = _storage._targetPrototype, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._slideIDPath) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._templateSlideNode) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._oldTemplateSlideNode) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._isUndoRedo) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._targetPrototype) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._slideIDPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._templateSlideNode {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._oldTemplateSlideNode {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._isUndoRedo {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._targetPrototype {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandChangeTemplateSlideArchive, rhs: KN_CommandChangeTemplateSlideArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._slideIDPath != rhs_storage._slideIDPath {return false}
        if _storage._templateSlideNode != rhs_storage._templateSlideNode {return false}
        if _storage._oldTemplateSlideNode != rhs_storage._oldTemplateSlideNode {return false}
        if _storage._isUndoRedo != rhs_storage._isUndoRedo {return false}
        if _storage._targetPrototype != rhs_storage._targetPrototype {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlidePrimitiveSetTemplateArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlidePrimitiveSetTemplateArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}slide_id_path\0\u{3}template_id\0\u{3}old_template_slide_node\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _slideIDPath: TSP_UUIDPath? = nil
    var _templateID: TSP_UUID? = nil
    var _oldTemplateSlideNode: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _slideIDPath = source._slideIDPath
      _templateID = source._templateID
      _oldTemplateSlideNode = source._oldTemplateSlideNode
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._slideIDPath == nil {return false}
      if _storage._templateID == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._slideIDPath, !v.isInitialized {return false}
      if let v = _storage._templateID, !v.isInitialized {return false}
      if let v = _storage._oldTemplateSlideNode, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._slideIDPath) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._templateID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._oldTemplateSlideNode) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._slideIDPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._templateID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._oldTemplateSlideNode {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlidePrimitiveSetTemplateArchive, rhs: KN_CommandSlidePrimitiveSetTemplateArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._slideIDPath != rhs_storage._slideIDPath {return false}
        if _storage._templateID != rhs_storage._templateID {return false}
        if _storage._oldTemplateSlideNode != rhs_storage._oldTemplateSlideNode {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideResetTemplateBackgroundObjectsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideResetTemplateBackgroundObjectsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}slide_id_path\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._slideIDPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._slideIDPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._slideIDPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideResetTemplateBackgroundObjectsArchive, rhs: KN_CommandSlideResetTemplateBackgroundObjectsArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._slideIDPath != rhs._slideIDPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandShowSetSoundtrack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandShowSetSoundtrack"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}show\0\u{1}soundtrack\0\u{3}old_soundtrack\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _show: TSP_Reference? = nil
    var _soundtrack: TSP_Reference? = nil
    var _oldSoundtrack: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _show = source._show
      _soundtrack = source._soundtrack
      _oldSoundtrack = source._oldSoundtrack
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._show, !v.isInitialized {return false}
      if let v = _storage._soundtrack, !v.isInitialized {return false}
      if let v = _storage._oldSoundtrack, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._show) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._soundtrack) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._oldSoundtrack) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._show {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._soundtrack {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._oldSoundtrack {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandShowSetSoundtrack, rhs: KN_CommandShowSetSoundtrack) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._show != rhs_storage._show {return false}
        if _storage._soundtrack != rhs_storage._soundtrack {return false}
        if _storage._oldSoundtrack != rhs_storage._oldSoundtrack {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSoundtrackSetValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSoundtrackSetValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}soundtrack_id\0\u{1}property\0\u{3}old_value\0\u{3}new_value\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _soundtrackID: TSP_UUID? = nil
    var _property: String? = nil
    var _oldValue: KN_CommandSoundtrackSetValue.PropertyValue? = nil
    var _newValue: KN_CommandSoundtrackSetValue.PropertyValue? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _soundtrackID = source._soundtrackID
      _property = source._property
      _oldValue = source._oldValue
      _newValue = source._newValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._soundtrackID, !v.isInitialized {return false}
      if let v = _storage._oldValue, !v.isInitialized {return false}
      if let v = _storage._newValue, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._soundtrackID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._property) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._oldValue) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._newValue) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._soundtrackID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._property {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._oldValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._newValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSoundtrackSetValue, rhs: KN_CommandSoundtrackSetValue) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._soundtrackID != rhs_storage._soundtrackID {return false}
        if _storage._property != rhs_storage._property {return false}
        if _storage._oldValue != rhs_storage._oldValue {return false}
        if _storage._newValue != rhs_storage._newValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSoundtrackSetValue.PropertyValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = KN_CommandSoundtrackSetValue.protoMessageName + ".PropertyValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}double_value\0\u{3}mode_value\0\u{3}media_reference_values\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.mediaReferenceValues) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._doubleValue) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._modeValue) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mediaReferenceValues) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._doubleValue {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._modeValue {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    if !self.mediaReferenceValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mediaReferenceValues, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSoundtrackSetValue.PropertyValue, rhs: KN_CommandSoundtrackSetValue.PropertyValue) -> Bool {
    if lhs._doubleValue != rhs._doubleValue {return false}
    if lhs._modeValue != rhs._modeValue {return false}
    if lhs.mediaReferenceValues != rhs.mediaReferenceValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandSlideUpdateTemplateDrawables: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSlideUpdateTemplateDrawables"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}slide_id\0\u{3}id_placement_operation_args\0\u{3}old_child_infos_for_undo\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._slideID == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._slideID, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.idPlacementOperationArgs) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldChildInfosForUndo) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._slideID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.idPlacementOperationArgs) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.oldChildInfosForUndo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._slideID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.idPlacementOperationArgs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.idPlacementOperationArgs, fieldNumber: 3)
    }
    if !self.oldChildInfosForUndo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldChildInfosForUndo, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandSlideUpdateTemplateDrawables, rhs: KN_CommandSlideUpdateTemplateDrawables) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._slideID != rhs._slideID {return false}
    if lhs.idPlacementOperationArgs != rhs.idPlacementOperationArgs {return false}
    if lhs.oldChildInfosForUndo != rhs.oldChildInfosForUndo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_ChartInfoGeometryCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChartInfoGeometryCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}previous_legend_offset\0\u{3}previous_legend_size\0\u{3}adjusted_legend_offset\0\u{3}adjusted_legend_size\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._previousLegendOffset == nil {return false}
    if self._previousLegendSize == nil {return false}
    if self._adjustedLegendOffset == nil {return false}
    if self._adjustedLegendSize == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._previousLegendOffset, !v.isInitialized {return false}
    if let v = self._previousLegendSize, !v.isInitialized {return false}
    if let v = self._adjustedLegendOffset, !v.isInitialized {return false}
    if let v = self._adjustedLegendSize, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._previousLegendOffset) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._previousLegendSize) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._adjustedLegendOffset) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._adjustedLegendSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._previousLegendOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._previousLegendSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._adjustedLegendOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._adjustedLegendSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_ChartInfoGeometryCommandArchive, rhs: KN_ChartInfoGeometryCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._previousLegendOffset != rhs._previousLegendOffset {return false}
    if lhs._previousLegendSize != rhs._previousLegendSize {return false}
    if lhs._adjustedLegendOffset != rhs._adjustedLegendOffset {return false}
    if lhs._adjustedLegendSize != rhs._adjustedLegendSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CanvasSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CanvasSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}transformer_helper\0\u{3}build_chunk_ids\0\u{3}action_build_ids\0\u{3}originally_selected_drawable_uuids\0")

  public var isInitialized: Bool {
    if self._transformerHelper == nil {return false}
    if let v = self._transformerHelper, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.buildChunkIds) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.actionBuildIds) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.originallySelectedDrawableUuids) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transformerHelper) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.buildChunkIds) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.actionBuildIds) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.originallySelectedDrawableUuids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transformerHelper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.buildChunkIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buildChunkIds, fieldNumber: 2)
    }
    if !self.actionBuildIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actionBuildIds, fieldNumber: 3)
    }
    if !self.originallySelectedDrawableUuids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.originallySelectedDrawableUuids, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CanvasSelectionTransformerArchive, rhs: KN_CanvasSelectionTransformerArchive) -> Bool {
    if lhs._transformerHelper != rhs._transformerHelper {return false}
    if lhs.buildChunkIds != rhs.buildChunkIds {return false}
    if lhs.actionBuildIds != rhs.actionBuildIds {return false}
    if lhs.originallySelectedDrawableUuids != rhs.originallySelectedDrawableUuids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_ActionGhostSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionGhostSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_ActionGhostSelectionTransformerArchive, rhs: KN_ActionGhostSelectionTransformerArchive) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_DocumentSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}document_selection\0")

  public var isInitialized: Bool {
    if self._documentSelection == nil {return false}
    if let v = self._documentSelection, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._documentSelection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._documentSelection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_DocumentSelectionTransformerArchive, rhs: KN_DocumentSelectionTransformerArchive) -> Bool {
    if lhs._documentSelection != rhs._documentSelection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_NoteCanvasSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NoteCanvasSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}transformer_helper\0")

  public var isInitialized: Bool {
    if self._transformerHelper == nil {return false}
    if let v = self._transformerHelper, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transformerHelper) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transformerHelper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_NoteCanvasSelectionTransformerArchive, rhs: KN_NoteCanvasSelectionTransformerArchive) -> Bool {
    if lhs._transformerHelper != rhs._transformerHelper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_OutlineCanvasSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OutlineCanvasSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}canvas_selection_transformer\0\u{3}storage_uuid_path\0")

  public var isInitialized: Bool {
    if self._canvasSelectionTransformer == nil {return false}
    if let v = self._canvasSelectionTransformer, !v.isInitialized {return false}
    if let v = self._storageUuidPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._canvasSelectionTransformer) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._storageUuidPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._canvasSelectionTransformer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._storageUuidPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_OutlineCanvasSelectionTransformerArchive, rhs: KN_OutlineCanvasSelectionTransformerArchive) -> Bool {
    if lhs._canvasSelectionTransformer != rhs._canvasSelectionTransformer {return false}
    if lhs._storageUuidPath != rhs._storageUuidPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_SlideCollectionSelectionTransformerHelperArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SlideCollectionSelectionTransformerHelperArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}slide_nodes\0\u{3}slide_node_to_edit\0\u{3}slide_collection_is_theme\0\u{3}previous_primary_selected_index\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.slideNodes) {return false}
    if let v = self._slideNodeToEdit, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.slideNodes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._slideNodeToEdit) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._slideCollectionIsTheme) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._previousPrimarySelectedIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.slideNodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.slideNodes, fieldNumber: 1)
    }
    try { if let v = self._slideNodeToEdit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._slideCollectionIsTheme {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._previousPrimarySelectedIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_SlideCollectionSelectionTransformerHelperArchive, rhs: KN_SlideCollectionSelectionTransformerHelperArchive) -> Bool {
    if lhs.slideNodes != rhs.slideNodes {return false}
    if lhs._slideNodeToEdit != rhs._slideNodeToEdit {return false}
    if lhs._slideCollectionIsTheme != rhs._slideCollectionIsTheme {return false}
    if lhs._previousPrimarySelectedIndex != rhs._previousPrimarySelectedIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_SlideCollectionSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SlideCollectionSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}transformer_helper\0")

  public var isInitialized: Bool {
    if self._transformerHelper == nil {return false}
    if let v = self._transformerHelper, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transformerHelper) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transformerHelper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_SlideCollectionSelectionTransformerArchive, rhs: KN_SlideCollectionSelectionTransformerArchive) -> Bool {
    if lhs._transformerHelper != rhs._transformerHelper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_OutlineSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OutlineSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}transformer_helper\0\u{3}can_have_range_in_selected_paragraph\0\u{3}selection_range_addresses\0")

  public var isInitialized: Bool {
    if self._transformerHelper == nil {return false}
    if let v = self._transformerHelper, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transformerHelper) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._canHaveRangeInSelectedParagraph) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.selectionRangeAddresses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transformerHelper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._canHaveRangeInSelectedParagraph {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    if !self.selectionRangeAddresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.selectionRangeAddresses, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_OutlineSelectionTransformerArchive, rhs: KN_OutlineSelectionTransformerArchive) -> Bool {
    if lhs._transformerHelper != rhs._transformerHelper {return false}
    if lhs._canHaveRangeInSelectedParagraph != rhs._canHaveRangeInSelectedParagraph {return false}
    if lhs.selectionRangeAddresses != rhs.selectionRangeAddresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandLiveVideoInfoApplyPreset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandLiveVideoInfoApplyPreset"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandLiveVideoInfoApplyPreset, rhs: KN_CommandLiveVideoInfoApplyPreset) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandLiveVideoInfoSetSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandLiveVideoInfoSetSource"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}live_video_info_id_path\0\u{3}source_id\0\u{3}local_collaboration_command_usage_token\0\u{3}working_source_old_collaboration_command_usage_state\0\u{3}old_source\0\u{3}old_source_id\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _liveVideoInfoIDPath: TSP_UUIDPath? = nil
    var _sourceID: TSP_UUID? = nil
    var _localCollaborationCommandUsageToken: TSP_UUID? = nil
    var _workingSourceOldCollaborationCommandUsageState: KN_LiveVideoSourceCollaborationCommandUsageState? = nil
    var _oldSource: TSP_Reference? = nil
    var _oldSourceID: TSP_UUID? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _liveVideoInfoIDPath = source._liveVideoInfoIDPath
      _sourceID = source._sourceID
      _localCollaborationCommandUsageToken = source._localCollaborationCommandUsageToken
      _workingSourceOldCollaborationCommandUsageState = source._workingSourceOldCollaborationCommandUsageState
      _oldSource = source._oldSource
      _oldSourceID = source._oldSourceID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._liveVideoInfoIDPath == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._liveVideoInfoIDPath, !v.isInitialized {return false}
      if let v = _storage._sourceID, !v.isInitialized {return false}
      if let v = _storage._localCollaborationCommandUsageToken, !v.isInitialized {return false}
      if let v = _storage._workingSourceOldCollaborationCommandUsageState, !v.isInitialized {return false}
      if let v = _storage._oldSource, !v.isInitialized {return false}
      if let v = _storage._oldSourceID, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._liveVideoInfoIDPath) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._sourceID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._localCollaborationCommandUsageToken) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._workingSourceOldCollaborationCommandUsageState) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._oldSource) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._oldSourceID) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._liveVideoInfoIDPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._sourceID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._localCollaborationCommandUsageToken {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._workingSourceOldCollaborationCommandUsageState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._oldSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._oldSourceID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandLiveVideoInfoSetSource, rhs: KN_CommandLiveVideoInfoSetSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._liveVideoInfoIDPath != rhs_storage._liveVideoInfoIDPath {return false}
        if _storage._sourceID != rhs_storage._sourceID {return false}
        if _storage._localCollaborationCommandUsageToken != rhs_storage._localCollaborationCommandUsageToken {return false}
        if _storage._workingSourceOldCollaborationCommandUsageState != rhs_storage._workingSourceOldCollaborationCommandUsageState {return false}
        if _storage._oldSource != rhs_storage._oldSource {return false}
        if _storage._oldSourceID != rhs_storage._oldSourceID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandLiveVideoInfoSetValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandLiveVideoInfoSetValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}live_video_info_id_path\0\u{1}property\0\u{1}value\0\u{3}old_value\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _liveVideoInfoIDPath: TSP_UUIDPath? = nil
    var _property: KN_CommandLiveVideoInfoSetValue.Property? = nil
    var _value: KN_CommandLiveVideoInfoSetValue.PropertyValue? = nil
    var _oldValue: KN_CommandLiveVideoInfoSetValue.PropertyValue? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _liveVideoInfoIDPath = source._liveVideoInfoIDPath
      _property = source._property
      _value = source._value
      _oldValue = source._oldValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._liveVideoInfoIDPath == nil {return false}
      if _storage._property == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._liveVideoInfoIDPath, !v.isInitialized {return false}
      if let v = _storage._value, !v.isInitialized {return false}
      if let v = _storage._oldValue, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._liveVideoInfoIDPath) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._property) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._value) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._oldValue) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._liveVideoInfoIDPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._property {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._oldValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandLiveVideoInfoSetValue, rhs: KN_CommandLiveVideoInfoSetValue) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._liveVideoInfoIDPath != rhs_storage._liveVideoInfoIDPath {return false}
        if _storage._property != rhs_storage._property {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._oldValue != rhs_storage._oldValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandLiveVideoInfoSetValue.Property: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Scale\0\u{1}NormalizedOffset\0\u{1}MaskKind\0\u{1}MaskCornerRadius\0\u{1}IsPlaceholder\0\u{1}BackgroundKind\0\u{1}BackgroundFill\0")
}

extension KN_CommandLiveVideoInfoSetValue.PropertyValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = KN_CommandLiveVideoInfoSetValue.protoMessageName + ".PropertyValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}scale\0\u{3}normalized_offset\0\u{3}mask_kind\0\u{3}mask_corner_radius\0\u{3}is_placeholder\0\u{3}background_kind\0\u{3}background_fill\0")

  public var isInitialized: Bool {
    if let v = self._normalizedOffset, !v.isInitialized {return false}
    if let v = self._backgroundFill, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._scale) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._normalizedOffset) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._maskKind) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._maskCornerRadius) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._isPlaceholder) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._backgroundKind) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._backgroundFill) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._scale {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._normalizedOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._maskKind {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._maskCornerRadius {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._isPlaceholder {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._backgroundKind {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._backgroundFill {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandLiveVideoInfoSetValue.PropertyValue, rhs: KN_CommandLiveVideoInfoSetValue.PropertyValue) -> Bool {
    if lhs._scale != rhs._scale {return false}
    if lhs._normalizedOffset != rhs._normalizedOffset {return false}
    if lhs._maskKind != rhs._maskKind {return false}
    if lhs._maskCornerRadius != rhs._maskCornerRadius {return false}
    if lhs._isPlaceholder != rhs._isPlaceholder {return false}
    if lhs._backgroundKind != rhs._backgroundKind {return false}
    if lhs._backgroundFill != rhs._backgroundFill {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandLiveVideoSourceSetValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandLiveVideoSourceSetValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}live_video_source_id\0\u{1}property\0\u{1}value\0\u{3}old_value\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _liveVideoSourceID: TSP_UUID? = nil
    var _property: KN_CommandLiveVideoSourceSetValue.Property? = nil
    var _value: KN_CommandLiveVideoSourceSetValue.PropertyValue? = nil
    var _oldValue: KN_CommandLiveVideoSourceSetValue.PropertyValue? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _liveVideoSourceID = source._liveVideoSourceID
      _property = source._property
      _value = source._value
      _oldValue = source._oldValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._liveVideoSourceID == nil {return false}
      if _storage._property == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._liveVideoSourceID, !v.isInitialized {return false}
      if let v = _storage._value, !v.isInitialized {return false}
      if let v = _storage._oldValue, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._liveVideoSourceID) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._property) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._value) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._oldValue) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._liveVideoSourceID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._property {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._oldValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandLiveVideoSourceSetValue, rhs: KN_CommandLiveVideoSourceSetValue) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._liveVideoSourceID != rhs_storage._liveVideoSourceID {return false}
        if _storage._property != rhs_storage._property {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._oldValue != rhs_storage._oldValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandLiveVideoSourceSetValue.Property: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SourceName\0\u{1}CaptureDeviceDescription\0\u{1}PosterImageData\0\u{1}SymbolAbbreviationText\0\u{1}SymbolImageIdentifier\0\u{1}SymbolTintColorIdentifier\0")
}

extension KN_CommandLiveVideoSourceSetValue.PropertyValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = KN_CommandLiveVideoSourceSetValue.protoMessageName + ".PropertyValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}capture_device_description\0\u{3}poster_image_data\0\u{3}symbol_abbreviation_text\0\u{3}symbol_image_identifier\0\u{3}symbol_tint_color_identifier\0")

  public var isInitialized: Bool {
    if let v = self._captureDeviceDescription, !v.isInitialized {return false}
    if let v = self._posterImageData, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._captureDeviceDescription) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._posterImageData) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._symbolAbbreviationText) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._symbolImageIdentifier) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._symbolTintColorIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._captureDeviceDescription {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._posterImageData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._symbolAbbreviationText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._symbolImageIdentifier {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._symbolTintColorIdentifier {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandLiveVideoSourceSetValue.PropertyValue, rhs: KN_CommandLiveVideoSourceSetValue.PropertyValue) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._captureDeviceDescription != rhs._captureDeviceDescription {return false}
    if lhs._posterImageData != rhs._posterImageData {return false}
    if lhs._symbolAbbreviationText != rhs._symbolAbbreviationText {return false}
    if lhs._symbolImageIdentifier != rhs._symbolImageIdentifier {return false}
    if lhs._symbolTintColorIdentifier != rhs._symbolTintColorIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandLiveVideoStyleSetValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandLiveVideoStyleSetValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}change\0")

  fileprivate class _StorageClass {
    var _super: TSD_BaseStyleSetValueCommandArchive? = nil
    var _change: TSDSOS_MediaStylePropertyChangeSetArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _change = source._change
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._change, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._change) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._change {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandLiveVideoStyleSetValue, rhs: KN_CommandLiveVideoStyleSetValue) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._change != rhs_storage._change {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandThemeAddLiveVideoSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandThemeAddLiveVideoSource"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}live_video_source\0\u{3}is_implicit\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._liveVideoSource, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._liveVideoSource) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._isImplicit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._liveVideoSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._isImplicit {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandThemeAddLiveVideoSource, rhs: KN_CommandThemeAddLiveVideoSource) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._liveVideoSource != rhs._liveVideoSource {return false}
    if lhs._isImplicit != rhs._isImplicit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandThemeRemoveLiveVideoSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandThemeRemoveLiveVideoSource"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}live_video_source_id\0\u{3}is_implicit\0\u{3}removed_live_video_source\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _liveVideoSourceID: TSP_UUID? = nil
    var _isImplicit: Bool? = nil
    var _removedLiveVideoSource: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _liveVideoSourceID = source._liveVideoSourceID
      _isImplicit = source._isImplicit
      _removedLiveVideoSource = source._removedLiveVideoSource
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._liveVideoSourceID == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._liveVideoSourceID, !v.isInitialized {return false}
      if let v = _storage._removedLiveVideoSource, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._liveVideoSourceID) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._isImplicit) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._removedLiveVideoSource) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._liveVideoSourceID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._isImplicit {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._removedLiveVideoSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandThemeRemoveLiveVideoSource, rhs: KN_CommandThemeRemoveLiveVideoSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._liveVideoSourceID != rhs_storage._liveVideoSourceID {return false}
        if _storage._isImplicit != rhs_storage._isImplicit {return false}
        if _storage._removedLiveVideoSource != rhs_storage._removedLiveVideoSource {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandMotionBackgroundStyleSetValueArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandMotionBackgroundStyleSetValueArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}old_style\0\u{1}change\0\u{3}slide_id_path\0\u{3}old_slide_style\0\u{3}undo_property_change\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _slideIDPath: TSP_UUIDPath? = nil
    var _oldStyle: TSP_Reference? = nil
    var _oldSlideStyle: TSP_Reference? = nil
    var _change: KNSOS_MotionBackgroundStylePropertyChangeSetArchive? = nil
    var _undoPropertyChange: KNSOS_MotionBackgroundStylePropertyChangeSetArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _slideIDPath = source._slideIDPath
      _oldStyle = source._oldStyle
      _oldSlideStyle = source._oldSlideStyle
      _change = source._change
      _undoPropertyChange = source._undoPropertyChange
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._slideIDPath == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._slideIDPath, !v.isInitialized {return false}
      if let v = _storage._oldStyle, !v.isInitialized {return false}
      if let v = _storage._oldSlideStyle, !v.isInitialized {return false}
      if let v = _storage._change, !v.isInitialized {return false}
      if let v = _storage._undoPropertyChange, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._oldStyle) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._change) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._slideIDPath) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._oldSlideStyle) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._undoPropertyChange) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._oldStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._change {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._slideIDPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._oldSlideStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._undoPropertyChange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandMotionBackgroundStyleSetValueArchive, rhs: KN_CommandMotionBackgroundStyleSetValueArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._slideIDPath != rhs_storage._slideIDPath {return false}
        if _storage._oldStyle != rhs_storage._oldStyle {return false}
        if _storage._oldSlideStyle != rhs_storage._oldSlideStyle {return false}
        if _storage._change != rhs_storage._change {return false}
        if _storage._undoPropertyChange != rhs_storage._undoPropertyChange {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KN_CommandMotionBackgroundStyleUpdatePosterFrameDataArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandMotionBackgroundStyleUpdatePosterFrameDataArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}motion_background_style\0\u{3}poster_image_data\0\u{3}old_poster_image_data\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._motionBackgroundStyle, !v.isInitialized {return false}
    if let v = self._posterImageData, !v.isInitialized {return false}
    if let v = self._oldPosterImageData, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._motionBackgroundStyle) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._posterImageData) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._oldPosterImageData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._motionBackgroundStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._posterImageData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._oldPosterImageData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KN_CommandMotionBackgroundStyleUpdatePosterFrameDataArchive, rhs: KN_CommandMotionBackgroundStyleUpdatePosterFrameDataArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._motionBackgroundStyle != rhs._motionBackgroundStyle {return false}
    if lhs._posterImageData != rhs._posterImageData {return false}
    if lhs._oldPosterImageData != rhs._oldPosterImageData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
