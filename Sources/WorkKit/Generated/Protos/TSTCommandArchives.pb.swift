// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TSTCommandArchives.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum TST_TableArea: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case body = 1
  case headerRow = 2
  case headerColumn = 3
  case footerRow = 4

  init() {
    self = .body
  }

}

enum TST_TableAreaTransition: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case headerRowToBody = 1
  case bodyToHeaderRow = 2
  case footerRowToBody = 3
  case bodyToFooterRow = 4
  case headerColumnToBody = 5
  case bodyToHeaderColumn = 6

  init() {
    self = .headerRowToBody
  }

}

enum TST_ColumnRowBundleItemTypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case columnRowTypeAnchor = 0
  case columnRowTypeHeaderRow = 1
  case columnRowTypeBodyRow = 2
  case columnRowTypeFooterRow = 3
  case columnRowTypeHeaderColumn = 4
  case columnRowTypeBodyColumn = 5

  init() {
    self = .columnRowTypeAnchor
  }

}

struct TST_TableCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var tableInfoIDPath: TSP_UUIDPath {
    get {return _storage._tableInfoIDPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._tableInfoIDPath = newValue}
  }
  /// Returns true if `tableInfoIDPath` has been explicitly set.
  var hasTableInfoIDPath: Bool {return _storage._tableInfoIDPath != nil}
  /// Clears the value of `tableInfoIDPath`. Subsequent reads from it will return its default value.
  mutating func clearTableInfoIDPath() {_uniqueStorage()._tableInfoIDPath = nil}

  var commandname: String {
    get {return _storage._commandname ?? String()}
    set {_uniqueStorage()._commandname = newValue}
  }
  /// Returns true if `commandname` has been explicitly set.
  var hasCommandname: Bool {return _storage._commandname != nil}
  /// Clears the value of `commandname`. Subsequent reads from it will return its default value.
  mutating func clearCommandname() {_uniqueStorage()._commandname = nil}

  var defaultCellStylesContainer: TSP_Reference {
    get {return _storage._defaultCellStylesContainer ?? TSP_Reference()}
    set {_uniqueStorage()._defaultCellStylesContainer = newValue}
  }
  /// Returns true if `defaultCellStylesContainer` has been explicitly set.
  var hasDefaultCellStylesContainer: Bool {return _storage._defaultCellStylesContainer != nil}
  /// Clears the value of `defaultCellStylesContainer`. Subsequent reads from it will return its default value.
  mutating func clearDefaultCellStylesContainer() {_uniqueStorage()._defaultCellStylesContainer = nil}

  var timestamp: Double {
    get {return _storage._timestamp ?? 0}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  var randomSeedLo: UInt32 {
    get {return _storage._randomSeedLo ?? 0}
    set {_uniqueStorage()._randomSeedLo = newValue}
  }
  /// Returns true if `randomSeedLo` has been explicitly set.
  var hasRandomSeedLo: Bool {return _storage._randomSeedLo != nil}
  /// Clears the value of `randomSeedLo`. Subsequent reads from it will return its default value.
  mutating func clearRandomSeedLo() {_uniqueStorage()._randomSeedLo = nil}

  var randomSeedHi: UInt32 {
    get {return _storage._randomSeedHi ?? 0}
    set {_uniqueStorage()._randomSeedHi = newValue}
  }
  /// Returns true if `randomSeedHi` has been explicitly set.
  var hasRandomSeedHi: Bool {return _storage._randomSeedHi != nil}
  /// Clears the value of `randomSeedHi`. Subsequent reads from it will return its default value.
  mutating func clearRandomSeedHi() {_uniqueStorage()._randomSeedHi = nil}

  var isInverse: Bool {
    get {return _storage._isInverse ?? false}
    set {_uniqueStorage()._isInverse = newValue}
  }
  /// Returns true if `isInverse` has been explicitly set.
  var hasIsInverse: Bool {return _storage._isInverse != nil}
  /// Clears the value of `isInverse`. Subsequent reads from it will return its default value.
  mutating func clearIsInverse() {_uniqueStorage()._isInverse = nil}

  var oldTimestamp: Double {
    get {return _storage._oldTimestamp ?? 0}
    set {_uniqueStorage()._oldTimestamp = newValue}
  }
  /// Returns true if `oldTimestamp` has been explicitly set.
  var hasOldTimestamp: Bool {return _storage._oldTimestamp != nil}
  /// Clears the value of `oldTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearOldTimestamp() {_uniqueStorage()._oldTimestamp = nil}

  var oldRandomSeed: UInt64 {
    get {return _storage._oldRandomSeed ?? 0}
    set {_uniqueStorage()._oldRandomSeed = newValue}
  }
  /// Returns true if `oldRandomSeed` has been explicitly set.
  var hasOldRandomSeed: Bool {return _storage._oldRandomSeed != nil}
  /// Clears the value of `oldRandomSeed`. Subsequent reads from it will return its default value.
  mutating func clearOldRandomSeed() {_uniqueStorage()._oldRandomSeed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandApplyCellContentsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var cellDiffMap: TSP_Reference {
    get {return _cellDiffMap ?? TSP_Reference()}
    set {_cellDiffMap = newValue}
  }
  /// Returns true if `cellDiffMap` has been explicitly set.
  var hasCellDiffMap: Bool {return self._cellDiffMap != nil}
  /// Clears the value of `cellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearCellDiffMap() {self._cellDiffMap = nil}

  var rollbackCellDiffMap: TSP_Reference {
    get {return _rollbackCellDiffMap ?? TSP_Reference()}
    set {_rollbackCellDiffMap = newValue}
  }
  /// Returns true if `rollbackCellDiffMap` has been explicitly set.
  var hasRollbackCellDiffMap: Bool {return self._rollbackCellDiffMap != nil}
  /// Clears the value of `rollbackCellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearRollbackCellDiffMap() {self._rollbackCellDiffMap = nil}

  var customFormatKeys: [TSP_UUID] = []

  var actionString: String {
    get {return _actionString ?? String()}
    set {_actionString = newValue}
  }
  /// Returns true if `actionString` has been explicitly set.
  var hasActionString: Bool {return self._actionString != nil}
  /// Clears the value of `actionString`. Subsequent reads from it will return its default value.
  mutating func clearActionString() {self._actionString = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _cellDiffMap: TSP_Reference? = nil
  fileprivate var _rollbackCellDiffMap: TSP_Reference? = nil
  fileprivate var _actionString: String? = nil
}

struct TST_CommandApplyCellDiffMapArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var cellDiffMap: TSP_Reference {
    get {return _cellDiffMap ?? TSP_Reference()}
    set {_cellDiffMap = newValue}
  }
  /// Returns true if `cellDiffMap` has been explicitly set.
  var hasCellDiffMap: Bool {return self._cellDiffMap != nil}
  /// Clears the value of `cellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearCellDiffMap() {self._cellDiffMap = nil}

  var shouldAllowMergeFragments: Bool {
    get {return _shouldAllowMergeFragments ?? false}
    set {_shouldAllowMergeFragments = newValue}
  }
  /// Returns true if `shouldAllowMergeFragments` has been explicitly set.
  var hasShouldAllowMergeFragments: Bool {return self._shouldAllowMergeFragments != nil}
  /// Clears the value of `shouldAllowMergeFragments`. Subsequent reads from it will return its default value.
  mutating func clearShouldAllowMergeFragments() {self._shouldAllowMergeFragments = nil}

  var inverseCellDiffMap: TSP_Reference {
    get {return _inverseCellDiffMap ?? TSP_Reference()}
    set {_inverseCellDiffMap = newValue}
  }
  /// Returns true if `inverseCellDiffMap` has been explicitly set.
  var hasInverseCellDiffMap: Bool {return self._inverseCellDiffMap != nil}
  /// Clears the value of `inverseCellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearInverseCellDiffMap() {self._inverseCellDiffMap = nil}

  var customFormatKeys: [TSP_UUID] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _cellDiffMap: TSP_Reference? = nil
  fileprivate var _shouldAllowMergeFragments: Bool? = nil
  fileprivate var _inverseCellDiffMap: TSP_Reference? = nil
}

struct TST_CommandApplyCellMapArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var redoCellMap: TSP_Reference {
    get {return _redoCellMap ?? TSP_Reference()}
    set {_redoCellMap = newValue}
  }
  /// Returns true if `redoCellMap` has been explicitly set.
  var hasRedoCellMap: Bool {return self._redoCellMap != nil}
  /// Clears the value of `redoCellMap`. Subsequent reads from it will return its default value.
  mutating func clearRedoCellMap() {self._redoCellMap = nil}

  var undoCellMap: TSP_Reference {
    get {return _undoCellMap ?? TSP_Reference()}
    set {_undoCellMap = newValue}
  }
  /// Returns true if `undoCellMap` has been explicitly set.
  var hasUndoCellMap: Bool {return self._undoCellMap != nil}
  /// Clears the value of `undoCellMap`. Subsequent reads from it will return its default value.
  mutating func clearUndoCellMap() {self._undoCellMap = nil}

  var undoFormulaRewriteCommand: TSP_Reference {
    get {return _undoFormulaRewriteCommand ?? TSP_Reference()}
    set {_undoFormulaRewriteCommand = newValue}
  }
  /// Returns true if `undoFormulaRewriteCommand` has been explicitly set.
  var hasUndoFormulaRewriteCommand: Bool {return self._undoFormulaRewriteCommand != nil}
  /// Clears the value of `undoFormulaRewriteCommand`. Subsequent reads from it will return its default value.
  mutating func clearUndoFormulaRewriteCommand() {self._undoFormulaRewriteCommand = nil}

  var customFormatKeys: [TSP_UUID] = []

  var mergeOwnerRollbackIndex: UInt32 {
    get {return _mergeOwnerRollbackIndex ?? 0}
    set {_mergeOwnerRollbackIndex = newValue}
  }
  /// Returns true if `mergeOwnerRollbackIndex` has been explicitly set.
  var hasMergeOwnerRollbackIndex: Bool {return self._mergeOwnerRollbackIndex != nil}
  /// Clears the value of `mergeOwnerRollbackIndex`. Subsequent reads from it will return its default value.
  mutating func clearMergeOwnerRollbackIndex() {self._mergeOwnerRollbackIndex = nil}

  var isFromPaste: Bool {
    get {return _isFromPaste ?? false}
    set {_isFromPaste = newValue}
  }
  /// Returns true if `isFromPaste` has been explicitly set.
  var hasIsFromPaste: Bool {return self._isFromPaste != nil}
  /// Clears the value of `isFromPaste`. Subsequent reads from it will return its default value.
  mutating func clearIsFromPaste() {self._isFromPaste = nil}

  var formulaRewriteCommands: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _redoCellMap: TSP_Reference? = nil
  fileprivate var _undoCellMap: TSP_Reference? = nil
  fileprivate var _undoFormulaRewriteCommand: TSP_Reference? = nil
  fileprivate var _mergeOwnerRollbackIndex: UInt32? = nil
  fileprivate var _isFromPaste: Bool? = nil
}

struct TST_CommandApplyConcurrentCellMapArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var redoConcurrentCellMap: TSP_Reference {
    get {return _redoConcurrentCellMap ?? TSP_Reference()}
    set {_redoConcurrentCellMap = newValue}
  }
  /// Returns true if `redoConcurrentCellMap` has been explicitly set.
  var hasRedoConcurrentCellMap: Bool {return self._redoConcurrentCellMap != nil}
  /// Clears the value of `redoConcurrentCellMap`. Subsequent reads from it will return its default value.
  mutating func clearRedoConcurrentCellMap() {self._redoConcurrentCellMap = nil}

  var undoConcurrentCellMap: TSP_Reference {
    get {return _undoConcurrentCellMap ?? TSP_Reference()}
    set {_undoConcurrentCellMap = newValue}
  }
  /// Returns true if `undoConcurrentCellMap` has been explicitly set.
  var hasUndoConcurrentCellMap: Bool {return self._undoConcurrentCellMap != nil}
  /// Clears the value of `undoConcurrentCellMap`. Subsequent reads from it will return its default value.
  mutating func clearUndoConcurrentCellMap() {self._undoConcurrentCellMap = nil}

  var undoFormulaRewriteCommand: TSP_Reference {
    get {return _undoFormulaRewriteCommand ?? TSP_Reference()}
    set {_undoFormulaRewriteCommand = newValue}
  }
  /// Returns true if `undoFormulaRewriteCommand` has been explicitly set.
  var hasUndoFormulaRewriteCommand: Bool {return self._undoFormulaRewriteCommand != nil}
  /// Clears the value of `undoFormulaRewriteCommand`. Subsequent reads from it will return its default value.
  mutating func clearUndoFormulaRewriteCommand() {self._undoFormulaRewriteCommand = nil}

  var customFormatKeys: [TSP_UUID] = []

  var mergeOwnerRollbackIndex: UInt32 {
    get {return _mergeOwnerRollbackIndex ?? 0}
    set {_mergeOwnerRollbackIndex = newValue}
  }
  /// Returns true if `mergeOwnerRollbackIndex` has been explicitly set.
  var hasMergeOwnerRollbackIndex: Bool {return self._mergeOwnerRollbackIndex != nil}
  /// Clears the value of `mergeOwnerRollbackIndex`. Subsequent reads from it will return its default value.
  mutating func clearMergeOwnerRollbackIndex() {self._mergeOwnerRollbackIndex = nil}

  var isFromPaste: Bool {
    get {return _isFromPaste ?? false}
    set {_isFromPaste = newValue}
  }
  /// Returns true if `isFromPaste` has been explicitly set.
  var hasIsFromPaste: Bool {return self._isFromPaste != nil}
  /// Clears the value of `isFromPaste`. Subsequent reads from it will return its default value.
  mutating func clearIsFromPaste() {self._isFromPaste = nil}

  var formulaRewriteCommands: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _redoConcurrentCellMap: TSP_Reference? = nil
  fileprivate var _undoConcurrentCellMap: TSP_Reference? = nil
  fileprivate var _undoFormulaRewriteCommand: TSP_Reference? = nil
  fileprivate var _mergeOwnerRollbackIndex: UInt32? = nil
  fileprivate var _isFromPaste: Bool? = nil
}

struct TST_CommandChangeFreezeHeaderStateArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var direction: TST_TableDimensionArchive {
    get {return _direction ?? .dimensionNeither}
    set {_direction = newValue}
  }
  /// Returns true if `direction` has been explicitly set.
  var hasDirection: Bool {return self._direction != nil}
  /// Clears the value of `direction`. Subsequent reads from it will return its default value.
  mutating func clearDirection() {self._direction = nil}

  var newFreezeState: Bool {
    get {return _newFreezeState ?? false}
    set {_newFreezeState = newValue}
  }
  /// Returns true if `newFreezeState` has been explicitly set.
  var hasNewFreezeState: Bool {return self._newFreezeState != nil}
  /// Clears the value of `newFreezeState`. Subsequent reads from it will return its default value.
  mutating func clearNewFreezeState() {self._newFreezeState = nil}

  var prevFreezeState: Bool {
    get {return _prevFreezeState ?? false}
    set {_prevFreezeState = newValue}
  }
  /// Returns true if `prevFreezeState` has been explicitly set.
  var hasPrevFreezeState: Bool {return self._prevFreezeState != nil}
  /// Clears the value of `prevFreezeState`. Subsequent reads from it will return its default value.
  mutating func clearPrevFreezeState() {self._prevFreezeState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _direction: TST_TableDimensionArchive? = nil
  fileprivate var _newFreezeState: Bool? = nil
  fileprivate var _prevFreezeState: Bool? = nil
}

struct TST_CommandDeleteCellsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var invalidateComments: Bool {
    get {return _invalidateComments ?? false}
    set {_invalidateComments = newValue}
  }
  /// Returns true if `invalidateComments` has been explicitly set.
  var hasInvalidateComments: Bool {return self._invalidateComments != nil}
  /// Clears the value of `invalidateComments`. Subsequent reads from it will return its default value.
  mutating func clearInvalidateComments() {self._invalidateComments = nil}

  var invalidateCommentsValid: Bool {
    get {return _invalidateCommentsValid ?? false}
    set {_invalidateCommentsValid = newValue}
  }
  /// Returns true if `invalidateCommentsValid` has been explicitly set.
  var hasInvalidateCommentsValid: Bool {return self._invalidateCommentsValid != nil}
  /// Clears the value of `invalidateCommentsValid`. Subsequent reads from it will return its default value.
  mutating func clearInvalidateCommentsValid() {self._invalidateCommentsValid = nil}

  var cellUidRegion: TST_CellUIDRegionArchive {
    get {return _cellUidRegion ?? TST_CellUIDRegionArchive()}
    set {_cellUidRegion = newValue}
  }
  /// Returns true if `cellUidRegion` has been explicitly set.
  var hasCellUidRegion: Bool {return self._cellUidRegion != nil}
  /// Clears the value of `cellUidRegion`. Subsequent reads from it will return its default value.
  mutating func clearCellUidRegion() {self._cellUidRegion = nil}

  var summaryCellUidList: TST_CellUIDListArchive {
    get {return _summaryCellUidList ?? TST_CellUIDListArchive()}
    set {_summaryCellUidList = newValue}
  }
  /// Returns true if `summaryCellUidList` has been explicitly set.
  var hasSummaryCellUidList: Bool {return self._summaryCellUidList != nil}
  /// Clears the value of `summaryCellUidList`. Subsequent reads from it will return its default value.
  mutating func clearSummaryCellUidList() {self._summaryCellUidList = nil}

  var inverseConcurrentCellMap: TSP_Reference {
    get {return _inverseConcurrentCellMap ?? TSP_Reference()}
    set {_inverseConcurrentCellMap = newValue}
  }
  /// Returns true if `inverseConcurrentCellMap` has been explicitly set.
  var hasInverseConcurrentCellMap: Bool {return self._inverseConcurrentCellMap != nil}
  /// Clears the value of `inverseConcurrentCellMap`. Subsequent reads from it will return its default value.
  mutating func clearInverseConcurrentCellMap() {self._inverseConcurrentCellMap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _invalidateComments: Bool? = nil
  fileprivate var _invalidateCommentsValid: Bool? = nil
  fileprivate var _cellUidRegion: TST_CellUIDRegionArchive? = nil
  fileprivate var _summaryCellUidList: TST_CellUIDListArchive? = nil
  fileprivate var _inverseConcurrentCellMap: TSP_Reference? = nil
}

struct TST_CommandDeleteCellContentsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var cellUidList: TST_CellUIDListArchive {
    get {return _cellUidList ?? TST_CellUIDListArchive()}
    set {_cellUidList = newValue}
  }
  /// Returns true if `cellUidList` has been explicitly set.
  var hasCellUidList: Bool {return self._cellUidList != nil}
  /// Clears the value of `cellUidList`. Subsequent reads from it will return its default value.
  mutating func clearCellUidList() {self._cellUidList = nil}

  var inverseCellDiffMap: TSP_Reference {
    get {return _inverseCellDiffMap ?? TSP_Reference()}
    set {_inverseCellDiffMap = newValue}
  }
  /// Returns true if `inverseCellDiffMap` has been explicitly set.
  var hasInverseCellDiffMap: Bool {return self._inverseCellDiffMap != nil}
  /// Clears the value of `inverseCellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearInverseCellDiffMap() {self._inverseCellDiffMap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _cellUidList: TST_CellUIDListArchive? = nil
  fileprivate var _inverseCellDiffMap: TSP_Reference? = nil
}

struct TST_CommandMutateCellFormatArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var cellUidList: TST_CellUIDListArchive {
    get {return _cellUidList ?? TST_CellUIDListArchive()}
    set {_cellUidList = newValue}
  }
  /// Returns true if `cellUidList` has been explicitly set.
  var hasCellUidList: Bool {return self._cellUidList != nil}
  /// Clears the value of `cellUidList`. Subsequent reads from it will return its default value.
  mutating func clearCellUidList() {self._cellUidList = nil}

  var inverseCellDiffMap: TSP_Reference {
    get {return _inverseCellDiffMap ?? TSP_Reference()}
    set {_inverseCellDiffMap = newValue}
  }
  /// Returns true if `inverseCellDiffMap` has been explicitly set.
  var hasInverseCellDiffMap: Bool {return self._inverseCellDiffMap != nil}
  /// Clears the value of `inverseCellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearInverseCellDiffMap() {self._inverseCellDiffMap = nil}

  var wholeFormatDiffMap: TSP_Reference {
    get {return _wholeFormatDiffMap ?? TSP_Reference()}
    set {_wholeFormatDiffMap = newValue}
  }
  /// Returns true if `wholeFormatDiffMap` has been explicitly set.
  var hasWholeFormatDiffMap: Bool {return self._wholeFormatDiffMap != nil}
  /// Clears the value of `wholeFormatDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearWholeFormatDiffMap() {self._wholeFormatDiffMap = nil}

  var intendedFormatType: UInt32 {
    get {return _intendedFormatType ?? 0}
    set {_intendedFormatType = newValue}
  }
  /// Returns true if `intendedFormatType` has been explicitly set.
  var hasIntendedFormatType: Bool {return self._intendedFormatType != nil}
  /// Clears the value of `intendedFormatType`. Subsequent reads from it will return its default value.
  mutating func clearIntendedFormatType() {self._intendedFormatType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _cellUidList: TST_CellUIDListArchive? = nil
  fileprivate var _inverseCellDiffMap: TSP_Reference? = nil
  fileprivate var _wholeFormatDiffMap: TSP_Reference? = nil
  fileprivate var _intendedFormatType: UInt32? = nil
}

struct TST_CommandSetAutomaticDurationUnitsArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_CommandMutateCellFormatArchive {
    get {return _storage._super ?? TST_CommandMutateCellFormatArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var automaticUnits: Bool {
    get {return _storage._automaticUnits ?? false}
    set {_uniqueStorage()._automaticUnits = newValue}
  }
  /// Returns true if `automaticUnits` has been explicitly set.
  var hasAutomaticUnits: Bool {return _storage._automaticUnits != nil}
  /// Clears the value of `automaticUnits`. Subsequent reads from it will return its default value.
  mutating func clearAutomaticUnits() {_uniqueStorage()._automaticUnits = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandSetDurationStyleArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_CommandMutateCellFormatArchive {
    get {return _storage._super ?? TST_CommandMutateCellFormatArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var durationStyle: UInt32 {
    get {return _storage._durationStyle ?? 0}
    set {_uniqueStorage()._durationStyle = newValue}
  }
  /// Returns true if `durationStyle` has been explicitly set.
  var hasDurationStyle: Bool {return _storage._durationStyle != nil}
  /// Clears the value of `durationStyle`. Subsequent reads from it will return its default value.
  mutating func clearDurationStyle() {_uniqueStorage()._durationStyle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandSetDurationUnitSmallestLargestArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_CommandMutateCellFormatArchive {
    get {return _storage._super ?? TST_CommandMutateCellFormatArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var smallestUnit: UInt32 {
    get {return _storage._smallestUnit ?? 0}
    set {_uniqueStorage()._smallestUnit = newValue}
  }
  /// Returns true if `smallestUnit` has been explicitly set.
  var hasSmallestUnit: Bool {return _storage._smallestUnit != nil}
  /// Clears the value of `smallestUnit`. Subsequent reads from it will return its default value.
  mutating func clearSmallestUnit() {_uniqueStorage()._smallestUnit = nil}

  var largestUnit: UInt32 {
    get {return _storage._largestUnit ?? 0}
    set {_uniqueStorage()._largestUnit = newValue}
  }
  /// Returns true if `largestUnit` has been explicitly set.
  var hasLargestUnit: Bool {return _storage._largestUnit != nil}
  /// Clears the value of `largestUnit`. Subsequent reads from it will return its default value.
  mutating func clearLargestUnit() {_uniqueStorage()._largestUnit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandReplaceCustomFormatArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var undoDiffMap: TSP_Reference {
    get {return _undoDiffMap ?? TSP_Reference()}
    set {_undoDiffMap = newValue}
  }
  /// Returns true if `undoDiffMap` has been explicitly set.
  var hasUndoDiffMap: Bool {return self._undoDiffMap != nil}
  /// Clears the value of `undoDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearUndoDiffMap() {self._undoDiffMap = nil}

  var commitDiffMap: TSP_Reference {
    get {return _commitDiffMap ?? TSP_Reference()}
    set {_commitDiffMap = newValue}
  }
  /// Returns true if `commitDiffMap` has been explicitly set.
  var hasCommitDiffMap: Bool {return self._commitDiffMap != nil}
  /// Clears the value of `commitDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearCommitDiffMap() {self._commitDiffMap = nil}

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _undoDiffMap: TSP_Reference? = nil
  fileprivate var _commitDiffMap: TSP_Reference? = nil
  fileprivate var _super: TST_TableCommandArchive? = nil
}

struct TST_CommandMoveCellsArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _storage._super ?? TST_TableCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var dstTableInfoIDPath: TSP_UUIDPath {
    get {return _storage._dstTableInfoIDPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._dstTableInfoIDPath = newValue}
  }
  /// Returns true if `dstTableInfoIDPath` has been explicitly set.
  var hasDstTableInfoIDPath: Bool {return _storage._dstTableInfoIDPath != nil}
  /// Clears the value of `dstTableInfoIDPath`. Subsequent reads from it will return its default value.
  mutating func clearDstTableInfoIDPath() {_uniqueStorage()._dstTableInfoIDPath = nil}

  var srcUidRange: TSP_UUIDRectArchive {
    get {return _storage._srcUidRange ?? TSP_UUIDRectArchive()}
    set {_uniqueStorage()._srcUidRange = newValue}
  }
  /// Returns true if `srcUidRange` has been explicitly set.
  var hasSrcUidRange: Bool {return _storage._srcUidRange != nil}
  /// Clears the value of `srcUidRange`. Subsequent reads from it will return its default value.
  mutating func clearSrcUidRange() {_uniqueStorage()._srcUidRange = nil}

  var dstUidRange: TSP_UUIDRectArchive {
    get {return _storage._dstUidRange ?? TSP_UUIDRectArchive()}
    set {_uniqueStorage()._dstUidRange = newValue}
  }
  /// Returns true if `dstUidRange` has been explicitly set.
  var hasDstUidRange: Bool {return _storage._dstUidRange != nil}
  /// Clears the value of `dstUidRange`. Subsequent reads from it will return its default value.
  mutating func clearDstUidRange() {_uniqueStorage()._dstUidRange = nil}

  var tableDimension: TST_TableDimensionArchive {
    get {return _storage._tableDimension ?? .dimensionNeither}
    set {_uniqueStorage()._tableDimension = newValue}
  }
  /// Returns true if `tableDimension` has been explicitly set.
  var hasTableDimension: Bool {return _storage._tableDimension != nil}
  /// Clears the value of `tableDimension`. Subsequent reads from it will return its default value.
  mutating func clearTableDimension() {_uniqueStorage()._tableDimension = nil}

  var srcCellMap: TSP_Reference {
    get {return _storage._srcCellMap ?? TSP_Reference()}
    set {_uniqueStorage()._srcCellMap = newValue}
  }
  /// Returns true if `srcCellMap` has been explicitly set.
  var hasSrcCellMap: Bool {return _storage._srcCellMap != nil}
  /// Clears the value of `srcCellMap`. Subsequent reads from it will return its default value.
  mutating func clearSrcCellMap() {_uniqueStorage()._srcCellMap = nil}

  var dstCellMap: TSP_Reference {
    get {return _storage._dstCellMap ?? TSP_Reference()}
    set {_uniqueStorage()._dstCellMap = newValue}
  }
  /// Returns true if `dstCellMap` has been explicitly set.
  var hasDstCellMap: Bool {return _storage._dstCellMap != nil}
  /// Clears the value of `dstCellMap`. Subsequent reads from it will return its default value.
  mutating func clearDstCellMap() {_uniqueStorage()._dstCellMap = nil}

  var dstCellStylesContainer: TSP_Reference {
    get {return _storage._dstCellStylesContainer ?? TSP_Reference()}
    set {_uniqueStorage()._dstCellStylesContainer = newValue}
  }
  /// Returns true if `dstCellStylesContainer` has been explicitly set.
  var hasDstCellStylesContainer: Bool {return _storage._dstCellStylesContainer != nil}
  /// Clears the value of `dstCellStylesContainer`. Subsequent reads from it will return its default value.
  mutating func clearDstCellStylesContainer() {_uniqueStorage()._dstCellStylesContainer = nil}

  var srcUndoCellMap: TSP_Reference {
    get {return _storage._srcUndoCellMap ?? TSP_Reference()}
    set {_uniqueStorage()._srcUndoCellMap = newValue}
  }
  /// Returns true if `srcUndoCellMap` has been explicitly set.
  var hasSrcUndoCellMap: Bool {return _storage._srcUndoCellMap != nil}
  /// Clears the value of `srcUndoCellMap`. Subsequent reads from it will return its default value.
  mutating func clearSrcUndoCellMap() {_uniqueStorage()._srcUndoCellMap = nil}

  var dstUndoCellMap: TSP_Reference {
    get {return _storage._dstUndoCellMap ?? TSP_Reference()}
    set {_uniqueStorage()._dstUndoCellMap = newValue}
  }
  /// Returns true if `dstUndoCellMap` has been explicitly set.
  var hasDstUndoCellMap: Bool {return _storage._dstUndoCellMap != nil}
  /// Clears the value of `dstUndoCellMap`. Subsequent reads from it will return its default value.
  mutating func clearDstUndoCellMap() {_uniqueStorage()._dstUndoCellMap = nil}

  var dstMergeOwnerRollbackIndex: UInt32 {
    get {return _storage._dstMergeOwnerRollbackIndex ?? 0}
    set {_uniqueStorage()._dstMergeOwnerRollbackIndex = newValue}
  }
  /// Returns true if `dstMergeOwnerRollbackIndex` has been explicitly set.
  var hasDstMergeOwnerRollbackIndex: Bool {return _storage._dstMergeOwnerRollbackIndex != nil}
  /// Clears the value of `dstMergeOwnerRollbackIndex`. Subsequent reads from it will return its default value.
  mutating func clearDstMergeOwnerRollbackIndex() {_uniqueStorage()._dstMergeOwnerRollbackIndex = nil}

  var formulaRewriteCommands: [TSP_Reference] {
    get {return _storage._formulaRewriteCommands}
    set {_uniqueStorage()._formulaRewriteCommands = newValue}
  }

  var mergeActionToRestore: TST_MergeOperationArchive {
    get {return _storage._mergeActionToRestore ?? TST_MergeOperationArchive()}
    set {_uniqueStorage()._mergeActionToRestore = newValue}
  }
  /// Returns true if `mergeActionToRestore` has been explicitly set.
  var hasMergeActionToRestore: Bool {return _storage._mergeActionToRestore != nil}
  /// Clears the value of `mergeActionToRestore`. Subsequent reads from it will return its default value.
  mutating func clearMergeActionToRestore() {_uniqueStorage()._mergeActionToRestore = nil}

  var commentCellUidsToRestore: TST_CellUIDListArchive {
    get {return _storage._commentCellUidsToRestore ?? TST_CellUIDListArchive()}
    set {_uniqueStorage()._commentCellUidsToRestore = newValue}
  }
  /// Returns true if `commentCellUidsToRestore` has been explicitly set.
  var hasCommentCellUidsToRestore: Bool {return _storage._commentCellUidsToRestore != nil}
  /// Clears the value of `commentCellUidsToRestore`. Subsequent reads from it will return its default value.
  mutating func clearCommentCellUidsToRestore() {_uniqueStorage()._commentCellUidsToRestore = nil}

  var commentStoragesToRestore: [TSP_Reference] {
    get {return _storage._commentStoragesToRestore}
    set {_uniqueStorage()._commentStoragesToRestore = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_ColumnRowMetadataArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var size: Double {
    get {return _size ?? 0}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var hidingAction: UInt32 {
    get {return _hidingAction ?? 0}
    set {_hidingAction = newValue}
  }
  /// Returns true if `hidingAction` has been explicitly set.
  var hasHidingAction: Bool {return self._hidingAction != nil}
  /// Clears the value of `hidingAction`. Subsequent reads from it will return its default value.
  mutating func clearHidingAction() {self._hidingAction = nil}

  var cellStyle: TSP_Reference {
    get {return _cellStyle ?? TSP_Reference()}
    set {_cellStyle = newValue}
  }
  /// Returns true if `cellStyle` has been explicitly set.
  var hasCellStyle: Bool {return self._cellStyle != nil}
  /// Clears the value of `cellStyle`. Subsequent reads from it will return its default value.
  mutating func clearCellStyle() {self._cellStyle = nil}

  var textStyle: TSP_Reference {
    get {return _textStyle ?? TSP_Reference()}
    set {_textStyle = newValue}
  }
  /// Returns true if `textStyle` has been explicitly set.
  var hasTextStyle: Bool {return self._textStyle != nil}
  /// Clears the value of `textStyle`. Subsequent reads from it will return its default value.
  mutating func clearTextStyle() {self._textStyle = nil}

  var uuid: TSP_UUID {
    get {return _uuid ?? TSP_UUID()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {self._uuid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _size: Double? = nil
  fileprivate var _hidingAction: UInt32? = nil
  fileprivate var _cellStyle: TSP_Reference? = nil
  fileprivate var _textStyle: TSP_Reference? = nil
  fileprivate var _uuid: TSP_UUID? = nil
}

struct TST_CommandInsertColumnsOrRowsArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _storage._super ?? TST_TableCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var bundle: TST_ColumnRowBundleArchive {
    get {return _storage._bundle ?? TST_ColumnRowBundleArchive()}
    set {_uniqueStorage()._bundle = newValue}
  }
  /// Returns true if `bundle` has been explicitly set.
  var hasBundle: Bool {return _storage._bundle != nil}
  /// Clears the value of `bundle`. Subsequent reads from it will return its default value.
  mutating func clearBundle() {_uniqueStorage()._bundle = nil}

  var concurrentCellMap: TSP_Reference {
    get {return _storage._concurrentCellMap ?? TSP_Reference()}
    set {_uniqueStorage()._concurrentCellMap = newValue}
  }
  /// Returns true if `concurrentCellMap` has been explicitly set.
  var hasConcurrentCellMap: Bool {return _storage._concurrentCellMap != nil}
  /// Clears the value of `concurrentCellMap`. Subsequent reads from it will return its default value.
  mutating func clearConcurrentCellMap() {_uniqueStorage()._concurrentCellMap = nil}

  var categoriesCellMap: TSP_Reference {
    get {return _storage._categoriesCellMap ?? TSP_Reference()}
    set {_uniqueStorage()._categoriesCellMap = newValue}
  }
  /// Returns true if `categoriesCellMap` has been explicitly set.
  var hasCategoriesCellMap: Bool {return _storage._categoriesCellMap != nil}
  /// Clears the value of `categoriesCellMap`. Subsequent reads from it will return its default value.
  mutating func clearCategoriesCellMap() {_uniqueStorage()._categoriesCellMap = nil}

  var undoCommands: TSP_Reference {
    get {return _storage._undoCommands ?? TSP_Reference()}
    set {_uniqueStorage()._undoCommands = newValue}
  }
  /// Returns true if `undoCommands` has been explicitly set.
  var hasUndoCommands: Bool {return _storage._undoCommands != nil}
  /// Clears the value of `undoCommands`. Subsequent reads from it will return its default value.
  mutating func clearUndoCommands() {_uniqueStorage()._undoCommands = nil}

  var undoConcurrentCellMap: TSP_Reference {
    get {return _storage._undoConcurrentCellMap ?? TSP_Reference()}
    set {_uniqueStorage()._undoConcurrentCellMap = newValue}
  }
  /// Returns true if `undoConcurrentCellMap` has been explicitly set.
  var hasUndoConcurrentCellMap: Bool {return _storage._undoConcurrentCellMap != nil}
  /// Clears the value of `undoConcurrentCellMap`. Subsequent reads from it will return its default value.
  mutating func clearUndoConcurrentCellMap() {_uniqueStorage()._undoConcurrentCellMap = nil}

  var undoCategoriesCellMap: TSP_Reference {
    get {return _storage._undoCategoriesCellMap ?? TSP_Reference()}
    set {_uniqueStorage()._undoCategoriesCellMap = newValue}
  }
  /// Returns true if `undoCategoriesCellMap` has been explicitly set.
  var hasUndoCategoriesCellMap: Bool {return _storage._undoCategoriesCellMap != nil}
  /// Clears the value of `undoCategoriesCellMap`. Subsequent reads from it will return its default value.
  mutating func clearUndoCategoriesCellMap() {_uniqueStorage()._undoCategoriesCellMap = nil}

  var sortOrder: TST_TableSortOrderUIDArchive {
    get {return _storage._sortOrder ?? TST_TableSortOrderUIDArchive()}
    set {_uniqueStorage()._sortOrder = newValue}
  }
  /// Returns true if `sortOrder` has been explicitly set.
  var hasSortOrder: Bool {return _storage._sortOrder != nil}
  /// Clears the value of `sortOrder`. Subsequent reads from it will return its default value.
  mutating func clearSortOrder() {_uniqueStorage()._sortOrder = nil}

  var groupSortOrder: TST_TableGroupSortOrderUIDArchive {
    get {return _storage._groupSortOrder ?? TST_TableGroupSortOrderUIDArchive()}
    set {_uniqueStorage()._groupSortOrder = newValue}
  }
  /// Returns true if `groupSortOrder` has been explicitly set.
  var hasGroupSortOrder: Bool {return _storage._groupSortOrder != nil}
  /// Clears the value of `groupSortOrder`. Subsequent reads from it will return its default value.
  mutating func clearGroupSortOrder() {_uniqueStorage()._groupSortOrder = nil}

  var filterSet: TSP_Reference {
    get {return _storage._filterSet ?? TSP_Reference()}
    set {_uniqueStorage()._filterSet = newValue}
  }
  /// Returns true if `filterSet` has been explicitly set.
  var hasFilterSet: Bool {return _storage._filterSet != nil}
  /// Clears the value of `filterSet`. Subsequent reads from it will return its default value.
  mutating func clearFilterSet() {_uniqueStorage()._filterSet = nil}

  var shouldEdgeExpandFormulaRanges: Bool {
    get {return _storage._shouldEdgeExpandFormulaRanges ?? false}
    set {_uniqueStorage()._shouldEdgeExpandFormulaRanges = newValue}
  }
  /// Returns true if `shouldEdgeExpandFormulaRanges` has been explicitly set.
  var hasShouldEdgeExpandFormulaRanges: Bool {return _storage._shouldEdgeExpandFormulaRanges != nil}
  /// Clears the value of `shouldEdgeExpandFormulaRanges`. Subsequent reads from it will return its default value.
  mutating func clearShouldEdgeExpandFormulaRanges() {_uniqueStorage()._shouldEdgeExpandFormulaRanges = nil}

  var wasCategorized: Bool {
    get {return _storage._wasCategorized ?? false}
    set {_uniqueStorage()._wasCategorized = newValue}
  }
  /// Returns true if `wasCategorized` has been explicitly set.
  var hasWasCategorized: Bool {return _storage._wasCategorized != nil}
  /// Clears the value of `wasCategorized`. Subsequent reads from it will return its default value.
  mutating func clearWasCategorized() {_uniqueStorage()._wasCategorized = nil}

  var undoOrder: [TSP_UUID] {
    get {return _storage._undoOrder}
    set {_uniqueStorage()._undoOrder = newValue}
  }

  var srcRowColumnUid: TSP_UUID {
    get {return _storage._srcRowColumnUid ?? TSP_UUID()}
    set {_uniqueStorage()._srcRowColumnUid = newValue}
  }
  /// Returns true if `srcRowColumnUid` has been explicitly set.
  var hasSrcRowColumnUid: Bool {return _storage._srcRowColumnUid != nil}
  /// Clears the value of `srcRowColumnUid`. Subsequent reads from it will return its default value.
  mutating func clearSrcRowColumnUid() {_uniqueStorage()._srcRowColumnUid = nil}

  var oppRowColumnUid: TSP_UUID {
    get {return _storage._oppRowColumnUid ?? TSP_UUID()}
    set {_uniqueStorage()._oppRowColumnUid = newValue}
  }
  /// Returns true if `oppRowColumnUid` has been explicitly set.
  var hasOppRowColumnUid: Bool {return _storage._oppRowColumnUid != nil}
  /// Clears the value of `oppRowColumnUid`. Subsequent reads from it will return its default value.
  mutating func clearOppRowColumnUid() {_uniqueStorage()._oppRowColumnUid = nil}

  var undoBundle: TST_ColumnRowBundleArchive {
    get {return _storage._undoBundle ?? TST_ColumnRowBundleArchive()}
    set {_uniqueStorage()._undoBundle = newValue}
  }
  /// Returns true if `undoBundle` has been explicitly set.
  var hasUndoBundle: Bool {return _storage._undoBundle != nil}
  /// Clears the value of `undoBundle`. Subsequent reads from it will return its default value.
  mutating func clearUndoBundle() {_uniqueStorage()._undoBundle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_ColumnRowBundleArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isRow: Bool {
    get {return _isRow ?? false}
    set {_isRow = newValue}
  }
  /// Returns true if `isRow` has been explicitly set.
  var hasIsRow: Bool {return self._isRow != nil}
  /// Clears the value of `isRow`. Subsequent reads from it will return its default value.
  mutating func clearIsRow() {self._isRow = nil}

  var viewUidList: [TSP_UUID] = []

  var viewTypeList: [TST_ColumnRowBundleItemTypeEnum] = []

  var baseUidList: [TSP_UUID] = []

  var baseTypeList: [TST_ColumnRowBundleItemTypeEnum] = []

  var categoryOrderUidList: [TSP_UUID] = []

  var categoryOrderTypeList: [TST_ColumnRowBundleItemTypeEnum] = []

  var metadataList: [TST_ColumnRowMetadataArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _isRow: Bool? = nil
}

struct TST_CommandRemoveColumnsOrRowsArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _storage._super ?? TST_TableCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var bundle: TST_ColumnRowBundleArchive {
    get {return _storage._bundle ?? TST_ColumnRowBundleArchive()}
    set {_uniqueStorage()._bundle = newValue}
  }
  /// Returns true if `bundle` has been explicitly set.
  var hasBundle: Bool {return _storage._bundle != nil}
  /// Clears the value of `bundle`. Subsequent reads from it will return its default value.
  mutating func clearBundle() {_uniqueStorage()._bundle = nil}

  var concurrentCellMap: TSP_Reference {
    get {return _storage._concurrentCellMap ?? TSP_Reference()}
    set {_uniqueStorage()._concurrentCellMap = newValue}
  }
  /// Returns true if `concurrentCellMap` has been explicitly set.
  var hasConcurrentCellMap: Bool {return _storage._concurrentCellMap != nil}
  /// Clears the value of `concurrentCellMap`. Subsequent reads from it will return its default value.
  mutating func clearConcurrentCellMap() {_uniqueStorage()._concurrentCellMap = nil}

  var categoriesCellMap: TSP_Reference {
    get {return _storage._categoriesCellMap ?? TSP_Reference()}
    set {_uniqueStorage()._categoriesCellMap = newValue}
  }
  /// Returns true if `categoriesCellMap` has been explicitly set.
  var hasCategoriesCellMap: Bool {return _storage._categoriesCellMap != nil}
  /// Clears the value of `categoriesCellMap`. Subsequent reads from it will return its default value.
  mutating func clearCategoriesCellMap() {_uniqueStorage()._categoriesCellMap = nil}

  var undoConcurrentCellMap: TSP_Reference {
    get {return _storage._undoConcurrentCellMap ?? TSP_Reference()}
    set {_uniqueStorage()._undoConcurrentCellMap = newValue}
  }
  /// Returns true if `undoConcurrentCellMap` has been explicitly set.
  var hasUndoConcurrentCellMap: Bool {return _storage._undoConcurrentCellMap != nil}
  /// Clears the value of `undoConcurrentCellMap`. Subsequent reads from it will return its default value.
  mutating func clearUndoConcurrentCellMap() {_uniqueStorage()._undoConcurrentCellMap = nil}

  var undoCategoriesCellMap: TSP_Reference {
    get {return _storage._undoCategoriesCellMap ?? TSP_Reference()}
    set {_uniqueStorage()._undoCategoriesCellMap = newValue}
  }
  /// Returns true if `undoCategoriesCellMap` has been explicitly set.
  var hasUndoCategoriesCellMap: Bool {return _storage._undoCategoriesCellMap != nil}
  /// Clears the value of `undoCategoriesCellMap`. Subsequent reads from it will return its default value.
  mutating func clearUndoCategoriesCellMap() {_uniqueStorage()._undoCategoriesCellMap = nil}

  var undoFilterSet: TSP_Reference {
    get {return _storage._undoFilterSet ?? TSP_Reference()}
    set {_uniqueStorage()._undoFilterSet = newValue}
  }
  /// Returns true if `undoFilterSet` has been explicitly set.
  var hasUndoFilterSet: Bool {return _storage._undoFilterSet != nil}
  /// Clears the value of `undoFilterSet`. Subsequent reads from it will return its default value.
  mutating func clearUndoFilterSet() {_uniqueStorage()._undoFilterSet = nil}

  var undoSortOrder: TST_TableSortOrderUIDArchive {
    get {return _storage._undoSortOrder ?? TST_TableSortOrderUIDArchive()}
    set {_uniqueStorage()._undoSortOrder = newValue}
  }
  /// Returns true if `undoSortOrder` has been explicitly set.
  var hasUndoSortOrder: Bool {return _storage._undoSortOrder != nil}
  /// Clears the value of `undoSortOrder`. Subsequent reads from it will return its default value.
  mutating func clearUndoSortOrder() {_uniqueStorage()._undoSortOrder = nil}

  var undoGroupSortOrder: TST_TableGroupSortOrderUIDArchive {
    get {return _storage._undoGroupSortOrder ?? TST_TableGroupSortOrderUIDArchive()}
    set {_uniqueStorage()._undoGroupSortOrder = newValue}
  }
  /// Returns true if `undoGroupSortOrder` has been explicitly set.
  var hasUndoGroupSortOrder: Bool {return _storage._undoGroupSortOrder != nil}
  /// Clears the value of `undoGroupSortOrder`. Subsequent reads from it will return its default value.
  mutating func clearUndoGroupSortOrder() {_uniqueStorage()._undoGroupSortOrder = nil}

  var formulaRewriteCommandForUndo: TSP_Reference {
    get {return _storage._formulaRewriteCommandForUndo ?? TSP_Reference()}
    set {_uniqueStorage()._formulaRewriteCommandForUndo = newValue}
  }
  /// Returns true if `formulaRewriteCommandForUndo` has been explicitly set.
  var hasFormulaRewriteCommandForUndo: Bool {return _storage._formulaRewriteCommandForUndo != nil}
  /// Clears the value of `formulaRewriteCommandForUndo`. Subsequent reads from it will return its default value.
  mutating func clearFormulaRewriteCommandForUndo() {_uniqueStorage()._formulaRewriteCommandForUndo = nil}

  var inverseShouldEdgeExpandFormulaRanges: Bool {
    get {return _storage._inverseShouldEdgeExpandFormulaRanges ?? false}
    set {_uniqueStorage()._inverseShouldEdgeExpandFormulaRanges = newValue}
  }
  /// Returns true if `inverseShouldEdgeExpandFormulaRanges` has been explicitly set.
  var hasInverseShouldEdgeExpandFormulaRanges: Bool {return _storage._inverseShouldEdgeExpandFormulaRanges != nil}
  /// Clears the value of `inverseShouldEdgeExpandFormulaRanges`. Subsequent reads from it will return its default value.
  mutating func clearInverseShouldEdgeExpandFormulaRanges() {_uniqueStorage()._inverseShouldEdgeExpandFormulaRanges = nil}

  var undoOrder: [TSP_UUID] {
    get {return _storage._undoOrder}
    set {_uniqueStorage()._undoOrder = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandRowColumnRangeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var uids: [TSP_UUID] = []

  var isRow: Bool {
    get {return _isRow ?? false}
    set {_isRow = newValue}
  }
  /// Returns true if `isRow` has been explicitly set.
  var hasIsRow: Bool {return self._isRow != nil}
  /// Clears the value of `isRow`. Subsequent reads from it will return its default value.
  mutating func clearIsRow() {self._isRow = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _isRow: Bool? = nil
}

struct TST_CommandResizeColumnOrRowArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_CommandRowColumnRangeArchive {
    get {return _super ?? TST_CommandRowColumnRangeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var sizes: [Float] = []

  var sizesForUndo: [Float] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_CommandRowColumnRangeArchive? = nil
}

struct TST_CommandCategoryResizeColumnOrRowArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var categoryRowSizes: [Float] = []

  var categoryRowSizesForUndo: [Float] = []

  var categoryLabelRowSizes: [Float] = []

  var categoryLabelRowSizesForUndo: [Float] = []

  var categoryColumnSize: Double {
    get {return _categoryColumnSize ?? 0}
    set {_categoryColumnSize = newValue}
  }
  /// Returns true if `categoryColumnSize` has been explicitly set.
  var hasCategoryColumnSize: Bool {return self._categoryColumnSize != nil}
  /// Clears the value of `categoryColumnSize`. Subsequent reads from it will return its default value.
  mutating func clearCategoryColumnSize() {self._categoryColumnSize = nil}

  var categoryColumnSizeForUndo: Double {
    get {return _categoryColumnSizeForUndo ?? 0}
    set {_categoryColumnSizeForUndo = newValue}
  }
  /// Returns true if `categoryColumnSizeForUndo` has been explicitly set.
  var hasCategoryColumnSizeForUndo: Bool {return self._categoryColumnSizeForUndo != nil}
  /// Clears the value of `categoryColumnSizeForUndo`. Subsequent reads from it will return its default value.
  mutating func clearCategoryColumnSizeForUndo() {self._categoryColumnSizeForUndo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _categoryColumnSize: Double? = nil
  fileprivate var _categoryColumnSizeForUndo: Double? = nil
}

struct TST_CommandHideShowArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_CommandRowColumnRangeArchive {
    get {return _super ?? TST_CommandRowColumnRangeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var hideShowAction: TST_HideShowActionArchive {
    get {return _hideShowAction ?? .hideShowActionHide}
    set {_hideShowAction = newValue}
  }
  /// Returns true if `hideShowAction` has been explicitly set.
  var hasHideShowAction: Bool {return self._hideShowAction != nil}
  /// Clears the value of `hideShowAction`. Subsequent reads from it will return its default value.
  mutating func clearHideShowAction() {self._hideShowAction = nil}

  var hidingAction: UInt32 {
    get {return _hidingAction ?? 0}
    set {_hidingAction = newValue}
  }
  /// Returns true if `hidingAction` has been explicitly set.
  var hasHidingAction: Bool {return self._hidingAction != nil}
  /// Clears the value of `hidingAction`. Subsequent reads from it will return its default value.
  mutating func clearHidingAction() {self._hidingAction = nil}

  var hideShowActionForUndo: [TST_HideShowActionArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_CommandRowColumnRangeArchive? = nil
  fileprivate var _hideShowAction: TST_HideShowActionArchive? = nil
  fileprivate var _hidingAction: UInt32? = nil
}

struct TST_CommandTextPreflightInsertCellArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _storage._super ?? TST_TableCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var coalescedTextcommand: TSP_Reference {
    get {return _storage._coalescedTextcommand ?? TSP_Reference()}
    set {_uniqueStorage()._coalescedTextcommand = newValue}
  }
  /// Returns true if `coalescedTextcommand` has been explicitly set.
  var hasCoalescedTextcommand: Bool {return _storage._coalescedTextcommand != nil}
  /// Clears the value of `coalescedTextcommand`. Subsequent reads from it will return its default value.
  mutating func clearCoalescedTextcommand() {_uniqueStorage()._coalescedTextcommand = nil}

  var postflightcommand: TSP_Reference {
    get {return _storage._postflightcommand ?? TSP_Reference()}
    set {_uniqueStorage()._postflightcommand = newValue}
  }
  /// Returns true if `postflightcommand` has been explicitly set.
  var hasPostflightcommand: Bool {return _storage._postflightcommand != nil}
  /// Clears the value of `postflightcommand`. Subsequent reads from it will return its default value.
  mutating func clearPostflightcommand() {_uniqueStorage()._postflightcommand = nil}

  var groupedWithPostflight: Bool {
    get {return _storage._groupedWithPostflight ?? false}
    set {_uniqueStorage()._groupedWithPostflight = newValue}
  }
  /// Returns true if `groupedWithPostflight` has been explicitly set.
  var hasGroupedWithPostflight: Bool {return _storage._groupedWithPostflight != nil}
  /// Clears the value of `groupedWithPostflight`. Subsequent reads from it will return its default value.
  mutating func clearGroupedWithPostflight() {_uniqueStorage()._groupedWithPostflight = nil}

  var editingCell: TST_Cell {
    get {return _storage._editingCell ?? TST_Cell()}
    set {_uniqueStorage()._editingCell = newValue}
  }
  /// Returns true if `editingCell` has been explicitly set.
  var hasEditingCell: Bool {return _storage._editingCell != nil}
  /// Clears the value of `editingCell`. Subsequent reads from it will return its default value.
  mutating func clearEditingCell() {_uniqueStorage()._editingCell = nil}

  var editingStorage: TSP_Reference {
    get {return _storage._editingStorage ?? TSP_Reference()}
    set {_uniqueStorage()._editingStorage = newValue}
  }
  /// Returns true if `editingStorage` has been explicitly set.
  var hasEditingStorage: Bool {return _storage._editingStorage != nil}
  /// Clears the value of `editingStorage`. Subsequent reads from it will return its default value.
  mutating func clearEditingStorage() {_uniqueStorage()._editingStorage = nil}

  var lastColumnHitByTap: UInt32 {
    get {return _storage._lastColumnHitByTap ?? 0}
    set {_uniqueStorage()._lastColumnHitByTap = newValue}
  }
  /// Returns true if `lastColumnHitByTap` has been explicitly set.
  var hasLastColumnHitByTap: Bool {return _storage._lastColumnHitByTap != nil}
  /// Clears the value of `lastColumnHitByTap`. Subsequent reads from it will return its default value.
  mutating func clearLastColumnHitByTap() {_uniqueStorage()._lastColumnHitByTap = nil}

  var cellUid: TSP_UUIDCoordArchive {
    get {return _storage._cellUid ?? TSP_UUIDCoordArchive()}
    set {_uniqueStorage()._cellUid = newValue}
  }
  /// Returns true if `cellUid` has been explicitly set.
  var hasCellUid: Bool {return _storage._cellUid != nil}
  /// Clears the value of `cellUid`. Subsequent reads from it will return its default value.
  mutating func clearCellUid() {_uniqueStorage()._cellUid = nil}

  var archivedInitialSelectionPath: TSK_SelectionPathArchive {
    get {return _storage._archivedInitialSelectionPath ?? TSK_SelectionPathArchive()}
    set {_uniqueStorage()._archivedInitialSelectionPath = newValue}
  }
  /// Returns true if `archivedInitialSelectionPath` has been explicitly set.
  var hasArchivedInitialSelectionPath: Bool {return _storage._archivedInitialSelectionPath != nil}
  /// Clears the value of `archivedInitialSelectionPath`. Subsequent reads from it will return its default value.
  mutating func clearArchivedInitialSelectionPath() {_uniqueStorage()._archivedInitialSelectionPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandPostflightSetCellArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var childcommandundo: TSP_Reference {
    get {return _childcommandundo ?? TSP_Reference()}
    set {_childcommandundo = newValue}
  }
  /// Returns true if `childcommandundo` has been explicitly set.
  var hasChildcommandundo: Bool {return self._childcommandundo != nil}
  /// Clears the value of `childcommandundo`. Subsequent reads from it will return its default value.
  mutating func clearChildcommandundo() {self._childcommandundo = nil}

  var editingCell: TST_Cell {
    get {return _editingCell ?? TST_Cell()}
    set {_editingCell = newValue}
  }
  /// Returns true if `editingCell` has been explicitly set.
  var hasEditingCell: Bool {return self._editingCell != nil}
  /// Clears the value of `editingCell`. Subsequent reads from it will return its default value.
  mutating func clearEditingCell() {self._editingCell = nil}

  var newCell: TST_Cell {
    get {return _newCell ?? TST_Cell()}
    set {_newCell = newValue}
  }
  /// Returns true if `newCell` has been explicitly set.
  var hasNewCell: Bool {return self._newCell != nil}
  /// Clears the value of `newCell`. Subsequent reads from it will return its default value.
  mutating func clearNewCell() {self._newCell = nil}

  var editingStorage: TSP_Reference {
    get {return _editingStorage ?? TSP_Reference()}
    set {_editingStorage = newValue}
  }
  /// Returns true if `editingStorage` has been explicitly set.
  var hasEditingStorage: Bool {return self._editingStorage != nil}
  /// Clears the value of `editingStorage`. Subsequent reads from it will return its default value.
  mutating func clearEditingStorage() {self._editingStorage = nil}

  var lastColumnHitByTap: UInt32 {
    get {return _lastColumnHitByTap ?? 0}
    set {_lastColumnHitByTap = newValue}
  }
  /// Returns true if `lastColumnHitByTap` has been explicitly set.
  var hasLastColumnHitByTap: Bool {return self._lastColumnHitByTap != nil}
  /// Clears the value of `lastColumnHitByTap`. Subsequent reads from it will return its default value.
  mutating func clearLastColumnHitByTap() {self._lastColumnHitByTap = nil}

  var cellUid: TSP_UUIDCoordArchive {
    get {return _cellUid ?? TSP_UUIDCoordArchive()}
    set {_cellUid = newValue}
  }
  /// Returns true if `cellUid` has been explicitly set.
  var hasCellUid: Bool {return self._cellUid != nil}
  /// Clears the value of `cellUid`. Subsequent reads from it will return its default value.
  mutating func clearCellUid() {self._cellUid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _childcommandundo: TSP_Reference? = nil
  fileprivate var _editingCell: TST_Cell? = nil
  fileprivate var _newCell: TST_Cell? = nil
  fileprivate var _editingStorage: TSP_Reference? = nil
  fileprivate var _lastColumnHitByTap: UInt32? = nil
  fileprivate var _cellUid: TSP_UUIDCoordArchive? = nil
}

struct TST_CommandChangeTableAreaForColumnOrRowArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_CommandRowColumnRangeArchive {
    get {return _super ?? TST_CommandRowColumnRangeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var tableAreaTransition: TST_TableAreaTransition {
    get {return _tableAreaTransition ?? .headerRowToBody}
    set {_tableAreaTransition = newValue}
  }
  /// Returns true if `tableAreaTransition` has been explicitly set.
  var hasTableAreaTransition: Bool {return self._tableAreaTransition != nil}
  /// Clears the value of `tableAreaTransition`. Subsequent reads from it will return its default value.
  mutating func clearTableAreaTransition() {self._tableAreaTransition = nil}

  var cellDiffMap: TSP_Reference {
    get {return _cellDiffMap ?? TSP_Reference()}
    set {_cellDiffMap = newValue}
  }
  /// Returns true if `cellDiffMap` has been explicitly set.
  var hasCellDiffMap: Bool {return self._cellDiffMap != nil}
  /// Clears the value of `cellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearCellDiffMap() {self._cellDiffMap = nil}

  var undoCellDiffMap: TSP_Reference {
    get {return _undoCellDiffMap ?? TSP_Reference()}
    set {_undoCellDiffMap = newValue}
  }
  /// Returns true if `undoCellDiffMap` has been explicitly set.
  var hasUndoCellDiffMap: Bool {return self._undoCellDiffMap != nil}
  /// Clears the value of `undoCellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearUndoCellDiffMap() {self._undoCellDiffMap = nil}

  var undoCommands: TSP_Reference {
    get {return _undoCommands ?? TSP_Reference()}
    set {_undoCommands = newValue}
  }
  /// Returns true if `undoCommands` has been explicitly set.
  var hasUndoCommands: Bool {return self._undoCommands != nil}
  /// Clears the value of `undoCommands`. Subsequent reads from it will return its default value.
  mutating func clearUndoCommands() {self._undoCommands = nil}

  var actionString: String {
    get {return _actionString ?? String()}
    set {_actionString = newValue}
  }
  /// Returns true if `actionString` has been explicitly set.
  var hasActionString: Bool {return self._actionString != nil}
  /// Clears the value of `actionString`. Subsequent reads from it will return its default value.
  mutating func clearActionString() {self._actionString = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_CommandRowColumnRangeArchive? = nil
  fileprivate var _tableAreaTransition: TST_TableAreaTransition? = nil
  fileprivate var _cellDiffMap: TSP_Reference? = nil
  fileprivate var _undoCellDiffMap: TSP_Reference? = nil
  fileprivate var _undoCommands: TSP_Reference? = nil
  fileprivate var _actionString: String? = nil
}

struct TST_CommandSetPencilAnnotationsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var annotations: [TSP_Reference] = []

  var formulas: [TSCE_FormulaArchive] = []

  var formulaIndexes: [UInt64] = []

  var inverseFormulas: [TSCE_FormulaArchive] = []

  var inverseFormulaIndexes: [UInt64] = []

  var rollbackIndex: UInt64 {
    get {return _rollbackIndex ?? 0}
    set {_rollbackIndex = newValue}
  }
  /// Returns true if `rollbackIndex` has been explicitly set.
  var hasRollbackIndex: Bool {return self._rollbackIndex != nil}
  /// Clears the value of `rollbackIndex`. Subsequent reads from it will return its default value.
  mutating func clearRollbackIndex() {self._rollbackIndex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _rollbackIndex: UInt64? = nil
}

struct TST_CommandSetTableNameArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var newtablename: String {
    get {return _storage._newtablename ?? String()}
    set {_uniqueStorage()._newtablename = newValue}
  }
  /// Returns true if `newtablename` has been explicitly set.
  var hasNewtablename: Bool {return _storage._newtablename != nil}
  /// Clears the value of `newtablename`. Subsequent reads from it will return its default value.
  mutating func clearNewtablename() {_uniqueStorage()._newtablename = nil}

  var oldtablename: String {
    get {return _storage._oldtablename ?? String()}
    set {_uniqueStorage()._oldtablename = newValue}
  }
  /// Returns true if `oldtablename` has been explicitly set.
  var hasOldtablename: Bool {return _storage._oldtablename != nil}
  /// Clears the value of `oldtablename`. Subsequent reads from it will return its default value.
  mutating func clearOldtablename() {_uniqueStorage()._oldtablename = nil}

  var newstyle: TSP_Reference {
    get {return _storage._newstyle ?? TSP_Reference()}
    set {_uniqueStorage()._newstyle = newValue}
  }
  /// Returns true if `newstyle` has been explicitly set.
  var hasNewstyle: Bool {return _storage._newstyle != nil}
  /// Clears the value of `newstyle`. Subsequent reads from it will return its default value.
  mutating func clearNewstyle() {_uniqueStorage()._newstyle = nil}

  var oldstyle: TSP_Reference {
    get {return _storage._oldstyle ?? TSP_Reference()}
    set {_uniqueStorage()._oldstyle = newValue}
  }
  /// Returns true if `oldstyle` has been explicitly set.
  var hasOldstyle: Bool {return _storage._oldstyle != nil}
  /// Clears the value of `oldstyle`. Subsequent reads from it will return its default value.
  mutating func clearOldstyle() {_uniqueStorage()._oldstyle = nil}

  var `super`: TST_TableCommandArchive {
    get {return _storage._super ?? TST_TableCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var oldShapeStyle: TSP_Reference {
    get {return _storage._oldShapeStyle ?? TSP_Reference()}
    set {_uniqueStorage()._oldShapeStyle = newValue}
  }
  /// Returns true if `oldShapeStyle` has been explicitly set.
  var hasOldShapeStyle: Bool {return _storage._oldShapeStyle != nil}
  /// Clears the value of `oldShapeStyle`. Subsequent reads from it will return its default value.
  mutating func clearOldShapeStyle() {_uniqueStorage()._oldShapeStyle = nil}

  var newShapeStyle: TSP_Reference {
    get {return _storage._newShapeStyle ?? TSP_Reference()}
    set {_uniqueStorage()._newShapeStyle = newValue}
  }
  /// Returns true if `newShapeStyle` has been explicitly set.
  var hasNewShapeStyle: Bool {return _storage._newShapeStyle != nil}
  /// Clears the value of `newShapeStyle`. Subsequent reads from it will return its default value.
  mutating func clearNewShapeStyle() {_uniqueStorage()._newShapeStyle = nil}

  var oldTableNameBorderEnabled: Bool {
    get {return _storage._oldTableNameBorderEnabled ?? false}
    set {_uniqueStorage()._oldTableNameBorderEnabled = newValue}
  }
  /// Returns true if `oldTableNameBorderEnabled` has been explicitly set.
  var hasOldTableNameBorderEnabled: Bool {return _storage._oldTableNameBorderEnabled != nil}
  /// Clears the value of `oldTableNameBorderEnabled`. Subsequent reads from it will return its default value.
  mutating func clearOldTableNameBorderEnabled() {_uniqueStorage()._oldTableNameBorderEnabled = nil}

  var newTableNameBorderEnabled: Bool {
    get {return _storage._newTableNameBorderEnabled ?? false}
    set {_uniqueStorage()._newTableNameBorderEnabled = newValue}
  }
  /// Returns true if `newTableNameBorderEnabled` has been explicitly set.
  var hasNewTableNameBorderEnabled: Bool {return _storage._newTableNameBorderEnabled != nil}
  /// Clears the value of `newTableNameBorderEnabled`. Subsequent reads from it will return its default value.
  mutating func clearNewTableNameBorderEnabled() {_uniqueStorage()._newTableNameBorderEnabled = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandSetTableNameEnabledArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var tableNameEnabled: Bool {
    get {return _tableNameEnabled ?? false}
    set {_tableNameEnabled = newValue}
  }
  /// Returns true if `tableNameEnabled` has been explicitly set.
  var hasTableNameEnabled: Bool {return self._tableNameEnabled != nil}
  /// Clears the value of `tableNameEnabled`. Subsequent reads from it will return its default value.
  mutating func clearTableNameEnabled() {self._tableNameEnabled = nil}

  var prevTableNameEnabled: Bool {
    get {return _prevTableNameEnabled ?? false}
    set {_prevTableNameEnabled = newValue}
  }
  /// Returns true if `prevTableNameEnabled` has been explicitly set.
  var hasPrevTableNameEnabled: Bool {return self._prevTableNameEnabled != nil}
  /// Clears the value of `prevTableNameEnabled`. Subsequent reads from it will return its default value.
  mutating func clearPrevTableNameEnabled() {self._prevTableNameEnabled = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _tableNameEnabled: Bool? = nil
  fileprivate var _prevTableNameEnabled: Bool? = nil
}

struct TST_CommandSetTableFontSizeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var isIncrease: Bool {
    get {return _isIncrease ?? false}
    set {_isIncrease = newValue}
  }
  /// Returns true if `isIncrease` has been explicitly set.
  var hasIsIncrease: Bool {return self._isIncrease != nil}
  /// Clears the value of `isIncrease`. Subsequent reads from it will return its default value.
  mutating func clearIsIncrease() {self._isIncrease = nil}

  var fontSizeDiff: Int32 {
    get {return _fontSizeDiff ?? 0}
    set {_fontSizeDiff = newValue}
  }
  /// Returns true if `fontSizeDiff` has been explicitly set.
  var hasFontSizeDiff: Bool {return self._fontSizeDiff != nil}
  /// Clears the value of `fontSizeDiff`. Subsequent reads from it will return its default value.
  mutating func clearFontSizeDiff() {self._fontSizeDiff = nil}

  var fontSizeList: [Double] = []

  var inverseFontSizeList: [Double] = []

  var cellDiffMap: TSP_Reference {
    get {return _cellDiffMap ?? TSP_Reference()}
    set {_cellDiffMap = newValue}
  }
  /// Returns true if `cellDiffMap` has been explicitly set.
  var hasCellDiffMap: Bool {return self._cellDiffMap != nil}
  /// Clears the value of `cellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearCellDiffMap() {self._cellDiffMap = nil}

  var inverseCellDiffMap: TSP_Reference {
    get {return _inverseCellDiffMap ?? TSP_Reference()}
    set {_inverseCellDiffMap = newValue}
  }
  /// Returns true if `inverseCellDiffMap` has been explicitly set.
  var hasInverseCellDiffMap: Bool {return self._inverseCellDiffMap != nil}
  /// Clears the value of `inverseCellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearInverseCellDiffMap() {self._inverseCellDiffMap = nil}

  var stylesContainerRefreshDone: Bool {
    get {return _stylesContainerRefreshDone ?? false}
    set {_stylesContainerRefreshDone = newValue}
  }
  /// Returns true if `stylesContainerRefreshDone` has been explicitly set.
  var hasStylesContainerRefreshDone: Bool {return self._stylesContainerRefreshDone != nil}
  /// Clears the value of `stylesContainerRefreshDone`. Subsequent reads from it will return its default value.
  mutating func clearStylesContainerRefreshDone() {self._stylesContainerRefreshDone = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _isIncrease: Bool? = nil
  fileprivate var _fontSizeDiff: Int32? = nil
  fileprivate var _cellDiffMap: TSP_Reference? = nil
  fileprivate var _inverseCellDiffMap: TSP_Reference? = nil
  fileprivate var _stylesContainerRefreshDone: Bool? = nil
}

struct TST_CommandSetTableFontNameArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var fontName: String {
    get {return _fontName ?? String()}
    set {_fontName = newValue}
  }
  /// Returns true if `fontName` has been explicitly set.
  var hasFontName: Bool {return self._fontName != nil}
  /// Clears the value of `fontName`. Subsequent reads from it will return its default value.
  mutating func clearFontName() {self._fontName = nil}

  var preserveFace: Bool {
    get {return _preserveFace ?? false}
    set {_preserveFace = newValue}
  }
  /// Returns true if `preserveFace` has been explicitly set.
  var hasPreserveFace: Bool {return self._preserveFace != nil}
  /// Clears the value of `preserveFace`. Subsequent reads from it will return its default value.
  mutating func clearPreserveFace() {self._preserveFace = nil}

  var previousFontName: String {
    get {return _previousFontName ?? String()}
    set {_previousFontName = newValue}
  }
  /// Returns true if `previousFontName` has been explicitly set.
  var hasPreviousFontName: Bool {return self._previousFontName != nil}
  /// Clears the value of `previousFontName`. Subsequent reads from it will return its default value.
  mutating func clearPreviousFontName() {self._previousFontName = nil}

  var previousTableStyle: TSP_Reference {
    get {return _previousTableStyle ?? TSP_Reference()}
    set {_previousTableStyle = newValue}
  }
  /// Returns true if `previousTableStyle` has been explicitly set.
  var hasPreviousTableStyle: Bool {return self._previousTableStyle != nil}
  /// Clears the value of `previousTableStyle`. Subsequent reads from it will return its default value.
  mutating func clearPreviousTableStyle() {self._previousTableStyle = nil}

  var previousTextStyles: [TSP_Reference] = []

  var cellDiffMap: TSP_Reference {
    get {return _cellDiffMap ?? TSP_Reference()}
    set {_cellDiffMap = newValue}
  }
  /// Returns true if `cellDiffMap` has been explicitly set.
  var hasCellDiffMap: Bool {return self._cellDiffMap != nil}
  /// Clears the value of `cellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearCellDiffMap() {self._cellDiffMap = nil}

  var inverseCellDiffMap: TSP_Reference {
    get {return _inverseCellDiffMap ?? TSP_Reference()}
    set {_inverseCellDiffMap = newValue}
  }
  /// Returns true if `inverseCellDiffMap` has been explicitly set.
  var hasInverseCellDiffMap: Bool {return self._inverseCellDiffMap != nil}
  /// Clears the value of `inverseCellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearInverseCellDiffMap() {self._inverseCellDiffMap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _fontName: String? = nil
  fileprivate var _preserveFace: Bool? = nil
  fileprivate var _previousFontName: String? = nil
  fileprivate var _previousTableStyle: TSP_Reference? = nil
  fileprivate var _cellDiffMap: TSP_Reference? = nil
  fileprivate var _inverseCellDiffMap: TSP_Reference? = nil
}

struct TST_CommandSetTableNameHeightArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var oldTableNameHeight: Double {
    get {return _oldTableNameHeight ?? 0}
    set {_oldTableNameHeight = newValue}
  }
  /// Returns true if `oldTableNameHeight` has been explicitly set.
  var hasOldTableNameHeight: Bool {return self._oldTableNameHeight != nil}
  /// Clears the value of `oldTableNameHeight`. Subsequent reads from it will return its default value.
  mutating func clearOldTableNameHeight() {self._oldTableNameHeight = nil}

  var newTableNameHeight: Double {
    get {return _newTableNameHeight ?? 0}
    set {_newTableNameHeight = newValue}
  }
  /// Returns true if `newTableNameHeight` has been explicitly set.
  var hasNewTableNameHeight: Bool {return self._newTableNameHeight != nil}
  /// Clears the value of `newTableNameHeight`. Subsequent reads from it will return its default value.
  mutating func clearNewTableNameHeight() {self._newTableNameHeight = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _oldTableNameHeight: Double? = nil
  fileprivate var _newTableNameHeight: Double? = nil
}

struct TST_CommandSetNowArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
}

struct TST_CommandSetWasCutArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var fromTableUid: TSP_UUID {
    get {return _fromTableUid ?? TSP_UUID()}
    set {_fromTableUid = newValue}
  }
  /// Returns true if `fromTableUid` has been explicitly set.
  var hasFromTableUid: Bool {return self._fromTableUid != nil}
  /// Clears the value of `fromTableUid`. Subsequent reads from it will return its default value.
  mutating func clearFromTableUid() {self._fromTableUid = nil}

  var prevFromTableUid: TSP_UUID {
    get {return _prevFromTableUid ?? TSP_UUID()}
    set {_prevFromTableUid = newValue}
  }
  /// Returns true if `prevFromTableUid` has been explicitly set.
  var hasPrevFromTableUid: Bool {return self._prevFromTableUid != nil}
  /// Clears the value of `prevFromTableUid`. Subsequent reads from it will return its default value.
  mutating func clearPrevFromTableUid() {self._prevFromTableUid = nil}

  var wasCut: Bool {
    get {return _wasCut ?? false}
    set {_wasCut = newValue}
  }
  /// Returns true if `wasCut` has been explicitly set.
  var hasWasCut: Bool {return self._wasCut != nil}
  /// Clears the value of `wasCut`. Subsequent reads from it will return its default value.
  mutating func clearWasCut() {self._wasCut = nil}

  var prevWasCut: Bool {
    get {return _prevWasCut ?? false}
    set {_prevWasCut = newValue}
  }
  /// Returns true if `prevWasCut` has been explicitly set.
  var hasPrevWasCut: Bool {return self._prevWasCut != nil}
  /// Clears the value of `prevWasCut`. Subsequent reads from it will return its default value.
  mutating func clearPrevWasCut() {self._prevWasCut = nil}

  var fromGroupByUid: TSP_UUID {
    get {return _fromGroupByUid ?? TSP_UUID()}
    set {_fromGroupByUid = newValue}
  }
  /// Returns true if `fromGroupByUid` has been explicitly set.
  var hasFromGroupByUid: Bool {return self._fromGroupByUid != nil}
  /// Clears the value of `fromGroupByUid`. Subsequent reads from it will return its default value.
  mutating func clearFromGroupByUid() {self._fromGroupByUid = nil}

  var prevFromGroupByUid: TSP_UUID {
    get {return _prevFromGroupByUid ?? TSP_UUID()}
    set {_prevFromGroupByUid = newValue}
  }
  /// Returns true if `prevFromGroupByUid` has been explicitly set.
  var hasPrevFromGroupByUid: Bool {return self._prevFromGroupByUid != nil}
  /// Clears the value of `prevFromGroupByUid`. Subsequent reads from it will return its default value.
  mutating func clearPrevFromGroupByUid() {self._prevFromGroupByUid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _fromTableUid: TSP_UUID? = nil
  fileprivate var _prevFromTableUid: TSP_UUID? = nil
  fileprivate var _wasCut: Bool? = nil
  fileprivate var _prevWasCut: Bool? = nil
  fileprivate var _fromGroupByUid: TSP_UUID? = nil
  fileprivate var _prevFromGroupByUid: TSP_UUID? = nil
}

struct TST_CommandStyleCellsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var formatProperties: TSP_ReferenceDictionary {
    get {return _formatProperties ?? TSP_ReferenceDictionary()}
    set {_formatProperties = newValue}
  }
  /// Returns true if `formatProperties` has been explicitly set.
  var hasFormatProperties: Bool {return self._formatProperties != nil}
  /// Clears the value of `formatProperties`. Subsequent reads from it will return its default value.
  mutating func clearFormatProperties() {self._formatProperties = nil}

  var selection: TST_SelectionArchive {
    get {return _selection ?? TST_SelectionArchive()}
    set {_selection = newValue}
  }
  /// Returns true if `selection` has been explicitly set.
  var hasSelection: Bool {return self._selection != nil}
  /// Clears the value of `selection`. Subsequent reads from it will return its default value.
  mutating func clearSelection() {self._selection = nil}

  var undoCellMap: TSP_Reference {
    get {return _undoCellMap ?? TSP_Reference()}
    set {_undoCellMap = newValue}
  }
  /// Returns true if `undoCellMap` has been explicitly set.
  var hasUndoCellMap: Bool {return self._undoCellMap != nil}
  /// Clears the value of `undoCellMap`. Subsequent reads from it will return its default value.
  mutating func clearUndoCellMap() {self._undoCellMap = nil}

  var redoCellMap: TSP_Reference {
    get {return _redoCellMap ?? TSP_Reference()}
    set {_redoCellMap = newValue}
  }
  /// Returns true if `redoCellMap` has been explicitly set.
  var hasRedoCellMap: Bool {return self._redoCellMap != nil}
  /// Clears the value of `redoCellMap`. Subsequent reads from it will return its default value.
  mutating func clearRedoCellMap() {self._redoCellMap = nil}

  var textUndo: TSP_Reference {
    get {return _textUndo ?? TSP_Reference()}
    set {_textUndo = newValue}
  }
  /// Returns true if `textUndo` has been explicitly set.
  var hasTextUndo: Bool {return self._textUndo != nil}
  /// Clears the value of `textUndo`. Subsequent reads from it will return its default value.
  mutating func clearTextUndo() {self._textUndo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _formatProperties: TSP_ReferenceDictionary? = nil
  fileprivate var _selection: TST_SelectionArchive? = nil
  fileprivate var _undoCellMap: TSP_Reference? = nil
  fileprivate var _redoCellMap: TSP_Reference? = nil
  fileprivate var _textUndo: TSP_Reference? = nil
}

struct TST_CommandStyleTableArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var formatProperties: TSP_ReferenceDictionary {
    get {return _formatProperties ?? TSP_ReferenceDictionary()}
    set {_formatProperties = newValue}
  }
  /// Returns true if `formatProperties` has been explicitly set.
  var hasFormatProperties: Bool {return self._formatProperties != nil}
  /// Clears the value of `formatProperties`. Subsequent reads from it will return its default value.
  mutating func clearFormatProperties() {self._formatProperties = nil}

  var oldStyle: TSTSOS_TableStylePropertyChangeSetArchive {
    get {return _oldStyle ?? TSTSOS_TableStylePropertyChangeSetArchive()}
    set {_oldStyle = newValue}
  }
  /// Returns true if `oldStyle` has been explicitly set.
  var hasOldStyle: Bool {return self._oldStyle != nil}
  /// Clears the value of `oldStyle`. Subsequent reads from it will return its default value.
  mutating func clearOldStyle() {self._oldStyle = nil}

  var newStyle: TSTSOS_TableStylePropertyChangeSetArchive {
    get {return _newStyle ?? TSTSOS_TableStylePropertyChangeSetArchive()}
    set {_newStyle = newValue}
  }
  /// Returns true if `newStyle` has been explicitly set.
  var hasNewStyle: Bool {return self._newStyle != nil}
  /// Clears the value of `newStyle`. Subsequent reads from it will return its default value.
  mutating func clearNewStyle() {self._newStyle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _formatProperties: TSP_ReferenceDictionary? = nil
  fileprivate var _oldStyle: TSTSOS_TableStylePropertyChangeSetArchive? = nil
  fileprivate var _newStyle: TSTSOS_TableStylePropertyChangeSetArchive? = nil
}

struct TST_CommandSetRepeatingHeaderEnabledArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var repeatingHeaderEnabled: Bool {
    get {return _repeatingHeaderEnabled ?? false}
    set {_repeatingHeaderEnabled = newValue}
  }
  /// Returns true if `repeatingHeaderEnabled` has been explicitly set.
  var hasRepeatingHeaderEnabled: Bool {return self._repeatingHeaderEnabled != nil}
  /// Clears the value of `repeatingHeaderEnabled`. Subsequent reads from it will return its default value.
  mutating func clearRepeatingHeaderEnabled() {self._repeatingHeaderEnabled = nil}

  var direction: TST_TableDimensionArchive {
    get {return _direction ?? .dimensionNeither}
    set {_direction = newValue}
  }
  /// Returns true if `direction` has been explicitly set.
  var hasDirection: Bool {return self._direction != nil}
  /// Clears the value of `direction`. Subsequent reads from it will return its default value.
  mutating func clearDirection() {self._direction = nil}

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var prevRepeatingHeaderEnabled: Bool {
    get {return _prevRepeatingHeaderEnabled ?? false}
    set {_prevRepeatingHeaderEnabled = newValue}
  }
  /// Returns true if `prevRepeatingHeaderEnabled` has been explicitly set.
  var hasPrevRepeatingHeaderEnabled: Bool {return self._prevRepeatingHeaderEnabled != nil}
  /// Clears the value of `prevRepeatingHeaderEnabled`. Subsequent reads from it will return its default value.
  mutating func clearPrevRepeatingHeaderEnabled() {self._prevRepeatingHeaderEnabled = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _repeatingHeaderEnabled: Bool? = nil
  fileprivate var _direction: TST_TableDimensionArchive? = nil
  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _prevRepeatingHeaderEnabled: Bool? = nil
}

struct TST_CommandSetFiltersEnabledArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var newFiltersEnabled: Bool {
    get {return _newFiltersEnabled ?? false}
    set {_newFiltersEnabled = newValue}
  }
  /// Returns true if `newFiltersEnabled` has been explicitly set.
  var hasNewFiltersEnabled: Bool {return self._newFiltersEnabled != nil}
  /// Clears the value of `newFiltersEnabled`. Subsequent reads from it will return its default value.
  mutating func clearNewFiltersEnabled() {self._newFiltersEnabled = nil}

  var oldFiltersEnabled: Bool {
    get {return _oldFiltersEnabled ?? false}
    set {_oldFiltersEnabled = newValue}
  }
  /// Returns true if `oldFiltersEnabled` has been explicitly set.
  var hasOldFiltersEnabled: Bool {return self._oldFiltersEnabled != nil}
  /// Clears the value of `oldFiltersEnabled`. Subsequent reads from it will return its default value.
  mutating func clearOldFiltersEnabled() {self._oldFiltersEnabled = nil}

  var rollbackUidList: [TSP_UUID] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _newFiltersEnabled: Bool? = nil
  fileprivate var _oldFiltersEnabled: Bool? = nil
}

struct TST_CommandAddTableStylePresetArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var presetIndex: Int32 {
    get {return _presetIndex ?? 0}
    set {_presetIndex = newValue}
  }
  /// Returns true if `presetIndex` has been explicitly set.
  var hasPresetIndex: Bool {return self._presetIndex != nil}
  /// Clears the value of `presetIndex`. Subsequent reads from it will return its default value.
  mutating func clearPresetIndex() {self._presetIndex = nil}

  var tableStyles: TSP_Reference {
    get {return _tableStyles ?? TSP_Reference()}
    set {_tableStyles = newValue}
  }
  /// Returns true if `tableStyles` has been explicitly set.
  var hasTableStyles: Bool {return self._tableStyles != nil}
  /// Clears the value of `tableStyles`. Subsequent reads from it will return its default value.
  mutating func clearTableStyles() {self._tableStyles = nil}

  var sendNotification: Bool {
    get {return _sendNotification ?? false}
    set {_sendNotification = newValue}
  }
  /// Returns true if `sendNotification` has been explicitly set.
  var hasSendNotification: Bool {return self._sendNotification != nil}
  /// Clears the value of `sendNotification`. Subsequent reads from it will return its default value.
  mutating func clearSendNotification() {self._sendNotification = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _presetIndex: Int32? = nil
  fileprivate var _tableStyles: TSP_Reference? = nil
  fileprivate var _sendNotification: Bool? = nil
}

struct TST_CommandRemoveTableStylePresetArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var theme: TSP_Reference {
    get {return _storage._theme ?? TSP_Reference()}
    set {_uniqueStorage()._theme = newValue}
  }
  /// Returns true if `theme` has been explicitly set.
  var hasTheme: Bool {return _storage._theme != nil}
  /// Clears the value of `theme`. Subsequent reads from it will return its default value.
  mutating func clearTheme() {_uniqueStorage()._theme = nil}

  var removedTableStyles: TSP_Reference {
    get {return _storage._removedTableStyles ?? TSP_Reference()}
    set {_uniqueStorage()._removedTableStyles = newValue}
  }
  /// Returns true if `removedTableStyles` has been explicitly set.
  var hasRemovedTableStyles: Bool {return _storage._removedTableStyles != nil}
  /// Clears the value of `removedTableStyles`. Subsequent reads from it will return its default value.
  mutating func clearRemovedTableStyles() {_uniqueStorage()._removedTableStyles = nil}

  var presetID: Int32 {
    get {return _storage._presetID ?? 0}
    set {_uniqueStorage()._presetID = newValue}
  }
  /// Returns true if `presetID` has been explicitly set.
  var hasPresetID: Bool {return _storage._presetID != nil}
  /// Clears the value of `presetID`. Subsequent reads from it will return its default value.
  mutating func clearPresetID() {_uniqueStorage()._presetID = nil}

  var presetIndexInTheme: Int32 {
    get {return _storage._presetIndexInTheme ?? 0}
    set {_uniqueStorage()._presetIndexInTheme = newValue}
  }
  /// Returns true if `presetIndexInTheme` has been explicitly set.
  var hasPresetIndexInTheme: Bool {return _storage._presetIndexInTheme != nil}
  /// Clears the value of `presetIndexInTheme`. Subsequent reads from it will return its default value.
  mutating func clearPresetIndexInTheme() {_uniqueStorage()._presetIndexInTheme = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandReplaceTableStylePresetArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var theme: TSP_Reference {
    get {return _storage._theme ?? TSP_Reference()}
    set {_uniqueStorage()._theme = newValue}
  }
  /// Returns true if `theme` has been explicitly set.
  var hasTheme: Bool {return _storage._theme != nil}
  /// Clears the value of `theme`. Subsequent reads from it will return its default value.
  mutating func clearTheme() {_uniqueStorage()._theme = nil}

  var oldTableStyles: TSP_Reference {
    get {return _storage._oldTableStyles ?? TSP_Reference()}
    set {_uniqueStorage()._oldTableStyles = newValue}
  }
  /// Returns true if `oldTableStyles` has been explicitly set.
  var hasOldTableStyles: Bool {return _storage._oldTableStyles != nil}
  /// Clears the value of `oldTableStyles`. Subsequent reads from it will return its default value.
  mutating func clearOldTableStyles() {_uniqueStorage()._oldTableStyles = nil}

  var newTableStyles: TSP_Reference {
    get {return _storage._newTableStyles ?? TSP_Reference()}
    set {_uniqueStorage()._newTableStyles = newValue}
  }
  /// Returns true if `newTableStyles` has been explicitly set.
  var hasNewTableStyles: Bool {return _storage._newTableStyles != nil}
  /// Clears the value of `newTableStyles`. Subsequent reads from it will return its default value.
  mutating func clearNewTableStyles() {_uniqueStorage()._newTableStyles = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandApplyTableStylePresetArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _storage._super ?? TST_TableCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var preset: TSP_Reference {
    get {return _storage._preset ?? TSP_Reference()}
    set {_uniqueStorage()._preset = newValue}
  }
  /// Returns true if `preset` has been explicitly set.
  var hasPreset: Bool {return _storage._preset != nil}
  /// Clears the value of `preset`. Subsequent reads from it will return its default value.
  mutating func clearPreset() {_uniqueStorage()._preset = nil}

  var styles: TSP_Reference {
    get {return _storage._styles ?? TSP_Reference()}
    set {_uniqueStorage()._styles = newValue}
  }
  /// Returns true if `styles` has been explicitly set.
  var hasStyles: Bool {return _storage._styles != nil}
  /// Clears the value of `styles`. Subsequent reads from it will return its default value.
  mutating func clearStyles() {_uniqueStorage()._styles = nil}

  var undoPreset: TSP_Reference {
    get {return _storage._undoPreset ?? TSP_Reference()}
    set {_uniqueStorage()._undoPreset = newValue}
  }
  /// Returns true if `undoPreset` has been explicitly set.
  var hasUndoPreset: Bool {return _storage._undoPreset != nil}
  /// Clears the value of `undoPreset`. Subsequent reads from it will return its default value.
  mutating func clearUndoPreset() {_uniqueStorage()._undoPreset = nil}

  var undoStyles: TSP_Reference {
    get {return _storage._undoStyles ?? TSP_Reference()}
    set {_uniqueStorage()._undoStyles = newValue}
  }
  /// Returns true if `undoStyles` has been explicitly set.
  var hasUndoStyles: Bool {return _storage._undoStyles != nil}
  /// Clears the value of `undoStyles`. Subsequent reads from it will return its default value.
  mutating func clearUndoStyles() {_uniqueStorage()._undoStyles = nil}

  var cellDiffMap: TSP_Reference {
    get {return _storage._cellDiffMap ?? TSP_Reference()}
    set {_uniqueStorage()._cellDiffMap = newValue}
  }
  /// Returns true if `cellDiffMap` has been explicitly set.
  var hasCellDiffMap: Bool {return _storage._cellDiffMap != nil}
  /// Clears the value of `cellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearCellDiffMap() {_uniqueStorage()._cellDiffMap = nil}

  var undoCellDiffMap: TSP_Reference {
    get {return _storage._undoCellDiffMap ?? TSP_Reference()}
    set {_uniqueStorage()._undoCellDiffMap = newValue}
  }
  /// Returns true if `undoCellDiffMap` has been explicitly set.
  var hasUndoCellDiffMap: Bool {return _storage._undoCellDiffMap != nil}
  /// Clears the value of `undoCellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearUndoCellDiffMap() {_uniqueStorage()._undoCellDiffMap = nil}

  var applyPresetOption: Int32 {
    get {return _storage._applyPresetOption ?? 0}
    set {_uniqueStorage()._applyPresetOption = newValue}
  }
  /// Returns true if `applyPresetOption` has been explicitly set.
  var hasApplyPresetOption: Bool {return _storage._applyPresetOption != nil}
  /// Clears the value of `applyPresetOption`. Subsequent reads from it will return its default value.
  mutating func clearApplyPresetOption() {_uniqueStorage()._applyPresetOption = nil}

  var tableClearsAllFlag: Bool {
    get {return _storage._tableClearsAllFlag ?? false}
    set {_uniqueStorage()._tableClearsAllFlag = newValue}
  }
  /// Returns true if `tableClearsAllFlag` has been explicitly set.
  var hasTableClearsAllFlag: Bool {return _storage._tableClearsAllFlag != nil}
  /// Clears the value of `tableClearsAllFlag`. Subsequent reads from it will return its default value.
  mutating func clearTableClearsAllFlag() {_uniqueStorage()._tableClearsAllFlag = nil}

  var undoTableClearsAllFlag: Bool {
    get {return _storage._undoTableClearsAllFlag ?? false}
    set {_uniqueStorage()._undoTableClearsAllFlag = newValue}
  }
  /// Returns true if `undoTableClearsAllFlag` has been explicitly set.
  var hasUndoTableClearsAllFlag: Bool {return _storage._undoTableClearsAllFlag != nil}
  /// Clears the value of `undoTableClearsAllFlag`. Subsequent reads from it will return its default value.
  mutating func clearUndoTableClearsAllFlag() {_uniqueStorage()._undoTableClearsAllFlag = nil}

  var rowColStyles: [TST_ColumnRowMetadataArchive] {
    get {return _storage._rowColStyles}
    set {_uniqueStorage()._rowColStyles = newValue}
  }

  var undoRowColStyles: [TST_ColumnRowMetadataArchive] {
    get {return _storage._undoRowColStyles}
    set {_uniqueStorage()._undoRowColStyles = newValue}
  }

  var changePropMapWrapper: TSP_Reference {
    get {return _storage._changePropMapWrapper ?? TSP_Reference()}
    set {_uniqueStorage()._changePropMapWrapper = newValue}
  }
  /// Returns true if `changePropMapWrapper` has been explicitly set.
  var hasChangePropMapWrapper: Bool {return _storage._changePropMapWrapper != nil}
  /// Clears the value of `changePropMapWrapper`. Subsequent reads from it will return its default value.
  mutating func clearChangePropMapWrapper() {_uniqueStorage()._changePropMapWrapper = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandSetBaseArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_CommandMutateCellFormatArchive {
    get {return _storage._super ?? TST_CommandMutateCellFormatArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var base: UInt32 {
    get {return _storage._base ?? 0}
    set {_uniqueStorage()._base = newValue}
  }
  /// Returns true if `base` has been explicitly set.
  var hasBase: Bool {return _storage._base != nil}
  /// Clears the value of `base`. Subsequent reads from it will return its default value.
  mutating func clearBase() {_uniqueStorage()._base = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandSetBasePlacesArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_CommandMutateCellFormatArchive {
    get {return _storage._super ?? TST_CommandMutateCellFormatArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var basePlaces: UInt32 {
    get {return _storage._basePlaces ?? 0}
    set {_uniqueStorage()._basePlaces = newValue}
  }
  /// Returns true if `basePlaces` has been explicitly set.
  var hasBasePlaces: Bool {return _storage._basePlaces != nil}
  /// Clears the value of `basePlaces`. Subsequent reads from it will return its default value.
  mutating func clearBasePlaces() {_uniqueStorage()._basePlaces = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandSetBaseUseMinusSignArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_CommandMutateCellFormatArchive {
    get {return _storage._super ?? TST_CommandMutateCellFormatArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var baseUseMinusSign: Bool {
    get {return _storage._baseUseMinusSign ?? false}
    set {_uniqueStorage()._baseUseMinusSign = newValue}
  }
  /// Returns true if `baseUseMinusSign` has been explicitly set.
  var hasBaseUseMinusSign: Bool {return _storage._baseUseMinusSign != nil}
  /// Clears the value of `baseUseMinusSign`. Subsequent reads from it will return its default value.
  mutating func clearBaseUseMinusSign() {_uniqueStorage()._baseUseMinusSign = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandSetCurrencyCodeArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_CommandMutateCellFormatArchive {
    get {return _storage._super ?? TST_CommandMutateCellFormatArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var currencyCode: String {
    get {return _storage._currencyCode ?? String()}
    set {_uniqueStorage()._currencyCode = newValue}
  }
  /// Returns true if `currencyCode` has been explicitly set.
  var hasCurrencyCode: Bool {return _storage._currencyCode != nil}
  /// Clears the value of `currencyCode`. Subsequent reads from it will return its default value.
  mutating func clearCurrencyCode() {_uniqueStorage()._currencyCode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandSetFractionAccuracyArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_CommandMutateCellFormatArchive {
    get {return _storage._super ?? TST_CommandMutateCellFormatArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var fractionAccuracy: UInt32 {
    get {return _storage._fractionAccuracy ?? 0}
    set {_uniqueStorage()._fractionAccuracy = newValue}
  }
  /// Returns true if `fractionAccuracy` has been explicitly set.
  var hasFractionAccuracy: Bool {return _storage._fractionAccuracy != nil}
  /// Clears the value of `fractionAccuracy`. Subsequent reads from it will return its default value.
  mutating func clearFractionAccuracy() {_uniqueStorage()._fractionAccuracy = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandSetNegativeNumberStyleArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_CommandMutateCellFormatArchive {
    get {return _storage._super ?? TST_CommandMutateCellFormatArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var negativeNumberStyle: UInt32 {
    get {return _storage._negativeNumberStyle ?? 0}
    set {_uniqueStorage()._negativeNumberStyle = newValue}
  }
  /// Returns true if `negativeNumberStyle` has been explicitly set.
  var hasNegativeNumberStyle: Bool {return _storage._negativeNumberStyle != nil}
  /// Clears the value of `negativeNumberStyle`. Subsequent reads from it will return its default value.
  mutating func clearNegativeNumberStyle() {_uniqueStorage()._negativeNumberStyle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandSetNumberOfDecimalPlacesArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_CommandMutateCellFormatArchive {
    get {return _storage._super ?? TST_CommandMutateCellFormatArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var decimalPlaces: UInt32 {
    get {return _storage._decimalPlaces ?? 0}
    set {_uniqueStorage()._decimalPlaces = newValue}
  }
  /// Returns true if `decimalPlaces` has been explicitly set.
  var hasDecimalPlaces: Bool {return _storage._decimalPlaces != nil}
  /// Clears the value of `decimalPlaces`. Subsequent reads from it will return its default value.
  mutating func clearDecimalPlaces() {_uniqueStorage()._decimalPlaces = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandSetDateTimeFormatArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_CommandMutateCellFormatArchive {
    get {return _storage._super ?? TST_CommandMutateCellFormatArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var dateFormatString: String {
    get {return _storage._dateFormatString ?? String()}
    set {_uniqueStorage()._dateFormatString = newValue}
  }
  /// Returns true if `dateFormatString` has been explicitly set.
  var hasDateFormatString: Bool {return _storage._dateFormatString != nil}
  /// Clears the value of `dateFormatString`. Subsequent reads from it will return its default value.
  mutating func clearDateFormatString() {_uniqueStorage()._dateFormatString = nil}

  var timeFormatString: String {
    get {return _storage._timeFormatString ?? String()}
    set {_uniqueStorage()._timeFormatString = newValue}
  }
  /// Returns true if `timeFormatString` has been explicitly set.
  var hasTimeFormatString: Bool {return _storage._timeFormatString != nil}
  /// Clears the value of `timeFormatString`. Subsequent reads from it will return its default value.
  mutating func clearTimeFormatString() {_uniqueStorage()._timeFormatString = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandSetShowThousandsSeparatorArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_CommandMutateCellFormatArchive {
    get {return _storage._super ?? TST_CommandMutateCellFormatArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var showThousandsSeparator: Bool {
    get {return _storage._showThousandsSeparator ?? false}
    set {_uniqueStorage()._showThousandsSeparator = newValue}
  }
  /// Returns true if `showThousandsSeparator` has been explicitly set.
  var hasShowThousandsSeparator: Bool {return _storage._showThousandsSeparator != nil}
  /// Clears the value of `showThousandsSeparator`. Subsequent reads from it will return its default value.
  mutating func clearShowThousandsSeparator() {_uniqueStorage()._showThousandsSeparator = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandSetUseAccountingStyleArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_CommandMutateCellFormatArchive {
    get {return _storage._super ?? TST_CommandMutateCellFormatArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var useAccountingStyle: Bool {
    get {return _storage._useAccountingStyle ?? false}
    set {_uniqueStorage()._useAccountingStyle = newValue}
  }
  /// Returns true if `useAccountingStyle` has been explicitly set.
  var hasUseAccountingStyle: Bool {return _storage._useAccountingStyle != nil}
  /// Clears the value of `useAccountingStyle`. Subsequent reads from it will return its default value.
  mutating func clearUseAccountingStyle() {_uniqueStorage()._useAccountingStyle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandSetRangeControlMinMaxIncArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _storage._super ?? TST_TableCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var minimum: Double {
    get {return _storage._minimum ?? 0}
    set {_uniqueStorage()._minimum = newValue}
  }
  /// Returns true if `minimum` has been explicitly set.
  var hasMinimum: Bool {return _storage._minimum != nil}
  /// Clears the value of `minimum`. Subsequent reads from it will return its default value.
  mutating func clearMinimum() {_uniqueStorage()._minimum = nil}

  var maximum: Double {
    get {return _storage._maximum ?? 0}
    set {_uniqueStorage()._maximum = newValue}
  }
  /// Returns true if `maximum` has been explicitly set.
  var hasMaximum: Bool {return _storage._maximum != nil}
  /// Clears the value of `maximum`. Subsequent reads from it will return its default value.
  mutating func clearMaximum() {_uniqueStorage()._maximum = nil}

  var increment: Double {
    get {return _storage._increment ?? 0}
    set {_uniqueStorage()._increment = newValue}
  }
  /// Returns true if `increment` has been explicitly set.
  var hasIncrement: Bool {return _storage._increment != nil}
  /// Clears the value of `increment`. Subsequent reads from it will return its default value.
  mutating func clearIncrement() {_uniqueStorage()._increment = nil}

  var cellDiffMap: TSP_Reference {
    get {return _storage._cellDiffMap ?? TSP_Reference()}
    set {_uniqueStorage()._cellDiffMap = newValue}
  }
  /// Returns true if `cellDiffMap` has been explicitly set.
  var hasCellDiffMap: Bool {return _storage._cellDiffMap != nil}
  /// Clears the value of `cellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearCellDiffMap() {_uniqueStorage()._cellDiffMap = nil}

  var cellUidList: TST_CellUIDListArchive {
    get {return _storage._cellUidList ?? TST_CellUIDListArchive()}
    set {_uniqueStorage()._cellUidList = newValue}
  }
  /// Returns true if `cellUidList` has been explicitly set.
  var hasCellUidList: Bool {return _storage._cellUidList != nil}
  /// Clears the value of `cellUidList`. Subsequent reads from it will return its default value.
  mutating func clearCellUidList() {_uniqueStorage()._cellUidList = nil}

  var inverseCellDiffMap: TSP_Reference {
    get {return _storage._inverseCellDiffMap ?? TSP_Reference()}
    set {_uniqueStorage()._inverseCellDiffMap = newValue}
  }
  /// Returns true if `inverseCellDiffMap` has been explicitly set.
  var hasInverseCellDiffMap: Bool {return _storage._inverseCellDiffMap != nil}
  /// Clears the value of `inverseCellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearInverseCellDiffMap() {_uniqueStorage()._inverseCellDiffMap = nil}

  var isFirstCommit: Bool {
    get {return _storage._isFirstCommit ?? false}
    set {_uniqueStorage()._isFirstCommit = newValue}
  }
  /// Returns true if `isFirstCommit` has been explicitly set.
  var hasIsFirstCommit: Bool {return _storage._isFirstCommit != nil}
  /// Clears the value of `isFirstCommit`. Subsequent reads from it will return its default value.
  mutating func clearIsFirstCommit() {_uniqueStorage()._isFirstCommit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandMoveColumnsOrRowsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var destUid: TSP_UUID {
    get {return _destUid ?? TSP_UUID()}
    set {_destUid = newValue}
  }
  /// Returns true if `destUid` has been explicitly set.
  var hasDestUid: Bool {return self._destUid != nil}
  /// Clears the value of `destUid`. Subsequent reads from it will return its default value.
  mutating func clearDestUid() {self._destUid = nil}

  var before: Bool {
    get {return _before ?? false}
    set {_before = newValue}
  }
  /// Returns true if `before` has been explicitly set.
  var hasBefore: Bool {return self._before != nil}
  /// Clears the value of `before`. Subsequent reads from it will return its default value.
  mutating func clearBefore() {self._before = nil}

  var undoDestUid: TSP_UUID {
    get {return _undoDestUid ?? TSP_UUID()}
    set {_undoDestUid = newValue}
  }
  /// Returns true if `undoDestUid` has been explicitly set.
  var hasUndoDestUid: Bool {return self._undoDestUid != nil}
  /// Clears the value of `undoDestUid`. Subsequent reads from it will return its default value.
  mutating func clearUndoDestUid() {self._undoDestUid = nil}

  var undoBefore: Bool {
    get {return _undoBefore ?? false}
    set {_undoBefore = newValue}
  }
  /// Returns true if `undoBefore` has been explicitly set.
  var hasUndoBefore: Bool {return self._undoBefore != nil}
  /// Clears the value of `undoBefore`. Subsequent reads from it will return its default value.
  mutating func clearUndoBefore() {self._undoBefore = nil}

  var uids: [TSP_UUID] = []

  var direction: TST_TableDimensionArchive {
    get {return _direction ?? .dimensionNeither}
    set {_direction = newValue}
  }
  /// Returns true if `direction` has been explicitly set.
  var hasDirection: Bool {return self._direction != nil}
  /// Clears the value of `direction`. Subsequent reads from it will return its default value.
  mutating func clearDirection() {self._direction = nil}

  var formulaRewriteCommand: TSP_Reference {
    get {return _formulaRewriteCommand ?? TSP_Reference()}
    set {_formulaRewriteCommand = newValue}
  }
  /// Returns true if `formulaRewriteCommand` has been explicitly set.
  var hasFormulaRewriteCommand: Bool {return self._formulaRewriteCommand != nil}
  /// Clears the value of `formulaRewriteCommand`. Subsequent reads from it will return its default value.
  mutating func clearFormulaRewriteCommand() {self._formulaRewriteCommand = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _destUid: TSP_UUID? = nil
  fileprivate var _before: Bool? = nil
  fileprivate var _undoDestUid: TSP_UUID? = nil
  fileprivate var _undoBefore: Bool? = nil
  fileprivate var _direction: TST_TableDimensionArchive? = nil
  fileprivate var _formulaRewriteCommand: TSP_Reference? = nil
}

struct TST_CommandSortArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var fromRowUids: [TSP_UUID] = []

  var toRowUids: [TSP_UUID] = []

  var formulaRewriteCommand: TSP_Reference {
    get {return _formulaRewriteCommand ?? TSP_Reference()}
    set {_formulaRewriteCommand = newValue}
  }
  /// Returns true if `formulaRewriteCommand` has been explicitly set.
  var hasFormulaRewriteCommand: Bool {return self._formulaRewriteCommand != nil}
  /// Clears the value of `formulaRewriteCommand`. Subsequent reads from it will return its default value.
  mutating func clearFormulaRewriteCommand() {self._formulaRewriteCommand = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _formulaRewriteCommand: TSP_Reference? = nil
}

struct TST_FormulaRewriteSpecArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rewriteType: UInt32 {
    get {return _storage._rewriteType ?? 0}
    set {_uniqueStorage()._rewriteType = newValue}
  }
  /// Returns true if `rewriteType` has been explicitly set.
  var hasRewriteType: Bool {return _storage._rewriteType != nil}
  /// Clears the value of `rewriteType`. Subsequent reads from it will return its default value.
  mutating func clearRewriteType() {_uniqueStorage()._rewriteType = nil}

  var tableUid: TSP_UUID {
    get {return _storage._tableUid ?? TSP_UUID()}
    set {_uniqueStorage()._tableUid = newValue}
  }
  /// Returns true if `tableUid` has been explicitly set.
  var hasTableUid: Bool {return _storage._tableUid != nil}
  /// Clears the value of `tableUid`. Subsequent reads from it will return its default value.
  mutating func clearTableUid() {_uniqueStorage()._tableUid = nil}

  var condStyleOwnerUid: TSP_UUID {
    get {return _storage._condStyleOwnerUid ?? TSP_UUID()}
    set {_uniqueStorage()._condStyleOwnerUid = newValue}
  }
  /// Returns true if `condStyleOwnerUid` has been explicitly set.
  var hasCondStyleOwnerUid: Bool {return _storage._condStyleOwnerUid != nil}
  /// Clears the value of `condStyleOwnerUid`. Subsequent reads from it will return its default value.
  mutating func clearCondStyleOwnerUid() {_uniqueStorage()._condStyleOwnerUid = nil}

  var groupByUid: TSP_UUID {
    get {return _storage._groupByUid ?? TSP_UUID()}
    set {_uniqueStorage()._groupByUid = newValue}
  }
  /// Returns true if `groupByUid` has been explicitly set.
  var hasGroupByUid: Bool {return _storage._groupByUid != nil}
  /// Clears the value of `groupByUid`. Subsequent reads from it will return its default value.
  mutating func clearGroupByUid() {_uniqueStorage()._groupByUid = nil}

  var isInverse: Bool {
    get {return _storage._isInverse ?? false}
    set {_uniqueStorage()._isInverse = newValue}
  }
  /// Returns true if `isInverse` has been explicitly set.
  var hasIsInverse: Bool {return _storage._isInverse != nil}
  /// Clears the value of `isInverse`. Subsequent reads from it will return its default value.
  mutating func clearIsInverse() {_uniqueStorage()._isInverse = nil}

  var columnOrRowUuidsInfo: TSCE_ColumnOrRowUuidsInfoArchive {
    get {return _storage._columnOrRowUuidsInfo ?? TSCE_ColumnOrRowUuidsInfoArchive()}
    set {_uniqueStorage()._columnOrRowUuidsInfo = newValue}
  }
  /// Returns true if `columnOrRowUuidsInfo` has been explicitly set.
  var hasColumnOrRowUuidsInfo: Bool {return _storage._columnOrRowUuidsInfo != nil}
  /// Clears the value of `columnOrRowUuidsInfo`. Subsequent reads from it will return its default value.
  mutating func clearColumnOrRowUuidsInfo() {_uniqueStorage()._columnOrRowUuidsInfo = nil}

  var auxColumnOrRowUuidsInfo: TSCE_ColumnOrRowUuidsInfoArchive {
    get {return _storage._auxColumnOrRowUuidsInfo ?? TSCE_ColumnOrRowUuidsInfoArchive()}
    set {_uniqueStorage()._auxColumnOrRowUuidsInfo = newValue}
  }
  /// Returns true if `auxColumnOrRowUuidsInfo` has been explicitly set.
  var hasAuxColumnOrRowUuidsInfo: Bool {return _storage._auxColumnOrRowUuidsInfo != nil}
  /// Clears the value of `auxColumnOrRowUuidsInfo`. Subsequent reads from it will return its default value.
  mutating func clearAuxColumnOrRowUuidsInfo() {_uniqueStorage()._auxColumnOrRowUuidsInfo = nil}

  var regionMovedInfo: TSCE_RegionMovedInfoArchive {
    get {return _storage._regionMovedInfo ?? TSCE_RegionMovedInfoArchive()}
    set {_uniqueStorage()._regionMovedInfo = newValue}
  }
  /// Returns true if `regionMovedInfo` has been explicitly set.
  var hasRegionMovedInfo: Bool {return _storage._regionMovedInfo != nil}
  /// Clears the value of `regionMovedInfo`. Subsequent reads from it will return its default value.
  mutating func clearRegionMovedInfo() {_uniqueStorage()._regionMovedInfo = nil}

  var regionInfo: TSCE_RegionInfoArchive {
    get {return _storage._regionInfo ?? TSCE_RegionInfoArchive()}
    set {_uniqueStorage()._regionInfo = newValue}
  }
  /// Returns true if `regionInfo` has been explicitly set.
  var hasRegionInfo: Bool {return _storage._regionInfo != nil}
  /// Clears the value of `regionInfo`. Subsequent reads from it will return its default value.
  mutating func clearRegionInfo() {_uniqueStorage()._regionInfo = nil}

  var rewriteTableIDInfo: TSCE_RewriteTableUIDInfoArchive {
    get {return _storage._rewriteTableIDInfo ?? TSCE_RewriteTableUIDInfoArchive()}
    set {_uniqueStorage()._rewriteTableIDInfo = newValue}
  }
  /// Returns true if `rewriteTableIDInfo` has been explicitly set.
  var hasRewriteTableIDInfo: Bool {return _storage._rewriteTableIDInfo != nil}
  /// Clears the value of `rewriteTableIDInfo`. Subsequent reads from it will return its default value.
  mutating func clearRewriteTableIDInfo() {_uniqueStorage()._rewriteTableIDInfo = nil}

  var transposedTableInfo: TSCE_TableTransposeInfoArchive {
    get {return _storage._transposedTableInfo ?? TSCE_TableTransposeInfoArchive()}
    set {_uniqueStorage()._transposedTableInfo = newValue}
  }
  /// Returns true if `transposedTableInfo` has been explicitly set.
  var hasTransposedTableInfo: Bool {return _storage._transposedTableInfo != nil}
  /// Clears the value of `transposedTableInfo`. Subsequent reads from it will return its default value.
  mutating func clearTransposedTableInfo() {_uniqueStorage()._transposedTableInfo = nil}

  var mergeOriginMovedInfo: TSCE_MergeOriginMovedArchive {
    get {return _storage._mergeOriginMovedInfo ?? TSCE_MergeOriginMovedArchive()}
    set {_uniqueStorage()._mergeOriginMovedInfo = newValue}
  }
  /// Returns true if `mergeOriginMovedInfo` has been explicitly set.
  var hasMergeOriginMovedInfo: Bool {return _storage._mergeOriginMovedInfo != nil}
  /// Clears the value of `mergeOriginMovedInfo`. Subsequent reads from it will return its default value.
  mutating func clearMergeOriginMovedInfo() {_uniqueStorage()._mergeOriginMovedInfo = nil}

  var mergeSource: TSCE_MergeSourceArchive {
    get {return _storage._mergeSource ?? TSCE_MergeSourceArchive()}
    set {_uniqueStorage()._mergeSource = newValue}
  }
  /// Returns true if `mergeSource` has been explicitly set.
  var hasMergeSource: Bool {return _storage._mergeSource != nil}
  /// Clears the value of `mergeSource`. Subsequent reads from it will return its default value.
  mutating func clearMergeSource() {_uniqueStorage()._mergeSource = nil}

  var groupNodeInfo: TSCE_RewriteGroupNodeUIDInfoArchive {
    get {return _storage._groupNodeInfo ?? TSCE_RewriteGroupNodeUIDInfoArchive()}
    set {_uniqueStorage()._groupNodeInfo = newValue}
  }
  /// Returns true if `groupNodeInfo` has been explicitly set.
  var hasGroupNodeInfo: Bool {return _storage._groupNodeInfo != nil}
  /// Clears the value of `groupNodeInfo`. Subsequent reads from it will return its default value.
  mutating func clearGroupNodeInfo() {_uniqueStorage()._groupNodeInfo = nil}

  var groupbyChange: TSCE_GroupByChangeArchive {
    get {return _storage._groupbyChange ?? TSCE_GroupByChangeArchive()}
    set {_uniqueStorage()._groupbyChange = newValue}
  }
  /// Returns true if `groupbyChange` has been explicitly set.
  var hasGroupbyChange: Bool {return _storage._groupbyChange != nil}
  /// Clears the value of `groupbyChange`. Subsequent reads from it will return its default value.
  mutating func clearGroupbyChange() {_uniqueStorage()._groupbyChange = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandRewriteFormulasForTransposeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var rewriteSpec: TST_FormulaRewriteSpecArchive {
    get {return _rewriteSpec ?? TST_FormulaRewriteSpecArchive()}
    set {_rewriteSpec = newValue}
  }
  /// Returns true if `rewriteSpec` has been explicitly set.
  var hasRewriteSpec: Bool {return self._rewriteSpec != nil}
  /// Clears the value of `rewriteSpec`. Subsequent reads from it will return its default value.
  mutating func clearRewriteSpec() {self._rewriteSpec = nil}

  var formulasToRewrite: TSCE_FormulasForUndoArchive {
    get {return _formulasToRewrite ?? TSCE_FormulasForUndoArchive()}
    set {_formulasToRewrite = newValue}
  }
  /// Returns true if `formulasToRewrite` has been explicitly set.
  var hasFormulasToRewrite: Bool {return self._formulasToRewrite != nil}
  /// Clears the value of `formulasToRewrite`. Subsequent reads from it will return its default value.
  mutating func clearFormulasToRewrite() {self._formulasToRewrite = nil}

  var warningsetMap: TST_ImportWarningSetByCellRefArchive {
    get {return _warningsetMap ?? TST_ImportWarningSetByCellRefArchive()}
    set {_warningsetMap = newValue}
  }
  /// Returns true if `warningsetMap` has been explicitly set.
  var hasWarningsetMap: Bool {return self._warningsetMap != nil}
  /// Clears the value of `warningsetMap`. Subsequent reads from it will return its default value.
  mutating func clearWarningsetMap() {self._warningsetMap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _rewriteSpec: TST_FormulaRewriteSpecArchive? = nil
  fileprivate var _formulasToRewrite: TSCE_FormulasForUndoArchive? = nil
  fileprivate var _warningsetMap: TST_ImportWarningSetByCellRefArchive? = nil
}

struct TST_CommandRewriteTableFormulasForRewriteSpecArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var rewriteSpec: TST_FormulaRewriteSpecArchive {
    get {return _rewriteSpec ?? TST_FormulaRewriteSpecArchive()}
    set {_rewriteSpec = newValue}
  }
  /// Returns true if `rewriteSpec` has been explicitly set.
  var hasRewriteSpec: Bool {return self._rewriteSpec != nil}
  /// Clears the value of `rewriteSpec`. Subsequent reads from it will return its default value.
  mutating func clearRewriteSpec() {self._rewriteSpec = nil}

  var formulasToRewrite: TSCE_FormulasForUndoArchive {
    get {return _formulasToRewrite ?? TSCE_FormulasForUndoArchive()}
    set {_formulasToRewrite = newValue}
  }
  /// Returns true if `formulasToRewrite` has been explicitly set.
  var hasFormulasToRewrite: Bool {return self._formulasToRewrite != nil}
  /// Clears the value of `formulasToRewrite`. Subsequent reads from it will return its default value.
  mutating func clearFormulasToRewrite() {self._formulasToRewrite = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _rewriteSpec: TST_FormulaRewriteSpecArchive? = nil
  fileprivate var _formulasToRewrite: TSCE_FormulasForUndoArchive? = nil
}

struct TST_CommandRewriteMergeFormulasArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var rewriteSpec: TST_FormulaRewriteSpecArchive {
    get {return _rewriteSpec ?? TST_FormulaRewriteSpecArchive()}
    set {_rewriteSpec = newValue}
  }
  /// Returns true if `rewriteSpec` has been explicitly set.
  var hasRewriteSpec: Bool {return self._rewriteSpec != nil}
  /// Clears the value of `rewriteSpec`. Subsequent reads from it will return its default value.
  mutating func clearRewriteSpec() {self._rewriteSpec = nil}

  var formulasToRewrite: TSCE_FormulasForUndoArchive {
    get {return _formulasToRewrite ?? TSCE_FormulasForUndoArchive()}
    set {_formulasToRewrite = newValue}
  }
  /// Returns true if `formulasToRewrite` has been explicitly set.
  var hasFormulasToRewrite: Bool {return self._formulasToRewrite != nil}
  /// Clears the value of `formulasToRewrite`. Subsequent reads from it will return its default value.
  mutating func clearFormulasToRewrite() {self._formulasToRewrite = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _rewriteSpec: TST_FormulaRewriteSpecArchive? = nil
  fileprivate var _formulasToRewrite: TSCE_FormulasForUndoArchive? = nil
}

struct TST_CommandRewriteCategoryFormulasArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var rewriteSpec: TST_FormulaRewriteSpecArchive {
    get {return _rewriteSpec ?? TST_FormulaRewriteSpecArchive()}
    set {_rewriteSpec = newValue}
  }
  /// Returns true if `rewriteSpec` has been explicitly set.
  var hasRewriteSpec: Bool {return self._rewriteSpec != nil}
  /// Clears the value of `rewriteSpec`. Subsequent reads from it will return its default value.
  mutating func clearRewriteSpec() {self._rewriteSpec = nil}

  var formulasToRewrite: TSCE_FormulasForUndoArchive {
    get {return _formulasToRewrite ?? TSCE_FormulasForUndoArchive()}
    set {_formulasToRewrite = newValue}
  }
  /// Returns true if `formulasToRewrite` has been explicitly set.
  var hasFormulasToRewrite: Bool {return self._formulasToRewrite != nil}
  /// Clears the value of `formulasToRewrite`. Subsequent reads from it will return its default value.
  mutating func clearFormulasToRewrite() {self._formulasToRewrite = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _rewriteSpec: TST_FormulaRewriteSpecArchive? = nil
  fileprivate var _formulasToRewrite: TSCE_FormulasForUndoArchive? = nil
}

struct TST_CommandRewriteFilterFormulasForTableResizeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
}

struct TST_CommandRewriteFilterFormulasForRewriteSpecArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var filterSet: TSP_Reference {
    get {return _filterSet ?? TSP_Reference()}
    set {_filterSet = newValue}
  }
  /// Returns true if `filterSet` has been explicitly set.
  var hasFilterSet: Bool {return self._filterSet != nil}
  /// Clears the value of `filterSet`. Subsequent reads from it will return its default value.
  mutating func clearFilterSet() {self._filterSet = nil}

  var rewriteSpec: TST_FormulaRewriteSpecArchive {
    get {return _rewriteSpec ?? TST_FormulaRewriteSpecArchive()}
    set {_rewriteSpec = newValue}
  }
  /// Returns true if `rewriteSpec` has been explicitly set.
  var hasRewriteSpec: Bool {return self._rewriteSpec != nil}
  /// Clears the value of `rewriteSpec`. Subsequent reads from it will return its default value.
  mutating func clearRewriteSpec() {self._rewriteSpec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _filterSet: TSP_Reference? = nil
  fileprivate var _rewriteSpec: TST_FormulaRewriteSpecArchive? = nil
}

struct TST_CommandRewriteConditionalStylesForRewriteSpecArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var rewriteSpec: TST_FormulaRewriteSpecArchive {
    get {return _rewriteSpec ?? TST_FormulaRewriteSpecArchive()}
    set {_rewriteSpec = newValue}
  }
  /// Returns true if `rewriteSpec` has been explicitly set.
  var hasRewriteSpec: Bool {return self._rewriteSpec != nil}
  /// Clears the value of `rewriteSpec`. Subsequent reads from it will return its default value.
  mutating func clearRewriteSpec() {self._rewriteSpec = nil}

  var formulasToRewrite: TSCE_FormulasForUndoArchive {
    get {return _formulasToRewrite ?? TSCE_FormulasForUndoArchive()}
    set {_formulasToRewrite = newValue}
  }
  /// Returns true if `formulasToRewrite` has been explicitly set.
  var hasFormulasToRewrite: Bool {return self._formulasToRewrite != nil}
  /// Clears the value of `formulasToRewrite`. Subsequent reads from it will return its default value.
  mutating func clearFormulasToRewrite() {self._formulasToRewrite = nil}

  var conditionalStyleSets: TSCE_ExpandedCellRefObjectMapArchive {
    get {return _conditionalStyleSets ?? TSCE_ExpandedCellRefObjectMapArchive()}
    set {_conditionalStyleSets = newValue}
  }
  /// Returns true if `conditionalStyleSets` has been explicitly set.
  var hasConditionalStyleSets: Bool {return self._conditionalStyleSets != nil}
  /// Clears the value of `conditionalStyleSets`. Subsequent reads from it will return its default value.
  mutating func clearConditionalStyleSets() {self._conditionalStyleSets = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _rewriteSpec: TST_FormulaRewriteSpecArchive? = nil
  fileprivate var _formulasToRewrite: TSCE_FormulasForUndoArchive? = nil
  fileprivate var _conditionalStyleSets: TSCE_ExpandedCellRefObjectMapArchive? = nil
}

struct TST_CommandRewritePivotOwnerFormulasArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var rewriteSpec: TST_FormulaRewriteSpecArchive {
    get {return _rewriteSpec ?? TST_FormulaRewriteSpecArchive()}
    set {_rewriteSpec = newValue}
  }
  /// Returns true if `rewriteSpec` has been explicitly set.
  var hasRewriteSpec: Bool {return self._rewriteSpec != nil}
  /// Clears the value of `rewriteSpec`. Subsequent reads from it will return its default value.
  mutating func clearRewriteSpec() {self._rewriteSpec = nil}

  var formulasToRewrite: TSCE_FormulasForUndoArchive {
    get {return _formulasToRewrite ?? TSCE_FormulasForUndoArchive()}
    set {_formulasToRewrite = newValue}
  }
  /// Returns true if `formulasToRewrite` has been explicitly set.
  var hasFormulasToRewrite: Bool {return self._formulasToRewrite != nil}
  /// Clears the value of `formulasToRewrite`. Subsequent reads from it will return its default value.
  mutating func clearFormulasToRewrite() {self._formulasToRewrite = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _rewriteSpec: TST_FormulaRewriteSpecArchive? = nil
  fileprivate var _formulasToRewrite: TSCE_FormulasForUndoArchive? = nil
}

struct TST_CommandMergeArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _storage._super ?? TST_TableCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var cellUidList: TST_CellUIDListArchive {
    get {return _storage._cellUidList ?? TST_CellUIDListArchive()}
    set {_uniqueStorage()._cellUidList = newValue}
  }
  /// Returns true if `cellUidList` has been explicitly set.
  var hasCellUidList: Bool {return _storage._cellUidList != nil}
  /// Clears the value of `cellUidList`. Subsequent reads from it will return its default value.
  mutating func clearCellUidList() {_uniqueStorage()._cellUidList = nil}

  var undoCellMap: TSP_Reference {
    get {return _storage._undoCellMap ?? TSP_Reference()}
    set {_uniqueStorage()._undoCellMap = newValue}
  }
  /// Returns true if `undoCellMap` has been explicitly set.
  var hasUndoCellMap: Bool {return _storage._undoCellMap != nil}
  /// Clears the value of `undoCellMap`. Subsequent reads from it will return its default value.
  mutating func clearUndoCellMap() {_uniqueStorage()._undoCellMap = nil}

  var undoFormulaRewriteCommand: TSP_Reference {
    get {return _storage._undoFormulaRewriteCommand ?? TSP_Reference()}
    set {_uniqueStorage()._undoFormulaRewriteCommand = newValue}
  }
  /// Returns true if `undoFormulaRewriteCommand` has been explicitly set.
  var hasUndoFormulaRewriteCommand: Bool {return _storage._undoFormulaRewriteCommand != nil}
  /// Clears the value of `undoFormulaRewriteCommand`. Subsequent reads from it will return its default value.
  mutating func clearUndoFormulaRewriteCommand() {_uniqueStorage()._undoFormulaRewriteCommand = nil}

  var mergeOwnerRollback: UInt32 {
    get {return _storage._mergeOwnerRollback ?? 0}
    set {_uniqueStorage()._mergeOwnerRollback = newValue}
  }
  /// Returns true if `mergeOwnerRollback` has been explicitly set.
  var hasMergeOwnerRollback: Bool {return _storage._mergeOwnerRollback != nil}
  /// Clears the value of `mergeOwnerRollback`. Subsequent reads from it will return its default value.
  mutating func clearMergeOwnerRollback() {_uniqueStorage()._mergeOwnerRollback = nil}

  var commitCellMap: TSP_Reference {
    get {return _storage._commitCellMap ?? TSP_Reference()}
    set {_uniqueStorage()._commitCellMap = newValue}
  }
  /// Returns true if `commitCellMap` has been explicitly set.
  var hasCommitCellMap: Bool {return _storage._commitCellMap != nil}
  /// Clears the value of `commitCellMap`. Subsequent reads from it will return its default value.
  mutating func clearCommitCellMap() {_uniqueStorage()._commitCellMap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandInverseMergeArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_CommandApplyCellMapArchive {
    get {return _storage._super ?? TST_CommandApplyCellMapArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var mergeSourceCellUid: TSP_UUIDCoordArchive {
    get {return _storage._mergeSourceCellUid ?? TSP_UUIDCoordArchive()}
    set {_uniqueStorage()._mergeSourceCellUid = newValue}
  }
  /// Returns true if `mergeSourceCellUid` has been explicitly set.
  var hasMergeSourceCellUid: Bool {return _storage._mergeSourceCellUid != nil}
  /// Clears the value of `mergeSourceCellUid`. Subsequent reads from it will return its default value.
  mutating func clearMergeSourceCellUid() {_uniqueStorage()._mergeSourceCellUid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandUnmergeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unmergeUidRanges: [TSP_UUIDRectArchive] = []

  var undoCellMap: TSP_Reference {
    get {return _undoCellMap ?? TSP_Reference()}
    set {_undoCellMap = newValue}
  }
  /// Returns true if `undoCellMap` has been explicitly set.
  var hasUndoCellMap: Bool {return self._undoCellMap != nil}
  /// Clears the value of `undoCellMap`. Subsequent reads from it will return its default value.
  mutating func clearUndoCellMap() {self._undoCellMap = nil}

  var undoFormulaRewriteCommand: TSP_Reference {
    get {return _undoFormulaRewriteCommand ?? TSP_Reference()}
    set {_undoFormulaRewriteCommand = newValue}
  }
  /// Returns true if `undoFormulaRewriteCommand` has been explicitly set.
  var hasUndoFormulaRewriteCommand: Bool {return self._undoFormulaRewriteCommand != nil}
  /// Clears the value of `undoFormulaRewriteCommand`. Subsequent reads from it will return its default value.
  mutating func clearUndoFormulaRewriteCommand() {self._undoFormulaRewriteCommand = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _undoCellMap: TSP_Reference? = nil
  fileprivate var _undoFormulaRewriteCommand: TSP_Reference? = nil
}

struct TST_CommandChooseTableIdRemapperArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var tableIDMapper: TST_MultiTableRemapperArchive {
    get {return _storage._tableIDMapper ?? TST_MultiTableRemapperArchive()}
    set {_uniqueStorage()._tableIDMapper = newValue}
  }
  /// Returns true if `tableIDMapper` has been explicitly set.
  var hasTableIDMapper: Bool {return _storage._tableIDMapper != nil}
  /// Clears the value of `tableIDMapper`. Subsequent reads from it will return its default value.
  mutating func clearTableIDMapper() {_uniqueStorage()._tableIDMapper = nil}

  var formulaRewriteCommandForUndo: TSP_Reference {
    get {return _storage._formulaRewriteCommandForUndo ?? TSP_Reference()}
    set {_uniqueStorage()._formulaRewriteCommandForUndo = newValue}
  }
  /// Returns true if `formulaRewriteCommandForUndo` has been explicitly set.
  var hasFormulaRewriteCommandForUndo: Bool {return _storage._formulaRewriteCommandForUndo != nil}
  /// Clears the value of `formulaRewriteCommandForUndo`. Subsequent reads from it will return its default value.
  mutating func clearFormulaRewriteCommandForUndo() {_uniqueStorage()._formulaRewriteCommandForUndo = nil}

  var applyAndClear: Bool {
    get {return _storage._applyAndClear ?? false}
    set {_uniqueStorage()._applyAndClear = newValue}
  }
  /// Returns true if `applyAndClear` has been explicitly set.
  var hasApplyAndClear: Bool {return _storage._applyAndClear != nil}
  /// Clears the value of `applyAndClear`. Subsequent reads from it will return its default value.
  mutating func clearApplyAndClear() {_uniqueStorage()._applyAndClear = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandCategorySetGroupingColumnsArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _storage._super ?? TST_TableCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var newEnabledChanging: Int32 {
    get {return _storage._newEnabledChanging ?? 0}
    set {_uniqueStorage()._newEnabledChanging = newValue}
  }
  /// Returns true if `newEnabledChanging` has been explicitly set.
  var hasNewEnabledChanging: Bool {return _storage._newEnabledChanging != nil}
  /// Clears the value of `newEnabledChanging`. Subsequent reads from it will return its default value.
  mutating func clearNewEnabledChanging() {_uniqueStorage()._newEnabledChanging = nil}

  var oldEnabledChanging: Int32 {
    get {return _storage._oldEnabledChanging ?? 0}
    set {_uniqueStorage()._oldEnabledChanging = newValue}
  }
  /// Returns true if `oldEnabledChanging` has been explicitly set.
  var hasOldEnabledChanging: Bool {return _storage._oldEnabledChanging != nil}
  /// Clears the value of `oldEnabledChanging`. Subsequent reads from it will return its default value.
  mutating func clearOldEnabledChanging() {_uniqueStorage()._oldEnabledChanging = nil}

  var newGroupingColumns: TST_GroupColumnListArchive {
    get {return _storage._newGroupingColumns ?? TST_GroupColumnListArchive()}
    set {_uniqueStorage()._newGroupingColumns = newValue}
  }
  /// Returns true if `newGroupingColumns` has been explicitly set.
  var hasNewGroupingColumns: Bool {return _storage._newGroupingColumns != nil}
  /// Clears the value of `newGroupingColumns`. Subsequent reads from it will return its default value.
  mutating func clearNewGroupingColumns() {_uniqueStorage()._newGroupingColumns = nil}

  var oldGroupingColumns: TST_GroupColumnListArchive {
    get {return _storage._oldGroupingColumns ?? TST_GroupColumnListArchive()}
    set {_uniqueStorage()._oldGroupingColumns = newValue}
  }
  /// Returns true if `oldGroupingColumns` has been explicitly set.
  var hasOldGroupingColumns: Bool {return _storage._oldGroupingColumns != nil}
  /// Clears the value of `oldGroupingColumns`. Subsequent reads from it will return its default value.
  mutating func clearOldGroupingColumns() {_uniqueStorage()._oldGroupingColumns = nil}

  var restoreBaseOrder: Bool {
    get {return _storage._restoreBaseOrder ?? false}
    set {_uniqueStorage()._restoreBaseOrder = newValue}
  }
  /// Returns true if `restoreBaseOrder` has been explicitly set.
  var hasRestoreBaseOrder: Bool {return _storage._restoreBaseOrder != nil}
  /// Clears the value of `restoreBaseOrder`. Subsequent reads from it will return its default value.
  mutating func clearRestoreBaseOrder() {_uniqueStorage()._restoreBaseOrder = nil}

  var baseRowOrder: [TSP_UUID] {
    get {return _storage._baseRowOrder}
    set {_uniqueStorage()._baseRowOrder = newValue}
  }

  var undoRestoreBaseOrder: Bool {
    get {return _storage._undoRestoreBaseOrder ?? false}
    set {_uniqueStorage()._undoRestoreBaseOrder = newValue}
  }
  /// Returns true if `undoRestoreBaseOrder` has been explicitly set.
  var hasUndoRestoreBaseOrder: Bool {return _storage._undoRestoreBaseOrder != nil}
  /// Clears the value of `undoRestoreBaseOrder`. Subsequent reads from it will return its default value.
  mutating func clearUndoRestoreBaseOrder() {_uniqueStorage()._undoRestoreBaseOrder = nil}

  var undoBaseRowOrder: [TSP_UUID] {
    get {return _storage._undoBaseRowOrder}
    set {_uniqueStorage()._undoBaseRowOrder = newValue}
  }

  var restoreViewOrder: Bool {
    get {return _storage._restoreViewOrder ?? false}
    set {_uniqueStorage()._restoreViewOrder = newValue}
  }
  /// Returns true if `restoreViewOrder` has been explicitly set.
  var hasRestoreViewOrder: Bool {return _storage._restoreViewOrder != nil}
  /// Clears the value of `restoreViewOrder`. Subsequent reads from it will return its default value.
  mutating func clearRestoreViewOrder() {_uniqueStorage()._restoreViewOrder = nil}

  var viewRowOrder: [TSP_UUID] {
    get {return _storage._viewRowOrder}
    set {_uniqueStorage()._viewRowOrder = newValue}
  }

  var undoRestoreViewOrder: Bool {
    get {return _storage._undoRestoreViewOrder ?? false}
    set {_uniqueStorage()._undoRestoreViewOrder = newValue}
  }
  /// Returns true if `undoRestoreViewOrder` has been explicitly set.
  var hasUndoRestoreViewOrder: Bool {return _storage._undoRestoreViewOrder != nil}
  /// Clears the value of `undoRestoreViewOrder`. Subsequent reads from it will return its default value.
  mutating func clearUndoRestoreViewOrder() {_uniqueStorage()._undoRestoreViewOrder = nil}

  var undoViewRowOrder: [TSP_UUID] {
    get {return _storage._undoViewRowOrder}
    set {_uniqueStorage()._undoViewRowOrder = newValue}
  }

  var collapseState: [TSP_UUID] {
    get {return _storage._collapseState}
    set {_uniqueStorage()._collapseState = newValue}
  }

  var undoCollapseState: [TSP_UUID] {
    get {return _storage._undoCollapseState}
    set {_uniqueStorage()._undoCollapseState = newValue}
  }

  var summaryChangeState: TST_SummaryModelGroupByChangeStateArchive {
    get {return _storage._summaryChangeState ?? TST_SummaryModelGroupByChangeStateArchive()}
    set {_uniqueStorage()._summaryChangeState = newValue}
  }
  /// Returns true if `summaryChangeState` has been explicitly set.
  var hasSummaryChangeState: Bool {return _storage._summaryChangeState != nil}
  /// Clears the value of `summaryChangeState`. Subsequent reads from it will return its default value.
  mutating func clearSummaryChangeState() {_uniqueStorage()._summaryChangeState = nil}

  var undoSummaryChangeState: TST_SummaryModelGroupByChangeStateArchive {
    get {return _storage._undoSummaryChangeState ?? TST_SummaryModelGroupByChangeStateArchive()}
    set {_uniqueStorage()._undoSummaryChangeState = newValue}
  }
  /// Returns true if `undoSummaryChangeState` has been explicitly set.
  var hasUndoSummaryChangeState: Bool {return _storage._undoSummaryChangeState != nil}
  /// Clears the value of `undoSummaryChangeState`. Subsequent reads from it will return its default value.
  mutating func clearUndoSummaryChangeState() {_uniqueStorage()._undoSummaryChangeState = nil}

  var newColumnAggregates: TST_ColumnAggregateListArchive {
    get {return _storage._newColumnAggregates ?? TST_ColumnAggregateListArchive()}
    set {_uniqueStorage()._newColumnAggregates = newValue}
  }
  /// Returns true if `newColumnAggregates` has been explicitly set.
  var hasNewColumnAggregates: Bool {return _storage._newColumnAggregates != nil}
  /// Clears the value of `newColumnAggregates`. Subsequent reads from it will return its default value.
  mutating func clearNewColumnAggregates() {_uniqueStorage()._newColumnAggregates = nil}

  var oldColumnAggregates: TST_ColumnAggregateListArchive {
    get {return _storage._oldColumnAggregates ?? TST_ColumnAggregateListArchive()}
    set {_uniqueStorage()._oldColumnAggregates = newValue}
  }
  /// Returns true if `oldColumnAggregates` has been explicitly set.
  var hasOldColumnAggregates: Bool {return _storage._oldColumnAggregates != nil}
  /// Clears the value of `oldColumnAggregates`. Subsequent reads from it will return its default value.
  mutating func clearOldColumnAggregates() {_uniqueStorage()._oldColumnAggregates = nil}

  var undoSetEnabledRewriteCommand: TSP_Reference {
    get {return _storage._undoSetEnabledRewriteCommand ?? TSP_Reference()}
    set {_uniqueStorage()._undoSetEnabledRewriteCommand = newValue}
  }
  /// Returns true if `undoSetEnabledRewriteCommand` has been explicitly set.
  var hasUndoSetEnabledRewriteCommand: Bool {return _storage._undoSetEnabledRewriteCommand != nil}
  /// Clears the value of `undoSetEnabledRewriteCommand`. Subsequent reads from it will return its default value.
  mutating func clearUndoSetEnabledRewriteCommand() {_uniqueStorage()._undoSetEnabledRewriteCommand = nil}

  var undoSetColumnsRewriteCommand: TSP_Reference {
    get {return _storage._undoSetColumnsRewriteCommand ?? TSP_Reference()}
    set {_uniqueStorage()._undoSetColumnsRewriteCommand = newValue}
  }
  /// Returns true if `undoSetColumnsRewriteCommand` has been explicitly set.
  var hasUndoSetColumnsRewriteCommand: Bool {return _storage._undoSetColumnsRewriteCommand != nil}
  /// Clears the value of `undoSetColumnsRewriteCommand`. Subsequent reads from it will return its default value.
  mutating func clearUndoSetColumnsRewriteCommand() {_uniqueStorage()._undoSetColumnsRewriteCommand = nil}

  var forceRestoreAllStates: Bool {
    get {return _storage._forceRestoreAllStates ?? false}
    set {_uniqueStorage()._forceRestoreAllStates = newValue}
  }
  /// Returns true if `forceRestoreAllStates` has been explicitly set.
  var hasForceRestoreAllStates: Bool {return _storage._forceRestoreAllStates != nil}
  /// Clears the value of `forceRestoreAllStates`. Subsequent reads from it will return its default value.
  mutating func clearForceRestoreAllStates() {_uniqueStorage()._forceRestoreAllStates = nil}

  var cellDiffMap: TSP_Reference {
    get {return _storage._cellDiffMap ?? TSP_Reference()}
    set {_uniqueStorage()._cellDiffMap = newValue}
  }
  /// Returns true if `cellDiffMap` has been explicitly set.
  var hasCellDiffMap: Bool {return _storage._cellDiffMap != nil}
  /// Clears the value of `cellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearCellDiffMap() {_uniqueStorage()._cellDiffMap = nil}

  var undoCellDiffMap: TSP_Reference {
    get {return _storage._undoCellDiffMap ?? TSP_Reference()}
    set {_uniqueStorage()._undoCellDiffMap = newValue}
  }
  /// Returns true if `undoCellDiffMap` has been explicitly set.
  var hasUndoCellDiffMap: Bool {return _storage._undoCellDiffMap != nil}
  /// Clears the value of `undoCellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearUndoCellDiffMap() {_uniqueStorage()._undoCellDiffMap = nil}

  var undoSetGroupSortOrderCommand: TSP_Reference {
    get {return _storage._undoSetGroupSortOrderCommand ?? TSP_Reference()}
    set {_uniqueStorage()._undoSetGroupSortOrderCommand = newValue}
  }
  /// Returns true if `undoSetGroupSortOrderCommand` has been explicitly set.
  var hasUndoSetGroupSortOrderCommand: Bool {return _storage._undoSetGroupSortOrderCommand != nil}
  /// Clears the value of `undoSetGroupSortOrderCommand`. Subsequent reads from it will return its default value.
  mutating func clearUndoSetGroupSortOrderCommand() {_uniqueStorage()._undoSetGroupSortOrderCommand = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_FormulaEditingCommandGroupArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_ProgressiveCommandGroupArchive {
    get {return _storage._super ?? TSK_ProgressiveCommandGroupArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var undoSelectionValid: Bool {
    get {return _storage._undoSelectionValid ?? false}
    set {_uniqueStorage()._undoSelectionValid = newValue}
  }
  /// Returns true if `undoSelectionValid` has been explicitly set.
  var hasUndoSelectionValid: Bool {return _storage._undoSelectionValid != nil}
  /// Clears the value of `undoSelectionValid`. Subsequent reads from it will return its default value.
  mutating func clearUndoSelectionValid() {_uniqueStorage()._undoSelectionValid = nil}

  var undoSelectionStart: UInt32 {
    get {return _storage._undoSelectionStart ?? 0}
    set {_uniqueStorage()._undoSelectionStart = newValue}
  }
  /// Returns true if `undoSelectionStart` has been explicitly set.
  var hasUndoSelectionStart: Bool {return _storage._undoSelectionStart != nil}
  /// Clears the value of `undoSelectionStart`. Subsequent reads from it will return its default value.
  mutating func clearUndoSelectionStart() {_uniqueStorage()._undoSelectionStart = nil}

  var undoSelectionLength: UInt32 {
    get {return _storage._undoSelectionLength ?? 0}
    set {_uniqueStorage()._undoSelectionLength = newValue}
  }
  /// Returns true if `undoSelectionLength` has been explicitly set.
  var hasUndoSelectionLength: Bool {return _storage._undoSelectionLength != nil}
  /// Clears the value of `undoSelectionLength`. Subsequent reads from it will return its default value.
  mutating func clearUndoSelectionLength() {_uniqueStorage()._undoSelectionLength = nil}

  var undoActiveToken: UInt32 {
    get {return _storage._undoActiveToken ?? 0}
    set {_uniqueStorage()._undoActiveToken = newValue}
  }
  /// Returns true if `undoActiveToken` has been explicitly set.
  var hasUndoActiveToken: Bool {return _storage._undoActiveToken != nil}
  /// Clears the value of `undoActiveToken`. Subsequent reads from it will return its default value.
  mutating func clearUndoActiveToken() {_uniqueStorage()._undoActiveToken = nil}

  var redoSelectionValid: Bool {
    get {return _storage._redoSelectionValid ?? false}
    set {_uniqueStorage()._redoSelectionValid = newValue}
  }
  /// Returns true if `redoSelectionValid` has been explicitly set.
  var hasRedoSelectionValid: Bool {return _storage._redoSelectionValid != nil}
  /// Clears the value of `redoSelectionValid`. Subsequent reads from it will return its default value.
  mutating func clearRedoSelectionValid() {_uniqueStorage()._redoSelectionValid = nil}

  var redoSelectionStart: UInt32 {
    get {return _storage._redoSelectionStart ?? 0}
    set {_uniqueStorage()._redoSelectionStart = newValue}
  }
  /// Returns true if `redoSelectionStart` has been explicitly set.
  var hasRedoSelectionStart: Bool {return _storage._redoSelectionStart != nil}
  /// Clears the value of `redoSelectionStart`. Subsequent reads from it will return its default value.
  mutating func clearRedoSelectionStart() {_uniqueStorage()._redoSelectionStart = nil}

  var redoSelectionLength: UInt32 {
    get {return _storage._redoSelectionLength ?? 0}
    set {_uniqueStorage()._redoSelectionLength = newValue}
  }
  /// Returns true if `redoSelectionLength` has been explicitly set.
  var hasRedoSelectionLength: Bool {return _storage._redoSelectionLength != nil}
  /// Clears the value of `redoSelectionLength`. Subsequent reads from it will return its default value.
  mutating func clearRedoSelectionLength() {_uniqueStorage()._redoSelectionLength = nil}

  var redoActiveToken: UInt32 {
    get {return _storage._redoActiveToken ?? 0}
    set {_uniqueStorage()._redoActiveToken = newValue}
  }
  /// Returns true if `redoActiveToken` has been explicitly set.
  var hasRedoActiveToken: Bool {return _storage._redoActiveToken != nil}
  /// Clears the value of `redoActiveToken`. Subsequent reads from it will return its default value.
  mutating func clearRedoActiveToken() {_uniqueStorage()._redoActiveToken = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_FormulaEditingCommandSelectionBehaviorArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandSelectionBehaviorArchive {
    get {return _super ?? TSK_CommandSelectionBehaviorArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var undoActiveToken: UInt32 {
    get {return _undoActiveToken ?? 0}
    set {_undoActiveToken = newValue}
  }
  /// Returns true if `undoActiveToken` has been explicitly set.
  var hasUndoActiveToken: Bool {return self._undoActiveToken != nil}
  /// Clears the value of `undoActiveToken`. Subsequent reads from it will return its default value.
  mutating func clearUndoActiveToken() {self._undoActiveToken = nil}

  var redoActiveToken: UInt32 {
    get {return _redoActiveToken ?? 0}
    set {_redoActiveToken = newValue}
  }
  /// Returns true if `redoActiveToken` has been explicitly set.
  var hasRedoActiveToken: Bool {return self._redoActiveToken != nil}
  /// Clears the value of `redoActiveToken`. Subsequent reads from it will return its default value.
  mutating func clearRedoActiveToken() {self._redoActiveToken = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandSelectionBehaviorArchive? = nil
  fileprivate var _undoActiveToken: UInt32? = nil
  fileprivate var _redoActiveToken: UInt32? = nil
}

struct TST_TableCommandSelectionBehaviorArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandSelectionBehaviorArchive {
    get {return _super ?? TSK_CommandSelectionBehaviorArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var tableInfo: TSP_Reference {
    get {return _tableInfo ?? TSP_Reference()}
    set {_tableInfo = newValue}
  }
  /// Returns true if `tableInfo` has been explicitly set.
  var hasTableInfo: Bool {return self._tableInfo != nil}
  /// Clears the value of `tableInfo`. Subsequent reads from it will return its default value.
  mutating func clearTableInfo() {self._tableInfo = nil}

  var lastColumnUidHitByTap: TSP_UUID {
    get {return _lastColumnUidHitByTap ?? TSP_UUID()}
    set {_lastColumnUidHitByTap = newValue}
  }
  /// Returns true if `lastColumnUidHitByTap` has been explicitly set.
  var hasLastColumnUidHitByTap: Bool {return self._lastColumnUidHitByTap != nil}
  /// Clears the value of `lastColumnUidHitByTap`. Subsequent reads from it will return its default value.
  mutating func clearLastColumnUidHitByTap() {self._lastColumnUidHitByTap = nil}

  var invalidateComments: UInt32 {
    get {return _invalidateComments ?? 0}
    set {_invalidateComments = newValue}
  }
  /// Returns true if `invalidateComments` has been explicitly set.
  var hasInvalidateComments: Bool {return self._invalidateComments != nil}
  /// Clears the value of `invalidateComments`. Subsequent reads from it will return its default value.
  mutating func clearInvalidateComments() {self._invalidateComments = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandSelectionBehaviorArchive? = nil
  fileprivate var _tableInfo: TSP_Reference? = nil
  fileprivate var _lastColumnUidHitByTap: TSP_UUID? = nil
  fileprivate var _invalidateComments: UInt32? = nil
}

struct TST_CommandApplyCellCommentArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var cellUid: TSP_UUIDCoordArchive {
    get {return _cellUid ?? TSP_UUIDCoordArchive()}
    set {_cellUid = newValue}
  }
  /// Returns true if `cellUid` has been explicitly set.
  var hasCellUid: Bool {return self._cellUid != nil}
  /// Clears the value of `cellUid`. Subsequent reads from it will return its default value.
  mutating func clearCellUid() {self._cellUid = nil}

  var oldCommentStorage: TSP_Reference {
    get {return _oldCommentStorage ?? TSP_Reference()}
    set {_oldCommentStorage = newValue}
  }
  /// Returns true if `oldCommentStorage` has been explicitly set.
  var hasOldCommentStorage: Bool {return self._oldCommentStorage != nil}
  /// Clears the value of `oldCommentStorage`. Subsequent reads from it will return its default value.
  mutating func clearOldCommentStorage() {self._oldCommentStorage = nil}

  var newCommentStorage: TSP_Reference {
    get {return _newCommentStorage ?? TSP_Reference()}
    set {_newCommentStorage = newValue}
  }
  /// Returns true if `newCommentStorage` has been explicitly set.
  var hasNewCommentStorage: Bool {return self._newCommentStorage != nil}
  /// Clears the value of `newCommentStorage`. Subsequent reads from it will return its default value.
  mutating func clearNewCommentStorage() {self._newCommentStorage = nil}

  var forwardVariant: TSD_CommentCommandVariant {
    get {return _forwardVariant ?? .baseComment}
    set {_forwardVariant = newValue}
  }
  /// Returns true if `forwardVariant` has been explicitly set.
  var hasForwardVariant: Bool {return self._forwardVariant != nil}
  /// Clears the value of `forwardVariant`. Subsequent reads from it will return its default value.
  mutating func clearForwardVariant() {self._forwardVariant = nil}

  var inverseVariant: TSD_CommentCommandVariant {
    get {return _inverseVariant ?? .baseComment}
    set {_inverseVariant = newValue}
  }
  /// Returns true if `inverseVariant` has been explicitly set.
  var hasInverseVariant: Bool {return self._inverseVariant != nil}
  /// Clears the value of `inverseVariant`. Subsequent reads from it will return its default value.
  mutating func clearInverseVariant() {self._inverseVariant = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _cellUid: TSP_UUIDCoordArchive? = nil
  fileprivate var _oldCommentStorage: TSP_Reference? = nil
  fileprivate var _newCommentStorage: TSP_Reference? = nil
  fileprivate var _forwardVariant: TSD_CommentCommandVariant? = nil
  fileprivate var _inverseVariant: TSD_CommentCommandVariant? = nil
}

struct TST_CommandSetFormulaTokenizationArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var tokenization: Bool {
    get {return _tokenization ?? false}
    set {_tokenization = newValue}
  }
  /// Returns true if `tokenization` has been explicitly set.
  var hasTokenization: Bool {return self._tokenization != nil}
  /// Clears the value of `tokenization`. Subsequent reads from it will return its default value.
  mutating func clearTokenization() {self._tokenization = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _tokenization: Bool? = nil
}

struct TST_CommandSetFilterSetTypeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var oldFilterSetType: TST_FilterSetArchive.FilterSetType {
    get {return _oldFilterSetType ?? .filterSetArchiveTypeAll}
    set {_oldFilterSetType = newValue}
  }
  /// Returns true if `oldFilterSetType` has been explicitly set.
  var hasOldFilterSetType: Bool {return self._oldFilterSetType != nil}
  /// Clears the value of `oldFilterSetType`. Subsequent reads from it will return its default value.
  mutating func clearOldFilterSetType() {self._oldFilterSetType = nil}

  var newFilterSetType: TST_FilterSetArchive.FilterSetType {
    get {return _newFilterSetType ?? .filterSetArchiveTypeAll}
    set {_newFilterSetType = newValue}
  }
  /// Returns true if `newFilterSetType` has been explicitly set.
  var hasNewFilterSetType: Bool {return self._newFilterSetType != nil}
  /// Clears the value of `newFilterSetType`. Subsequent reads from it will return its default value.
  mutating func clearNewFilterSetType() {self._newFilterSetType = nil}

  var rollbackUidList: [TSP_UUID] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _oldFilterSetType: TST_FilterSetArchive.FilterSetType? = nil
  fileprivate var _newFilterSetType: TST_FilterSetArchive.FilterSetType? = nil
}

struct TST_CommandSetTextStyleArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var cellDiffMap: TSP_Reference {
    get {return _cellDiffMap ?? TSP_Reference()}
    set {_cellDiffMap = newValue}
  }
  /// Returns true if `cellDiffMap` has been explicitly set.
  var hasCellDiffMap: Bool {return self._cellDiffMap != nil}
  /// Clears the value of `cellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearCellDiffMap() {self._cellDiffMap = nil}

  var inverseCellDiffMap: TSP_Reference {
    get {return _inverseCellDiffMap ?? TSP_Reference()}
    set {_inverseCellDiffMap = newValue}
  }
  /// Returns true if `inverseCellDiffMap` has been explicitly set.
  var hasInverseCellDiffMap: Bool {return self._inverseCellDiffMap != nil}
  /// Clears the value of `inverseCellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearInverseCellDiffMap() {self._inverseCellDiffMap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _cellDiffMap: TSP_Reference? = nil
  fileprivate var _inverseCellDiffMap: TSP_Reference? = nil
}

struct TST_CommandSetTextStylePropertiesArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var cellDiffMap: TSP_Reference {
    get {return _cellDiffMap ?? TSP_Reference()}
    set {_cellDiffMap = newValue}
  }
  /// Returns true if `cellDiffMap` has been explicitly set.
  var hasCellDiffMap: Bool {return self._cellDiffMap != nil}
  /// Clears the value of `cellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearCellDiffMap() {self._cellDiffMap = nil}

  var cellWasRichText: [Bool] = []

  var inverseCellDiffMap: TSP_Reference {
    get {return _inverseCellDiffMap ?? TSP_Reference()}
    set {_inverseCellDiffMap = newValue}
  }
  /// Returns true if `inverseCellDiffMap` has been explicitly set.
  var hasInverseCellDiffMap: Bool {return self._inverseCellDiffMap != nil}
  /// Clears the value of `inverseCellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearInverseCellDiffMap() {self._inverseCellDiffMap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _cellDiffMap: TSP_Reference? = nil
  fileprivate var _inverseCellDiffMap: TSP_Reference? = nil
}

struct TST_CommandJustForNotifyingArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var changeDescriptorType: UInt32 {
    get {return _changeDescriptorType ?? 0}
    set {_changeDescriptorType = newValue}
  }
  /// Returns true if `changeDescriptorType` has been explicitly set.
  var hasChangeDescriptorType: Bool {return self._changeDescriptorType != nil}
  /// Clears the value of `changeDescriptorType`. Subsequent reads from it will return its default value.
  mutating func clearChangeDescriptorType() {self._changeDescriptorType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _changeDescriptorType: UInt32? = nil
}

struct TST_CommandSetStorageLanguageArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var storage: TSP_Reference {
    get {return _storage._storage ?? TSP_Reference()}
    set {_uniqueStorage()._storage = newValue}
  }
  /// Returns true if `storage` has been explicitly set.
  var hasStorage: Bool {return _storage._storage != nil}
  /// Clears the value of `storage`. Subsequent reads from it will return its default value.
  mutating func clearStorage() {_uniqueStorage()._storage = nil}

  var language: String {
    get {return _storage._language ?? String()}
    set {_uniqueStorage()._language = newValue}
  }
  /// Returns true if `language` has been explicitly set.
  var hasLanguage: Bool {return _storage._language != nil}
  /// Clears the value of `language`. Subsequent reads from it will return its default value.
  mutating func clearLanguage() {_uniqueStorage()._language = nil}

  var rangeLocation: UInt32 {
    get {return _storage._rangeLocation ?? 0}
    set {_uniqueStorage()._rangeLocation = newValue}
  }
  /// Returns true if `rangeLocation` has been explicitly set.
  var hasRangeLocation: Bool {return _storage._rangeLocation != nil}
  /// Clears the value of `rangeLocation`. Subsequent reads from it will return its default value.
  mutating func clearRangeLocation() {_uniqueStorage()._rangeLocation = nil}

  var rangeLength: UInt32 {
    get {return _storage._rangeLength ?? 0}
    set {_uniqueStorage()._rangeLength = newValue}
  }
  /// Returns true if `rangeLength` has been explicitly set.
  var hasRangeLength: Bool {return _storage._rangeLength != nil}
  /// Clears the value of `rangeLength`. Subsequent reads from it will return its default value.
  mutating func clearRangeLength() {_uniqueStorage()._rangeLength = nil}

  var undoTransaction: TSWP_UndoTransaction {
    get {return _storage._undoTransaction ?? TSWP_UndoTransaction()}
    set {_uniqueStorage()._undoTransaction = newValue}
  }
  /// Returns true if `undoTransaction` has been explicitly set.
  var hasUndoTransaction: Bool {return _storage._undoTransaction != nil}
  /// Clears the value of `undoTransaction`. Subsequent reads from it will return its default value.
  mutating func clearUndoTransaction() {_uniqueStorage()._undoTransaction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandSetSortOrderArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var oldSortOrder: TST_TableSortOrderArchive {
    get {return _oldSortOrder ?? TST_TableSortOrderArchive()}
    set {_oldSortOrder = newValue}
  }
  /// Returns true if `oldSortOrder` has been explicitly set.
  var hasOldSortOrder: Bool {return self._oldSortOrder != nil}
  /// Clears the value of `oldSortOrder`. Subsequent reads from it will return its default value.
  mutating func clearOldSortOrder() {self._oldSortOrder = nil}

  var newSortOrder: TST_TableSortOrderArchive {
    get {return _newSortOrder ?? TST_TableSortOrderArchive()}
    set {_newSortOrder = newValue}
  }
  /// Returns true if `newSortOrder` has been explicitly set.
  var hasNewSortOrder: Bool {return self._newSortOrder != nil}
  /// Clears the value of `newSortOrder`. Subsequent reads from it will return its default value.
  mutating func clearNewSortOrder() {self._newSortOrder = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _oldSortOrder: TST_TableSortOrderArchive? = nil
  fileprivate var _newSortOrder: TST_TableSortOrderArchive? = nil
}

struct TST_CommandSetGroupSortOrderArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var oldGroupSortOrder: TST_TableGroupSortOrderUIDArchive {
    get {return _oldGroupSortOrder ?? TST_TableGroupSortOrderUIDArchive()}
    set {_oldGroupSortOrder = newValue}
  }
  /// Returns true if `oldGroupSortOrder` has been explicitly set.
  var hasOldGroupSortOrder: Bool {return self._oldGroupSortOrder != nil}
  /// Clears the value of `oldGroupSortOrder`. Subsequent reads from it will return its default value.
  mutating func clearOldGroupSortOrder() {self._oldGroupSortOrder = nil}

  var newGroupSortOrder: TST_TableGroupSortOrderUIDArchive {
    get {return _newGroupSortOrder ?? TST_TableGroupSortOrderUIDArchive()}
    set {_newGroupSortOrder = newValue}
  }
  /// Returns true if `newGroupSortOrder` has been explicitly set.
  var hasNewGroupSortOrder: Bool {return self._newGroupSortOrder != nil}
  /// Clears the value of `newGroupSortOrder`. Subsequent reads from it will return its default value.
  mutating func clearNewGroupSortOrder() {self._newGroupSortOrder = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _oldGroupSortOrder: TST_TableGroupSortOrderUIDArchive? = nil
  fileprivate var _newGroupSortOrder: TST_TableGroupSortOrderUIDArchive? = nil
}

struct TST_CommandRewriteSortOrderForTableResizeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var oldSortOrder: TST_TableSortOrderArchive {
    get {return _oldSortOrder ?? TST_TableSortOrderArchive()}
    set {_oldSortOrder = newValue}
  }
  /// Returns true if `oldSortOrder` has been explicitly set.
  var hasOldSortOrder: Bool {return self._oldSortOrder != nil}
  /// Clears the value of `oldSortOrder`. Subsequent reads from it will return its default value.
  mutating func clearOldSortOrder() {self._oldSortOrder = nil}

  var newSortOrder: TST_TableSortOrderArchive {
    get {return _newSortOrder ?? TST_TableSortOrderArchive()}
    set {_newSortOrder = newValue}
  }
  /// Returns true if `newSortOrder` has been explicitly set.
  var hasNewSortOrder: Bool {return self._newSortOrder != nil}
  /// Clears the value of `newSortOrder`. Subsequent reads from it will return its default value.
  mutating func clearNewSortOrder() {self._newSortOrder = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _oldSortOrder: TST_TableSortOrderArchive? = nil
  fileprivate var _newSortOrder: TST_TableSortOrderArchive? = nil
}

struct TST_CommandRewriteSortOrderForRewriteSpecArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var rewriteSpec: TST_FormulaRewriteSpecArchive {
    get {return _rewriteSpec ?? TST_FormulaRewriteSpecArchive()}
    set {_rewriteSpec = newValue}
  }
  /// Returns true if `rewriteSpec` has been explicitly set.
  var hasRewriteSpec: Bool {return self._rewriteSpec != nil}
  /// Clears the value of `rewriteSpec`. Subsequent reads from it will return its default value.
  mutating func clearRewriteSpec() {self._rewriteSpec = nil}

  var oldSortOrder: TST_TableSortOrderArchive {
    get {return _oldSortOrder ?? TST_TableSortOrderArchive()}
    set {_oldSortOrder = newValue}
  }
  /// Returns true if `oldSortOrder` has been explicitly set.
  var hasOldSortOrder: Bool {return self._oldSortOrder != nil}
  /// Clears the value of `oldSortOrder`. Subsequent reads from it will return its default value.
  mutating func clearOldSortOrder() {self._oldSortOrder = nil}

  var newSortOrder: TST_TableSortOrderArchive {
    get {return _newSortOrder ?? TST_TableSortOrderArchive()}
    set {_newSortOrder = newValue}
  }
  /// Returns true if `newSortOrder` has been explicitly set.
  var hasNewSortOrder: Bool {return self._newSortOrder != nil}
  /// Clears the value of `newSortOrder`. Subsequent reads from it will return its default value.
  mutating func clearNewSortOrder() {self._newSortOrder = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _rewriteSpec: TST_FormulaRewriteSpecArchive? = nil
  fileprivate var _oldSortOrder: TST_TableSortOrderArchive? = nil
  fileprivate var _newSortOrder: TST_TableSortOrderArchive? = nil
}

struct TST_CommandSetFilterSetArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var newFilterSet: TSP_Reference {
    get {return _newFilterSet ?? TSP_Reference()}
    set {_newFilterSet = newValue}
  }
  /// Returns true if `newFilterSet` has been explicitly set.
  var hasNewFilterSet: Bool {return self._newFilterSet != nil}
  /// Clears the value of `newFilterSet`. Subsequent reads from it will return its default value.
  mutating func clearNewFilterSet() {self._newFilterSet = nil}

  var oldFilterSet: TSP_Reference {
    get {return _oldFilterSet ?? TSP_Reference()}
    set {_oldFilterSet = newValue}
  }
  /// Returns true if `oldFilterSet` has been explicitly set.
  var hasOldFilterSet: Bool {return self._oldFilterSet != nil}
  /// Clears the value of `oldFilterSet`. Subsequent reads from it will return its default value.
  mutating func clearOldFilterSet() {self._oldFilterSet = nil}

  var rollbackUidList: [TSP_UUID] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _newFilterSet: TSP_Reference? = nil
  fileprivate var _oldFilterSet: TSP_Reference? = nil
}

struct TST_ColumnRowRestoreDataArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uidList: [TSP_UUID] = []

  var metadatas: [TST_ColumnRowMetadataArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TST_CommandTransposeTableArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _storage._super ?? TST_TableCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var originalTableRange: TST_ExpandedCellRange {
    get {return _storage._originalTableRange ?? TST_ExpandedCellRange()}
    set {_uniqueStorage()._originalTableRange = newValue}
  }
  /// Returns true if `originalTableRange` has been explicitly set.
  var hasOriginalTableRange: Bool {return _storage._originalTableRange != nil}
  /// Clears the value of `originalTableRange`. Subsequent reads from it will return its default value.
  mutating func clearOriginalTableRange() {_uniqueStorage()._originalTableRange = nil}

  var originalCellMap: TSP_Reference {
    get {return _storage._originalCellMap ?? TSP_Reference()}
    set {_uniqueStorage()._originalCellMap = newValue}
  }
  /// Returns true if `originalCellMap` has been explicitly set.
  var hasOriginalCellMap: Bool {return _storage._originalCellMap != nil}
  /// Clears the value of `originalCellMap`. Subsequent reads from it will return its default value.
  mutating func clearOriginalCellMap() {_uniqueStorage()._originalCellMap = nil}

  var originalFooterRowCount: UInt32 {
    get {return _storage._originalFooterRowCount ?? 0}
    set {_uniqueStorage()._originalFooterRowCount = newValue}
  }
  /// Returns true if `originalFooterRowCount` has been explicitly set.
  var hasOriginalFooterRowCount: Bool {return _storage._originalFooterRowCount != nil}
  /// Clears the value of `originalFooterRowCount`. Subsequent reads from it will return its default value.
  mutating func clearOriginalFooterRowCount() {_uniqueStorage()._originalFooterRowCount = nil}

  var originalColumnWidths: [Float] {
    get {return _storage._originalColumnWidths}
    set {_uniqueStorage()._originalColumnWidths = newValue}
  }

  var originalRowHeights: [Float] {
    get {return _storage._originalRowHeights}
    set {_uniqueStorage()._originalRowHeights = newValue}
  }

  var ineligibleMergeList: [TST_CellRange] {
    get {return _storage._ineligibleMergeList}
    set {_uniqueStorage()._ineligibleMergeList = newValue}
  }

  var transposedCellMap: TSP_Reference {
    get {return _storage._transposedCellMap ?? TSP_Reference()}
    set {_uniqueStorage()._transposedCellMap = newValue}
  }
  /// Returns true if `transposedCellMap` has been explicitly set.
  var hasTransposedCellMap: Bool {return _storage._transposedCellMap != nil}
  /// Clears the value of `transposedCellMap`. Subsequent reads from it will return its default value.
  mutating func clearTransposedCellMap() {_uniqueStorage()._transposedCellMap = nil}

  var undoFormulaRewriteCommand: TSP_Reference {
    get {return _storage._undoFormulaRewriteCommand ?? TSP_Reference()}
    set {_uniqueStorage()._undoFormulaRewriteCommand = newValue}
  }
  /// Returns true if `undoFormulaRewriteCommand` has been explicitly set.
  var hasUndoFormulaRewriteCommand: Bool {return _storage._undoFormulaRewriteCommand != nil}
  /// Clears the value of `undoFormulaRewriteCommand`. Subsequent reads from it will return its default value.
  mutating func clearUndoFormulaRewriteCommand() {_uniqueStorage()._undoFormulaRewriteCommand = nil}

  var richTextSubcommands: TSP_Reference {
    get {return _storage._richTextSubcommands ?? TSP_Reference()}
    set {_uniqueStorage()._richTextSubcommands = newValue}
  }
  /// Returns true if `richTextSubcommands` has been explicitly set.
  var hasRichTextSubcommands: Bool {return _storage._richTextSubcommands != nil}
  /// Clears the value of `richTextSubcommands`. Subsequent reads from it will return its default value.
  mutating func clearRichTextSubcommands() {_uniqueStorage()._richTextSubcommands = nil}

  var columnRestoreData: TST_ColumnRowRestoreDataArchive {
    get {return _storage._columnRestoreData ?? TST_ColumnRowRestoreDataArchive()}
    set {_uniqueStorage()._columnRestoreData = newValue}
  }
  /// Returns true if `columnRestoreData` has been explicitly set.
  var hasColumnRestoreData: Bool {return _storage._columnRestoreData != nil}
  /// Clears the value of `columnRestoreData`. Subsequent reads from it will return its default value.
  mutating func clearColumnRestoreData() {_uniqueStorage()._columnRestoreData = nil}

  var rowRestoreData: TST_ColumnRowRestoreDataArchive {
    get {return _storage._rowRestoreData ?? TST_ColumnRowRestoreDataArchive()}
    set {_uniqueStorage()._rowRestoreData = newValue}
  }
  /// Returns true if `rowRestoreData` has been explicitly set.
  var hasRowRestoreData: Bool {return _storage._rowRestoreData != nil}
  /// Clears the value of `rowRestoreData`. Subsequent reads from it will return its default value.
  mutating func clearRowRestoreData() {_uniqueStorage()._rowRestoreData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandSetStructuredTextImportRecordArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var newImportRecord: TST_StructuredTextImportRecord {
    get {return _newImportRecord ?? TST_StructuredTextImportRecord()}
    set {_newImportRecord = newValue}
  }
  /// Returns true if `newImportRecord` has been explicitly set.
  var hasNewImportRecord: Bool {return self._newImportRecord != nil}
  /// Clears the value of `newImportRecord`. Subsequent reads from it will return its default value.
  mutating func clearNewImportRecord() {self._newImportRecord = nil}

  var oldImportRecord: TST_StructuredTextImportRecord {
    get {return _oldImportRecord ?? TST_StructuredTextImportRecord()}
    set {_oldImportRecord = newValue}
  }
  /// Returns true if `oldImportRecord` has been explicitly set.
  var hasOldImportRecord: Bool {return self._oldImportRecord != nil}
  /// Clears the value of `oldImportRecord`. Subsequent reads from it will return its default value.
  mutating func clearOldImportRecord() {self._oldImportRecord = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _newImportRecord: TST_StructuredTextImportRecord? = nil
  fileprivate var _oldImportRecord: TST_StructuredTextImportRecord? = nil
}

struct TST_CommandCategoryCollapseExpandGroupArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var isCollapsing: Bool {
    get {return _isCollapsing ?? false}
    set {_isCollapsing = newValue}
  }
  /// Returns true if `isCollapsing` has been explicitly set.
  var hasIsCollapsing: Bool {return self._isCollapsing != nil}
  /// Clears the value of `isCollapsing`. Subsequent reads from it will return its default value.
  mutating func clearIsCollapsing() {self._isCollapsing = nil}

  var groupingColumns: TST_GroupColumnListArchive {
    get {return _groupingColumns ?? TST_GroupColumnListArchive()}
    set {_groupingColumns = newValue}
  }
  /// Returns true if `groupingColumns` has been explicitly set.
  var hasGroupingColumns: Bool {return self._groupingColumns != nil}
  /// Clears the value of `groupingColumns`. Subsequent reads from it will return its default value.
  mutating func clearGroupingColumns() {self._groupingColumns = nil}

  var collapseState: TST_ExpandCollapseStateArchive {
    get {return _collapseState ?? TST_ExpandCollapseStateArchive()}
    set {_collapseState = newValue}
  }
  /// Returns true if `collapseState` has been explicitly set.
  var hasCollapseState: Bool {return self._collapseState != nil}
  /// Clears the value of `collapseState`. Subsequent reads from it will return its default value.
  mutating func clearCollapseState() {self._collapseState = nil}

  var undoCollapseState: TST_ExpandCollapseStateArchive {
    get {return _undoCollapseState ?? TST_ExpandCollapseStateArchive()}
    set {_undoCollapseState = newValue}
  }
  /// Returns true if `undoCollapseState` has been explicitly set.
  var hasUndoCollapseState: Bool {return self._undoCollapseState != nil}
  /// Clears the value of `undoCollapseState`. Subsequent reads from it will return its default value.
  mutating func clearUndoCollapseState() {self._undoCollapseState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _isCollapsing: Bool? = nil
  fileprivate var _groupingColumns: TST_GroupColumnListArchive? = nil
  fileprivate var _collapseState: TST_ExpandCollapseStateArchive? = nil
  fileprivate var _undoCollapseState: TST_ExpandCollapseStateArchive? = nil
}

struct TST_CommandCategoryChangeSummaryAggregateType: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var aggregateType: UInt32 {
    get {return _aggregateType ?? 0}
    set {_aggregateType = newValue}
  }
  /// Returns true if `aggregateType` has been explicitly set.
  var hasAggregateType: Bool {return self._aggregateType != nil}
  /// Clears the value of `aggregateType`. Subsequent reads from it will return its default value.
  mutating func clearAggregateType() {self._aggregateType = nil}

  var undoAggregateType: UInt32 {
    get {return _undoAggregateType ?? 0}
    set {_undoAggregateType = newValue}
  }
  /// Returns true if `undoAggregateType` has been explicitly set.
  var hasUndoAggregateType: Bool {return self._undoAggregateType != nil}
  /// Clears the value of `undoAggregateType`. Subsequent reads from it will return its default value.
  mutating func clearUndoAggregateType() {self._undoAggregateType = nil}

  var columnUid: TSP_UUID {
    get {return _columnUid ?? TSP_UUID()}
    set {_columnUid = newValue}
  }
  /// Returns true if `columnUid` has been explicitly set.
  var hasColumnUid: Bool {return self._columnUid != nil}
  /// Clears the value of `columnUid`. Subsequent reads from it will return its default value.
  mutating func clearColumnUid() {self._columnUid = nil}

  var groupLevel: Int32 {
    get {return _groupLevel ?? 0}
    set {_groupLevel = newValue}
  }
  /// Returns true if `groupLevel` has been explicitly set.
  var hasGroupLevel: Bool {return self._groupLevel != nil}
  /// Clears the value of `groupLevel`. Subsequent reads from it will return its default value.
  mutating func clearGroupLevel() {self._groupLevel = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _aggregateType: UInt32? = nil
  fileprivate var _undoAggregateType: UInt32? = nil
  fileprivate var _columnUid: TSP_UUID? = nil
  fileprivate var _groupLevel: Int32? = nil
}

struct TST_CommandCategorySetLabelRowVisibility: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var groupLevel: UInt32 {
    get {return _groupLevel ?? 0}
    set {_groupLevel = newValue}
  }
  /// Returns true if `groupLevel` has been explicitly set.
  var hasGroupLevel: Bool {return self._groupLevel != nil}
  /// Clears the value of `groupLevel`. Subsequent reads from it will return its default value.
  mutating func clearGroupLevel() {self._groupLevel = nil}

  var labelRowVisibility: UInt32 {
    get {return _labelRowVisibility ?? 0}
    set {_labelRowVisibility = newValue}
  }
  /// Returns true if `labelRowVisibility` has been explicitly set.
  var hasLabelRowVisibility: Bool {return self._labelRowVisibility != nil}
  /// Clears the value of `labelRowVisibility`. Subsequent reads from it will return its default value.
  mutating func clearLabelRowVisibility() {self._labelRowVisibility = nil}

  var undoLabelRowVisibility: UInt32 {
    get {return _undoLabelRowVisibility ?? 0}
    set {_undoLabelRowVisibility = newValue}
  }
  /// Returns true if `undoLabelRowVisibility` has been explicitly set.
  var hasUndoLabelRowVisibility: Bool {return self._undoLabelRowVisibility != nil}
  /// Clears the value of `undoLabelRowVisibility`. Subsequent reads from it will return its default value.
  mutating func clearUndoLabelRowVisibility() {self._undoLabelRowVisibility = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _groupLevel: UInt32? = nil
  fileprivate var _labelRowVisibility: UInt32? = nil
  fileprivate var _undoLabelRowVisibility: UInt32? = nil
}

struct TST_CommandCategoryWillChangeGroupValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var groupNodeUid: TSP_UUID {
    get {return _groupNodeUid ?? TSP_UUID()}
    set {_groupNodeUid = newValue}
  }
  /// Returns true if `groupNodeUid` has been explicitly set.
  var hasGroupNodeUid: Bool {return self._groupNodeUid != nil}
  /// Clears the value of `groupNodeUid`. Subsequent reads from it will return its default value.
  mutating func clearGroupNodeUid() {self._groupNodeUid = nil}

  var undoGroupNodeUid: TSP_UUID {
    get {return _undoGroupNodeUid ?? TSP_UUID()}
    set {_undoGroupNodeUid = newValue}
  }
  /// Returns true if `undoGroupNodeUid` has been explicitly set.
  var hasUndoGroupNodeUid: Bool {return self._undoGroupNodeUid != nil}
  /// Clears the value of `undoGroupNodeUid`. Subsequent reads from it will return its default value.
  mutating func clearUndoGroupNodeUid() {self._undoGroupNodeUid = nil}

  var groupValue: TSCE_CellValueArchive {
    get {return _groupValue ?? TSCE_CellValueArchive()}
    set {_groupValue = newValue}
  }
  /// Returns true if `groupValue` has been explicitly set.
  var hasGroupValue: Bool {return self._groupValue != nil}
  /// Clears the value of `groupValue`. Subsequent reads from it will return its default value.
  mutating func clearGroupValue() {self._groupValue = nil}

  var undoGroupValue: TSCE_CellValueArchive {
    get {return _undoGroupValue ?? TSCE_CellValueArchive()}
    set {_undoGroupValue = newValue}
  }
  /// Returns true if `undoGroupValue` has been explicitly set.
  var hasUndoGroupValue: Bool {return self._undoGroupValue != nil}
  /// Clears the value of `undoGroupValue`. Subsequent reads from it will return its default value.
  mutating func clearUndoGroupValue() {self._undoGroupValue = nil}

  var rewriteCommandForUndo: TSP_Reference {
    get {return _rewriteCommandForUndo ?? TSP_Reference()}
    set {_rewriteCommandForUndo = newValue}
  }
  /// Returns true if `rewriteCommandForUndo` has been explicitly set.
  var hasRewriteCommandForUndo: Bool {return self._rewriteCommandForUndo != nil}
  /// Clears the value of `rewriteCommandForUndo`. Subsequent reads from it will return its default value.
  mutating func clearRewriteCommandForUndo() {self._rewriteCommandForUndo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _groupNodeUid: TSP_UUID? = nil
  fileprivate var _undoGroupNodeUid: TSP_UUID? = nil
  fileprivate var _groupValue: TSCE_CellValueArchive? = nil
  fileprivate var _undoGroupValue: TSCE_CellValueArchive? = nil
  fileprivate var _rewriteCommandForUndo: TSP_Reference? = nil
}

struct TST_IdempotentSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var archivedSelection: TSP_Reference {
    get {return _archivedSelection ?? TSP_Reference()}
    set {_archivedSelection = newValue}
  }
  /// Returns true if `archivedSelection` has been explicitly set.
  var hasArchivedSelection: Bool {return self._archivedSelection != nil}
  /// Clears the value of `archivedSelection`. Subsequent reads from it will return its default value.
  mutating func clearArchivedSelection() {self._archivedSelection = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _archivedSelection: TSP_Reference? = nil
}

struct TST_WPSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableSubSelectionTransformerBaseArchive {
    get {return _super ?? TST_TableSubSelectionTransformerBaseArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var archivedSelection: TSP_Reference {
    get {return _archivedSelection ?? TSP_Reference()}
    set {_archivedSelection = newValue}
  }
  /// Returns true if `archivedSelection` has been explicitly set.
  var hasArchivedSelection: Bool {return self._archivedSelection != nil}
  /// Clears the value of `archivedSelection`. Subsequent reads from it will return its default value.
  mutating func clearArchivedSelection() {self._archivedSelection = nil}

  var originCellUid: TSP_UUIDCoordArchive {
    get {return _originCellUid ?? TSP_UUIDCoordArchive()}
    set {_originCellUid = newValue}
  }
  /// Returns true if `originCellUid` has been explicitly set.
  var hasOriginCellUid: Bool {return self._originCellUid != nil}
  /// Clears the value of `originCellUid`. Subsequent reads from it will return its default value.
  mutating func clearOriginCellUid() {self._originCellUid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableSubSelectionTransformerBaseArchive? = nil
  fileprivate var _archivedSelection: TSP_Reference? = nil
  fileprivate var _originCellUid: TSP_UUIDCoordArchive? = nil
}

struct TST_TableSubSelectionTransformerBaseArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tableInfoIDPath: TSP_UUIDPath {
    get {return _tableInfoIDPath ?? TSP_UUIDPath()}
    set {_tableInfoIDPath = newValue}
  }
  /// Returns true if `tableInfoIDPath` has been explicitly set.
  var hasTableInfoIDPath: Bool {return self._tableInfoIDPath != nil}
  /// Clears the value of `tableInfoIDPath`. Subsequent reads from it will return its default value.
  mutating func clearTableInfoIDPath() {self._tableInfoIDPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tableInfoIDPath: TSP_UUIDPath? = nil
}

struct TST_TableNameSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableSubSelectionTransformerBaseArchive {
    get {return _super ?? TST_TableSubSelectionTransformerBaseArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableSubSelectionTransformerBaseArchive? = nil
}

struct TST_ControlCellSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableSubSelectionTransformerBaseArchive {
    get {return _super ?? TST_TableSubSelectionTransformerBaseArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var cellUids: TST_CellUIDListArchive {
    get {return _cellUids ?? TST_CellUIDListArchive()}
    set {_cellUids = newValue}
  }
  /// Returns true if `cellUids` has been explicitly set.
  var hasCellUids: Bool {return self._cellUids != nil}
  /// Clears the value of `cellUids`. Subsequent reads from it will return its default value.
  mutating func clearCellUids() {self._cellUids = nil}

  var originCellUid: TSP_UUIDCoordArchive {
    get {return _originCellUid ?? TSP_UUIDCoordArchive()}
    set {_originCellUid = newValue}
  }
  /// Returns true if `originCellUid` has been explicitly set.
  var hasOriginCellUid: Bool {return self._originCellUid != nil}
  /// Clears the value of `originCellUid`. Subsequent reads from it will return its default value.
  mutating func clearOriginCellUid() {self._originCellUid = nil}

  var originCellID: TSCE_CellCoordinateArchive {
    get {return _originCellID ?? TSCE_CellCoordinateArchive()}
    set {_originCellID = newValue}
  }
  /// Returns true if `originCellID` has been explicitly set.
  var hasOriginCellID: Bool {return self._originCellID != nil}
  /// Clears the value of `originCellID`. Subsequent reads from it will return its default value.
  mutating func clearOriginCellID() {self._originCellID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableSubSelectionTransformerBaseArchive? = nil
  fileprivate var _cellUids: TST_CellUIDListArchive? = nil
  fileprivate var _originCellUid: TSP_UUIDCoordArchive? = nil
  fileprivate var _originCellID: TSCE_CellCoordinateArchive? = nil
}

struct TST_StockCellSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableSubSelectionTransformerBaseArchive {
    get {return _super ?? TST_TableSubSelectionTransformerBaseArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var cellUids: TST_CellUIDListArchive {
    get {return _cellUids ?? TST_CellUIDListArchive()}
    set {_cellUids = newValue}
  }
  /// Returns true if `cellUids` has been explicitly set.
  var hasCellUids: Bool {return self._cellUids != nil}
  /// Clears the value of `cellUids`. Subsequent reads from it will return its default value.
  mutating func clearCellUids() {self._cellUids = nil}

  var originCellUid: TSP_UUIDCoordArchive {
    get {return _originCellUid ?? TSP_UUIDCoordArchive()}
    set {_originCellUid = newValue}
  }
  /// Returns true if `originCellUid` has been explicitly set.
  var hasOriginCellUid: Bool {return self._originCellUid != nil}
  /// Clears the value of `originCellUid`. Subsequent reads from it will return its default value.
  mutating func clearOriginCellUid() {self._originCellUid = nil}

  var originCellID: TSCE_CellCoordinateArchive {
    get {return _originCellID ?? TSCE_CellCoordinateArchive()}
    set {_originCellID = newValue}
  }
  /// Returns true if `originCellID` has been explicitly set.
  var hasOriginCellID: Bool {return self._originCellID != nil}
  /// Clears the value of `originCellID`. Subsequent reads from it will return its default value.
  mutating func clearOriginCellID() {self._originCellID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableSubSelectionTransformerBaseArchive? = nil
  fileprivate var _cellUids: TST_CellUIDListArchive? = nil
  fileprivate var _originCellUid: TSP_UUIDCoordArchive? = nil
  fileprivate var _originCellID: TSCE_CellCoordinateArchive? = nil
}

struct TST_RegionSelectionTransformerArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableSubSelectionTransformerBaseArchive {
    get {return _storage._super ?? TST_TableSubSelectionTransformerBaseArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var cellUids: TST_CellUIDListArchive {
    get {return _storage._cellUids ?? TST_CellUIDListArchive()}
    set {_uniqueStorage()._cellUids = newValue}
  }
  /// Returns true if `cellUids` has been explicitly set.
  var hasCellUids: Bool {return _storage._cellUids != nil}
  /// Clears the value of `cellUids`. Subsequent reads from it will return its default value.
  mutating func clearCellUids() {_uniqueStorage()._cellUids = nil}

  var originCellUid: TSP_UUIDCoordArchive {
    get {return _storage._originCellUid ?? TSP_UUIDCoordArchive()}
    set {_uniqueStorage()._originCellUid = newValue}
  }
  /// Returns true if `originCellUid` has been explicitly set.
  var hasOriginCellUid: Bool {return _storage._originCellUid != nil}
  /// Clears the value of `originCellUid`. Subsequent reads from it will return its default value.
  mutating func clearOriginCellUid() {_uniqueStorage()._originCellUid = nil}

  var anchorCellUid: TSP_UUIDCoordArchive {
    get {return _storage._anchorCellUid ?? TSP_UUIDCoordArchive()}
    set {_uniqueStorage()._anchorCellUid = newValue}
  }
  /// Returns true if `anchorCellUid` has been explicitly set.
  var hasAnchorCellUid: Bool {return _storage._anchorCellUid != nil}
  /// Clears the value of `anchorCellUid`. Subsequent reads from it will return its default value.
  mutating func clearAnchorCellUid() {_uniqueStorage()._anchorCellUid = nil}

  var cursorCellUid: TSP_UUIDCoordArchive {
    get {return _storage._cursorCellUid ?? TSP_UUIDCoordArchive()}
    set {_uniqueStorage()._cursorCellUid = newValue}
  }
  /// Returns true if `cursorCellUid` has been explicitly set.
  var hasCursorCellUid: Bool {return _storage._cursorCellUid != nil}
  /// Clears the value of `cursorCellUid`. Subsequent reads from it will return its default value.
  mutating func clearCursorCellUid() {_uniqueStorage()._cursorCellUid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_StrokeSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableSubSelectionTransformerBaseArchive {
    get {return _super ?? TST_TableSubSelectionTransformerBaseArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var archivedSelection: TSP_Reference {
    get {return _archivedSelection ?? TSP_Reference()}
    set {_archivedSelection = newValue}
  }
  /// Returns true if `archivedSelection` has been explicitly set.
  var hasArchivedSelection: Bool {return self._archivedSelection != nil}
  /// Clears the value of `archivedSelection`. Subsequent reads from it will return its default value.
  mutating func clearArchivedSelection() {self._archivedSelection = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableSubSelectionTransformerBaseArchive? = nil
  fileprivate var _archivedSelection: TSP_Reference? = nil
}

struct TST_RowColumnSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableSubSelectionTransformerBaseArchive {
    get {return _super ?? TST_TableSubSelectionTransformerBaseArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var selectionType: TST_SelectionTypeArchive {
    get {return _selectionType ?? .deprecatedCellSelectionType}
    set {_selectionType = newValue}
  }
  /// Returns true if `selectionType` has been explicitly set.
  var hasSelectionType: Bool {return self._selectionType != nil}
  /// Clears the value of `selectionType`. Subsequent reads from it will return its default value.
  mutating func clearSelectionType() {self._selectionType = nil}

  var rowColUids: [TSP_UUID] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableSubSelectionTransformerBaseArchive? = nil
  fileprivate var _selectionType: TST_SelectionTypeArchive? = nil
}

struct TST_CommandCategoryMoveRowsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var actionType: UInt32 {
    get {return _actionType ?? 0}
    set {_actionType = newValue}
  }
  /// Returns true if `actionType` has been explicitly set.
  var hasActionType: Bool {return self._actionType != nil}
  /// Clears the value of `actionType`. Subsequent reads from it will return its default value.
  mutating func clearActionType() {self._actionType = nil}

  var categoryRowOrder: [TSP_UUID] = []

  var undoCategoryRowOrder: [TSP_UUID] = []

  var cellDiffMap: TSP_Reference {
    get {return _cellDiffMap ?? TSP_Reference()}
    set {_cellDiffMap = newValue}
  }
  /// Returns true if `cellDiffMap` has been explicitly set.
  var hasCellDiffMap: Bool {return self._cellDiffMap != nil}
  /// Clears the value of `cellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearCellDiffMap() {self._cellDiffMap = nil}

  var undoCellDiffMap: TSP_Reference {
    get {return _undoCellDiffMap ?? TSP_Reference()}
    set {_undoCellDiffMap = newValue}
  }
  /// Returns true if `undoCellDiffMap` has been explicitly set.
  var hasUndoCellDiffMap: Bool {return self._undoCellDiffMap != nil}
  /// Clears the value of `undoCellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearUndoCellDiffMap() {self._undoCellDiffMap = nil}

  var groupingColumns: TST_GroupColumnListArchive {
    get {return _groupingColumns ?? TST_GroupColumnListArchive()}
    set {_groupingColumns = newValue}
  }
  /// Returns true if `groupingColumns` has been explicitly set.
  var hasGroupingColumns: Bool {return self._groupingColumns != nil}
  /// Clears the value of `groupingColumns`. Subsequent reads from it will return its default value.
  mutating func clearGroupingColumns() {self._groupingColumns = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _actionType: UInt32? = nil
  fileprivate var _cellDiffMap: TSP_Reference? = nil
  fileprivate var _undoCellDiffMap: TSP_Reference? = nil
  fileprivate var _groupingColumns: TST_GroupColumnListArchive? = nil
}

struct TST_CommandRewriteHiddenStatesForGroupByChangeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var groupByChange: TSCE_GroupByChangeArchive {
    get {return _groupByChange ?? TSCE_GroupByChangeArchive()}
    set {_groupByChange = newValue}
  }
  /// Returns true if `groupByChange` has been explicitly set.
  var hasGroupByChange: Bool {return self._groupByChange != nil}
  /// Clears the value of `groupByChange`. Subsequent reads from it will return its default value.
  mutating func clearGroupByChange() {self._groupByChange = nil}

  var collapsedState: TST_ExpandCollapseStateArchive {
    get {return _collapsedState ?? TST_ExpandCollapseStateArchive()}
    set {_collapsedState = newValue}
  }
  /// Returns true if `collapsedState` has been explicitly set.
  var hasCollapsedState: Bool {return self._collapsedState != nil}
  /// Clears the value of `collapsedState`. Subsequent reads from it will return its default value.
  mutating func clearCollapsedState() {self._collapsedState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _groupByChange: TSCE_GroupByChangeArchive? = nil
  fileprivate var _collapsedState: TST_ExpandCollapseStateArchive? = nil
}

struct TST_CommandRewritePencilAnnotationFormulasArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var rewriteSpec: TST_FormulaRewriteSpecArchive {
    get {return _rewriteSpec ?? TST_FormulaRewriteSpecArchive()}
    set {_rewriteSpec = newValue}
  }
  /// Returns true if `rewriteSpec` has been explicitly set.
  var hasRewriteSpec: Bool {return self._rewriteSpec != nil}
  /// Clears the value of `rewriteSpec`. Subsequent reads from it will return its default value.
  mutating func clearRewriteSpec() {self._rewriteSpec = nil}

  var formulasToRewrite: TSCE_FormulasForUndoArchive {
    get {return _formulasToRewrite ?? TSCE_FormulasForUndoArchive()}
    set {_formulasToRewrite = newValue}
  }
  /// Returns true if `formulasToRewrite` has been explicitly set.
  var hasFormulasToRewrite: Bool {return self._formulasToRewrite != nil}
  /// Clears the value of `formulasToRewrite`. Subsequent reads from it will return its default value.
  mutating func clearFormulasToRewrite() {self._formulasToRewrite = nil}

  var annotationsForUndo: [TST_CommandRewritePencilAnnotationFormulasArchive.AnnotationPair] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct AnnotationPair: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var index: UInt64 {
      get {return _index ?? 0}
      set {_index = newValue}
    }
    /// Returns true if `index` has been explicitly set.
    var hasIndex: Bool {return self._index != nil}
    /// Clears the value of `index`. Subsequent reads from it will return its default value.
    mutating func clearIndex() {self._index = nil}

    var annotation: TSP_Reference {
      get {return _annotation ?? TSP_Reference()}
      set {_annotation = newValue}
    }
    /// Returns true if `annotation` has been explicitly set.
    var hasAnnotation: Bool {return self._annotation != nil}
    /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
    mutating func clearAnnotation() {self._annotation = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _index: UInt64? = nil
    fileprivate var _annotation: TSP_Reference? = nil
  }

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _rewriteSpec: TST_FormulaRewriteSpecArchive? = nil
  fileprivate var _formulasToRewrite: TSCE_FormulasForUndoArchive? = nil
}

struct TST_CommandPivotSetPivotRulesArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _storage._super ?? TST_TableCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var newTargetPivotRefreshUid: TSP_UUID {
    get {return _storage._newTargetPivotRefreshUid ?? TSP_UUID()}
    set {_uniqueStorage()._newTargetPivotRefreshUid = newValue}
  }
  /// Returns true if `newTargetPivotRefreshUid` has been explicitly set.
  var hasNewTargetPivotRefreshUid: Bool {return _storage._newTargetPivotRefreshUid != nil}
  /// Clears the value of `newTargetPivotRefreshUid`. Subsequent reads from it will return its default value.
  mutating func clearNewTargetPivotRefreshUid() {_uniqueStorage()._newTargetPivotRefreshUid = nil}

  var newRowGroupings: TST_GroupColumnListArchive {
    get {return _storage._newRowGroupings ?? TST_GroupColumnListArchive()}
    set {_uniqueStorage()._newRowGroupings = newValue}
  }
  /// Returns true if `newRowGroupings` has been explicitly set.
  var hasNewRowGroupings: Bool {return _storage._newRowGroupings != nil}
  /// Clears the value of `newRowGroupings`. Subsequent reads from it will return its default value.
  mutating func clearNewRowGroupings() {_uniqueStorage()._newRowGroupings = nil}

  var oldRowGroupings: TST_GroupColumnListArchive {
    get {return _storage._oldRowGroupings ?? TST_GroupColumnListArchive()}
    set {_uniqueStorage()._oldRowGroupings = newValue}
  }
  /// Returns true if `oldRowGroupings` has been explicitly set.
  var hasOldRowGroupings: Bool {return _storage._oldRowGroupings != nil}
  /// Clears the value of `oldRowGroupings`. Subsequent reads from it will return its default value.
  mutating func clearOldRowGroupings() {_uniqueStorage()._oldRowGroupings = nil}

  var newColumnGroupings: TST_GroupColumnListArchive {
    get {return _storage._newColumnGroupings ?? TST_GroupColumnListArchive()}
    set {_uniqueStorage()._newColumnGroupings = newValue}
  }
  /// Returns true if `newColumnGroupings` has been explicitly set.
  var hasNewColumnGroupings: Bool {return _storage._newColumnGroupings != nil}
  /// Clears the value of `newColumnGroupings`. Subsequent reads from it will return its default value.
  mutating func clearNewColumnGroupings() {_uniqueStorage()._newColumnGroupings = nil}

  var oldColumnGroupings: TST_GroupColumnListArchive {
    get {return _storage._oldColumnGroupings ?? TST_GroupColumnListArchive()}
    set {_uniqueStorage()._oldColumnGroupings = newValue}
  }
  /// Returns true if `oldColumnGroupings` has been explicitly set.
  var hasOldColumnGroupings: Bool {return _storage._oldColumnGroupings != nil}
  /// Clears the value of `oldColumnGroupings`. Subsequent reads from it will return its default value.
  mutating func clearOldColumnGroupings() {_uniqueStorage()._oldColumnGroupings = nil}

  var newAggregates: TST_ColumnAggregateListArchive {
    get {return _storage._newAggregates ?? TST_ColumnAggregateListArchive()}
    set {_uniqueStorage()._newAggregates = newValue}
  }
  /// Returns true if `newAggregates` has been explicitly set.
  var hasNewAggregates: Bool {return _storage._newAggregates != nil}
  /// Clears the value of `newAggregates`. Subsequent reads from it will return its default value.
  mutating func clearNewAggregates() {_uniqueStorage()._newAggregates = nil}

  var oldAggregates: TST_ColumnAggregateListArchive {
    get {return _storage._oldAggregates ?? TST_ColumnAggregateListArchive()}
    set {_uniqueStorage()._oldAggregates = newValue}
  }
  /// Returns true if `oldAggregates` has been explicitly set.
  var hasOldAggregates: Bool {return _storage._oldAggregates != nil}
  /// Clears the value of `oldAggregates`. Subsequent reads from it will return its default value.
  mutating func clearOldAggregates() {_uniqueStorage()._oldAggregates = nil}

  var newFlatteningDimension: TST_TableDimensionArchive {
    get {return _storage._newFlatteningDimension ?? .dimensionNeither}
    set {_uniqueStorage()._newFlatteningDimension = newValue}
  }
  /// Returns true if `newFlatteningDimension` has been explicitly set.
  var hasNewFlatteningDimension: Bool {return _storage._newFlatteningDimension != nil}
  /// Clears the value of `newFlatteningDimension`. Subsequent reads from it will return its default value.
  mutating func clearNewFlatteningDimension() {_uniqueStorage()._newFlatteningDimension = nil}

  var oldFlatteningDimension: TST_TableDimensionArchive {
    get {return _storage._oldFlatteningDimension ?? .dimensionNeither}
    set {_uniqueStorage()._oldFlatteningDimension = newValue}
  }
  /// Returns true if `oldFlatteningDimension` has been explicitly set.
  var hasOldFlatteningDimension: Bool {return _storage._oldFlatteningDimension != nil}
  /// Clears the value of `oldFlatteningDimension`. Subsequent reads from it will return its default value.
  mutating func clearOldFlatteningDimension() {_uniqueStorage()._oldFlatteningDimension = nil}

  var newPivotDataModel: TSP_Reference {
    get {return _storage._newPivotDataModel ?? TSP_Reference()}
    set {_uniqueStorage()._newPivotDataModel = newValue}
  }
  /// Returns true if `newPivotDataModel` has been explicitly set.
  var hasNewPivotDataModel: Bool {return _storage._newPivotDataModel != nil}
  /// Clears the value of `newPivotDataModel`. Subsequent reads from it will return its default value.
  mutating func clearNewPivotDataModel() {_uniqueStorage()._newPivotDataModel = nil}

  var oldPivotDataModel: TSP_Reference {
    get {return _storage._oldPivotDataModel ?? TSP_Reference()}
    set {_uniqueStorage()._oldPivotDataModel = newValue}
  }
  /// Returns true if `oldPivotDataModel` has been explicitly set.
  var hasOldPivotDataModel: Bool {return _storage._oldPivotDataModel != nil}
  /// Clears the value of `oldPivotDataModel`. Subsequent reads from it will return its default value.
  mutating func clearOldPivotDataModel() {_uniqueStorage()._oldPivotDataModel = nil}

  var newPivotRefreshUid: TSP_UUID {
    get {return _storage._newPivotRefreshUid ?? TSP_UUID()}
    set {_uniqueStorage()._newPivotRefreshUid = newValue}
  }
  /// Returns true if `newPivotRefreshUid` has been explicitly set.
  var hasNewPivotRefreshUid: Bool {return _storage._newPivotRefreshUid != nil}
  /// Clears the value of `newPivotRefreshUid`. Subsequent reads from it will return its default value.
  mutating func clearNewPivotRefreshUid() {_uniqueStorage()._newPivotRefreshUid = nil}

  var oldPivotRefreshUid: TSP_UUID {
    get {return _storage._oldPivotRefreshUid ?? TSP_UUID()}
    set {_uniqueStorage()._oldPivotRefreshUid = newValue}
  }
  /// Returns true if `oldPivotRefreshUid` has been explicitly set.
  var hasOldPivotRefreshUid: Bool {return _storage._oldPivotRefreshUid != nil}
  /// Clears the value of `oldPivotRefreshUid`. Subsequent reads from it will return its default value.
  mutating func clearOldPivotRefreshUid() {_uniqueStorage()._oldPivotRefreshUid = nil}

  var newPivotRefreshTimestamp: Double {
    get {return _storage._newPivotRefreshTimestamp ?? 0}
    set {_uniqueStorage()._newPivotRefreshTimestamp = newValue}
  }
  /// Returns true if `newPivotRefreshTimestamp` has been explicitly set.
  var hasNewPivotRefreshTimestamp: Bool {return _storage._newPivotRefreshTimestamp != nil}
  /// Clears the value of `newPivotRefreshTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearNewPivotRefreshTimestamp() {_uniqueStorage()._newPivotRefreshTimestamp = nil}

  var oldPivotRefreshTimestamp: Double {
    get {return _storage._oldPivotRefreshTimestamp ?? 0}
    set {_uniqueStorage()._oldPivotRefreshTimestamp = newValue}
  }
  /// Returns true if `oldPivotRefreshTimestamp` has been explicitly set.
  var hasOldPivotRefreshTimestamp: Bool {return _storage._oldPivotRefreshTimestamp != nil}
  /// Clears the value of `oldPivotRefreshTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearOldPivotRefreshTimestamp() {_uniqueStorage()._oldPivotRefreshTimestamp = nil}

  var newOptionsMap: TSP_Reference {
    get {return _storage._newOptionsMap ?? TSP_Reference()}
    set {_uniqueStorage()._newOptionsMap = newValue}
  }
  /// Returns true if `newOptionsMap` has been explicitly set.
  var hasNewOptionsMap: Bool {return _storage._newOptionsMap != nil}
  /// Clears the value of `newOptionsMap`. Subsequent reads from it will return its default value.
  mutating func clearNewOptionsMap() {_uniqueStorage()._newOptionsMap = nil}

  var oldOptionsMap: TSP_Reference {
    get {return _storage._oldOptionsMap ?? TSP_Reference()}
    set {_uniqueStorage()._oldOptionsMap = newValue}
  }
  /// Returns true if `oldOptionsMap` has been explicitly set.
  var hasOldOptionsMap: Bool {return _storage._oldOptionsMap != nil}
  /// Clears the value of `oldOptionsMap`. Subsequent reads from it will return its default value.
  mutating func clearOldOptionsMap() {_uniqueStorage()._oldOptionsMap = nil}

  var newViewRowOrder: [TSP_UUID] {
    get {return _storage._newViewRowOrder}
    set {_uniqueStorage()._newViewRowOrder = newValue}
  }

  var oldViewRowOrder: [TSP_UUID] {
    get {return _storage._oldViewRowOrder}
    set {_uniqueStorage()._oldViewRowOrder = newValue}
  }

  var newViewColumnOrder: [TSP_UUID] {
    get {return _storage._newViewColumnOrder}
    set {_uniqueStorage()._newViewColumnOrder = newValue}
  }

  var oldViewColumnOrder: [TSP_UUID] {
    get {return _storage._oldViewColumnOrder}
    set {_uniqueStorage()._oldViewColumnOrder = newValue}
  }

  var newCollapsedRowGroups: [TSP_UUID] {
    get {return _storage._newCollapsedRowGroups}
    set {_uniqueStorage()._newCollapsedRowGroups = newValue}
  }

  var oldCollapsedRowGroups: [TSP_UUID] {
    get {return _storage._oldCollapsedRowGroups}
    set {_uniqueStorage()._oldCollapsedRowGroups = newValue}
  }

  var newCollapsedColumnGroups: [TSP_UUID] {
    get {return _storage._newCollapsedColumnGroups}
    set {_uniqueStorage()._newCollapsedColumnGroups = newValue}
  }

  var oldCollapsedColumnGroups: [TSP_UUID] {
    get {return _storage._oldCollapsedColumnGroups}
    set {_uniqueStorage()._oldCollapsedColumnGroups = newValue}
  }

  var newHierarchicalCellDiffMap: TST_HierarchicalCellDiffMapArchive {
    get {return _storage._newHierarchicalCellDiffMap ?? TST_HierarchicalCellDiffMapArchive()}
    set {_uniqueStorage()._newHierarchicalCellDiffMap = newValue}
  }
  /// Returns true if `newHierarchicalCellDiffMap` has been explicitly set.
  var hasNewHierarchicalCellDiffMap: Bool {return _storage._newHierarchicalCellDiffMap != nil}
  /// Clears the value of `newHierarchicalCellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearNewHierarchicalCellDiffMap() {_uniqueStorage()._newHierarchicalCellDiffMap = nil}

  var oldHierarchicalCellDiffMap: TST_HierarchicalCellDiffMapArchive {
    get {return _storage._oldHierarchicalCellDiffMap ?? TST_HierarchicalCellDiffMapArchive()}
    set {_uniqueStorage()._oldHierarchicalCellDiffMap = newValue}
  }
  /// Returns true if `oldHierarchicalCellDiffMap` has been explicitly set.
  var hasOldHierarchicalCellDiffMap: Bool {return _storage._oldHierarchicalCellDiffMap != nil}
  /// Clears the value of `oldHierarchicalCellDiffMap`. Subsequent reads from it will return its default value.
  mutating func clearOldHierarchicalCellDiffMap() {_uniqueStorage()._oldHierarchicalCellDiffMap = nil}

  var formulaRewriteCommandForUndo: TSP_Reference {
    get {return _storage._formulaRewriteCommandForUndo ?? TSP_Reference()}
    set {_uniqueStorage()._formulaRewriteCommandForUndo = newValue}
  }
  /// Returns true if `formulaRewriteCommandForUndo` has been explicitly set.
  var hasFormulaRewriteCommandForUndo: Bool {return _storage._formulaRewriteCommandForUndo != nil}
  /// Clears the value of `formulaRewriteCommandForUndo`. Subsequent reads from it will return its default value.
  mutating func clearFormulaRewriteCommandForUndo() {_uniqueStorage()._formulaRewriteCommandForUndo = nil}

  var newBodyUidTract: TSP_UUIDRectArchive {
    get {return _storage._newBodyUidTract ?? TSP_UUIDRectArchive()}
    set {_uniqueStorage()._newBodyUidTract = newValue}
  }
  /// Returns true if `newBodyUidTract` has been explicitly set.
  var hasNewBodyUidTract: Bool {return _storage._newBodyUidTract != nil}
  /// Clears the value of `newBodyUidTract`. Subsequent reads from it will return its default value.
  mutating func clearNewBodyUidTract() {_uniqueStorage()._newBodyUidTract = nil}

  var oldBodyUidTract: TSP_UUIDRectArchive {
    get {return _storage._oldBodyUidTract ?? TSP_UUIDRectArchive()}
    set {_uniqueStorage()._oldBodyUidTract = newValue}
  }
  /// Returns true if `oldBodyUidTract` has been explicitly set.
  var hasOldBodyUidTract: Bool {return _storage._oldBodyUidTract != nil}
  /// Clears the value of `oldBodyUidTract`. Subsequent reads from it will return its default value.
  mutating func clearOldBodyUidTract() {_uniqueStorage()._oldBodyUidTract = nil}

  var oldTargetPivotRefreshUid: TSP_UUID {
    get {return _storage._oldTargetPivotRefreshUid ?? TSP_UUID()}
    set {_uniqueStorage()._oldTargetPivotRefreshUid = newValue}
  }
  /// Returns true if `oldTargetPivotRefreshUid` has been explicitly set.
  var hasOldTargetPivotRefreshUid: Bool {return _storage._oldTargetPivotRefreshUid != nil}
  /// Clears the value of `oldTargetPivotRefreshUid`. Subsequent reads from it will return its default value.
  mutating func clearOldTargetPivotRefreshUid() {_uniqueStorage()._oldTargetPivotRefreshUid = nil}

  var newTargetPivotRowColumnRuleChangeUid: TSP_UUID {
    get {return _storage._newTargetPivotRowColumnRuleChangeUid ?? TSP_UUID()}
    set {_uniqueStorage()._newTargetPivotRowColumnRuleChangeUid = newValue}
  }
  /// Returns true if `newTargetPivotRowColumnRuleChangeUid` has been explicitly set.
  var hasNewTargetPivotRowColumnRuleChangeUid: Bool {return _storage._newTargetPivotRowColumnRuleChangeUid != nil}
  /// Clears the value of `newTargetPivotRowColumnRuleChangeUid`. Subsequent reads from it will return its default value.
  mutating func clearNewTargetPivotRowColumnRuleChangeUid() {_uniqueStorage()._newTargetPivotRowColumnRuleChangeUid = nil}

  var oldTargetPivotRowColumnRuleChangeUid: TSP_UUID {
    get {return _storage._oldTargetPivotRowColumnRuleChangeUid ?? TSP_UUID()}
    set {_uniqueStorage()._oldTargetPivotRowColumnRuleChangeUid = newValue}
  }
  /// Returns true if `oldTargetPivotRowColumnRuleChangeUid` has been explicitly set.
  var hasOldTargetPivotRowColumnRuleChangeUid: Bool {return _storage._oldTargetPivotRowColumnRuleChangeUid != nil}
  /// Clears the value of `oldTargetPivotRowColumnRuleChangeUid`. Subsequent reads from it will return its default value.
  mutating func clearOldTargetPivotRowColumnRuleChangeUid() {_uniqueStorage()._oldTargetPivotRowColumnRuleChangeUid = nil}

  var newTargetPivotAggregateRuleChangeUid: TSP_UUID {
    get {return _storage._newTargetPivotAggregateRuleChangeUid ?? TSP_UUID()}
    set {_uniqueStorage()._newTargetPivotAggregateRuleChangeUid = newValue}
  }
  /// Returns true if `newTargetPivotAggregateRuleChangeUid` has been explicitly set.
  var hasNewTargetPivotAggregateRuleChangeUid: Bool {return _storage._newTargetPivotAggregateRuleChangeUid != nil}
  /// Clears the value of `newTargetPivotAggregateRuleChangeUid`. Subsequent reads from it will return its default value.
  mutating func clearNewTargetPivotAggregateRuleChangeUid() {_uniqueStorage()._newTargetPivotAggregateRuleChangeUid = nil}

  var oldTargetPivotAggregateRuleChangeUid: TSP_UUID {
    get {return _storage._oldTargetPivotAggregateRuleChangeUid ?? TSP_UUID()}
    set {_uniqueStorage()._oldTargetPivotAggregateRuleChangeUid = newValue}
  }
  /// Returns true if `oldTargetPivotAggregateRuleChangeUid` has been explicitly set.
  var hasOldTargetPivotAggregateRuleChangeUid: Bool {return _storage._oldTargetPivotAggregateRuleChangeUid != nil}
  /// Clears the value of `oldTargetPivotAggregateRuleChangeUid`. Subsequent reads from it will return its default value.
  mutating func clearOldTargetPivotAggregateRuleChangeUid() {_uniqueStorage()._oldTargetPivotAggregateRuleChangeUid = nil}

  var isOrderFinalized: Bool {
    get {return _storage._isOrderFinalized ?? false}
    set {_uniqueStorage()._isOrderFinalized = newValue}
  }
  /// Returns true if `isOrderFinalized` has been explicitly set.
  var hasIsOrderFinalized: Bool {return _storage._isOrderFinalized != nil}
  /// Clears the value of `isOrderFinalized`. Subsequent reads from it will return its default value.
  mutating func clearIsOrderFinalized() {_uniqueStorage()._isOrderFinalized = nil}

  var newFilterSet: TSP_Reference {
    get {return _storage._newFilterSet ?? TSP_Reference()}
    set {_uniqueStorage()._newFilterSet = newValue}
  }
  /// Returns true if `newFilterSet` has been explicitly set.
  var hasNewFilterSet: Bool {return _storage._newFilterSet != nil}
  /// Clears the value of `newFilterSet`. Subsequent reads from it will return its default value.
  mutating func clearNewFilterSet() {_uniqueStorage()._newFilterSet = nil}

  var oldFilterSet: TSP_Reference {
    get {return _storage._oldFilterSet ?? TSP_Reference()}
    set {_uniqueStorage()._oldFilterSet = newValue}
  }
  /// Returns true if `oldFilterSet` has been explicitly set.
  var hasOldFilterSet: Bool {return _storage._oldFilterSet != nil}
  /// Clears the value of `oldFilterSet`. Subsequent reads from it will return its default value.
  mutating func clearOldFilterSet() {_uniqueStorage()._oldFilterSet = nil}

  var useSmallTableLimits: Bool {
    get {return _storage._useSmallTableLimits ?? false}
    set {_uniqueStorage()._useSmallTableLimits = newValue}
  }
  /// Returns true if `useSmallTableLimits` has been explicitly set.
  var hasUseSmallTableLimits: Bool {return _storage._useSmallTableLimits != nil}
  /// Clears the value of `useSmallTableLimits`. Subsequent reads from it will return its default value.
  mutating func clearUseSmallTableLimits() {_uniqueStorage()._useSmallTableLimits = nil}

  var settingFiltersEnabled: Int32 {
    get {return _storage._settingFiltersEnabled ?? 0}
    set {_uniqueStorage()._settingFiltersEnabled = newValue}
  }
  /// Returns true if `settingFiltersEnabled` has been explicitly set.
  var hasSettingFiltersEnabled: Bool {return _storage._settingFiltersEnabled != nil}
  /// Clears the value of `settingFiltersEnabled`. Subsequent reads from it will return its default value.
  mutating func clearSettingFiltersEnabled() {_uniqueStorage()._settingFiltersEnabled = nil}

  var undoSettingFiltersEnabled: Int32 {
    get {return _storage._undoSettingFiltersEnabled ?? 0}
    set {_uniqueStorage()._undoSettingFiltersEnabled = newValue}
  }
  /// Returns true if `undoSettingFiltersEnabled` has been explicitly set.
  var hasUndoSettingFiltersEnabled: Bool {return _storage._undoSettingFiltersEnabled != nil}
  /// Clears the value of `undoSettingFiltersEnabled`. Subsequent reads from it will return its default value.
  mutating func clearUndoSettingFiltersEnabled() {_uniqueStorage()._undoSettingFiltersEnabled = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandPivotSetGroupingColumnOptionsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var groupingColumnUid: TSP_UUID {
    get {return _groupingColumnUid ?? TSP_UUID()}
    set {_groupingColumnUid = newValue}
  }
  /// Returns true if `groupingColumnUid` has been explicitly set.
  var hasGroupingColumnUid: Bool {return self._groupingColumnUid != nil}
  /// Clears the value of `groupingColumnUid`. Subsequent reads from it will return its default value.
  mutating func clearGroupingColumnUid() {self._groupingColumnUid = nil}

  var nonSortingFlag: UInt32 {
    get {return _nonSortingFlag ?? 0}
    set {_nonSortingFlag = newValue}
  }
  /// Returns true if `nonSortingFlag` has been explicitly set.
  var hasNonSortingFlag: Bool {return self._nonSortingFlag != nil}
  /// Clears the value of `nonSortingFlag`. Subsequent reads from it will return its default value.
  mutating func clearNonSortingFlag() {self._nonSortingFlag = nil}

  var boolValue: Bool {
    get {return _boolValue ?? false}
    set {_boolValue = newValue}
  }
  /// Returns true if `boolValue` has been explicitly set.
  var hasBoolValue: Bool {return self._boolValue != nil}
  /// Clears the value of `boolValue`. Subsequent reads from it will return its default value.
  mutating func clearBoolValue() {self._boolValue = nil}

  var undoBoolValue: Bool {
    get {return _undoBoolValue ?? false}
    set {_undoBoolValue = newValue}
  }
  /// Returns true if `undoBoolValue` has been explicitly set.
  var hasUndoBoolValue: Bool {return self._undoBoolValue != nil}
  /// Clears the value of `undoBoolValue`. Subsequent reads from it will return its default value.
  mutating func clearUndoBoolValue() {self._undoBoolValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _groupingColumnUid: TSP_UUID? = nil
  fileprivate var _nonSortingFlag: UInt32? = nil
  fileprivate var _boolValue: Bool? = nil
  fileprivate var _undoBoolValue: Bool? = nil
}

struct TST_CommandPivotHideShowGrandTotalsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _super ?? TST_TableCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var dimension: TST_TableDimensionArchive {
    get {return _dimension ?? .dimensionNeither}
    set {_dimension = newValue}
  }
  /// Returns true if `dimension` has been explicitly set.
  var hasDimension: Bool {return self._dimension != nil}
  /// Clears the value of `dimension`. Subsequent reads from it will return its default value.
  mutating func clearDimension() {self._dimension = nil}

  var isHiding: Bool {
    get {return _isHiding ?? false}
    set {_isHiding = newValue}
  }
  /// Returns true if `isHiding` has been explicitly set.
  var hasIsHiding: Bool {return self._isHiding != nil}
  /// Clears the value of `isHiding`. Subsequent reads from it will return its default value.
  mutating func clearIsHiding() {self._isHiding = nil}

  var undoIsHiding: Bool {
    get {return _undoIsHiding ?? false}
    set {_undoIsHiding = newValue}
  }
  /// Returns true if `undoIsHiding` has been explicitly set.
  var hasUndoIsHiding: Bool {return self._undoIsHiding != nil}
  /// Clears the value of `undoIsHiding`. Subsequent reads from it will return its default value.
  mutating func clearUndoIsHiding() {self._undoIsHiding = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TST_TableCommandArchive? = nil
  fileprivate var _dimension: TST_TableDimensionArchive? = nil
  fileprivate var _isHiding: Bool? = nil
  fileprivate var _undoIsHiding: Bool? = nil
}

struct TST_CommandPivotSortArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TST_TableCommandArchive {
    get {return _storage._super ?? TST_TableCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var dimension: TST_TableDimensionArchive {
    get {return _storage._dimension ?? .dimensionNeither}
    set {_uniqueStorage()._dimension = newValue}
  }
  /// Returns true if `dimension` has been explicitly set.
  var hasDimension: Bool {return _storage._dimension != nil}
  /// Clears the value of `dimension`. Subsequent reads from it will return its default value.
  mutating func clearDimension() {_uniqueStorage()._dimension = nil}

  var columnOrder: [TSP_UUID] {
    get {return _storage._columnOrder}
    set {_uniqueStorage()._columnOrder = newValue}
  }

  var undoColumnOrder: [TSP_UUID] {
    get {return _storage._undoColumnOrder}
    set {_uniqueStorage()._undoColumnOrder = newValue}
  }

  var rowOrder: [TSP_UUID] {
    get {return _storage._rowOrder}
    set {_uniqueStorage()._rowOrder = newValue}
  }

  var undoRowOrder: [TSP_UUID] {
    get {return _storage._undoRowOrder}
    set {_uniqueStorage()._undoRowOrder = newValue}
  }

  var targetPivotRowColumnRuleChangeUid: TSP_UUID {
    get {return _storage._targetPivotRowColumnRuleChangeUid ?? TSP_UUID()}
    set {_uniqueStorage()._targetPivotRowColumnRuleChangeUid = newValue}
  }
  /// Returns true if `targetPivotRowColumnRuleChangeUid` has been explicitly set.
  var hasTargetPivotRowColumnRuleChangeUid: Bool {return _storage._targetPivotRowColumnRuleChangeUid != nil}
  /// Clears the value of `targetPivotRowColumnRuleChangeUid`. Subsequent reads from it will return its default value.
  mutating func clearTargetPivotRowColumnRuleChangeUid() {_uniqueStorage()._targetPivotRowColumnRuleChangeUid = nil}

  var targetPivotAggregateRuleChangeUid: TSP_UUID {
    get {return _storage._targetPivotAggregateRuleChangeUid ?? TSP_UUID()}
    set {_uniqueStorage()._targetPivotAggregateRuleChangeUid = newValue}
  }
  /// Returns true if `targetPivotAggregateRuleChangeUid` has been explicitly set.
  var hasTargetPivotAggregateRuleChangeUid: Bool {return _storage._targetPivotAggregateRuleChangeUid != nil}
  /// Clears the value of `targetPivotAggregateRuleChangeUid`. Subsequent reads from it will return its default value.
  mutating func clearTargetPivotAggregateRuleChangeUid() {_uniqueStorage()._targetPivotAggregateRuleChangeUid = nil}

  var targetPivotDataRefreshUid: TSP_UUID {
    get {return _storage._targetPivotDataRefreshUid ?? TSP_UUID()}
    set {_uniqueStorage()._targetPivotDataRefreshUid = newValue}
  }
  /// Returns true if `targetPivotDataRefreshUid` has been explicitly set.
  var hasTargetPivotDataRefreshUid: Bool {return _storage._targetPivotDataRefreshUid != nil}
  /// Clears the value of `targetPivotDataRefreshUid`. Subsequent reads from it will return its default value.
  mutating func clearTargetPivotDataRefreshUid() {_uniqueStorage()._targetPivotDataRefreshUid = nil}

  var groupingColumnUid: TSP_UUID {
    get {return _storage._groupingColumnUid ?? TSP_UUID()}
    set {_uniqueStorage()._groupingColumnUid = newValue}
  }
  /// Returns true if `groupingColumnUid` has been explicitly set.
  var hasGroupingColumnUid: Bool {return _storage._groupingColumnUid != nil}
  /// Clears the value of `groupingColumnUid`. Subsequent reads from it will return its default value.
  mutating func clearGroupingColumnUid() {_uniqueStorage()._groupingColumnUid = nil}

  var sortingFlags: UInt32 {
    get {return _storage._sortingFlags ?? 0}
    set {_uniqueStorage()._sortingFlags = newValue}
  }
  /// Returns true if `sortingFlags` has been explicitly set.
  var hasSortingFlags: Bool {return _storage._sortingFlags != nil}
  /// Clears the value of `sortingFlags`. Subsequent reads from it will return its default value.
  mutating func clearSortingFlags() {_uniqueStorage()._sortingFlags = nil}

  var undoSortingFlags: UInt32 {
    get {return _storage._undoSortingFlags ?? 0}
    set {_uniqueStorage()._undoSortingFlags = newValue}
  }
  /// Returns true if `undoSortingFlags` has been explicitly set.
  var hasUndoSortingFlags: Bool {return _storage._undoSortingFlags != nil}
  /// Clears the value of `undoSortingFlags`. Subsequent reads from it will return its default value.
  mutating func clearUndoSortingFlags() {_uniqueStorage()._undoSortingFlags = nil}

  var sortingAggregateRuleUid: TSP_UUID {
    get {return _storage._sortingAggregateRuleUid ?? TSP_UUID()}
    set {_uniqueStorage()._sortingAggregateRuleUid = newValue}
  }
  /// Returns true if `sortingAggregateRuleUid` has been explicitly set.
  var hasSortingAggregateRuleUid: Bool {return _storage._sortingAggregateRuleUid != nil}
  /// Clears the value of `sortingAggregateRuleUid`. Subsequent reads from it will return its default value.
  mutating func clearSortingAggregateRuleUid() {_uniqueStorage()._sortingAggregateRuleUid = nil}

  var undoSortingAggregateRuleUid: TSP_UUID {
    get {return _storage._undoSortingAggregateRuleUid ?? TSP_UUID()}
    set {_uniqueStorage()._undoSortingAggregateRuleUid = newValue}
  }
  /// Returns true if `undoSortingAggregateRuleUid` has been explicitly set.
  var hasUndoSortingAggregateRuleUid: Bool {return _storage._undoSortingAggregateRuleUid != nil}
  /// Clears the value of `undoSortingAggregateRuleUid`. Subsequent reads from it will return its default value.
  mutating func clearUndoSortingAggregateRuleUid() {_uniqueStorage()._undoSortingAggregateRuleUid = nil}

  var isOrderFinalized: Bool {
    get {return _storage._isOrderFinalized ?? false}
    set {_uniqueStorage()._isOrderFinalized = newValue}
  }
  /// Returns true if `isOrderFinalized` has been explicitly set.
  var hasIsOrderFinalized: Bool {return _storage._isOrderFinalized != nil}
  /// Clears the value of `isOrderFinalized`. Subsequent reads from it will return its default value.
  mutating func clearIsOrderFinalized() {_uniqueStorage()._isOrderFinalized = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TST_CommandRewriteTrackedReferencesArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var rewriteSpec: TST_FormulaRewriteSpecArchive {
    get {return _rewriteSpec ?? TST_FormulaRewriteSpecArchive()}
    set {_rewriteSpec = newValue}
  }
  /// Returns true if `rewriteSpec` has been explicitly set.
  var hasRewriteSpec: Bool {return self._rewriteSpec != nil}
  /// Clears the value of `rewriteSpec`. Subsequent reads from it will return its default value.
  mutating func clearRewriteSpec() {self._rewriteSpec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _rewriteSpec: TST_FormulaRewriteSpecArchive? = nil
}

struct TST_CommandExtendTableIDHistoryArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var rewriteSpec: TST_FormulaRewriteSpecArchive {
    get {return _rewriteSpec ?? TST_FormulaRewriteSpecArchive()}
    set {_rewriteSpec = newValue}
  }
  /// Returns true if `rewriteSpec` has been explicitly set.
  var hasRewriteSpec: Bool {return self._rewriteSpec != nil}
  /// Clears the value of `rewriteSpec`. Subsequent reads from it will return its default value.
  mutating func clearRewriteSpec() {self._rewriteSpec = nil}

  var tableUidHistoryRollback: TSCE_RewriteTableUIDInfoArchive {
    get {return _tableUidHistoryRollback ?? TSCE_RewriteTableUIDInfoArchive()}
    set {_tableUidHistoryRollback = newValue}
  }
  /// Returns true if `tableUidHistoryRollback` has been explicitly set.
  var hasTableUidHistoryRollback: Bool {return self._tableUidHistoryRollback != nil}
  /// Clears the value of `tableUidHistoryRollback`. Subsequent reads from it will return its default value.
  mutating func clearTableUidHistoryRollback() {self._tableUidHistoryRollback = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _rewriteSpec: TST_FormulaRewriteSpecArchive? = nil
  fileprivate var _tableUidHistoryRollback: TSCE_RewriteTableUIDInfoArchive? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TST"

extension TST_TableArea: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}TableAreaBody\0\u{1}TableAreaHeaderRow\0\u{1}TableAreaHeaderColumn\0\u{1}TableAreaFooterRow\0")
}

extension TST_TableAreaTransition: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}TableAreaTransitionHeaderRowToBody\0\u{1}TableAreaTransitionBodyToHeaderRow\0\u{1}TableAreaTransitionFooterRowToBody\0\u{1}TableAreaTransitionBodyToFooterRow\0\u{1}TableAreaTransitionHeaderColumnToBody\0\u{1}TableAreaTransitionBodyToHeaderColumn\0")
}

extension TST_ColumnRowBundleItemTypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ColumnRowTypeAnchor\0\u{1}ColumnRowTypeHeaderRow\0\u{1}ColumnRowTypeBodyRow\0\u{1}ColumnRowTypeFooterRow\0\u{1}ColumnRowTypeHeaderColumn\0\u{1}ColumnRowTypeBodyColumn\0")
}

extension TST_TableCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TableCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}table_info_id_path\0\u{1}commandname\0\u{3}default_cell_styles_container\0\u{1}timestamp\0\u{3}random_seed_lo\0\u{3}random_seed_hi\0\u{3}is_inverse\0\u{3}old_timestamp\0\u{3}old_random_seed\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _tableInfoIDPath: TSP_UUIDPath? = nil
    var _commandname: String? = nil
    var _defaultCellStylesContainer: TSP_Reference? = nil
    var _timestamp: Double? = nil
    var _randomSeedLo: UInt32? = nil
    var _randomSeedHi: UInt32? = nil
    var _isInverse: Bool? = nil
    var _oldTimestamp: Double? = nil
    var _oldRandomSeed: UInt64? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _tableInfoIDPath = source._tableInfoIDPath
      _commandname = source._commandname
      _defaultCellStylesContainer = source._defaultCellStylesContainer
      _timestamp = source._timestamp
      _randomSeedLo = source._randomSeedLo
      _randomSeedHi = source._randomSeedHi
      _isInverse = source._isInverse
      _oldTimestamp = source._oldTimestamp
      _oldRandomSeed = source._oldRandomSeed
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._tableInfoIDPath == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._tableInfoIDPath, !v.isInitialized {return false}
      if let v = _storage._defaultCellStylesContainer, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._tableInfoIDPath) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._commandname) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._defaultCellStylesContainer) }()
        case 5: try { try decoder.decodeSingularDoubleField(value: &_storage._timestamp) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._randomSeedLo) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._randomSeedHi) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._isInverse) }()
        case 9: try { try decoder.decodeSingularDoubleField(value: &_storage._oldTimestamp) }()
        case 10: try { try decoder.decodeSingularUInt64Field(value: &_storage._oldRandomSeed) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._tableInfoIDPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._commandname {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._defaultCellStylesContainer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._timestamp {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._randomSeedLo {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._randomSeedHi {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._isInverse {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._oldTimestamp {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._oldRandomSeed {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableCommandArchive, rhs: TST_TableCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._tableInfoIDPath != rhs_storage._tableInfoIDPath {return false}
        if _storage._commandname != rhs_storage._commandname {return false}
        if _storage._defaultCellStylesContainer != rhs_storage._defaultCellStylesContainer {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._randomSeedLo != rhs_storage._randomSeedLo {return false}
        if _storage._randomSeedHi != rhs_storage._randomSeedHi {return false}
        if _storage._isInverse != rhs_storage._isInverse {return false}
        if _storage._oldTimestamp != rhs_storage._oldTimestamp {return false}
        if _storage._oldRandomSeed != rhs_storage._oldRandomSeed {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandApplyCellContentsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandApplyCellContentsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}cell_diff_map\0\u{3}rollback_cell_diff_map\0\u{3}custom_format_keys\0\u{3}action_string\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._cellDiffMap == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._cellDiffMap, !v.isInitialized {return false}
    if let v = self._rollbackCellDiffMap, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.customFormatKeys) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cellDiffMap) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._rollbackCellDiffMap) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.customFormatKeys) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._actionString) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cellDiffMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._rollbackCellDiffMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.customFormatKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customFormatKeys, fieldNumber: 4)
    }
    try { if let v = self._actionString {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandApplyCellContentsArchive, rhs: TST_CommandApplyCellContentsArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._cellDiffMap != rhs._cellDiffMap {return false}
    if lhs._rollbackCellDiffMap != rhs._rollbackCellDiffMap {return false}
    if lhs.customFormatKeys != rhs.customFormatKeys {return false}
    if lhs._actionString != rhs._actionString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandApplyCellDiffMapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandApplyCellDiffMapArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}cell_diff_map\0\u{3}should_allow_merge_fragments\0\u{3}inverse_cell_diff_map\0\u{3}custom_format_keys\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._cellDiffMap == nil {return false}
    if self._shouldAllowMergeFragments == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._cellDiffMap, !v.isInitialized {return false}
    if let v = self._inverseCellDiffMap, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.customFormatKeys) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cellDiffMap) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._shouldAllowMergeFragments) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._inverseCellDiffMap) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.customFormatKeys) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cellDiffMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._shouldAllowMergeFragments {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._inverseCellDiffMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.customFormatKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customFormatKeys, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandApplyCellDiffMapArchive, rhs: TST_CommandApplyCellDiffMapArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._cellDiffMap != rhs._cellDiffMap {return false}
    if lhs._shouldAllowMergeFragments != rhs._shouldAllowMergeFragments {return false}
    if lhs._inverseCellDiffMap != rhs._inverseCellDiffMap {return false}
    if lhs.customFormatKeys != rhs.customFormatKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandApplyCellMapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandApplyCellMapArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}redo_cell_map\0\u{3}undo_cell_map\0\u{3}undo_formula_rewrite_command\0\u{3}custom_format_keys\0\u{3}merge_owner_rollback_index\0\u{3}is_from_paste\0\u{3}formula_rewrite_commands\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._redoCellMap == nil {return false}
    if self._isFromPaste == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._redoCellMap, !v.isInitialized {return false}
    if let v = self._undoCellMap, !v.isInitialized {return false}
    if let v = self._undoFormulaRewriteCommand, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.customFormatKeys) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.formulaRewriteCommands) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._redoCellMap) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._undoCellMap) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._undoFormulaRewriteCommand) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.customFormatKeys) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._mergeOwnerRollbackIndex) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._isFromPaste) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.formulaRewriteCommands) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._redoCellMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._undoCellMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._undoFormulaRewriteCommand {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.customFormatKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customFormatKeys, fieldNumber: 5)
    }
    try { if let v = self._mergeOwnerRollbackIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._isFromPaste {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    if !self.formulaRewriteCommands.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.formulaRewriteCommands, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandApplyCellMapArchive, rhs: TST_CommandApplyCellMapArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._redoCellMap != rhs._redoCellMap {return false}
    if lhs._undoCellMap != rhs._undoCellMap {return false}
    if lhs._undoFormulaRewriteCommand != rhs._undoFormulaRewriteCommand {return false}
    if lhs.customFormatKeys != rhs.customFormatKeys {return false}
    if lhs._mergeOwnerRollbackIndex != rhs._mergeOwnerRollbackIndex {return false}
    if lhs._isFromPaste != rhs._isFromPaste {return false}
    if lhs.formulaRewriteCommands != rhs.formulaRewriteCommands {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandApplyConcurrentCellMapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandApplyConcurrentCellMapArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}redo_concurrent_cell_map\0\u{3}undo_concurrent_cell_map\0\u{3}undo_formula_rewrite_command\0\u{3}custom_format_keys\0\u{3}merge_owner_rollback_index\0\u{3}is_from_paste\0\u{3}formula_rewrite_commands\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._redoConcurrentCellMap == nil {return false}
    if self._isFromPaste == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._redoConcurrentCellMap, !v.isInitialized {return false}
    if let v = self._undoConcurrentCellMap, !v.isInitialized {return false}
    if let v = self._undoFormulaRewriteCommand, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.customFormatKeys) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.formulaRewriteCommands) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._redoConcurrentCellMap) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._undoConcurrentCellMap) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._undoFormulaRewriteCommand) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.customFormatKeys) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._mergeOwnerRollbackIndex) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._isFromPaste) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.formulaRewriteCommands) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._redoConcurrentCellMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._undoConcurrentCellMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._undoFormulaRewriteCommand {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.customFormatKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customFormatKeys, fieldNumber: 5)
    }
    try { if let v = self._mergeOwnerRollbackIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._isFromPaste {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    if !self.formulaRewriteCommands.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.formulaRewriteCommands, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandApplyConcurrentCellMapArchive, rhs: TST_CommandApplyConcurrentCellMapArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._redoConcurrentCellMap != rhs._redoConcurrentCellMap {return false}
    if lhs._undoConcurrentCellMap != rhs._undoConcurrentCellMap {return false}
    if lhs._undoFormulaRewriteCommand != rhs._undoFormulaRewriteCommand {return false}
    if lhs.customFormatKeys != rhs.customFormatKeys {return false}
    if lhs._mergeOwnerRollbackIndex != rhs._mergeOwnerRollbackIndex {return false}
    if lhs._isFromPaste != rhs._isFromPaste {return false}
    if lhs.formulaRewriteCommands != rhs.formulaRewriteCommands {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandChangeFreezeHeaderStateArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandChangeFreezeHeaderStateArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}direction\0\u{3}new_freeze_state\0\u{3}prev_freeze_state\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._direction == nil {return false}
    if self._newFreezeState == nil {return false}
    if self._prevFreezeState == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._direction) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._newFreezeState) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._prevFreezeState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._direction {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newFreezeState {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._prevFreezeState {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandChangeFreezeHeaderStateArchive, rhs: TST_CommandChangeFreezeHeaderStateArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._direction != rhs._direction {return false}
    if lhs._newFreezeState != rhs._newFreezeState {return false}
    if lhs._prevFreezeState != rhs._prevFreezeState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandDeleteCellsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandDeleteCellsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{4}invalidate_comments\0\u{3}invalidate_comments_valid\0\u{3}cell_uid_region\0\u{3}summary_cell_uid_list\0\u{3}inverse_concurrent_cell_map\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._cellUidRegion, !v.isInitialized {return false}
    if let v = self._summaryCellUidList, !v.isInitialized {return false}
    if let v = self._inverseConcurrentCellMap, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._invalidateComments) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._invalidateCommentsValid) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._cellUidRegion) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._summaryCellUidList) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._inverseConcurrentCellMap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._invalidateComments {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._invalidateCommentsValid {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._cellUidRegion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._summaryCellUidList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._inverseConcurrentCellMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandDeleteCellsArchive, rhs: TST_CommandDeleteCellsArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._invalidateComments != rhs._invalidateComments {return false}
    if lhs._invalidateCommentsValid != rhs._invalidateCommentsValid {return false}
    if lhs._cellUidRegion != rhs._cellUidRegion {return false}
    if lhs._summaryCellUidList != rhs._summaryCellUidList {return false}
    if lhs._inverseConcurrentCellMap != rhs._inverseConcurrentCellMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandDeleteCellContentsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandDeleteCellContentsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}cell_uid_list\0\u{3}inverse_cell_diff_map\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._cellUidList == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._cellUidList, !v.isInitialized {return false}
    if let v = self._inverseCellDiffMap, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cellUidList) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._inverseCellDiffMap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cellUidList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._inverseCellDiffMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandDeleteCellContentsArchive, rhs: TST_CommandDeleteCellContentsArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._cellUidList != rhs._cellUidList {return false}
    if lhs._inverseCellDiffMap != rhs._inverseCellDiffMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandMutateCellFormatArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandMutateCellFormatArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}cell_uid_list\0\u{3}inverse_cell_diff_map\0\u{3}whole_format_diff_map\0\u{3}intended_format_type\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._intendedFormatType == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._cellUidList, !v.isInitialized {return false}
    if let v = self._inverseCellDiffMap, !v.isInitialized {return false}
    if let v = self._wholeFormatDiffMap, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cellUidList) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._inverseCellDiffMap) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._wholeFormatDiffMap) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._intendedFormatType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cellUidList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._inverseCellDiffMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._wholeFormatDiffMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._intendedFormatType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandMutateCellFormatArchive, rhs: TST_CommandMutateCellFormatArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._cellUidList != rhs._cellUidList {return false}
    if lhs._inverseCellDiffMap != rhs._inverseCellDiffMap {return false}
    if lhs._wholeFormatDiffMap != rhs._wholeFormatDiffMap {return false}
    if lhs._intendedFormatType != rhs._intendedFormatType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetAutomaticDurationUnitsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetAutomaticDurationUnitsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{3}automatic_units\0")

  fileprivate class _StorageClass {
    var _super: TST_CommandMutateCellFormatArchive? = nil
    var _automaticUnits: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _automaticUnits = source._automaticUnits
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._automaticUnits) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._automaticUnits {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetAutomaticDurationUnitsArchive, rhs: TST_CommandSetAutomaticDurationUnitsArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._automaticUnits != rhs_storage._automaticUnits {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetDurationStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetDurationStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}duration_style\0")

  fileprivate class _StorageClass {
    var _super: TST_CommandMutateCellFormatArchive? = nil
    var _durationStyle: UInt32? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _durationStyle = source._durationStyle
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._durationStyle) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._durationStyle {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetDurationStyleArchive, rhs: TST_CommandSetDurationStyleArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._durationStyle != rhs_storage._durationStyle {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetDurationUnitSmallestLargestArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetDurationUnitSmallestLargestArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}smallest_unit\0\u{3}largest_unit\0")

  fileprivate class _StorageClass {
    var _super: TST_CommandMutateCellFormatArchive? = nil
    var _smallestUnit: UInt32? = nil
    var _largestUnit: UInt32? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _smallestUnit = source._smallestUnit
      _largestUnit = source._largestUnit
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._smallestUnit) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._largestUnit) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._smallestUnit {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._largestUnit {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetDurationUnitSmallestLargestArchive, rhs: TST_CommandSetDurationUnitSmallestLargestArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._smallestUnit != rhs_storage._smallestUnit {return false}
        if _storage._largestUnit != rhs_storage._largestUnit {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandReplaceCustomFormatArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandReplaceCustomFormatArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}undo_diff_map\0\u{3}commit_diff_map\0\u{2}\u{4}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._undoDiffMap, !v.isInitialized {return false}
    if let v = self._commitDiffMap, !v.isInitialized {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._undoDiffMap) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._commitDiffMap) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._undoDiffMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._commitDiffMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandReplaceCustomFormatArchive, rhs: TST_CommandReplaceCustomFormatArchive) -> Bool {
    if lhs._undoDiffMap != rhs._undoDiffMap {return false}
    if lhs._commitDiffMap != rhs._commitDiffMap {return false}
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandMoveCellsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandMoveCellsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}dst_table_info_id_path\0\u{3}src_uid_range\0\u{3}dst_uid_range\0\u{3}table_dimension\0\u{3}src_cell_map\0\u{3}dst_cell_map\0\u{3}dst_cell_styles_container\0\u{3}src_undo_cell_map\0\u{3}dst_undo_cell_map\0\u{3}dst_merge_owner_rollback_index\0\u{3}formula_rewrite_commands\0\u{3}merge_action_to_restore\0\u{3}comment_cell_uids_to_restore\0\u{3}comment_storages_to_restore\0")

  fileprivate class _StorageClass {
    var _super: TST_TableCommandArchive? = nil
    var _dstTableInfoIDPath: TSP_UUIDPath? = nil
    var _srcUidRange: TSP_UUIDRectArchive? = nil
    var _dstUidRange: TSP_UUIDRectArchive? = nil
    var _tableDimension: TST_TableDimensionArchive? = nil
    var _srcCellMap: TSP_Reference? = nil
    var _dstCellMap: TSP_Reference? = nil
    var _dstCellStylesContainer: TSP_Reference? = nil
    var _srcUndoCellMap: TSP_Reference? = nil
    var _dstUndoCellMap: TSP_Reference? = nil
    var _dstMergeOwnerRollbackIndex: UInt32? = nil
    var _formulaRewriteCommands: [TSP_Reference] = []
    var _mergeActionToRestore: TST_MergeOperationArchive? = nil
    var _commentCellUidsToRestore: TST_CellUIDListArchive? = nil
    var _commentStoragesToRestore: [TSP_Reference] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _dstTableInfoIDPath = source._dstTableInfoIDPath
      _srcUidRange = source._srcUidRange
      _dstUidRange = source._dstUidRange
      _tableDimension = source._tableDimension
      _srcCellMap = source._srcCellMap
      _dstCellMap = source._dstCellMap
      _dstCellStylesContainer = source._dstCellStylesContainer
      _srcUndoCellMap = source._srcUndoCellMap
      _dstUndoCellMap = source._dstUndoCellMap
      _dstMergeOwnerRollbackIndex = source._dstMergeOwnerRollbackIndex
      _formulaRewriteCommands = source._formulaRewriteCommands
      _mergeActionToRestore = source._mergeActionToRestore
      _commentCellUidsToRestore = source._commentCellUidsToRestore
      _commentStoragesToRestore = source._commentStoragesToRestore
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._dstTableInfoIDPath == nil {return false}
      if _storage._srcUidRange == nil {return false}
      if _storage._dstUidRange == nil {return false}
      if _storage._srcCellMap == nil {return false}
      if _storage._dstMergeOwnerRollbackIndex == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._dstTableInfoIDPath, !v.isInitialized {return false}
      if let v = _storage._srcUidRange, !v.isInitialized {return false}
      if let v = _storage._dstUidRange, !v.isInitialized {return false}
      if let v = _storage._srcCellMap, !v.isInitialized {return false}
      if let v = _storage._dstCellMap, !v.isInitialized {return false}
      if let v = _storage._dstCellStylesContainer, !v.isInitialized {return false}
      if let v = _storage._srcUndoCellMap, !v.isInitialized {return false}
      if let v = _storage._dstUndoCellMap, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._formulaRewriteCommands) {return false}
      if let v = _storage._mergeActionToRestore, !v.isInitialized {return false}
      if let v = _storage._commentCellUidsToRestore, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._commentStoragesToRestore) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._dstTableInfoIDPath) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._srcUidRange) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._dstUidRange) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._tableDimension) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._srcCellMap) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._dstCellMap) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._dstCellStylesContainer) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._srcUndoCellMap) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._dstUndoCellMap) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._dstMergeOwnerRollbackIndex) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._formulaRewriteCommands) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._mergeActionToRestore) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._commentCellUidsToRestore) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._commentStoragesToRestore) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._dstTableInfoIDPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._srcUidRange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._dstUidRange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._tableDimension {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._srcCellMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._dstCellMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._dstCellStylesContainer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._srcUndoCellMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._dstUndoCellMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._dstMergeOwnerRollbackIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
      } }()
      if !_storage._formulaRewriteCommands.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._formulaRewriteCommands, fieldNumber: 12)
      }
      try { if let v = _storage._mergeActionToRestore {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._commentCellUidsToRestore {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if !_storage._commentStoragesToRestore.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._commentStoragesToRestore, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandMoveCellsArchive, rhs: TST_CommandMoveCellsArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._dstTableInfoIDPath != rhs_storage._dstTableInfoIDPath {return false}
        if _storage._srcUidRange != rhs_storage._srcUidRange {return false}
        if _storage._dstUidRange != rhs_storage._dstUidRange {return false}
        if _storage._tableDimension != rhs_storage._tableDimension {return false}
        if _storage._srcCellMap != rhs_storage._srcCellMap {return false}
        if _storage._dstCellMap != rhs_storage._dstCellMap {return false}
        if _storage._dstCellStylesContainer != rhs_storage._dstCellStylesContainer {return false}
        if _storage._srcUndoCellMap != rhs_storage._srcUndoCellMap {return false}
        if _storage._dstUndoCellMap != rhs_storage._dstUndoCellMap {return false}
        if _storage._dstMergeOwnerRollbackIndex != rhs_storage._dstMergeOwnerRollbackIndex {return false}
        if _storage._formulaRewriteCommands != rhs_storage._formulaRewriteCommands {return false}
        if _storage._mergeActionToRestore != rhs_storage._mergeActionToRestore {return false}
        if _storage._commentCellUidsToRestore != rhs_storage._commentCellUidsToRestore {return false}
        if _storage._commentStoragesToRestore != rhs_storage._commentStoragesToRestore {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ColumnRowMetadataArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ColumnRowMetadataArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}size\0\u{3}hiding_action\0\u{3}cell_style\0\u{3}text_style\0\u{1}uuid\0")

  public var isInitialized: Bool {
    if self._size == nil {return false}
    if self._hidingAction == nil {return false}
    if let v = self._cellStyle, !v.isInitialized {return false}
    if let v = self._textStyle, !v.isInitialized {return false}
    if let v = self._uuid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._size) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._hidingAction) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cellStyle) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._textStyle) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._size {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._hidingAction {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cellStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._textStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ColumnRowMetadataArchive, rhs: TST_ColumnRowMetadataArchive) -> Bool {
    if lhs._size != rhs._size {return false}
    if lhs._hidingAction != rhs._hidingAction {return false}
    if lhs._cellStyle != rhs._cellStyle {return false}
    if lhs._textStyle != rhs._textStyle {return false}
    if lhs._uuid != rhs._uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandInsertColumnsOrRowsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandInsertColumnsOrRowsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}bundle\0\u{4}\u{2}undo_commands\0\u{4}\u{2}sort_order\0\u{3}filter_set\0\u{3}should_edge_expand_formula_ranges\0\u{3}was_categorized\0\u{3}undo_order\0\u{3}src_row_column_uid\0\u{3}opp_row_column_uid\0\u{3}undo_bundle\0\u{3}group_sort_order\0\u{3}concurrent_cell_map\0\u{3}categories_cell_map\0\u{3}undo_concurrent_cell_map\0\u{3}undo_categories_cell_map\0")

  fileprivate class _StorageClass {
    var _super: TST_TableCommandArchive? = nil
    var _bundle: TST_ColumnRowBundleArchive? = nil
    var _concurrentCellMap: TSP_Reference? = nil
    var _categoriesCellMap: TSP_Reference? = nil
    var _undoCommands: TSP_Reference? = nil
    var _undoConcurrentCellMap: TSP_Reference? = nil
    var _undoCategoriesCellMap: TSP_Reference? = nil
    var _sortOrder: TST_TableSortOrderUIDArchive? = nil
    var _groupSortOrder: TST_TableGroupSortOrderUIDArchive? = nil
    var _filterSet: TSP_Reference? = nil
    var _shouldEdgeExpandFormulaRanges: Bool? = nil
    var _wasCategorized: Bool? = nil
    var _undoOrder: [TSP_UUID] = []
    var _srcRowColumnUid: TSP_UUID? = nil
    var _oppRowColumnUid: TSP_UUID? = nil
    var _undoBundle: TST_ColumnRowBundleArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _bundle = source._bundle
      _concurrentCellMap = source._concurrentCellMap
      _categoriesCellMap = source._categoriesCellMap
      _undoCommands = source._undoCommands
      _undoConcurrentCellMap = source._undoConcurrentCellMap
      _undoCategoriesCellMap = source._undoCategoriesCellMap
      _sortOrder = source._sortOrder
      _groupSortOrder = source._groupSortOrder
      _filterSet = source._filterSet
      _shouldEdgeExpandFormulaRanges = source._shouldEdgeExpandFormulaRanges
      _wasCategorized = source._wasCategorized
      _undoOrder = source._undoOrder
      _srcRowColumnUid = source._srcRowColumnUid
      _oppRowColumnUid = source._oppRowColumnUid
      _undoBundle = source._undoBundle
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._bundle == nil {return false}
      if _storage._concurrentCellMap == nil {return false}
      if _storage._categoriesCellMap == nil {return false}
      if _storage._srcRowColumnUid == nil {return false}
      if _storage._oppRowColumnUid == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._bundle, !v.isInitialized {return false}
      if let v = _storage._concurrentCellMap, !v.isInitialized {return false}
      if let v = _storage._categoriesCellMap, !v.isInitialized {return false}
      if let v = _storage._undoCommands, !v.isInitialized {return false}
      if let v = _storage._undoConcurrentCellMap, !v.isInitialized {return false}
      if let v = _storage._undoCategoriesCellMap, !v.isInitialized {return false}
      if let v = _storage._sortOrder, !v.isInitialized {return false}
      if let v = _storage._groupSortOrder, !v.isInitialized {return false}
      if let v = _storage._filterSet, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._undoOrder) {return false}
      if let v = _storage._srcRowColumnUid, !v.isInitialized {return false}
      if let v = _storage._oppRowColumnUid, !v.isInitialized {return false}
      if let v = _storage._undoBundle, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._bundle) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._undoCommands) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._sortOrder) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._filterSet) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._shouldEdgeExpandFormulaRanges) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._wasCategorized) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._undoOrder) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._srcRowColumnUid) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._oppRowColumnUid) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._undoBundle) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._groupSortOrder) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._concurrentCellMap) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._categoriesCellMap) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._undoConcurrentCellMap) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._undoCategoriesCellMap) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._bundle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._undoCommands {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._sortOrder {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._filterSet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._shouldEdgeExpandFormulaRanges {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._wasCategorized {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
      if !_storage._undoOrder.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._undoOrder, fieldNumber: 10)
      }
      try { if let v = _storage._srcRowColumnUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._oppRowColumnUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._undoBundle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._groupSortOrder {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._concurrentCellMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._categoriesCellMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._undoConcurrentCellMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._undoCategoriesCellMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandInsertColumnsOrRowsArchive, rhs: TST_CommandInsertColumnsOrRowsArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._bundle != rhs_storage._bundle {return false}
        if _storage._concurrentCellMap != rhs_storage._concurrentCellMap {return false}
        if _storage._categoriesCellMap != rhs_storage._categoriesCellMap {return false}
        if _storage._undoCommands != rhs_storage._undoCommands {return false}
        if _storage._undoConcurrentCellMap != rhs_storage._undoConcurrentCellMap {return false}
        if _storage._undoCategoriesCellMap != rhs_storage._undoCategoriesCellMap {return false}
        if _storage._sortOrder != rhs_storage._sortOrder {return false}
        if _storage._groupSortOrder != rhs_storage._groupSortOrder {return false}
        if _storage._filterSet != rhs_storage._filterSet {return false}
        if _storage._shouldEdgeExpandFormulaRanges != rhs_storage._shouldEdgeExpandFormulaRanges {return false}
        if _storage._wasCategorized != rhs_storage._wasCategorized {return false}
        if _storage._undoOrder != rhs_storage._undoOrder {return false}
        if _storage._srcRowColumnUid != rhs_storage._srcRowColumnUid {return false}
        if _storage._oppRowColumnUid != rhs_storage._oppRowColumnUid {return false}
        if _storage._undoBundle != rhs_storage._undoBundle {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ColumnRowBundleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ColumnRowBundleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}is_row\0\u{3}view_uid_list\0\u{3}view_type_list\0\u{3}base_uid_list\0\u{3}base_type_list\0\u{3}category_order_uid_list\0\u{3}category_order_type_list\0\u{3}metadata_list\0")

  public var isInitialized: Bool {
    if self._isRow == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.viewUidList) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.baseUidList) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.categoryOrderUidList) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.metadataList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._isRow) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.viewUidList) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.viewTypeList) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.baseUidList) }()
      case 5: try { try decoder.decodeRepeatedEnumField(value: &self.baseTypeList) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.categoryOrderUidList) }()
      case 7: try { try decoder.decodeRepeatedEnumField(value: &self.categoryOrderTypeList) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.metadataList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._isRow {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    if !self.viewUidList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.viewUidList, fieldNumber: 2)
    }
    if !self.viewTypeList.isEmpty {
      try visitor.visitRepeatedEnumField(value: self.viewTypeList, fieldNumber: 3)
    }
    if !self.baseUidList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.baseUidList, fieldNumber: 4)
    }
    if !self.baseTypeList.isEmpty {
      try visitor.visitRepeatedEnumField(value: self.baseTypeList, fieldNumber: 5)
    }
    if !self.categoryOrderUidList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.categoryOrderUidList, fieldNumber: 6)
    }
    if !self.categoryOrderTypeList.isEmpty {
      try visitor.visitRepeatedEnumField(value: self.categoryOrderTypeList, fieldNumber: 7)
    }
    if !self.metadataList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadataList, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ColumnRowBundleArchive, rhs: TST_ColumnRowBundleArchive) -> Bool {
    if lhs._isRow != rhs._isRow {return false}
    if lhs.viewUidList != rhs.viewUidList {return false}
    if lhs.viewTypeList != rhs.viewTypeList {return false}
    if lhs.baseUidList != rhs.baseUidList {return false}
    if lhs.baseTypeList != rhs.baseTypeList {return false}
    if lhs.categoryOrderUidList != rhs.categoryOrderUidList {return false}
    if lhs.categoryOrderTypeList != rhs.categoryOrderTypeList {return false}
    if lhs.metadataList != rhs.metadataList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandRemoveColumnsOrRowsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandRemoveColumnsOrRowsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}bundle\0\u{4}\u{3}undo_filter_set\0\u{3}undo_sort_order\0\u{3}formula_rewrite_command_for_undo\0\u{3}inverse_should_edge_expand_formula_ranges\0\u{3}undo_order\0\u{3}undo_group_sort_order\0\u{3}concurrent_cell_map\0\u{3}categories_cell_map\0\u{3}undo_concurrent_cell_map\0\u{3}undo_categories_cell_map\0")

  fileprivate class _StorageClass {
    var _super: TST_TableCommandArchive? = nil
    var _bundle: TST_ColumnRowBundleArchive? = nil
    var _concurrentCellMap: TSP_Reference? = nil
    var _categoriesCellMap: TSP_Reference? = nil
    var _undoConcurrentCellMap: TSP_Reference? = nil
    var _undoCategoriesCellMap: TSP_Reference? = nil
    var _undoFilterSet: TSP_Reference? = nil
    var _undoSortOrder: TST_TableSortOrderUIDArchive? = nil
    var _undoGroupSortOrder: TST_TableGroupSortOrderUIDArchive? = nil
    var _formulaRewriteCommandForUndo: TSP_Reference? = nil
    var _inverseShouldEdgeExpandFormulaRanges: Bool? = nil
    var _undoOrder: [TSP_UUID] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _bundle = source._bundle
      _concurrentCellMap = source._concurrentCellMap
      _categoriesCellMap = source._categoriesCellMap
      _undoConcurrentCellMap = source._undoConcurrentCellMap
      _undoCategoriesCellMap = source._undoCategoriesCellMap
      _undoFilterSet = source._undoFilterSet
      _undoSortOrder = source._undoSortOrder
      _undoGroupSortOrder = source._undoGroupSortOrder
      _formulaRewriteCommandForUndo = source._formulaRewriteCommandForUndo
      _inverseShouldEdgeExpandFormulaRanges = source._inverseShouldEdgeExpandFormulaRanges
      _undoOrder = source._undoOrder
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._bundle == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._bundle, !v.isInitialized {return false}
      if let v = _storage._concurrentCellMap, !v.isInitialized {return false}
      if let v = _storage._categoriesCellMap, !v.isInitialized {return false}
      if let v = _storage._undoConcurrentCellMap, !v.isInitialized {return false}
      if let v = _storage._undoCategoriesCellMap, !v.isInitialized {return false}
      if let v = _storage._undoFilterSet, !v.isInitialized {return false}
      if let v = _storage._undoSortOrder, !v.isInitialized {return false}
      if let v = _storage._undoGroupSortOrder, !v.isInitialized {return false}
      if let v = _storage._formulaRewriteCommandForUndo, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._undoOrder) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._bundle) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._undoFilterSet) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._undoSortOrder) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._formulaRewriteCommandForUndo) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._inverseShouldEdgeExpandFormulaRanges) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._undoOrder) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._undoGroupSortOrder) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._concurrentCellMap) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._categoriesCellMap) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._undoConcurrentCellMap) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._undoCategoriesCellMap) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._bundle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._undoFilterSet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._undoSortOrder {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._formulaRewriteCommandForUndo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._inverseShouldEdgeExpandFormulaRanges {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      if !_storage._undoOrder.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._undoOrder, fieldNumber: 9)
      }
      try { if let v = _storage._undoGroupSortOrder {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._concurrentCellMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._categoriesCellMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._undoConcurrentCellMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._undoCategoriesCellMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandRemoveColumnsOrRowsArchive, rhs: TST_CommandRemoveColumnsOrRowsArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._bundle != rhs_storage._bundle {return false}
        if _storage._concurrentCellMap != rhs_storage._concurrentCellMap {return false}
        if _storage._categoriesCellMap != rhs_storage._categoriesCellMap {return false}
        if _storage._undoConcurrentCellMap != rhs_storage._undoConcurrentCellMap {return false}
        if _storage._undoCategoriesCellMap != rhs_storage._undoCategoriesCellMap {return false}
        if _storage._undoFilterSet != rhs_storage._undoFilterSet {return false}
        if _storage._undoSortOrder != rhs_storage._undoSortOrder {return false}
        if _storage._undoGroupSortOrder != rhs_storage._undoGroupSortOrder {return false}
        if _storage._formulaRewriteCommandForUndo != rhs_storage._formulaRewriteCommandForUndo {return false}
        if _storage._inverseShouldEdgeExpandFormulaRanges != rhs_storage._inverseShouldEdgeExpandFormulaRanges {return false}
        if _storage._undoOrder != rhs_storage._undoOrder {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandRowColumnRangeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandRowColumnRangeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}uids\0\u{3}is_row\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._isRow == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.uids) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.uids) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._isRow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.uids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uids, fieldNumber: 2)
    }
    try { if let v = self._isRow {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandRowColumnRangeArchive, rhs: TST_CommandRowColumnRangeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.uids != rhs.uids {return false}
    if lhs._isRow != rhs._isRow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandResizeColumnOrRowArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandResizeColumnOrRowArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}sizes\0\u{3}sizes_for_undo\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedFloatField(value: &self.sizes) }()
      case 3: try { try decoder.decodeRepeatedFloatField(value: &self.sizesForUndo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.sizes.isEmpty {
      try visitor.visitRepeatedFloatField(value: self.sizes, fieldNumber: 2)
    }
    if !self.sizesForUndo.isEmpty {
      try visitor.visitRepeatedFloatField(value: self.sizesForUndo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandResizeColumnOrRowArchive, rhs: TST_CommandResizeColumnOrRowArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.sizes != rhs.sizes {return false}
    if lhs.sizesForUndo != rhs.sizesForUndo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandCategoryResizeColumnOrRowArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandCategoryResizeColumnOrRowArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}category_row_sizes\0\u{3}category_row_sizes_for_undo\0\u{3}category_label_row_sizes\0\u{3}category_label_row_sizes_for_undo\0\u{3}category_column_size\0\u{3}category_column_size_for_undo\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedFloatField(value: &self.categoryRowSizes) }()
      case 3: try { try decoder.decodeRepeatedFloatField(value: &self.categoryRowSizesForUndo) }()
      case 4: try { try decoder.decodeRepeatedFloatField(value: &self.categoryLabelRowSizes) }()
      case 5: try { try decoder.decodeRepeatedFloatField(value: &self.categoryLabelRowSizesForUndo) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self._categoryColumnSize) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self._categoryColumnSizeForUndo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.categoryRowSizes.isEmpty {
      try visitor.visitRepeatedFloatField(value: self.categoryRowSizes, fieldNumber: 2)
    }
    if !self.categoryRowSizesForUndo.isEmpty {
      try visitor.visitRepeatedFloatField(value: self.categoryRowSizesForUndo, fieldNumber: 3)
    }
    if !self.categoryLabelRowSizes.isEmpty {
      try visitor.visitRepeatedFloatField(value: self.categoryLabelRowSizes, fieldNumber: 4)
    }
    if !self.categoryLabelRowSizesForUndo.isEmpty {
      try visitor.visitRepeatedFloatField(value: self.categoryLabelRowSizesForUndo, fieldNumber: 5)
    }
    try { if let v = self._categoryColumnSize {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._categoryColumnSizeForUndo {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandCategoryResizeColumnOrRowArchive, rhs: TST_CommandCategoryResizeColumnOrRowArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.categoryRowSizes != rhs.categoryRowSizes {return false}
    if lhs.categoryRowSizesForUndo != rhs.categoryRowSizesForUndo {return false}
    if lhs.categoryLabelRowSizes != rhs.categoryLabelRowSizes {return false}
    if lhs.categoryLabelRowSizesForUndo != rhs.categoryLabelRowSizesForUndo {return false}
    if lhs._categoryColumnSize != rhs._categoryColumnSize {return false}
    if lhs._categoryColumnSizeForUndo != rhs._categoryColumnSizeForUndo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandHideShowArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandHideShowArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}hide_show_action\0\u{3}hiding_action\0\u{3}hide_show_action_for_undo\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._hideShowAction == nil {return false}
    if self._hidingAction == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._hideShowAction) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._hidingAction) }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.hideShowActionForUndo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._hideShowAction {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hidingAction {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    if !self.hideShowActionForUndo.isEmpty {
      try visitor.visitRepeatedEnumField(value: self.hideShowActionForUndo, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandHideShowArchive, rhs: TST_CommandHideShowArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._hideShowAction != rhs._hideShowAction {return false}
    if lhs._hidingAction != rhs._hidingAction {return false}
    if lhs.hideShowActionForUndo != rhs.hideShowActionForUndo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandTextPreflightInsertCellArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandTextPreflightInsertCellArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{3}super\0\u{4}\u{3}coalesced_textcommand\0\u{2}\u{2}postflightcommand\0\u{3}grouped_with_postflight\0\u{3}editing_cell\0\u{3}editing_storage\0\u{3}last_column_hit_by_tap\0\u{3}cell_uid\0\u{3}archived_initial_selection_path\0")

  fileprivate class _StorageClass {
    var _super: TST_TableCommandArchive? = nil
    var _coalescedTextcommand: TSP_Reference? = nil
    var _postflightcommand: TSP_Reference? = nil
    var _groupedWithPostflight: Bool? = nil
    var _editingCell: TST_Cell? = nil
    var _editingStorage: TSP_Reference? = nil
    var _lastColumnHitByTap: UInt32? = nil
    var _cellUid: TSP_UUIDCoordArchive? = nil
    var _archivedInitialSelectionPath: TSK_SelectionPathArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _coalescedTextcommand = source._coalescedTextcommand
      _postflightcommand = source._postflightcommand
      _groupedWithPostflight = source._groupedWithPostflight
      _editingCell = source._editingCell
      _editingStorage = source._editingStorage
      _lastColumnHitByTap = source._lastColumnHitByTap
      _cellUid = source._cellUid
      _archivedInitialSelectionPath = source._archivedInitialSelectionPath
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._editingCell == nil {return false}
      if _storage._editingStorage == nil {return false}
      if _storage._cellUid == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._coalescedTextcommand, !v.isInitialized {return false}
      if let v = _storage._postflightcommand, !v.isInitialized {return false}
      if let v = _storage._editingCell, !v.isInitialized {return false}
      if let v = _storage._editingStorage, !v.isInitialized {return false}
      if let v = _storage._cellUid, !v.isInitialized {return false}
      if let v = _storage._archivedInitialSelectionPath, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._coalescedTextcommand) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._postflightcommand) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._groupedWithPostflight) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._editingCell) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._editingStorage) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._lastColumnHitByTap) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._cellUid) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._archivedInitialSelectionPath) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._coalescedTextcommand {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._postflightcommand {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._groupedWithPostflight {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._editingCell {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._editingStorage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._lastColumnHitByTap {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._cellUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._archivedInitialSelectionPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandTextPreflightInsertCellArchive, rhs: TST_CommandTextPreflightInsertCellArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._coalescedTextcommand != rhs_storage._coalescedTextcommand {return false}
        if _storage._postflightcommand != rhs_storage._postflightcommand {return false}
        if _storage._groupedWithPostflight != rhs_storage._groupedWithPostflight {return false}
        if _storage._editingCell != rhs_storage._editingCell {return false}
        if _storage._editingStorage != rhs_storage._editingStorage {return false}
        if _storage._lastColumnHitByTap != rhs_storage._lastColumnHitByTap {return false}
        if _storage._cellUid != rhs_storage._cellUid {return false}
        if _storage._archivedInitialSelectionPath != rhs_storage._archivedInitialSelectionPath {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandPostflightSetCellArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandPostflightSetCellArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{3}super\0\u{1}childcommandundo\0\u{4}\u{2}editing_cell\0\u{3}new_cell\0\u{3}editing_storage\0\u{3}last_column_hit_by_tap\0\u{3}cell_uid\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._editingCell == nil {return false}
    if self._newCell == nil {return false}
    if self._editingStorage == nil {return false}
    if self._cellUid == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._childcommandundo, !v.isInitialized {return false}
    if let v = self._editingCell, !v.isInitialized {return false}
    if let v = self._newCell, !v.isInitialized {return false}
    if let v = self._editingStorage, !v.isInitialized {return false}
    if let v = self._cellUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._childcommandundo) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._editingCell) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._newCell) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._editingStorage) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._lastColumnHitByTap) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._cellUid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._childcommandundo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._editingCell {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._newCell {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._editingStorage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._lastColumnHitByTap {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._cellUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandPostflightSetCellArchive, rhs: TST_CommandPostflightSetCellArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._childcommandundo != rhs._childcommandundo {return false}
    if lhs._editingCell != rhs._editingCell {return false}
    if lhs._newCell != rhs._newCell {return false}
    if lhs._editingStorage != rhs._editingStorage {return false}
    if lhs._lastColumnHitByTap != rhs._lastColumnHitByTap {return false}
    if lhs._cellUid != rhs._cellUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandChangeTableAreaForColumnOrRowArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandChangeTableAreaForColumnOrRowArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}table_area_transition\0\u{3}cell_diff_map\0\u{3}undo_cell_diff_map\0\u{3}undo_commands\0\u{3}action_string\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._tableAreaTransition == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._cellDiffMap, !v.isInitialized {return false}
    if let v = self._undoCellDiffMap, !v.isInitialized {return false}
    if let v = self._undoCommands, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._tableAreaTransition) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cellDiffMap) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._undoCellDiffMap) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._undoCommands) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._actionString) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tableAreaTransition {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cellDiffMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._undoCellDiffMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._undoCommands {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._actionString {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandChangeTableAreaForColumnOrRowArchive, rhs: TST_CommandChangeTableAreaForColumnOrRowArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._tableAreaTransition != rhs._tableAreaTransition {return false}
    if lhs._cellDiffMap != rhs._cellDiffMap {return false}
    if lhs._undoCellDiffMap != rhs._undoCellDiffMap {return false}
    if lhs._undoCommands != rhs._undoCommands {return false}
    if lhs._actionString != rhs._actionString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetPencilAnnotationsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetPencilAnnotationsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}annotations\0\u{1}formulas\0\u{3}formula_indexes\0\u{3}inverse_formulas\0\u{3}inverse_formula_indexes\0\u{3}rollback_index\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.annotations) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.formulas) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.inverseFormulas) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.annotations) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.formulas) }()
      case 4: try { try decoder.decodeRepeatedUInt64Field(value: &self.formulaIndexes) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.inverseFormulas) }()
      case 6: try { try decoder.decodeRepeatedUInt64Field(value: &self.inverseFormulaIndexes) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self._rollbackIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.annotations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotations, fieldNumber: 2)
    }
    if !self.formulas.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.formulas, fieldNumber: 3)
    }
    if !self.formulaIndexes.isEmpty {
      try visitor.visitRepeatedUInt64Field(value: self.formulaIndexes, fieldNumber: 4)
    }
    if !self.inverseFormulas.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inverseFormulas, fieldNumber: 5)
    }
    if !self.inverseFormulaIndexes.isEmpty {
      try visitor.visitRepeatedUInt64Field(value: self.inverseFormulaIndexes, fieldNumber: 6)
    }
    try { if let v = self._rollbackIndex {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetPencilAnnotationsArchive, rhs: TST_CommandSetPencilAnnotationsArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.annotations != rhs.annotations {return false}
    if lhs.formulas != rhs.formulas {return false}
    if lhs.formulaIndexes != rhs.formulaIndexes {return false}
    if lhs.inverseFormulas != rhs.inverseFormulas {return false}
    if lhs.inverseFormulaIndexes != rhs.inverseFormulaIndexes {return false}
    if lhs._rollbackIndex != rhs._rollbackIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetTableNameArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetTableNameArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}newtablename\0\u{1}oldtablename\0\u{1}newstyle\0\u{1}oldstyle\0\u{1}super\0\u{3}old_shape_style\0\u{3}new_shape_style\0\u{3}old_table_name_border_enabled\0\u{3}new_table_name_border_enabled\0")

  fileprivate class _StorageClass {
    var _newtablename: String? = nil
    var _oldtablename: String? = nil
    var _newstyle: TSP_Reference? = nil
    var _oldstyle: TSP_Reference? = nil
    var _super: TST_TableCommandArchive? = nil
    var _oldShapeStyle: TSP_Reference? = nil
    var _newShapeStyle: TSP_Reference? = nil
    var _oldTableNameBorderEnabled: Bool? = nil
    var _newTableNameBorderEnabled: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _newtablename = source._newtablename
      _oldtablename = source._oldtablename
      _newstyle = source._newstyle
      _oldstyle = source._oldstyle
      _super = source._super
      _oldShapeStyle = source._oldShapeStyle
      _newShapeStyle = source._newShapeStyle
      _oldTableNameBorderEnabled = source._oldTableNameBorderEnabled
      _newTableNameBorderEnabled = source._newTableNameBorderEnabled
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._newtablename == nil {return false}
      if _storage._super == nil {return false}
      if let v = _storage._newstyle, !v.isInitialized {return false}
      if let v = _storage._oldstyle, !v.isInitialized {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._oldShapeStyle, !v.isInitialized {return false}
      if let v = _storage._newShapeStyle, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._newtablename) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._oldtablename) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._newstyle) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._oldstyle) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._oldShapeStyle) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._newShapeStyle) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._oldTableNameBorderEnabled) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._newTableNameBorderEnabled) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._newtablename {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._oldtablename {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._newstyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._oldstyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._oldShapeStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._newShapeStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._oldTableNameBorderEnabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._newTableNameBorderEnabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetTableNameArchive, rhs: TST_CommandSetTableNameArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._newtablename != rhs_storage._newtablename {return false}
        if _storage._oldtablename != rhs_storage._oldtablename {return false}
        if _storage._newstyle != rhs_storage._newstyle {return false}
        if _storage._oldstyle != rhs_storage._oldstyle {return false}
        if _storage._super != rhs_storage._super {return false}
        if _storage._oldShapeStyle != rhs_storage._oldShapeStyle {return false}
        if _storage._newShapeStyle != rhs_storage._newShapeStyle {return false}
        if _storage._oldTableNameBorderEnabled != rhs_storage._oldTableNameBorderEnabled {return false}
        if _storage._newTableNameBorderEnabled != rhs_storage._newTableNameBorderEnabled {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetTableNameEnabledArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetTableNameEnabledArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}table_name_enabled\0\u{3}prev_table_name_enabled\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._tableNameEnabled == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._tableNameEnabled) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._prevTableNameEnabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tableNameEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._prevTableNameEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetTableNameEnabledArchive, rhs: TST_CommandSetTableNameEnabledArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._tableNameEnabled != rhs._tableNameEnabled {return false}
    if lhs._prevTableNameEnabled != rhs._prevTableNameEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetTableFontSizeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetTableFontSizeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}is_increase\0\u{3}font_size_diff\0\u{3}font_size_list\0\u{3}inverse_font_size_list\0\u{3}cell_diff_map\0\u{3}inverse_cell_diff_map\0\u{3}styles_container_refresh_done\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._isIncrease == nil {return false}
    if self._fontSizeDiff == nil {return false}
    if self._stylesContainerRefreshDone == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._cellDiffMap, !v.isInitialized {return false}
    if let v = self._inverseCellDiffMap, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isIncrease) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._fontSizeDiff) }()
      case 4: try { try decoder.decodeRepeatedDoubleField(value: &self.fontSizeList) }()
      case 5: try { try decoder.decodeRepeatedDoubleField(value: &self.inverseFontSizeList) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._cellDiffMap) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._inverseCellDiffMap) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._stylesContainerRefreshDone) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._isIncrease {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._fontSizeDiff {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    if !self.fontSizeList.isEmpty {
      try visitor.visitRepeatedDoubleField(value: self.fontSizeList, fieldNumber: 4)
    }
    if !self.inverseFontSizeList.isEmpty {
      try visitor.visitRepeatedDoubleField(value: self.inverseFontSizeList, fieldNumber: 5)
    }
    try { if let v = self._cellDiffMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._inverseCellDiffMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._stylesContainerRefreshDone {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetTableFontSizeArchive, rhs: TST_CommandSetTableFontSizeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._isIncrease != rhs._isIncrease {return false}
    if lhs._fontSizeDiff != rhs._fontSizeDiff {return false}
    if lhs.fontSizeList != rhs.fontSizeList {return false}
    if lhs.inverseFontSizeList != rhs.inverseFontSizeList {return false}
    if lhs._cellDiffMap != rhs._cellDiffMap {return false}
    if lhs._inverseCellDiffMap != rhs._inverseCellDiffMap {return false}
    if lhs._stylesContainerRefreshDone != rhs._stylesContainerRefreshDone {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetTableFontNameArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetTableFontNameArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}font_name\0\u{3}preserve_face\0\u{3}previous_font_name\0\u{3}previous_table_style\0\u{3}previous_text_styles\0\u{3}cell_diff_map\0\u{3}inverse_cell_diff_map\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._fontName == nil {return false}
    if self._preserveFace == nil {return false}
    if self._cellDiffMap == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._previousTableStyle, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.previousTextStyles) {return false}
    if let v = self._cellDiffMap, !v.isInitialized {return false}
    if let v = self._inverseCellDiffMap, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._fontName) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._preserveFace) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._previousFontName) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._previousTableStyle) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.previousTextStyles) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._cellDiffMap) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._inverseCellDiffMap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fontName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._preserveFace {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._previousFontName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._previousTableStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.previousTextStyles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.previousTextStyles, fieldNumber: 6)
    }
    try { if let v = self._cellDiffMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._inverseCellDiffMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetTableFontNameArchive, rhs: TST_CommandSetTableFontNameArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._fontName != rhs._fontName {return false}
    if lhs._preserveFace != rhs._preserveFace {return false}
    if lhs._previousFontName != rhs._previousFontName {return false}
    if lhs._previousTableStyle != rhs._previousTableStyle {return false}
    if lhs.previousTextStyles != rhs.previousTextStyles {return false}
    if lhs._cellDiffMap != rhs._cellDiffMap {return false}
    if lhs._inverseCellDiffMap != rhs._inverseCellDiffMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetTableNameHeightArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetTableNameHeightArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}old_table_name_height\0\u{3}new_table_name_height\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._oldTableNameHeight == nil {return false}
    if self._newTableNameHeight == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._oldTableNameHeight) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self._newTableNameHeight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oldTableNameHeight {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newTableNameHeight {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetTableNameHeightArchive, rhs: TST_CommandSetTableNameHeightArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._oldTableNameHeight != rhs._oldTableNameHeight {return false}
    if lhs._newTableNameHeight != rhs._newTableNameHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetNowArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetNowArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetNowArchive, rhs: TST_CommandSetNowArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetWasCutArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetWasCutArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}from_table_uid\0\u{3}prev_from_table_uid\0\u{3}was_cut\0\u{3}prev_was_cut\0\u{3}from_group_by_uid\0\u{3}prev_from_group_by_uid\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._fromTableUid == nil {return false}
    if self._prevFromTableUid == nil {return false}
    if self._wasCut == nil {return false}
    if self._prevWasCut == nil {return false}
    if self._fromGroupByUid == nil {return false}
    if self._prevFromGroupByUid == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._fromTableUid, !v.isInitialized {return false}
    if let v = self._prevFromTableUid, !v.isInitialized {return false}
    if let v = self._fromGroupByUid, !v.isInitialized {return false}
    if let v = self._prevFromGroupByUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fromTableUid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._prevFromTableUid) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._wasCut) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._prevWasCut) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._fromGroupByUid) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._prevFromGroupByUid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fromTableUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._prevFromTableUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._wasCut {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._prevWasCut {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._fromGroupByUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._prevFromGroupByUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetWasCutArchive, rhs: TST_CommandSetWasCutArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._fromTableUid != rhs._fromTableUid {return false}
    if lhs._prevFromTableUid != rhs._prevFromTableUid {return false}
    if lhs._wasCut != rhs._wasCut {return false}
    if lhs._prevWasCut != rhs._prevWasCut {return false}
    if lhs._fromGroupByUid != rhs._fromGroupByUid {return false}
    if lhs._prevFromGroupByUid != rhs._prevFromGroupByUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandStyleCellsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandStyleCellsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}format_properties\0\u{1}selection\0\u{3}undo_cell_map\0\u{3}redo_cell_map\0\u{3}text_undo\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._selection == nil {return false}
    if self._undoCellMap == nil {return false}
    if self._redoCellMap == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._formatProperties, !v.isInitialized {return false}
    if let v = self._selection, !v.isInitialized {return false}
    if let v = self._undoCellMap, !v.isInitialized {return false}
    if let v = self._redoCellMap, !v.isInitialized {return false}
    if let v = self._textUndo, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._formatProperties) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._selection) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._undoCellMap) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._redoCellMap) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._textUndo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._formatProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._selection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._undoCellMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._redoCellMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._textUndo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandStyleCellsArchive, rhs: TST_CommandStyleCellsArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._formatProperties != rhs._formatProperties {return false}
    if lhs._selection != rhs._selection {return false}
    if lhs._undoCellMap != rhs._undoCellMap {return false}
    if lhs._redoCellMap != rhs._redoCellMap {return false}
    if lhs._textUndo != rhs._textUndo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandStyleTableArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandStyleTableArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}format_properties\0\u{3}old_style\0\u{3}new_style\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._formatProperties, !v.isInitialized {return false}
    if let v = self._oldStyle, !v.isInitialized {return false}
    if let v = self._newStyle, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._formatProperties) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._oldStyle) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._newStyle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._formatProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._oldStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._newStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandStyleTableArchive, rhs: TST_CommandStyleTableArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._formatProperties != rhs._formatProperties {return false}
    if lhs._oldStyle != rhs._oldStyle {return false}
    if lhs._newStyle != rhs._newStyle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetRepeatingHeaderEnabledArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetRepeatingHeaderEnabledArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}repeating_header_enabled\0\u{1}direction\0\u{1}super\0\u{3}prev_repeating_header_enabled\0")

  public var isInitialized: Bool {
    if self._repeatingHeaderEnabled == nil {return false}
    if self._direction == nil {return false}
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._repeatingHeaderEnabled) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._direction) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._prevRepeatingHeaderEnabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._repeatingHeaderEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._direction {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._prevRepeatingHeaderEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetRepeatingHeaderEnabledArchive, rhs: TST_CommandSetRepeatingHeaderEnabledArchive) -> Bool {
    if lhs._repeatingHeaderEnabled != rhs._repeatingHeaderEnabled {return false}
    if lhs._direction != rhs._direction {return false}
    if lhs._super != rhs._super {return false}
    if lhs._prevRepeatingHeaderEnabled != rhs._prevRepeatingHeaderEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetFiltersEnabledArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetFiltersEnabledArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}new_filters_enabled\0\u{3}old_filters_enabled\0\u{3}rollback_uid_list\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._newFiltersEnabled == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rollbackUidList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._newFiltersEnabled) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._oldFiltersEnabled) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.rollbackUidList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newFiltersEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._oldFiltersEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    if !self.rollbackUidList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rollbackUidList, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetFiltersEnabledArchive, rhs: TST_CommandSetFiltersEnabledArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._newFiltersEnabled != rhs._newFiltersEnabled {return false}
    if lhs._oldFiltersEnabled != rhs._oldFiltersEnabled {return false}
    if lhs.rollbackUidList != rhs.rollbackUidList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandAddTableStylePresetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandAddTableStylePresetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}preset_index\0\u{3}table_styles\0\u{3}send_notification\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._presetIndex == nil {return false}
    if self._tableStyles == nil {return false}
    if self._sendNotification == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._tableStyles, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._presetIndex) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tableStyles) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._sendNotification) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._presetIndex {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._tableStyles {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._sendNotification {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandAddTableStylePresetArchive, rhs: TST_CommandAddTableStylePresetArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._presetIndex != rhs._presetIndex {return false}
    if lhs._tableStyles != rhs._tableStyles {return false}
    if lhs._sendNotification != rhs._sendNotification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandRemoveTableStylePresetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandRemoveTableStylePresetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}theme\0\u{3}removed_table_styles\0\u{3}preset_id\0\u{3}preset_index_in_theme\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _theme: TSP_Reference? = nil
    var _removedTableStyles: TSP_Reference? = nil
    var _presetID: Int32? = nil
    var _presetIndexInTheme: Int32? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _theme = source._theme
      _removedTableStyles = source._removedTableStyles
      _presetID = source._presetID
      _presetIndexInTheme = source._presetIndexInTheme
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._theme == nil {return false}
      if _storage._removedTableStyles == nil {return false}
      if _storage._presetID == nil {return false}
      if _storage._presetIndexInTheme == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._theme, !v.isInitialized {return false}
      if let v = _storage._removedTableStyles, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._theme) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._removedTableStyles) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._presetID) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._presetIndexInTheme) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._theme {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._removedTableStyles {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._presetID {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._presetIndexInTheme {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandRemoveTableStylePresetArchive, rhs: TST_CommandRemoveTableStylePresetArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._theme != rhs_storage._theme {return false}
        if _storage._removedTableStyles != rhs_storage._removedTableStyles {return false}
        if _storage._presetID != rhs_storage._presetID {return false}
        if _storage._presetIndexInTheme != rhs_storage._presetIndexInTheme {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandReplaceTableStylePresetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandReplaceTableStylePresetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}theme\0\u{3}old_table_styles\0\u{3}new_table_styles\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _theme: TSP_Reference? = nil
    var _oldTableStyles: TSP_Reference? = nil
    var _newTableStyles: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _theme = source._theme
      _oldTableStyles = source._oldTableStyles
      _newTableStyles = source._newTableStyles
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._theme == nil {return false}
      if _storage._oldTableStyles == nil {return false}
      if _storage._newTableStyles == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._theme, !v.isInitialized {return false}
      if let v = _storage._oldTableStyles, !v.isInitialized {return false}
      if let v = _storage._newTableStyles, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._theme) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._oldTableStyles) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._newTableStyles) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._theme {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._oldTableStyles {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._newTableStyles {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandReplaceTableStylePresetArchive, rhs: TST_CommandReplaceTableStylePresetArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._theme != rhs_storage._theme {return false}
        if _storage._oldTableStyles != rhs_storage._oldTableStyles {return false}
        if _storage._newTableStyles != rhs_storage._newTableStyles {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandApplyTableStylePresetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandApplyTableStylePresetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}preset\0\u{1}styles\0\u{3}undo_preset\0\u{3}undo_styles\0\u{3}cell_diff_map\0\u{3}undo_cell_diff_map\0\u{3}apply_preset_option\0\u{4}\u{3}table_clears_all_flag\0\u{3}undo_table_clears_all_flag\0\u{3}row_col_styles\0\u{3}undo_row_col_styles\0\u{3}change_prop_map_wrapper\0")

  fileprivate class _StorageClass {
    var _super: TST_TableCommandArchive? = nil
    var _preset: TSP_Reference? = nil
    var _styles: TSP_Reference? = nil
    var _undoPreset: TSP_Reference? = nil
    var _undoStyles: TSP_Reference? = nil
    var _cellDiffMap: TSP_Reference? = nil
    var _undoCellDiffMap: TSP_Reference? = nil
    var _applyPresetOption: Int32? = nil
    var _tableClearsAllFlag: Bool? = nil
    var _undoTableClearsAllFlag: Bool? = nil
    var _rowColStyles: [TST_ColumnRowMetadataArchive] = []
    var _undoRowColStyles: [TST_ColumnRowMetadataArchive] = []
    var _changePropMapWrapper: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _preset = source._preset
      _styles = source._styles
      _undoPreset = source._undoPreset
      _undoStyles = source._undoStyles
      _cellDiffMap = source._cellDiffMap
      _undoCellDiffMap = source._undoCellDiffMap
      _applyPresetOption = source._applyPresetOption
      _tableClearsAllFlag = source._tableClearsAllFlag
      _undoTableClearsAllFlag = source._undoTableClearsAllFlag
      _rowColStyles = source._rowColStyles
      _undoRowColStyles = source._undoRowColStyles
      _changePropMapWrapper = source._changePropMapWrapper
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._applyPresetOption == nil {return false}
      if _storage._tableClearsAllFlag == nil {return false}
      if _storage._undoTableClearsAllFlag == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._preset, !v.isInitialized {return false}
      if let v = _storage._styles, !v.isInitialized {return false}
      if let v = _storage._undoPreset, !v.isInitialized {return false}
      if let v = _storage._undoStyles, !v.isInitialized {return false}
      if let v = _storage._cellDiffMap, !v.isInitialized {return false}
      if let v = _storage._undoCellDiffMap, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._rowColStyles) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._undoRowColStyles) {return false}
      if let v = _storage._changePropMapWrapper, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._preset) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._styles) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._undoPreset) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._undoStyles) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._cellDiffMap) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._undoCellDiffMap) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._applyPresetOption) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._tableClearsAllFlag) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._undoTableClearsAllFlag) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._rowColStyles) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._undoRowColStyles) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._changePropMapWrapper) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._preset {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._styles {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._undoPreset {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._undoStyles {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._cellDiffMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._undoCellDiffMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._applyPresetOption {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._tableClearsAllFlag {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._undoTableClearsAllFlag {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      } }()
      if !_storage._rowColStyles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rowColStyles, fieldNumber: 13)
      }
      if !_storage._undoRowColStyles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._undoRowColStyles, fieldNumber: 14)
      }
      try { if let v = _storage._changePropMapWrapper {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandApplyTableStylePresetArchive, rhs: TST_CommandApplyTableStylePresetArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._preset != rhs_storage._preset {return false}
        if _storage._styles != rhs_storage._styles {return false}
        if _storage._undoPreset != rhs_storage._undoPreset {return false}
        if _storage._undoStyles != rhs_storage._undoStyles {return false}
        if _storage._cellDiffMap != rhs_storage._cellDiffMap {return false}
        if _storage._undoCellDiffMap != rhs_storage._undoCellDiffMap {return false}
        if _storage._applyPresetOption != rhs_storage._applyPresetOption {return false}
        if _storage._tableClearsAllFlag != rhs_storage._tableClearsAllFlag {return false}
        if _storage._undoTableClearsAllFlag != rhs_storage._undoTableClearsAllFlag {return false}
        if _storage._rowColStyles != rhs_storage._rowColStyles {return false}
        if _storage._undoRowColStyles != rhs_storage._undoRowColStyles {return false}
        if _storage._changePropMapWrapper != rhs_storage._changePropMapWrapper {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetBaseArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetBaseArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}base\0")

  fileprivate class _StorageClass {
    var _super: TST_CommandMutateCellFormatArchive? = nil
    var _base: UInt32? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _base = source._base
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._base == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._base) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._base {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetBaseArchive, rhs: TST_CommandSetBaseArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._base != rhs_storage._base {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetBasePlacesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetBasePlacesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}base_places\0")

  fileprivate class _StorageClass {
    var _super: TST_CommandMutateCellFormatArchive? = nil
    var _basePlaces: UInt32? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _basePlaces = source._basePlaces
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._basePlaces == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._basePlaces) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._basePlaces {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetBasePlacesArchive, rhs: TST_CommandSetBasePlacesArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._basePlaces != rhs_storage._basePlaces {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetBaseUseMinusSignArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetBaseUseMinusSignArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}base_use_minus_sign\0")

  fileprivate class _StorageClass {
    var _super: TST_CommandMutateCellFormatArchive? = nil
    var _baseUseMinusSign: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _baseUseMinusSign = source._baseUseMinusSign
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._baseUseMinusSign == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._baseUseMinusSign) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._baseUseMinusSign {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetBaseUseMinusSignArchive, rhs: TST_CommandSetBaseUseMinusSignArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._baseUseMinusSign != rhs_storage._baseUseMinusSign {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetCurrencyCodeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetCurrencyCodeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}currency_code\0")

  fileprivate class _StorageClass {
    var _super: TST_CommandMutateCellFormatArchive? = nil
    var _currencyCode: String? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _currencyCode = source._currencyCode
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._currencyCode == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._currencyCode) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._currencyCode {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetCurrencyCodeArchive, rhs: TST_CommandSetCurrencyCodeArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._currencyCode != rhs_storage._currencyCode {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetFractionAccuracyArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetFractionAccuracyArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}fraction_accuracy\0")

  fileprivate class _StorageClass {
    var _super: TST_CommandMutateCellFormatArchive? = nil
    var _fractionAccuracy: UInt32? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _fractionAccuracy = source._fractionAccuracy
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._fractionAccuracy == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._fractionAccuracy) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._fractionAccuracy {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetFractionAccuracyArchive, rhs: TST_CommandSetFractionAccuracyArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._fractionAccuracy != rhs_storage._fractionAccuracy {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetNegativeNumberStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetNegativeNumberStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}negative_number_style\0")

  fileprivate class _StorageClass {
    var _super: TST_CommandMutateCellFormatArchive? = nil
    var _negativeNumberStyle: UInt32? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _negativeNumberStyle = source._negativeNumberStyle
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._negativeNumberStyle == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._negativeNumberStyle) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._negativeNumberStyle {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetNegativeNumberStyleArchive, rhs: TST_CommandSetNegativeNumberStyleArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._negativeNumberStyle != rhs_storage._negativeNumberStyle {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetNumberOfDecimalPlacesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetNumberOfDecimalPlacesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}decimal_places\0")

  fileprivate class _StorageClass {
    var _super: TST_CommandMutateCellFormatArchive? = nil
    var _decimalPlaces: UInt32? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _decimalPlaces = source._decimalPlaces
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._decimalPlaces == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._decimalPlaces) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._decimalPlaces {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetNumberOfDecimalPlacesArchive, rhs: TST_CommandSetNumberOfDecimalPlacesArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._decimalPlaces != rhs_storage._decimalPlaces {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetDateTimeFormatArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetDateTimeFormatArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}date_format_string\0\u{3}time_format_string\0")

  fileprivate class _StorageClass {
    var _super: TST_CommandMutateCellFormatArchive? = nil
    var _dateFormatString: String? = nil
    var _timeFormatString: String? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _dateFormatString = source._dateFormatString
      _timeFormatString = source._timeFormatString
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._dateFormatString) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._timeFormatString) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._dateFormatString {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._timeFormatString {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetDateTimeFormatArchive, rhs: TST_CommandSetDateTimeFormatArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._dateFormatString != rhs_storage._dateFormatString {return false}
        if _storage._timeFormatString != rhs_storage._timeFormatString {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetShowThousandsSeparatorArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetShowThousandsSeparatorArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}show_thousands_separator\0")

  fileprivate class _StorageClass {
    var _super: TST_CommandMutateCellFormatArchive? = nil
    var _showThousandsSeparator: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _showThousandsSeparator = source._showThousandsSeparator
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._showThousandsSeparator == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._showThousandsSeparator) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._showThousandsSeparator {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetShowThousandsSeparatorArchive, rhs: TST_CommandSetShowThousandsSeparatorArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._showThousandsSeparator != rhs_storage._showThousandsSeparator {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetUseAccountingStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetUseAccountingStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}use_accounting_style\0")

  fileprivate class _StorageClass {
    var _super: TST_CommandMutateCellFormatArchive? = nil
    var _useAccountingStyle: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _useAccountingStyle = source._useAccountingStyle
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._useAccountingStyle == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._useAccountingStyle) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._useAccountingStyle {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetUseAccountingStyleArchive, rhs: TST_CommandSetUseAccountingStyleArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._useAccountingStyle != rhs_storage._useAccountingStyle {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetRangeControlMinMaxIncArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetRangeControlMinMaxIncArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}minimum\0\u{1}maximum\0\u{1}increment\0\u{3}cell_diff_map\0\u{3}cell_uid_list\0\u{3}inverse_cell_diff_map\0\u{3}is_first_commit\0")

  fileprivate class _StorageClass {
    var _super: TST_TableCommandArchive? = nil
    var _minimum: Double? = nil
    var _maximum: Double? = nil
    var _increment: Double? = nil
    var _cellDiffMap: TSP_Reference? = nil
    var _cellUidList: TST_CellUIDListArchive? = nil
    var _inverseCellDiffMap: TSP_Reference? = nil
    var _isFirstCommit: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _minimum = source._minimum
      _maximum = source._maximum
      _increment = source._increment
      _cellDiffMap = source._cellDiffMap
      _cellUidList = source._cellUidList
      _inverseCellDiffMap = source._inverseCellDiffMap
      _isFirstCommit = source._isFirstCommit
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._isFirstCommit == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._cellDiffMap, !v.isInitialized {return false}
      if let v = _storage._cellUidList, !v.isInitialized {return false}
      if let v = _storage._inverseCellDiffMap, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularDoubleField(value: &_storage._minimum) }()
        case 3: try { try decoder.decodeSingularDoubleField(value: &_storage._maximum) }()
        case 4: try { try decoder.decodeSingularDoubleField(value: &_storage._increment) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._cellDiffMap) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._cellUidList) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._inverseCellDiffMap) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._isFirstCommit) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._minimum {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._maximum {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._increment {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._cellDiffMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._cellUidList {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._inverseCellDiffMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._isFirstCommit {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetRangeControlMinMaxIncArchive, rhs: TST_CommandSetRangeControlMinMaxIncArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._minimum != rhs_storage._minimum {return false}
        if _storage._maximum != rhs_storage._maximum {return false}
        if _storage._increment != rhs_storage._increment {return false}
        if _storage._cellDiffMap != rhs_storage._cellDiffMap {return false}
        if _storage._cellUidList != rhs_storage._cellUidList {return false}
        if _storage._inverseCellDiffMap != rhs_storage._inverseCellDiffMap {return false}
        if _storage._isFirstCommit != rhs_storage._isFirstCommit {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandMoveColumnsOrRowsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandMoveColumnsOrRowsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}dest_uid\0\u{1}before\0\u{3}undo_dest_uid\0\u{3}undo_before\0\u{1}uids\0\u{1}direction\0\u{3}formula_rewrite_command\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._destUid == nil {return false}
    if self._before == nil {return false}
    if self._undoDestUid == nil {return false}
    if self._undoBefore == nil {return false}
    if self._direction == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._destUid, !v.isInitialized {return false}
    if let v = self._undoDestUid, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.uids) {return false}
    if let v = self._formulaRewriteCommand, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._destUid) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._before) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._undoDestUid) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._undoBefore) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.uids) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._direction) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._formulaRewriteCommand) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._destUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._before {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._undoDestUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._undoBefore {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    if !self.uids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uids, fieldNumber: 6)
    }
    try { if let v = self._direction {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._formulaRewriteCommand {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandMoveColumnsOrRowsArchive, rhs: TST_CommandMoveColumnsOrRowsArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._destUid != rhs._destUid {return false}
    if lhs._before != rhs._before {return false}
    if lhs._undoDestUid != rhs._undoDestUid {return false}
    if lhs._undoBefore != rhs._undoBefore {return false}
    if lhs.uids != rhs.uids {return false}
    if lhs._direction != rhs._direction {return false}
    if lhs._formulaRewriteCommand != rhs._formulaRewriteCommand {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSortArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSortArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}from_row_uids\0\u{3}to_row_uids\0\u{3}formula_rewrite_command\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.fromRowUids) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.toRowUids) {return false}
    if let v = self._formulaRewriteCommand, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.fromRowUids) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.toRowUids) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._formulaRewriteCommand) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.fromRowUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fromRowUids, fieldNumber: 2)
    }
    if !self.toRowUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.toRowUids, fieldNumber: 3)
    }
    try { if let v = self._formulaRewriteCommand {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSortArchive, rhs: TST_CommandSortArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.fromRowUids != rhs.fromRowUids {return false}
    if lhs.toRowUids != rhs.toRowUids {return false}
    if lhs._formulaRewriteCommand != rhs._formulaRewriteCommand {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_FormulaRewriteSpecArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormulaRewriteSpecArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}rewrite_type\0\u{3}table_uid\0\u{3}cond_style_owner_uid\0\u{3}group_by_uid\0\u{3}is_inverse\0\u{3}column_or_row_uuids_info\0\u{3}aux_column_or_row_uuids_info\0\u{3}region_moved_info\0\u{3}region_info\0\u{3}rewrite_table_id_info\0\u{3}transposed_table_info\0\u{3}merge_origin_moved_info\0\u{3}merge_source\0\u{3}group_node_info\0\u{3}groupby_change\0")

  fileprivate class _StorageClass {
    var _rewriteType: UInt32? = nil
    var _tableUid: TSP_UUID? = nil
    var _condStyleOwnerUid: TSP_UUID? = nil
    var _groupByUid: TSP_UUID? = nil
    var _isInverse: Bool? = nil
    var _columnOrRowUuidsInfo: TSCE_ColumnOrRowUuidsInfoArchive? = nil
    var _auxColumnOrRowUuidsInfo: TSCE_ColumnOrRowUuidsInfoArchive? = nil
    var _regionMovedInfo: TSCE_RegionMovedInfoArchive? = nil
    var _regionInfo: TSCE_RegionInfoArchive? = nil
    var _rewriteTableIDInfo: TSCE_RewriteTableUIDInfoArchive? = nil
    var _transposedTableInfo: TSCE_TableTransposeInfoArchive? = nil
    var _mergeOriginMovedInfo: TSCE_MergeOriginMovedArchive? = nil
    var _mergeSource: TSCE_MergeSourceArchive? = nil
    var _groupNodeInfo: TSCE_RewriteGroupNodeUIDInfoArchive? = nil
    var _groupbyChange: TSCE_GroupByChangeArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rewriteType = source._rewriteType
      _tableUid = source._tableUid
      _condStyleOwnerUid = source._condStyleOwnerUid
      _groupByUid = source._groupByUid
      _isInverse = source._isInverse
      _columnOrRowUuidsInfo = source._columnOrRowUuidsInfo
      _auxColumnOrRowUuidsInfo = source._auxColumnOrRowUuidsInfo
      _regionMovedInfo = source._regionMovedInfo
      _regionInfo = source._regionInfo
      _rewriteTableIDInfo = source._rewriteTableIDInfo
      _transposedTableInfo = source._transposedTableInfo
      _mergeOriginMovedInfo = source._mergeOriginMovedInfo
      _mergeSource = source._mergeSource
      _groupNodeInfo = source._groupNodeInfo
      _groupbyChange = source._groupbyChange
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._rewriteType == nil {return false}
      if let v = _storage._tableUid, !v.isInitialized {return false}
      if let v = _storage._condStyleOwnerUid, !v.isInitialized {return false}
      if let v = _storage._groupByUid, !v.isInitialized {return false}
      if let v = _storage._columnOrRowUuidsInfo, !v.isInitialized {return false}
      if let v = _storage._auxColumnOrRowUuidsInfo, !v.isInitialized {return false}
      if let v = _storage._regionMovedInfo, !v.isInitialized {return false}
      if let v = _storage._regionInfo, !v.isInitialized {return false}
      if let v = _storage._rewriteTableIDInfo, !v.isInitialized {return false}
      if let v = _storage._transposedTableInfo, !v.isInitialized {return false}
      if let v = _storage._mergeSource, !v.isInitialized {return false}
      if let v = _storage._groupNodeInfo, !v.isInitialized {return false}
      if let v = _storage._groupbyChange, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._rewriteType) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._tableUid) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._condStyleOwnerUid) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._groupByUid) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._isInverse) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._columnOrRowUuidsInfo) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._auxColumnOrRowUuidsInfo) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._regionMovedInfo) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._regionInfo) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._rewriteTableIDInfo) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._transposedTableInfo) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._mergeOriginMovedInfo) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._mergeSource) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._groupNodeInfo) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._groupbyChange) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._rewriteType {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._tableUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._condStyleOwnerUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._groupByUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._isInverse {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._columnOrRowUuidsInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._auxColumnOrRowUuidsInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._regionMovedInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._regionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._rewriteTableIDInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._transposedTableInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._mergeOriginMovedInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._mergeSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._groupNodeInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._groupbyChange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_FormulaRewriteSpecArchive, rhs: TST_FormulaRewriteSpecArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rewriteType != rhs_storage._rewriteType {return false}
        if _storage._tableUid != rhs_storage._tableUid {return false}
        if _storage._condStyleOwnerUid != rhs_storage._condStyleOwnerUid {return false}
        if _storage._groupByUid != rhs_storage._groupByUid {return false}
        if _storage._isInverse != rhs_storage._isInverse {return false}
        if _storage._columnOrRowUuidsInfo != rhs_storage._columnOrRowUuidsInfo {return false}
        if _storage._auxColumnOrRowUuidsInfo != rhs_storage._auxColumnOrRowUuidsInfo {return false}
        if _storage._regionMovedInfo != rhs_storage._regionMovedInfo {return false}
        if _storage._regionInfo != rhs_storage._regionInfo {return false}
        if _storage._rewriteTableIDInfo != rhs_storage._rewriteTableIDInfo {return false}
        if _storage._transposedTableInfo != rhs_storage._transposedTableInfo {return false}
        if _storage._mergeOriginMovedInfo != rhs_storage._mergeOriginMovedInfo {return false}
        if _storage._mergeSource != rhs_storage._mergeSource {return false}
        if _storage._groupNodeInfo != rhs_storage._groupNodeInfo {return false}
        if _storage._groupbyChange != rhs_storage._groupbyChange {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandRewriteFormulasForTransposeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandRewriteFormulasForTransposeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}rewrite_spec\0\u{3}formulas_to_rewrite\0\u{3}warningset_map\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._rewriteSpec == nil {return false}
    if self._formulasToRewrite == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._rewriteSpec, !v.isInitialized {return false}
    if let v = self._formulasToRewrite, !v.isInitialized {return false}
    if let v = self._warningsetMap, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rewriteSpec) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._formulasToRewrite) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._warningsetMap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rewriteSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._formulasToRewrite {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._warningsetMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandRewriteFormulasForTransposeArchive, rhs: TST_CommandRewriteFormulasForTransposeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._rewriteSpec != rhs._rewriteSpec {return false}
    if lhs._formulasToRewrite != rhs._formulasToRewrite {return false}
    if lhs._warningsetMap != rhs._warningsetMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandRewriteTableFormulasForRewriteSpecArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandRewriteTableFormulasForRewriteSpecArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}rewrite_spec\0\u{3}formulas_to_rewrite\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._rewriteSpec == nil {return false}
    if self._formulasToRewrite == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._rewriteSpec, !v.isInitialized {return false}
    if let v = self._formulasToRewrite, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rewriteSpec) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._formulasToRewrite) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rewriteSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._formulasToRewrite {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandRewriteTableFormulasForRewriteSpecArchive, rhs: TST_CommandRewriteTableFormulasForRewriteSpecArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._rewriteSpec != rhs._rewriteSpec {return false}
    if lhs._formulasToRewrite != rhs._formulasToRewrite {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandRewriteMergeFormulasArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandRewriteMergeFormulasArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}rewrite_spec\0\u{3}formulas_to_rewrite\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._rewriteSpec == nil {return false}
    if self._formulasToRewrite == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._rewriteSpec, !v.isInitialized {return false}
    if let v = self._formulasToRewrite, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rewriteSpec) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._formulasToRewrite) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rewriteSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._formulasToRewrite {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandRewriteMergeFormulasArchive, rhs: TST_CommandRewriteMergeFormulasArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._rewriteSpec != rhs._rewriteSpec {return false}
    if lhs._formulasToRewrite != rhs._formulasToRewrite {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandRewriteCategoryFormulasArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandRewriteCategoryFormulasArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}rewrite_spec\0\u{3}formulas_to_rewrite\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._rewriteSpec == nil {return false}
    if self._formulasToRewrite == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._rewriteSpec, !v.isInitialized {return false}
    if let v = self._formulasToRewrite, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rewriteSpec) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._formulasToRewrite) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rewriteSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._formulasToRewrite {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandRewriteCategoryFormulasArchive, rhs: TST_CommandRewriteCategoryFormulasArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._rewriteSpec != rhs._rewriteSpec {return false}
    if lhs._formulasToRewrite != rhs._formulasToRewrite {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandRewriteFilterFormulasForTableResizeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandRewriteFilterFormulasForTableResizeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandRewriteFilterFormulasForTableResizeArchive, rhs: TST_CommandRewriteFilterFormulasForTableResizeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandRewriteFilterFormulasForRewriteSpecArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandRewriteFilterFormulasForRewriteSpecArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}filter_set\0\u{3}rewrite_spec\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._filterSet == nil {return false}
    if self._rewriteSpec == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._filterSet, !v.isInitialized {return false}
    if let v = self._rewriteSpec, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._filterSet) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._rewriteSpec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._filterSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._rewriteSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandRewriteFilterFormulasForRewriteSpecArchive, rhs: TST_CommandRewriteFilterFormulasForRewriteSpecArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._filterSet != rhs._filterSet {return false}
    if lhs._rewriteSpec != rhs._rewriteSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandRewriteConditionalStylesForRewriteSpecArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandRewriteConditionalStylesForRewriteSpecArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}rewrite_spec\0\u{3}formulas_to_rewrite\0\u{3}conditional_style_sets\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._rewriteSpec == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._rewriteSpec, !v.isInitialized {return false}
    if let v = self._formulasToRewrite, !v.isInitialized {return false}
    if let v = self._conditionalStyleSets, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rewriteSpec) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._formulasToRewrite) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._conditionalStyleSets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rewriteSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._formulasToRewrite {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._conditionalStyleSets {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandRewriteConditionalStylesForRewriteSpecArchive, rhs: TST_CommandRewriteConditionalStylesForRewriteSpecArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._rewriteSpec != rhs._rewriteSpec {return false}
    if lhs._formulasToRewrite != rhs._formulasToRewrite {return false}
    if lhs._conditionalStyleSets != rhs._conditionalStyleSets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandRewritePivotOwnerFormulasArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandRewritePivotOwnerFormulasArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}rewrite_spec\0\u{3}formulas_to_rewrite\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._rewriteSpec == nil {return false}
    if self._formulasToRewrite == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._rewriteSpec, !v.isInitialized {return false}
    if let v = self._formulasToRewrite, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rewriteSpec) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._formulasToRewrite) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rewriteSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._formulasToRewrite {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandRewritePivotOwnerFormulasArchive, rhs: TST_CommandRewritePivotOwnerFormulasArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._rewriteSpec != rhs._rewriteSpec {return false}
    if lhs._formulasToRewrite != rhs._formulasToRewrite {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandMergeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandMergeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}cell_uid_list\0\u{3}undo_cell_map\0\u{3}undo_formula_rewrite_command\0\u{3}merge_owner_rollback\0\u{3}commit_cell_map\0")

  fileprivate class _StorageClass {
    var _super: TST_TableCommandArchive? = nil
    var _cellUidList: TST_CellUIDListArchive? = nil
    var _undoCellMap: TSP_Reference? = nil
    var _undoFormulaRewriteCommand: TSP_Reference? = nil
    var _mergeOwnerRollback: UInt32? = nil
    var _commitCellMap: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _cellUidList = source._cellUidList
      _undoCellMap = source._undoCellMap
      _undoFormulaRewriteCommand = source._undoFormulaRewriteCommand
      _mergeOwnerRollback = source._mergeOwnerRollback
      _commitCellMap = source._commitCellMap
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._cellUidList == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._cellUidList, !v.isInitialized {return false}
      if let v = _storage._undoCellMap, !v.isInitialized {return false}
      if let v = _storage._undoFormulaRewriteCommand, !v.isInitialized {return false}
      if let v = _storage._commitCellMap, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._cellUidList) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._undoCellMap) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._undoFormulaRewriteCommand) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._mergeOwnerRollback) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._commitCellMap) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._cellUidList {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._undoCellMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._undoFormulaRewriteCommand {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._mergeOwnerRollback {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._commitCellMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandMergeArchive, rhs: TST_CommandMergeArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._cellUidList != rhs_storage._cellUidList {return false}
        if _storage._undoCellMap != rhs_storage._undoCellMap {return false}
        if _storage._undoFormulaRewriteCommand != rhs_storage._undoFormulaRewriteCommand {return false}
        if _storage._mergeOwnerRollback != rhs_storage._mergeOwnerRollback {return false}
        if _storage._commitCellMap != rhs_storage._commitCellMap {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandInverseMergeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandInverseMergeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}merge_source_cell_uid\0")

  fileprivate class _StorageClass {
    var _super: TST_CommandApplyCellMapArchive? = nil
    var _mergeSourceCellUid: TSP_UUIDCoordArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _mergeSourceCellUid = source._mergeSourceCellUid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._mergeSourceCellUid == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._mergeSourceCellUid, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._mergeSourceCellUid) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._mergeSourceCellUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandInverseMergeArchive, rhs: TST_CommandInverseMergeArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._mergeSourceCellUid != rhs_storage._mergeSourceCellUid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandUnmergeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandUnmergeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}unmerge_uid_ranges\0\u{3}undo_cell_map\0\u{3}undo_formula_rewrite_command\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.unmergeUidRanges) {return false}
    if let v = self._undoCellMap, !v.isInitialized {return false}
    if let v = self._undoFormulaRewriteCommand, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.unmergeUidRanges) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._undoCellMap) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._undoFormulaRewriteCommand) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.unmergeUidRanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.unmergeUidRanges, fieldNumber: 2)
    }
    try { if let v = self._undoCellMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._undoFormulaRewriteCommand {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandUnmergeArchive, rhs: TST_CommandUnmergeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unmergeUidRanges != rhs.unmergeUidRanges {return false}
    if lhs._undoCellMap != rhs._undoCellMap {return false}
    if lhs._undoFormulaRewriteCommand != rhs._undoFormulaRewriteCommand {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandChooseTableIdRemapperArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandChooseTableIdRemapperArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}table_id_mapper\0\u{3}formula_rewrite_command_for_undo\0\u{3}apply_and_clear\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _tableIDMapper: TST_MultiTableRemapperArchive? = nil
    var _formulaRewriteCommandForUndo: TSP_Reference? = nil
    var _applyAndClear: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _tableIDMapper = source._tableIDMapper
      _formulaRewriteCommandForUndo = source._formulaRewriteCommandForUndo
      _applyAndClear = source._applyAndClear
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._tableIDMapper == nil {return false}
      if _storage._applyAndClear == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._tableIDMapper, !v.isInitialized {return false}
      if let v = _storage._formulaRewriteCommandForUndo, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._tableIDMapper) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._formulaRewriteCommandForUndo) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._applyAndClear) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._tableIDMapper {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._formulaRewriteCommandForUndo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._applyAndClear {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandChooseTableIdRemapperArchive, rhs: TST_CommandChooseTableIdRemapperArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._tableIDMapper != rhs_storage._tableIDMapper {return false}
        if _storage._formulaRewriteCommandForUndo != rhs_storage._formulaRewriteCommandForUndo {return false}
        if _storage._applyAndClear != rhs_storage._applyAndClear {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandCategorySetGroupingColumnsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandCategorySetGroupingColumnsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}new_enabled_changing\0\u{3}old_enabled_changing\0\u{3}new_grouping_columns\0\u{3}old_grouping_columns\0\u{3}restore_base_order\0\u{3}base_row_order\0\u{3}undo_restore_base_order\0\u{3}undo_base_row_order\0\u{3}restore_view_order\0\u{3}view_row_order\0\u{3}undo_restore_view_order\0\u{3}undo_view_row_order\0\u{3}collapse_state\0\u{3}undo_collapse_state\0\u{3}summary_change_state\0\u{3}undo_summary_change_state\0\u{3}new_column_aggregates\0\u{3}old_column_aggregates\0\u{3}undo_set_enabled_rewrite_command\0\u{3}undo_set_columns_rewrite_command\0\u{3}force_restore_all_states\0\u{3}cell_diff_map\0\u{3}undo_cell_diff_map\0\u{3}undo_set_group_sort_order_command\0")

  fileprivate class _StorageClass {
    var _super: TST_TableCommandArchive? = nil
    var _newEnabledChanging: Int32? = nil
    var _oldEnabledChanging: Int32? = nil
    var _newGroupingColumns: TST_GroupColumnListArchive? = nil
    var _oldGroupingColumns: TST_GroupColumnListArchive? = nil
    var _restoreBaseOrder: Bool? = nil
    var _baseRowOrder: [TSP_UUID] = []
    var _undoRestoreBaseOrder: Bool? = nil
    var _undoBaseRowOrder: [TSP_UUID] = []
    var _restoreViewOrder: Bool? = nil
    var _viewRowOrder: [TSP_UUID] = []
    var _undoRestoreViewOrder: Bool? = nil
    var _undoViewRowOrder: [TSP_UUID] = []
    var _collapseState: [TSP_UUID] = []
    var _undoCollapseState: [TSP_UUID] = []
    var _summaryChangeState: TST_SummaryModelGroupByChangeStateArchive? = nil
    var _undoSummaryChangeState: TST_SummaryModelGroupByChangeStateArchive? = nil
    var _newColumnAggregates: TST_ColumnAggregateListArchive? = nil
    var _oldColumnAggregates: TST_ColumnAggregateListArchive? = nil
    var _undoSetEnabledRewriteCommand: TSP_Reference? = nil
    var _undoSetColumnsRewriteCommand: TSP_Reference? = nil
    var _forceRestoreAllStates: Bool? = nil
    var _cellDiffMap: TSP_Reference? = nil
    var _undoCellDiffMap: TSP_Reference? = nil
    var _undoSetGroupSortOrderCommand: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _newEnabledChanging = source._newEnabledChanging
      _oldEnabledChanging = source._oldEnabledChanging
      _newGroupingColumns = source._newGroupingColumns
      _oldGroupingColumns = source._oldGroupingColumns
      _restoreBaseOrder = source._restoreBaseOrder
      _baseRowOrder = source._baseRowOrder
      _undoRestoreBaseOrder = source._undoRestoreBaseOrder
      _undoBaseRowOrder = source._undoBaseRowOrder
      _restoreViewOrder = source._restoreViewOrder
      _viewRowOrder = source._viewRowOrder
      _undoRestoreViewOrder = source._undoRestoreViewOrder
      _undoViewRowOrder = source._undoViewRowOrder
      _collapseState = source._collapseState
      _undoCollapseState = source._undoCollapseState
      _summaryChangeState = source._summaryChangeState
      _undoSummaryChangeState = source._undoSummaryChangeState
      _newColumnAggregates = source._newColumnAggregates
      _oldColumnAggregates = source._oldColumnAggregates
      _undoSetEnabledRewriteCommand = source._undoSetEnabledRewriteCommand
      _undoSetColumnsRewriteCommand = source._undoSetColumnsRewriteCommand
      _forceRestoreAllStates = source._forceRestoreAllStates
      _cellDiffMap = source._cellDiffMap
      _undoCellDiffMap = source._undoCellDiffMap
      _undoSetGroupSortOrderCommand = source._undoSetGroupSortOrderCommand
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._newEnabledChanging == nil {return false}
      if _storage._oldEnabledChanging == nil {return false}
      if _storage._newGroupingColumns == nil {return false}
      if _storage._restoreBaseOrder == nil {return false}
      if _storage._undoRestoreBaseOrder == nil {return false}
      if _storage._restoreViewOrder == nil {return false}
      if _storage._undoRestoreViewOrder == nil {return false}
      if _storage._forceRestoreAllStates == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._newGroupingColumns, !v.isInitialized {return false}
      if let v = _storage._oldGroupingColumns, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._baseRowOrder) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._undoBaseRowOrder) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._viewRowOrder) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._undoViewRowOrder) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._collapseState) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._undoCollapseState) {return false}
      if let v = _storage._summaryChangeState, !v.isInitialized {return false}
      if let v = _storage._undoSummaryChangeState, !v.isInitialized {return false}
      if let v = _storage._newColumnAggregates, !v.isInitialized {return false}
      if let v = _storage._oldColumnAggregates, !v.isInitialized {return false}
      if let v = _storage._undoSetEnabledRewriteCommand, !v.isInitialized {return false}
      if let v = _storage._undoSetColumnsRewriteCommand, !v.isInitialized {return false}
      if let v = _storage._cellDiffMap, !v.isInitialized {return false}
      if let v = _storage._undoCellDiffMap, !v.isInitialized {return false}
      if let v = _storage._undoSetGroupSortOrderCommand, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._newEnabledChanging) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._oldEnabledChanging) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._newGroupingColumns) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._oldGroupingColumns) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._restoreBaseOrder) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._baseRowOrder) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._undoRestoreBaseOrder) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._undoBaseRowOrder) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._restoreViewOrder) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._viewRowOrder) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._undoRestoreViewOrder) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._undoViewRowOrder) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._collapseState) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._undoCollapseState) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._summaryChangeState) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._undoSummaryChangeState) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._newColumnAggregates) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._oldColumnAggregates) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._undoSetEnabledRewriteCommand) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._undoSetColumnsRewriteCommand) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._forceRestoreAllStates) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._cellDiffMap) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._undoCellDiffMap) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._undoSetGroupSortOrderCommand) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._newEnabledChanging {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._oldEnabledChanging {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._newGroupingColumns {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._oldGroupingColumns {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._restoreBaseOrder {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      if !_storage._baseRowOrder.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._baseRowOrder, fieldNumber: 7)
      }
      try { if let v = _storage._undoRestoreBaseOrder {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      if !_storage._undoBaseRowOrder.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._undoBaseRowOrder, fieldNumber: 9)
      }
      try { if let v = _storage._restoreViewOrder {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      if !_storage._viewRowOrder.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._viewRowOrder, fieldNumber: 11)
      }
      try { if let v = _storage._undoRestoreViewOrder {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      } }()
      if !_storage._undoViewRowOrder.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._undoViewRowOrder, fieldNumber: 13)
      }
      if !_storage._collapseState.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._collapseState, fieldNumber: 14)
      }
      if !_storage._undoCollapseState.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._undoCollapseState, fieldNumber: 15)
      }
      try { if let v = _storage._summaryChangeState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._undoSummaryChangeState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._newColumnAggregates {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._oldColumnAggregates {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._undoSetEnabledRewriteCommand {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._undoSetColumnsRewriteCommand {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._forceRestoreAllStates {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._cellDiffMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._undoCellDiffMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._undoSetGroupSortOrderCommand {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandCategorySetGroupingColumnsArchive, rhs: TST_CommandCategorySetGroupingColumnsArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._newEnabledChanging != rhs_storage._newEnabledChanging {return false}
        if _storage._oldEnabledChanging != rhs_storage._oldEnabledChanging {return false}
        if _storage._newGroupingColumns != rhs_storage._newGroupingColumns {return false}
        if _storage._oldGroupingColumns != rhs_storage._oldGroupingColumns {return false}
        if _storage._restoreBaseOrder != rhs_storage._restoreBaseOrder {return false}
        if _storage._baseRowOrder != rhs_storage._baseRowOrder {return false}
        if _storage._undoRestoreBaseOrder != rhs_storage._undoRestoreBaseOrder {return false}
        if _storage._undoBaseRowOrder != rhs_storage._undoBaseRowOrder {return false}
        if _storage._restoreViewOrder != rhs_storage._restoreViewOrder {return false}
        if _storage._viewRowOrder != rhs_storage._viewRowOrder {return false}
        if _storage._undoRestoreViewOrder != rhs_storage._undoRestoreViewOrder {return false}
        if _storage._undoViewRowOrder != rhs_storage._undoViewRowOrder {return false}
        if _storage._collapseState != rhs_storage._collapseState {return false}
        if _storage._undoCollapseState != rhs_storage._undoCollapseState {return false}
        if _storage._summaryChangeState != rhs_storage._summaryChangeState {return false}
        if _storage._undoSummaryChangeState != rhs_storage._undoSummaryChangeState {return false}
        if _storage._newColumnAggregates != rhs_storage._newColumnAggregates {return false}
        if _storage._oldColumnAggregates != rhs_storage._oldColumnAggregates {return false}
        if _storage._undoSetEnabledRewriteCommand != rhs_storage._undoSetEnabledRewriteCommand {return false}
        if _storage._undoSetColumnsRewriteCommand != rhs_storage._undoSetColumnsRewriteCommand {return false}
        if _storage._forceRestoreAllStates != rhs_storage._forceRestoreAllStates {return false}
        if _storage._cellDiffMap != rhs_storage._cellDiffMap {return false}
        if _storage._undoCellDiffMap != rhs_storage._undoCellDiffMap {return false}
        if _storage._undoSetGroupSortOrderCommand != rhs_storage._undoSetGroupSortOrderCommand {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_FormulaEditingCommandGroupArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormulaEditingCommandGroupArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}undoSelectionValid\0\u{1}undoSelectionStart\0\u{1}undoSelectionLength\0\u{1}undoActiveToken\0\u{1}redoSelectionValid\0\u{1}redoSelectionStart\0\u{1}redoSelectionLength\0\u{1}redoActiveToken\0")

  fileprivate class _StorageClass {
    var _super: TSK_ProgressiveCommandGroupArchive? = nil
    var _undoSelectionValid: Bool? = nil
    var _undoSelectionStart: UInt32? = nil
    var _undoSelectionLength: UInt32? = nil
    var _undoActiveToken: UInt32? = nil
    var _redoSelectionValid: Bool? = nil
    var _redoSelectionStart: UInt32? = nil
    var _redoSelectionLength: UInt32? = nil
    var _redoActiveToken: UInt32? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _undoSelectionValid = source._undoSelectionValid
      _undoSelectionStart = source._undoSelectionStart
      _undoSelectionLength = source._undoSelectionLength
      _undoActiveToken = source._undoActiveToken
      _redoSelectionValid = source._redoSelectionValid
      _redoSelectionStart = source._redoSelectionStart
      _redoSelectionLength = source._redoSelectionLength
      _redoActiveToken = source._redoActiveToken
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._undoSelectionValid == nil {return false}
      if _storage._undoSelectionStart == nil {return false}
      if _storage._undoSelectionLength == nil {return false}
      if _storage._undoActiveToken == nil {return false}
      if _storage._redoSelectionValid == nil {return false}
      if _storage._redoSelectionStart == nil {return false}
      if _storage._redoSelectionLength == nil {return false}
      if _storage._redoActiveToken == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._undoSelectionValid) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._undoSelectionStart) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._undoSelectionLength) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._undoActiveToken) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._redoSelectionValid) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._redoSelectionStart) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._redoSelectionLength) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._redoActiveToken) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._undoSelectionValid {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._undoSelectionStart {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._undoSelectionLength {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._undoActiveToken {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._redoSelectionValid {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._redoSelectionStart {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._redoSelectionLength {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._redoActiveToken {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_FormulaEditingCommandGroupArchive, rhs: TST_FormulaEditingCommandGroupArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._undoSelectionValid != rhs_storage._undoSelectionValid {return false}
        if _storage._undoSelectionStart != rhs_storage._undoSelectionStart {return false}
        if _storage._undoSelectionLength != rhs_storage._undoSelectionLength {return false}
        if _storage._undoActiveToken != rhs_storage._undoActiveToken {return false}
        if _storage._redoSelectionValid != rhs_storage._redoSelectionValid {return false}
        if _storage._redoSelectionStart != rhs_storage._redoSelectionStart {return false}
        if _storage._redoSelectionLength != rhs_storage._redoSelectionLength {return false}
        if _storage._redoActiveToken != rhs_storage._redoActiveToken {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_FormulaEditingCommandSelectionBehaviorArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormulaEditingCommandSelectionBehaviorArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}undoActiveToken\0\u{1}redoActiveToken\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._undoActiveToken) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._redoActiveToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._undoActiveToken {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._redoActiveToken {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_FormulaEditingCommandSelectionBehaviorArchive, rhs: TST_FormulaEditingCommandSelectionBehaviorArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._undoActiveToken != rhs._undoActiveToken {return false}
    if lhs._redoActiveToken != rhs._redoActiveToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableCommandSelectionBehaviorArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TableCommandSelectionBehaviorArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}table_info\0\u{3}last_column_uid_hit_by_tap\0\u{3}invalidate_comments\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._tableInfo, !v.isInitialized {return false}
    if let v = self._lastColumnUidHitByTap, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tableInfo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lastColumnUidHitByTap) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._invalidateComments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tableInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lastColumnUidHitByTap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._invalidateComments {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableCommandSelectionBehaviorArchive, rhs: TST_TableCommandSelectionBehaviorArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._tableInfo != rhs._tableInfo {return false}
    if lhs._lastColumnUidHitByTap != rhs._lastColumnUidHitByTap {return false}
    if lhs._invalidateComments != rhs._invalidateComments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandApplyCellCommentArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandApplyCellCommentArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}cell_uid\0\u{3}old_comment_storage\0\u{3}new_comment_storage\0\u{3}forward_variant\0\u{3}inverse_variant\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._cellUid == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._cellUid, !v.isInitialized {return false}
    if let v = self._oldCommentStorage, !v.isInitialized {return false}
    if let v = self._newCommentStorage, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cellUid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._oldCommentStorage) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._newCommentStorage) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._forwardVariant) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._inverseVariant) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cellUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._oldCommentStorage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._newCommentStorage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._forwardVariant {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._inverseVariant {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandApplyCellCommentArchive, rhs: TST_CommandApplyCellCommentArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._cellUid != rhs._cellUid {return false}
    if lhs._oldCommentStorage != rhs._oldCommentStorage {return false}
    if lhs._newCommentStorage != rhs._newCommentStorage {return false}
    if lhs._forwardVariant != rhs._forwardVariant {return false}
    if lhs._inverseVariant != rhs._inverseVariant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetFormulaTokenizationArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetFormulaTokenizationArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}tokenization\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._tokenization == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._tokenization) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tokenization {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetFormulaTokenizationArchive, rhs: TST_CommandSetFormulaTokenizationArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._tokenization != rhs._tokenization {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetFilterSetTypeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetFilterSetTypeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}old_filter_set_type\0\u{3}new_filter_set_type\0\u{3}rollback_uid_list\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._newFilterSetType == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rollbackUidList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._oldFilterSetType) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._newFilterSetType) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.rollbackUidList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oldFilterSetType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newFilterSetType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    if !self.rollbackUidList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rollbackUidList, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetFilterSetTypeArchive, rhs: TST_CommandSetFilterSetTypeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._oldFilterSetType != rhs._oldFilterSetType {return false}
    if lhs._newFilterSetType != rhs._newFilterSetType {return false}
    if lhs.rollbackUidList != rhs.rollbackUidList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetTextStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetTextStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}cell_diff_map\0\u{3}inverse_cell_diff_map\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._cellDiffMap == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._cellDiffMap, !v.isInitialized {return false}
    if let v = self._inverseCellDiffMap, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cellDiffMap) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._inverseCellDiffMap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cellDiffMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._inverseCellDiffMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetTextStyleArchive, rhs: TST_CommandSetTextStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._cellDiffMap != rhs._cellDiffMap {return false}
    if lhs._inverseCellDiffMap != rhs._inverseCellDiffMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetTextStylePropertiesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetTextStylePropertiesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}cell_diff_map\0\u{3}cell_was_rich_text\0\u{3}inverse_cell_diff_map\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._cellDiffMap == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._cellDiffMap, !v.isInitialized {return false}
    if let v = self._inverseCellDiffMap, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cellDiffMap) }()
      case 3: try { try decoder.decodeRepeatedBoolField(value: &self.cellWasRichText) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._inverseCellDiffMap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cellDiffMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.cellWasRichText.isEmpty {
      try visitor.visitRepeatedBoolField(value: self.cellWasRichText, fieldNumber: 3)
    }
    try { if let v = self._inverseCellDiffMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetTextStylePropertiesArchive, rhs: TST_CommandSetTextStylePropertiesArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._cellDiffMap != rhs._cellDiffMap {return false}
    if lhs.cellWasRichText != rhs.cellWasRichText {return false}
    if lhs._inverseCellDiffMap != rhs._inverseCellDiffMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandJustForNotifyingArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandJustForNotifyingArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}change_descriptor_type\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._changeDescriptorType == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._changeDescriptorType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._changeDescriptorType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandJustForNotifyingArchive, rhs: TST_CommandJustForNotifyingArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._changeDescriptorType != rhs._changeDescriptorType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetStorageLanguageArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetStorageLanguageArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}storage\0\u{1}language\0\u{3}range_location\0\u{3}range_length\0\u{3}undo_transaction\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _storage: TSP_Reference? = nil
    var _language: String? = nil
    var _rangeLocation: UInt32? = nil
    var _rangeLength: UInt32? = nil
    var _undoTransaction: TSWP_UndoTransaction? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _storage = source._storage
      _language = source._language
      _rangeLocation = source._rangeLocation
      _rangeLength = source._rangeLength
      _undoTransaction = source._undoTransaction
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._storage == nil {return false}
      if _storage._language == nil {return false}
      if _storage._rangeLocation == nil {return false}
      if _storage._rangeLength == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._storage, !v.isInitialized {return false}
      if let v = _storage._undoTransaction, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._storage) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._language) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._rangeLocation) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._rangeLength) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._undoTransaction) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._storage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._language {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._rangeLocation {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._rangeLength {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._undoTransaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetStorageLanguageArchive, rhs: TST_CommandSetStorageLanguageArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._storage != rhs_storage._storage {return false}
        if _storage._language != rhs_storage._language {return false}
        if _storage._rangeLocation != rhs_storage._rangeLocation {return false}
        if _storage._rangeLength != rhs_storage._rangeLength {return false}
        if _storage._undoTransaction != rhs_storage._undoTransaction {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetSortOrderArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetSortOrderArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}old_sort_order\0\u{3}new_sort_order\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._oldSortOrder, !v.isInitialized {return false}
    if let v = self._newSortOrder, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._oldSortOrder) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newSortOrder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oldSortOrder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newSortOrder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetSortOrderArchive, rhs: TST_CommandSetSortOrderArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._oldSortOrder != rhs._oldSortOrder {return false}
    if lhs._newSortOrder != rhs._newSortOrder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetGroupSortOrderArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetGroupSortOrderArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}old_group_sort_order\0\u{3}new_group_sort_order\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._oldGroupSortOrder, !v.isInitialized {return false}
    if let v = self._newGroupSortOrder, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._oldGroupSortOrder) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newGroupSortOrder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oldGroupSortOrder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newGroupSortOrder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetGroupSortOrderArchive, rhs: TST_CommandSetGroupSortOrderArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._oldGroupSortOrder != rhs._oldGroupSortOrder {return false}
    if lhs._newGroupSortOrder != rhs._newGroupSortOrder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandRewriteSortOrderForTableResizeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandRewriteSortOrderForTableResizeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}old_sort_order\0\u{3}new_sort_order\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._oldSortOrder, !v.isInitialized {return false}
    if let v = self._newSortOrder, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._oldSortOrder) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newSortOrder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oldSortOrder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newSortOrder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandRewriteSortOrderForTableResizeArchive, rhs: TST_CommandRewriteSortOrderForTableResizeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._oldSortOrder != rhs._oldSortOrder {return false}
    if lhs._newSortOrder != rhs._newSortOrder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandRewriteSortOrderForRewriteSpecArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandRewriteSortOrderForRewriteSpecArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}rewrite_spec\0\u{3}old_sort_order\0\u{3}new_sort_order\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._rewriteSpec == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._rewriteSpec, !v.isInitialized {return false}
    if let v = self._oldSortOrder, !v.isInitialized {return false}
    if let v = self._newSortOrder, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rewriteSpec) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._oldSortOrder) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._newSortOrder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rewriteSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._oldSortOrder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._newSortOrder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandRewriteSortOrderForRewriteSpecArchive, rhs: TST_CommandRewriteSortOrderForRewriteSpecArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._rewriteSpec != rhs._rewriteSpec {return false}
    if lhs._oldSortOrder != rhs._oldSortOrder {return false}
    if lhs._newSortOrder != rhs._newSortOrder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetFilterSetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetFilterSetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}new_filter_set\0\u{3}old_filter_set\0\u{3}rollback_uid_list\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._newFilterSet == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._newFilterSet, !v.isInitialized {return false}
    if let v = self._oldFilterSet, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rollbackUidList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newFilterSet) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._oldFilterSet) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.rollbackUidList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newFilterSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._oldFilterSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.rollbackUidList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rollbackUidList, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetFilterSetArchive, rhs: TST_CommandSetFilterSetArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._newFilterSet != rhs._newFilterSet {return false}
    if lhs._oldFilterSet != rhs._oldFilterSet {return false}
    if lhs.rollbackUidList != rhs.rollbackUidList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ColumnRowRestoreDataArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ColumnRowRestoreDataArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}uid_list\0\u{1}metadatas\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.uidList) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.metadatas) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.uidList) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.metadatas) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uidList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uidList, fieldNumber: 1)
    }
    if !self.metadatas.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadatas, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ColumnRowRestoreDataArchive, rhs: TST_ColumnRowRestoreDataArchive) -> Bool {
    if lhs.uidList != rhs.uidList {return false}
    if lhs.metadatas != rhs.metadatas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandTransposeTableArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandTransposeTableArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}original_table_range\0\u{3}original_cell_map\0\u{3}original_footer_row_count\0\u{3}original_column_widths\0\u{3}original_row_heights\0\u{3}ineligible_merge_list\0\u{3}transposed_cell_map\0\u{3}undo_formula_rewrite_command\0\u{3}rich_text_subcommands\0\u{3}column_restore_data\0\u{3}row_restore_data\0")

  fileprivate class _StorageClass {
    var _super: TST_TableCommandArchive? = nil
    var _originalTableRange: TST_ExpandedCellRange? = nil
    var _originalCellMap: TSP_Reference? = nil
    var _originalFooterRowCount: UInt32? = nil
    var _originalColumnWidths: [Float] = []
    var _originalRowHeights: [Float] = []
    var _ineligibleMergeList: [TST_CellRange] = []
    var _transposedCellMap: TSP_Reference? = nil
    var _undoFormulaRewriteCommand: TSP_Reference? = nil
    var _richTextSubcommands: TSP_Reference? = nil
    var _columnRestoreData: TST_ColumnRowRestoreDataArchive? = nil
    var _rowRestoreData: TST_ColumnRowRestoreDataArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _originalTableRange = source._originalTableRange
      _originalCellMap = source._originalCellMap
      _originalFooterRowCount = source._originalFooterRowCount
      _originalColumnWidths = source._originalColumnWidths
      _originalRowHeights = source._originalRowHeights
      _ineligibleMergeList = source._ineligibleMergeList
      _transposedCellMap = source._transposedCellMap
      _undoFormulaRewriteCommand = source._undoFormulaRewriteCommand
      _richTextSubcommands = source._richTextSubcommands
      _columnRestoreData = source._columnRestoreData
      _rowRestoreData = source._rowRestoreData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._originalTableRange == nil {return false}
      if _storage._originalCellMap == nil {return false}
      if _storage._originalFooterRowCount == nil {return false}
      if _storage._transposedCellMap == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._originalTableRange, !v.isInitialized {return false}
      if let v = _storage._originalCellMap, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._ineligibleMergeList) {return false}
      if let v = _storage._transposedCellMap, !v.isInitialized {return false}
      if let v = _storage._undoFormulaRewriteCommand, !v.isInitialized {return false}
      if let v = _storage._richTextSubcommands, !v.isInitialized {return false}
      if let v = _storage._columnRestoreData, !v.isInitialized {return false}
      if let v = _storage._rowRestoreData, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._originalTableRange) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._originalCellMap) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._originalFooterRowCount) }()
        case 5: try { try decoder.decodeRepeatedFloatField(value: &_storage._originalColumnWidths) }()
        case 6: try { try decoder.decodeRepeatedFloatField(value: &_storage._originalRowHeights) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._ineligibleMergeList) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._transposedCellMap) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._undoFormulaRewriteCommand) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._richTextSubcommands) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._columnRestoreData) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._rowRestoreData) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._originalTableRange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._originalCellMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._originalFooterRowCount {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      if !_storage._originalColumnWidths.isEmpty {
        try visitor.visitRepeatedFloatField(value: _storage._originalColumnWidths, fieldNumber: 5)
      }
      if !_storage._originalRowHeights.isEmpty {
        try visitor.visitRepeatedFloatField(value: _storage._originalRowHeights, fieldNumber: 6)
      }
      if !_storage._ineligibleMergeList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ineligibleMergeList, fieldNumber: 7)
      }
      try { if let v = _storage._transposedCellMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._undoFormulaRewriteCommand {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._richTextSubcommands {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._columnRestoreData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._rowRestoreData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandTransposeTableArchive, rhs: TST_CommandTransposeTableArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._originalTableRange != rhs_storage._originalTableRange {return false}
        if _storage._originalCellMap != rhs_storage._originalCellMap {return false}
        if _storage._originalFooterRowCount != rhs_storage._originalFooterRowCount {return false}
        if _storage._originalColumnWidths != rhs_storage._originalColumnWidths {return false}
        if _storage._originalRowHeights != rhs_storage._originalRowHeights {return false}
        if _storage._ineligibleMergeList != rhs_storage._ineligibleMergeList {return false}
        if _storage._transposedCellMap != rhs_storage._transposedCellMap {return false}
        if _storage._undoFormulaRewriteCommand != rhs_storage._undoFormulaRewriteCommand {return false}
        if _storage._richTextSubcommands != rhs_storage._richTextSubcommands {return false}
        if _storage._columnRestoreData != rhs_storage._columnRestoreData {return false}
        if _storage._rowRestoreData != rhs_storage._rowRestoreData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandSetStructuredTextImportRecordArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetStructuredTextImportRecordArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}new_import_record\0\u{3}old_import_record\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._newImportRecord, !v.isInitialized {return false}
    if let v = self._oldImportRecord, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newImportRecord) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._oldImportRecord) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newImportRecord {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._oldImportRecord {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandSetStructuredTextImportRecordArchive, rhs: TST_CommandSetStructuredTextImportRecordArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._newImportRecord != rhs._newImportRecord {return false}
    if lhs._oldImportRecord != rhs._oldImportRecord {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandCategoryCollapseExpandGroupArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandCategoryCollapseExpandGroupArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}is_collapsing\0\u{3}grouping_columns\0\u{3}collapse_state\0\u{3}undo_collapse_state\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._isCollapsing == nil {return false}
    if self._groupingColumns == nil {return false}
    if self._collapseState == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._groupingColumns, !v.isInitialized {return false}
    if let v = self._collapseState, !v.isInitialized {return false}
    if let v = self._undoCollapseState, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isCollapsing) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._groupingColumns) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._collapseState) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._undoCollapseState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._isCollapsing {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._groupingColumns {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._collapseState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._undoCollapseState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandCategoryCollapseExpandGroupArchive, rhs: TST_CommandCategoryCollapseExpandGroupArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._isCollapsing != rhs._isCollapsing {return false}
    if lhs._groupingColumns != rhs._groupingColumns {return false}
    if lhs._collapseState != rhs._collapseState {return false}
    if lhs._undoCollapseState != rhs._undoCollapseState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandCategoryChangeSummaryAggregateType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandCategoryChangeSummaryAggregateType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}aggregate_type\0\u{3}undo_aggregate_type\0\u{3}column_uid\0\u{3}group_level\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._aggregateType == nil {return false}
    if self._undoAggregateType == nil {return false}
    if self._columnUid == nil {return false}
    if self._groupLevel == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._columnUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._aggregateType) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._undoAggregateType) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._columnUid) }()
      case 5: try { try decoder.decodeSingularSInt32Field(value: &self._groupLevel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._aggregateType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._undoAggregateType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._columnUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._groupLevel {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandCategoryChangeSummaryAggregateType, rhs: TST_CommandCategoryChangeSummaryAggregateType) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._aggregateType != rhs._aggregateType {return false}
    if lhs._undoAggregateType != rhs._undoAggregateType {return false}
    if lhs._columnUid != rhs._columnUid {return false}
    if lhs._groupLevel != rhs._groupLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandCategorySetLabelRowVisibility: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandCategorySetLabelRowVisibility"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}group_level\0\u{3}label_row_visibility\0\u{3}undo_label_row_visibility\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._groupLevel == nil {return false}
    if self._labelRowVisibility == nil {return false}
    if self._undoLabelRowVisibility == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._groupLevel) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._labelRowVisibility) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._undoLabelRowVisibility) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._groupLevel {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._labelRowVisibility {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._undoLabelRowVisibility {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandCategorySetLabelRowVisibility, rhs: TST_CommandCategorySetLabelRowVisibility) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._groupLevel != rhs._groupLevel {return false}
    if lhs._labelRowVisibility != rhs._labelRowVisibility {return false}
    if lhs._undoLabelRowVisibility != rhs._undoLabelRowVisibility {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandCategoryWillChangeGroupValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandCategoryWillChangeGroupValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}group_node_uid\0\u{3}undo_group_node_uid\0\u{3}group_value\0\u{3}undo_group_value\0\u{3}rewrite_command_for_undo\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._groupNodeUid == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._groupNodeUid, !v.isInitialized {return false}
    if let v = self._undoGroupNodeUid, !v.isInitialized {return false}
    if let v = self._groupValue, !v.isInitialized {return false}
    if let v = self._undoGroupValue, !v.isInitialized {return false}
    if let v = self._rewriteCommandForUndo, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._groupNodeUid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._undoGroupNodeUid) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._groupValue) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._undoGroupValue) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._rewriteCommandForUndo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._groupNodeUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._undoGroupNodeUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._groupValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._undoGroupValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._rewriteCommandForUndo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandCategoryWillChangeGroupValue, rhs: TST_CommandCategoryWillChangeGroupValue) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._groupNodeUid != rhs._groupNodeUid {return false}
    if lhs._undoGroupNodeUid != rhs._undoGroupNodeUid {return false}
    if lhs._groupValue != rhs._groupValue {return false}
    if lhs._undoGroupValue != rhs._undoGroupValue {return false}
    if lhs._rewriteCommandForUndo != rhs._rewriteCommandForUndo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_IdempotentSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IdempotentSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}archived_selection\0")

  public var isInitialized: Bool {
    if self._archivedSelection == nil {return false}
    if let v = self._archivedSelection, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._archivedSelection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._archivedSelection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_IdempotentSelectionTransformerArchive, rhs: TST_IdempotentSelectionTransformerArchive) -> Bool {
    if lhs._archivedSelection != rhs._archivedSelection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_WPSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WPSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}archived_selection\0\u{3}origin_cell_uid\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._archivedSelection == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._archivedSelection, !v.isInitialized {return false}
    if let v = self._originCellUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._archivedSelection) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._originCellUid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._archivedSelection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._originCellUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_WPSelectionTransformerArchive, rhs: TST_WPSelectionTransformerArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._archivedSelection != rhs._archivedSelection {return false}
    if lhs._originCellUid != rhs._originCellUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableSubSelectionTransformerBaseArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TableSubSelectionTransformerBaseArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}table_info_id_path\0")

  public var isInitialized: Bool {
    if self._tableInfoIDPath == nil {return false}
    if let v = self._tableInfoIDPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tableInfoIDPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tableInfoIDPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableSubSelectionTransformerBaseArchive, rhs: TST_TableSubSelectionTransformerBaseArchive) -> Bool {
    if lhs._tableInfoIDPath != rhs._tableInfoIDPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_TableNameSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TableNameSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_TableNameSelectionTransformerArchive, rhs: TST_TableNameSelectionTransformerArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_ControlCellSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ControlCellSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}cell_uids\0\u{3}origin_cell_uid\0\u{3}origin_cell_id\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._originCellID == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._cellUids, !v.isInitialized {return false}
    if let v = self._originCellUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cellUids) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._originCellUid) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._originCellID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cellUids {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._originCellUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._originCellID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_ControlCellSelectionTransformerArchive, rhs: TST_ControlCellSelectionTransformerArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._cellUids != rhs._cellUids {return false}
    if lhs._originCellUid != rhs._originCellUid {return false}
    if lhs._originCellID != rhs._originCellID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_StockCellSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StockCellSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}cell_uids\0\u{3}origin_cell_uid\0\u{3}origin_cell_id\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._originCellID == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._cellUids, !v.isInitialized {return false}
    if let v = self._originCellUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cellUids) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._originCellUid) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._originCellID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cellUids {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._originCellUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._originCellID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_StockCellSelectionTransformerArchive, rhs: TST_StockCellSelectionTransformerArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._cellUids != rhs._cellUids {return false}
    if lhs._originCellUid != rhs._originCellUid {return false}
    if lhs._originCellID != rhs._originCellID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_RegionSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegionSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}cell_uids\0\u{3}origin_cell_uid\0\u{3}anchor_cell_uid\0\u{3}cursor_cell_uid\0")

  fileprivate class _StorageClass {
    var _super: TST_TableSubSelectionTransformerBaseArchive? = nil
    var _cellUids: TST_CellUIDListArchive? = nil
    var _originCellUid: TSP_UUIDCoordArchive? = nil
    var _anchorCellUid: TSP_UUIDCoordArchive? = nil
    var _cursorCellUid: TSP_UUIDCoordArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _cellUids = source._cellUids
      _originCellUid = source._originCellUid
      _anchorCellUid = source._anchorCellUid
      _cursorCellUid = source._cursorCellUid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._anchorCellUid == nil {return false}
      if _storage._cursorCellUid == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._cellUids, !v.isInitialized {return false}
      if let v = _storage._originCellUid, !v.isInitialized {return false}
      if let v = _storage._anchorCellUid, !v.isInitialized {return false}
      if let v = _storage._cursorCellUid, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._cellUids) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._originCellUid) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._anchorCellUid) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._cursorCellUid) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._cellUids {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._originCellUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._anchorCellUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._cursorCellUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_RegionSelectionTransformerArchive, rhs: TST_RegionSelectionTransformerArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._cellUids != rhs_storage._cellUids {return false}
        if _storage._originCellUid != rhs_storage._originCellUid {return false}
        if _storage._anchorCellUid != rhs_storage._anchorCellUid {return false}
        if _storage._cursorCellUid != rhs_storage._cursorCellUid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_StrokeSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StrokeSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}archived_selection\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._archivedSelection == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._archivedSelection, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._archivedSelection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._archivedSelection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_StrokeSelectionTransformerArchive, rhs: TST_StrokeSelectionTransformerArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._archivedSelection != rhs._archivedSelection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_RowColumnSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RowColumnSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}selection_type\0\u{3}row_col_uids\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._selectionType == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rowColUids) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._selectionType) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.rowColUids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._selectionType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    if !self.rowColUids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rowColUids, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_RowColumnSelectionTransformerArchive, rhs: TST_RowColumnSelectionTransformerArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._selectionType != rhs._selectionType {return false}
    if lhs.rowColUids != rhs.rowColUids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandCategoryMoveRowsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandCategoryMoveRowsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}action_type\0\u{3}category_row_order\0\u{3}undo_category_row_order\0\u{3}cell_diff_map\0\u{3}undo_cell_diff_map\0\u{3}grouping_columns\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._actionType == nil {return false}
    if self._cellDiffMap == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.categoryRowOrder) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.undoCategoryRowOrder) {return false}
    if let v = self._cellDiffMap, !v.isInitialized {return false}
    if let v = self._undoCellDiffMap, !v.isInitialized {return false}
    if let v = self._groupingColumns, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._actionType) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.categoryRowOrder) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.undoCategoryRowOrder) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._cellDiffMap) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._undoCellDiffMap) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._groupingColumns) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._actionType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    if !self.categoryRowOrder.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.categoryRowOrder, fieldNumber: 3)
    }
    if !self.undoCategoryRowOrder.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.undoCategoryRowOrder, fieldNumber: 4)
    }
    try { if let v = self._cellDiffMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._undoCellDiffMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._groupingColumns {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandCategoryMoveRowsArchive, rhs: TST_CommandCategoryMoveRowsArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._actionType != rhs._actionType {return false}
    if lhs.categoryRowOrder != rhs.categoryRowOrder {return false}
    if lhs.undoCategoryRowOrder != rhs.undoCategoryRowOrder {return false}
    if lhs._cellDiffMap != rhs._cellDiffMap {return false}
    if lhs._undoCellDiffMap != rhs._undoCellDiffMap {return false}
    if lhs._groupingColumns != rhs._groupingColumns {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandRewriteHiddenStatesForGroupByChangeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandRewriteHiddenStatesForGroupByChangeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}group_by_change\0\u{3}collapsed_state\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._groupByChange == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._groupByChange, !v.isInitialized {return false}
    if let v = self._collapsedState, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._groupByChange) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._collapsedState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._groupByChange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._collapsedState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandRewriteHiddenStatesForGroupByChangeArchive, rhs: TST_CommandRewriteHiddenStatesForGroupByChangeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._groupByChange != rhs._groupByChange {return false}
    if lhs._collapsedState != rhs._collapsedState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandRewritePencilAnnotationFormulasArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandRewritePencilAnnotationFormulasArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}rewrite_spec\0\u{3}formulas_to_rewrite\0\u{3}annotations_for_undo\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._rewriteSpec == nil {return false}
    if self._formulasToRewrite == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._rewriteSpec, !v.isInitialized {return false}
    if let v = self._formulasToRewrite, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.annotationsForUndo) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rewriteSpec) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._formulasToRewrite) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.annotationsForUndo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rewriteSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._formulasToRewrite {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.annotationsForUndo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotationsForUndo, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandRewritePencilAnnotationFormulasArchive, rhs: TST_CommandRewritePencilAnnotationFormulasArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._rewriteSpec != rhs._rewriteSpec {return false}
    if lhs._formulasToRewrite != rhs._formulasToRewrite {return false}
    if lhs.annotationsForUndo != rhs.annotationsForUndo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandRewritePencilAnnotationFormulasArchive.AnnotationPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TST_CommandRewritePencilAnnotationFormulasArchive.protoMessageName + ".AnnotationPair"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}index\0\u{1}annotation\0")

  public var isInitialized: Bool {
    if self._index == nil {return false}
    if self._annotation == nil {return false}
    if let v = self._annotation, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._index) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._annotation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._index {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._annotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandRewritePencilAnnotationFormulasArchive.AnnotationPair, rhs: TST_CommandRewritePencilAnnotationFormulasArchive.AnnotationPair) -> Bool {
    if lhs._index != rhs._index {return false}
    if lhs._annotation != rhs._annotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandPivotSetPivotRulesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandPivotSetPivotRulesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}new_target_pivot_refresh_uid\0\u{3}new_row_groupings\0\u{3}old_row_groupings\0\u{3}new_column_groupings\0\u{3}old_column_groupings\0\u{3}new_aggregates\0\u{3}old_aggregates\0\u{3}new_flattening_dimension\0\u{3}old_flattening_dimension\0\u{3}new_pivot_data_model\0\u{3}old_pivot_data_model\0\u{3}new_pivot_refresh_uid\0\u{3}old_pivot_refresh_uid\0\u{3}new_pivot_refresh_timestamp\0\u{3}old_pivot_refresh_timestamp\0\u{3}new_options_map\0\u{3}old_options_map\0\u{3}new_view_row_order\0\u{3}old_view_row_order\0\u{3}new_view_column_order\0\u{3}old_view_column_order\0\u{3}new_collapsed_row_groups\0\u{3}old_collapsed_row_groups\0\u{3}new_collapsed_column_groups\0\u{3}old_collapsed_column_groups\0\u{3}new_hierarchical_cell_diff_map\0\u{3}old_hierarchical_cell_diff_map\0\u{3}formula_rewrite_command_for_undo\0\u{3}new_body_uid_tract\0\u{3}old_body_uid_tract\0\u{3}old_target_pivot_refresh_uid\0\u{3}new_target_pivot_row_column_rule_change_uid\0\u{3}old_target_pivot_row_column_rule_change_uid\0\u{3}new_target_pivot_aggregate_rule_change_uid\0\u{3}old_target_pivot_aggregate_rule_change_uid\0\u{3}is_order_finalized\0\u{4}\u{2}new_filter_set\0\u{3}old_filter_set\0\u{3}use_small_table_limits\0\u{3}setting_filters_enabled\0\u{3}undo_setting_filters_enabled\0")

  fileprivate class _StorageClass {
    var _super: TST_TableCommandArchive? = nil
    var _newTargetPivotRefreshUid: TSP_UUID? = nil
    var _newRowGroupings: TST_GroupColumnListArchive? = nil
    var _oldRowGroupings: TST_GroupColumnListArchive? = nil
    var _newColumnGroupings: TST_GroupColumnListArchive? = nil
    var _oldColumnGroupings: TST_GroupColumnListArchive? = nil
    var _newAggregates: TST_ColumnAggregateListArchive? = nil
    var _oldAggregates: TST_ColumnAggregateListArchive? = nil
    var _newFlatteningDimension: TST_TableDimensionArchive? = nil
    var _oldFlatteningDimension: TST_TableDimensionArchive? = nil
    var _newPivotDataModel: TSP_Reference? = nil
    var _oldPivotDataModel: TSP_Reference? = nil
    var _newPivotRefreshUid: TSP_UUID? = nil
    var _oldPivotRefreshUid: TSP_UUID? = nil
    var _newPivotRefreshTimestamp: Double? = nil
    var _oldPivotRefreshTimestamp: Double? = nil
    var _newOptionsMap: TSP_Reference? = nil
    var _oldOptionsMap: TSP_Reference? = nil
    var _newViewRowOrder: [TSP_UUID] = []
    var _oldViewRowOrder: [TSP_UUID] = []
    var _newViewColumnOrder: [TSP_UUID] = []
    var _oldViewColumnOrder: [TSP_UUID] = []
    var _newCollapsedRowGroups: [TSP_UUID] = []
    var _oldCollapsedRowGroups: [TSP_UUID] = []
    var _newCollapsedColumnGroups: [TSP_UUID] = []
    var _oldCollapsedColumnGroups: [TSP_UUID] = []
    var _newHierarchicalCellDiffMap: TST_HierarchicalCellDiffMapArchive? = nil
    var _oldHierarchicalCellDiffMap: TST_HierarchicalCellDiffMapArchive? = nil
    var _formulaRewriteCommandForUndo: TSP_Reference? = nil
    var _newBodyUidTract: TSP_UUIDRectArchive? = nil
    var _oldBodyUidTract: TSP_UUIDRectArchive? = nil
    var _oldTargetPivotRefreshUid: TSP_UUID? = nil
    var _newTargetPivotRowColumnRuleChangeUid: TSP_UUID? = nil
    var _oldTargetPivotRowColumnRuleChangeUid: TSP_UUID? = nil
    var _newTargetPivotAggregateRuleChangeUid: TSP_UUID? = nil
    var _oldTargetPivotAggregateRuleChangeUid: TSP_UUID? = nil
    var _isOrderFinalized: Bool? = nil
    var _newFilterSet: TSP_Reference? = nil
    var _oldFilterSet: TSP_Reference? = nil
    var _useSmallTableLimits: Bool? = nil
    var _settingFiltersEnabled: Int32? = nil
    var _undoSettingFiltersEnabled: Int32? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _newTargetPivotRefreshUid = source._newTargetPivotRefreshUid
      _newRowGroupings = source._newRowGroupings
      _oldRowGroupings = source._oldRowGroupings
      _newColumnGroupings = source._newColumnGroupings
      _oldColumnGroupings = source._oldColumnGroupings
      _newAggregates = source._newAggregates
      _oldAggregates = source._oldAggregates
      _newFlatteningDimension = source._newFlatteningDimension
      _oldFlatteningDimension = source._oldFlatteningDimension
      _newPivotDataModel = source._newPivotDataModel
      _oldPivotDataModel = source._oldPivotDataModel
      _newPivotRefreshUid = source._newPivotRefreshUid
      _oldPivotRefreshUid = source._oldPivotRefreshUid
      _newPivotRefreshTimestamp = source._newPivotRefreshTimestamp
      _oldPivotRefreshTimestamp = source._oldPivotRefreshTimestamp
      _newOptionsMap = source._newOptionsMap
      _oldOptionsMap = source._oldOptionsMap
      _newViewRowOrder = source._newViewRowOrder
      _oldViewRowOrder = source._oldViewRowOrder
      _newViewColumnOrder = source._newViewColumnOrder
      _oldViewColumnOrder = source._oldViewColumnOrder
      _newCollapsedRowGroups = source._newCollapsedRowGroups
      _oldCollapsedRowGroups = source._oldCollapsedRowGroups
      _newCollapsedColumnGroups = source._newCollapsedColumnGroups
      _oldCollapsedColumnGroups = source._oldCollapsedColumnGroups
      _newHierarchicalCellDiffMap = source._newHierarchicalCellDiffMap
      _oldHierarchicalCellDiffMap = source._oldHierarchicalCellDiffMap
      _formulaRewriteCommandForUndo = source._formulaRewriteCommandForUndo
      _newBodyUidTract = source._newBodyUidTract
      _oldBodyUidTract = source._oldBodyUidTract
      _oldTargetPivotRefreshUid = source._oldTargetPivotRefreshUid
      _newTargetPivotRowColumnRuleChangeUid = source._newTargetPivotRowColumnRuleChangeUid
      _oldTargetPivotRowColumnRuleChangeUid = source._oldTargetPivotRowColumnRuleChangeUid
      _newTargetPivotAggregateRuleChangeUid = source._newTargetPivotAggregateRuleChangeUid
      _oldTargetPivotAggregateRuleChangeUid = source._oldTargetPivotAggregateRuleChangeUid
      _isOrderFinalized = source._isOrderFinalized
      _newFilterSet = source._newFilterSet
      _oldFilterSet = source._oldFilterSet
      _useSmallTableLimits = source._useSmallTableLimits
      _settingFiltersEnabled = source._settingFiltersEnabled
      _undoSettingFiltersEnabled = source._undoSettingFiltersEnabled
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._newTargetPivotRefreshUid, !v.isInitialized {return false}
      if let v = _storage._newRowGroupings, !v.isInitialized {return false}
      if let v = _storage._oldRowGroupings, !v.isInitialized {return false}
      if let v = _storage._newColumnGroupings, !v.isInitialized {return false}
      if let v = _storage._oldColumnGroupings, !v.isInitialized {return false}
      if let v = _storage._newAggregates, !v.isInitialized {return false}
      if let v = _storage._oldAggregates, !v.isInitialized {return false}
      if let v = _storage._newPivotDataModel, !v.isInitialized {return false}
      if let v = _storage._oldPivotDataModel, !v.isInitialized {return false}
      if let v = _storage._newPivotRefreshUid, !v.isInitialized {return false}
      if let v = _storage._oldPivotRefreshUid, !v.isInitialized {return false}
      if let v = _storage._newOptionsMap, !v.isInitialized {return false}
      if let v = _storage._oldOptionsMap, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._newViewRowOrder) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._oldViewRowOrder) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._newViewColumnOrder) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._oldViewColumnOrder) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._newCollapsedRowGroups) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._oldCollapsedRowGroups) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._newCollapsedColumnGroups) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._oldCollapsedColumnGroups) {return false}
      if let v = _storage._newHierarchicalCellDiffMap, !v.isInitialized {return false}
      if let v = _storage._oldHierarchicalCellDiffMap, !v.isInitialized {return false}
      if let v = _storage._formulaRewriteCommandForUndo, !v.isInitialized {return false}
      if let v = _storage._newBodyUidTract, !v.isInitialized {return false}
      if let v = _storage._oldBodyUidTract, !v.isInitialized {return false}
      if let v = _storage._oldTargetPivotRefreshUid, !v.isInitialized {return false}
      if let v = _storage._newTargetPivotRowColumnRuleChangeUid, !v.isInitialized {return false}
      if let v = _storage._oldTargetPivotRowColumnRuleChangeUid, !v.isInitialized {return false}
      if let v = _storage._newTargetPivotAggregateRuleChangeUid, !v.isInitialized {return false}
      if let v = _storage._oldTargetPivotAggregateRuleChangeUid, !v.isInitialized {return false}
      if let v = _storage._newFilterSet, !v.isInitialized {return false}
      if let v = _storage._oldFilterSet, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._newTargetPivotRefreshUid) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._newRowGroupings) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._oldRowGroupings) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._newColumnGroupings) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._oldColumnGroupings) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._newAggregates) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._oldAggregates) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._newFlatteningDimension) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._oldFlatteningDimension) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._newPivotDataModel) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._oldPivotDataModel) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._newPivotRefreshUid) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._oldPivotRefreshUid) }()
        case 15: try { try decoder.decodeSingularDoubleField(value: &_storage._newPivotRefreshTimestamp) }()
        case 16: try { try decoder.decodeSingularDoubleField(value: &_storage._oldPivotRefreshTimestamp) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._newOptionsMap) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._oldOptionsMap) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._newViewRowOrder) }()
        case 20: try { try decoder.decodeRepeatedMessageField(value: &_storage._oldViewRowOrder) }()
        case 21: try { try decoder.decodeRepeatedMessageField(value: &_storage._newViewColumnOrder) }()
        case 22: try { try decoder.decodeRepeatedMessageField(value: &_storage._oldViewColumnOrder) }()
        case 23: try { try decoder.decodeRepeatedMessageField(value: &_storage._newCollapsedRowGroups) }()
        case 24: try { try decoder.decodeRepeatedMessageField(value: &_storage._oldCollapsedRowGroups) }()
        case 25: try { try decoder.decodeRepeatedMessageField(value: &_storage._newCollapsedColumnGroups) }()
        case 26: try { try decoder.decodeRepeatedMessageField(value: &_storage._oldCollapsedColumnGroups) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._newHierarchicalCellDiffMap) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._oldHierarchicalCellDiffMap) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._formulaRewriteCommandForUndo) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._newBodyUidTract) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._oldBodyUidTract) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._oldTargetPivotRefreshUid) }()
        case 33: try { try decoder.decodeSingularMessageField(value: &_storage._newTargetPivotRowColumnRuleChangeUid) }()
        case 34: try { try decoder.decodeSingularMessageField(value: &_storage._oldTargetPivotRowColumnRuleChangeUid) }()
        case 35: try { try decoder.decodeSingularMessageField(value: &_storage._newTargetPivotAggregateRuleChangeUid) }()
        case 36: try { try decoder.decodeSingularMessageField(value: &_storage._oldTargetPivotAggregateRuleChangeUid) }()
        case 37: try { try decoder.decodeSingularBoolField(value: &_storage._isOrderFinalized) }()
        case 39: try { try decoder.decodeSingularMessageField(value: &_storage._newFilterSet) }()
        case 40: try { try decoder.decodeSingularMessageField(value: &_storage._oldFilterSet) }()
        case 41: try { try decoder.decodeSingularBoolField(value: &_storage._useSmallTableLimits) }()
        case 42: try { try decoder.decodeSingularInt32Field(value: &_storage._settingFiltersEnabled) }()
        case 43: try { try decoder.decodeSingularInt32Field(value: &_storage._undoSettingFiltersEnabled) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._newTargetPivotRefreshUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._newRowGroupings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._oldRowGroupings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._newColumnGroupings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._oldColumnGroupings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._newAggregates {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._oldAggregates {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._newFlatteningDimension {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._oldFlatteningDimension {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._newPivotDataModel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._oldPivotDataModel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._newPivotRefreshUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._oldPivotRefreshUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._newPivotRefreshTimestamp {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._oldPivotRefreshTimestamp {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._newOptionsMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._oldOptionsMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      if !_storage._newViewRowOrder.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._newViewRowOrder, fieldNumber: 19)
      }
      if !_storage._oldViewRowOrder.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oldViewRowOrder, fieldNumber: 20)
      }
      if !_storage._newViewColumnOrder.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._newViewColumnOrder, fieldNumber: 21)
      }
      if !_storage._oldViewColumnOrder.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oldViewColumnOrder, fieldNumber: 22)
      }
      if !_storage._newCollapsedRowGroups.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._newCollapsedRowGroups, fieldNumber: 23)
      }
      if !_storage._oldCollapsedRowGroups.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oldCollapsedRowGroups, fieldNumber: 24)
      }
      if !_storage._newCollapsedColumnGroups.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._newCollapsedColumnGroups, fieldNumber: 25)
      }
      if !_storage._oldCollapsedColumnGroups.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oldCollapsedColumnGroups, fieldNumber: 26)
      }
      try { if let v = _storage._newHierarchicalCellDiffMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      } }()
      try { if let v = _storage._oldHierarchicalCellDiffMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._formulaRewriteCommandForUndo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._newBodyUidTract {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._oldBodyUidTract {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._oldTargetPivotRefreshUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._newTargetPivotRowColumnRuleChangeUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      } }()
      try { if let v = _storage._oldTargetPivotRowColumnRuleChangeUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      } }()
      try { if let v = _storage._newTargetPivotAggregateRuleChangeUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      } }()
      try { if let v = _storage._oldTargetPivotAggregateRuleChangeUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      } }()
      try { if let v = _storage._isOrderFinalized {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 37)
      } }()
      try { if let v = _storage._newFilterSet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      } }()
      try { if let v = _storage._oldFilterSet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      } }()
      try { if let v = _storage._useSmallTableLimits {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 41)
      } }()
      try { if let v = _storage._settingFiltersEnabled {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 42)
      } }()
      try { if let v = _storage._undoSettingFiltersEnabled {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 43)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandPivotSetPivotRulesArchive, rhs: TST_CommandPivotSetPivotRulesArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._newTargetPivotRefreshUid != rhs_storage._newTargetPivotRefreshUid {return false}
        if _storage._newRowGroupings != rhs_storage._newRowGroupings {return false}
        if _storage._oldRowGroupings != rhs_storage._oldRowGroupings {return false}
        if _storage._newColumnGroupings != rhs_storage._newColumnGroupings {return false}
        if _storage._oldColumnGroupings != rhs_storage._oldColumnGroupings {return false}
        if _storage._newAggregates != rhs_storage._newAggregates {return false}
        if _storage._oldAggregates != rhs_storage._oldAggregates {return false}
        if _storage._newFlatteningDimension != rhs_storage._newFlatteningDimension {return false}
        if _storage._oldFlatteningDimension != rhs_storage._oldFlatteningDimension {return false}
        if _storage._newPivotDataModel != rhs_storage._newPivotDataModel {return false}
        if _storage._oldPivotDataModel != rhs_storage._oldPivotDataModel {return false}
        if _storage._newPivotRefreshUid != rhs_storage._newPivotRefreshUid {return false}
        if _storage._oldPivotRefreshUid != rhs_storage._oldPivotRefreshUid {return false}
        if _storage._newPivotRefreshTimestamp != rhs_storage._newPivotRefreshTimestamp {return false}
        if _storage._oldPivotRefreshTimestamp != rhs_storage._oldPivotRefreshTimestamp {return false}
        if _storage._newOptionsMap != rhs_storage._newOptionsMap {return false}
        if _storage._oldOptionsMap != rhs_storage._oldOptionsMap {return false}
        if _storage._newViewRowOrder != rhs_storage._newViewRowOrder {return false}
        if _storage._oldViewRowOrder != rhs_storage._oldViewRowOrder {return false}
        if _storage._newViewColumnOrder != rhs_storage._newViewColumnOrder {return false}
        if _storage._oldViewColumnOrder != rhs_storage._oldViewColumnOrder {return false}
        if _storage._newCollapsedRowGroups != rhs_storage._newCollapsedRowGroups {return false}
        if _storage._oldCollapsedRowGroups != rhs_storage._oldCollapsedRowGroups {return false}
        if _storage._newCollapsedColumnGroups != rhs_storage._newCollapsedColumnGroups {return false}
        if _storage._oldCollapsedColumnGroups != rhs_storage._oldCollapsedColumnGroups {return false}
        if _storage._newHierarchicalCellDiffMap != rhs_storage._newHierarchicalCellDiffMap {return false}
        if _storage._oldHierarchicalCellDiffMap != rhs_storage._oldHierarchicalCellDiffMap {return false}
        if _storage._formulaRewriteCommandForUndo != rhs_storage._formulaRewriteCommandForUndo {return false}
        if _storage._newBodyUidTract != rhs_storage._newBodyUidTract {return false}
        if _storage._oldBodyUidTract != rhs_storage._oldBodyUidTract {return false}
        if _storage._oldTargetPivotRefreshUid != rhs_storage._oldTargetPivotRefreshUid {return false}
        if _storage._newTargetPivotRowColumnRuleChangeUid != rhs_storage._newTargetPivotRowColumnRuleChangeUid {return false}
        if _storage._oldTargetPivotRowColumnRuleChangeUid != rhs_storage._oldTargetPivotRowColumnRuleChangeUid {return false}
        if _storage._newTargetPivotAggregateRuleChangeUid != rhs_storage._newTargetPivotAggregateRuleChangeUid {return false}
        if _storage._oldTargetPivotAggregateRuleChangeUid != rhs_storage._oldTargetPivotAggregateRuleChangeUid {return false}
        if _storage._isOrderFinalized != rhs_storage._isOrderFinalized {return false}
        if _storage._newFilterSet != rhs_storage._newFilterSet {return false}
        if _storage._oldFilterSet != rhs_storage._oldFilterSet {return false}
        if _storage._useSmallTableLimits != rhs_storage._useSmallTableLimits {return false}
        if _storage._settingFiltersEnabled != rhs_storage._settingFiltersEnabled {return false}
        if _storage._undoSettingFiltersEnabled != rhs_storage._undoSettingFiltersEnabled {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandPivotSetGroupingColumnOptionsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandPivotSetGroupingColumnOptionsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}grouping_column_uid\0\u{3}non_sorting_flag\0\u{3}bool_value\0\u{3}undo_bool_value\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._groupingColumnUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._groupingColumnUid) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._nonSortingFlag) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._boolValue) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._undoBoolValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._groupingColumnUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._nonSortingFlag {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._boolValue {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._undoBoolValue {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandPivotSetGroupingColumnOptionsArchive, rhs: TST_CommandPivotSetGroupingColumnOptionsArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._groupingColumnUid != rhs._groupingColumnUid {return false}
    if lhs._nonSortingFlag != rhs._nonSortingFlag {return false}
    if lhs._boolValue != rhs._boolValue {return false}
    if lhs._undoBoolValue != rhs._undoBoolValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandPivotHideShowGrandTotalsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandPivotHideShowGrandTotalsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}dimension\0\u{3}is_hiding\0\u{3}undo_is_hiding\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._dimension) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._isHiding) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._undoIsHiding) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._dimension {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._isHiding {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._undoIsHiding {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandPivotHideShowGrandTotalsArchive, rhs: TST_CommandPivotHideShowGrandTotalsArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._dimension != rhs._dimension {return false}
    if lhs._isHiding != rhs._isHiding {return false}
    if lhs._undoIsHiding != rhs._undoIsHiding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandPivotSortArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandPivotSortArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}dimension\0\u{3}column_order\0\u{3}undo_column_order\0\u{3}row_order\0\u{3}undo_row_order\0\u{3}target_pivot_row_column_rule_change_uid\0\u{3}target_pivot_aggregate_rule_change_uid\0\u{3}target_pivot_data_refresh_uid\0\u{3}grouping_column_uid\0\u{3}sorting_flags\0\u{3}undo_sorting_flags\0\u{3}sorting_aggregate_rule_uid\0\u{3}undo_sorting_aggregate_rule_uid\0\u{3}is_order_finalized\0")

  fileprivate class _StorageClass {
    var _super: TST_TableCommandArchive? = nil
    var _dimension: TST_TableDimensionArchive? = nil
    var _columnOrder: [TSP_UUID] = []
    var _undoColumnOrder: [TSP_UUID] = []
    var _rowOrder: [TSP_UUID] = []
    var _undoRowOrder: [TSP_UUID] = []
    var _targetPivotRowColumnRuleChangeUid: TSP_UUID? = nil
    var _targetPivotAggregateRuleChangeUid: TSP_UUID? = nil
    var _targetPivotDataRefreshUid: TSP_UUID? = nil
    var _groupingColumnUid: TSP_UUID? = nil
    var _sortingFlags: UInt32? = nil
    var _undoSortingFlags: UInt32? = nil
    var _sortingAggregateRuleUid: TSP_UUID? = nil
    var _undoSortingAggregateRuleUid: TSP_UUID? = nil
    var _isOrderFinalized: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _dimension = source._dimension
      _columnOrder = source._columnOrder
      _undoColumnOrder = source._undoColumnOrder
      _rowOrder = source._rowOrder
      _undoRowOrder = source._undoRowOrder
      _targetPivotRowColumnRuleChangeUid = source._targetPivotRowColumnRuleChangeUid
      _targetPivotAggregateRuleChangeUid = source._targetPivotAggregateRuleChangeUid
      _targetPivotDataRefreshUid = source._targetPivotDataRefreshUid
      _groupingColumnUid = source._groupingColumnUid
      _sortingFlags = source._sortingFlags
      _undoSortingFlags = source._undoSortingFlags
      _sortingAggregateRuleUid = source._sortingAggregateRuleUid
      _undoSortingAggregateRuleUid = source._undoSortingAggregateRuleUid
      _isOrderFinalized = source._isOrderFinalized
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._targetPivotRowColumnRuleChangeUid == nil {return false}
      if _storage._targetPivotAggregateRuleChangeUid == nil {return false}
      if _storage._targetPivotDataRefreshUid == nil {return false}
      if _storage._isOrderFinalized == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._columnOrder) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._undoColumnOrder) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._rowOrder) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._undoRowOrder) {return false}
      if let v = _storage._targetPivotRowColumnRuleChangeUid, !v.isInitialized {return false}
      if let v = _storage._targetPivotAggregateRuleChangeUid, !v.isInitialized {return false}
      if let v = _storage._targetPivotDataRefreshUid, !v.isInitialized {return false}
      if let v = _storage._groupingColumnUid, !v.isInitialized {return false}
      if let v = _storage._sortingAggregateRuleUid, !v.isInitialized {return false}
      if let v = _storage._undoSortingAggregateRuleUid, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._dimension) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._columnOrder) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._undoColumnOrder) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._rowOrder) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._undoRowOrder) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._targetPivotRowColumnRuleChangeUid) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._targetPivotAggregateRuleChangeUid) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._targetPivotDataRefreshUid) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._groupingColumnUid) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._sortingFlags) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._undoSortingFlags) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._sortingAggregateRuleUid) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._undoSortingAggregateRuleUid) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._isOrderFinalized) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._dimension {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      } }()
      if !_storage._columnOrder.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._columnOrder, fieldNumber: 3)
      }
      if !_storage._undoColumnOrder.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._undoColumnOrder, fieldNumber: 4)
      }
      if !_storage._rowOrder.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rowOrder, fieldNumber: 5)
      }
      if !_storage._undoRowOrder.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._undoRowOrder, fieldNumber: 6)
      }
      try { if let v = _storage._targetPivotRowColumnRuleChangeUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._targetPivotAggregateRuleChangeUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._targetPivotDataRefreshUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._groupingColumnUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._sortingFlags {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._undoSortingFlags {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._sortingAggregateRuleUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._undoSortingAggregateRuleUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._isOrderFinalized {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandPivotSortArchive, rhs: TST_CommandPivotSortArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._dimension != rhs_storage._dimension {return false}
        if _storage._columnOrder != rhs_storage._columnOrder {return false}
        if _storage._undoColumnOrder != rhs_storage._undoColumnOrder {return false}
        if _storage._rowOrder != rhs_storage._rowOrder {return false}
        if _storage._undoRowOrder != rhs_storage._undoRowOrder {return false}
        if _storage._targetPivotRowColumnRuleChangeUid != rhs_storage._targetPivotRowColumnRuleChangeUid {return false}
        if _storage._targetPivotAggregateRuleChangeUid != rhs_storage._targetPivotAggregateRuleChangeUid {return false}
        if _storage._targetPivotDataRefreshUid != rhs_storage._targetPivotDataRefreshUid {return false}
        if _storage._groupingColumnUid != rhs_storage._groupingColumnUid {return false}
        if _storage._sortingFlags != rhs_storage._sortingFlags {return false}
        if _storage._undoSortingFlags != rhs_storage._undoSortingFlags {return false}
        if _storage._sortingAggregateRuleUid != rhs_storage._sortingAggregateRuleUid {return false}
        if _storage._undoSortingAggregateRuleUid != rhs_storage._undoSortingAggregateRuleUid {return false}
        if _storage._isOrderFinalized != rhs_storage._isOrderFinalized {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandRewriteTrackedReferencesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandRewriteTrackedReferencesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}rewrite_spec\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._rewriteSpec, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rewriteSpec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rewriteSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandRewriteTrackedReferencesArchive, rhs: TST_CommandRewriteTrackedReferencesArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._rewriteSpec != rhs._rewriteSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TST_CommandExtendTableIDHistoryArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandExtendTableIDHistoryArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}rewrite_spec\0\u{3}table_uid_history_rollback\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._rewriteSpec == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._rewriteSpec, !v.isInitialized {return false}
    if let v = self._tableUidHistoryRollback, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rewriteSpec) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tableUidHistoryRollback) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rewriteSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._tableUidHistoryRollback {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TST_CommandExtendTableIDHistoryArchive, rhs: TST_CommandExtendTableIDHistoryArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._rewriteSpec != rhs._rewriteSpec {return false}
    if lhs._tableUidHistoryRollback != rhs._tableUidHistoryRollback {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
