// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TNCommandArchives.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct TN_CommandFormChooseTargetTableArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var tableID: TSP_UUID {
    get {return _storage._tableID ?? TSP_UUID()}
    set {_uniqueStorage()._tableID = newValue}
  }
  /// Returns true if `tableID` has been explicitly set.
  var hasTableID: Bool {return _storage._tableID != nil}
  /// Clears the value of `tableID`. Subsequent reads from it will return its default value.
  mutating func clearTableID() {_uniqueStorage()._tableID = nil}

  var previousTableID: TSP_UUID {
    get {return _storage._previousTableID ?? TSP_UUID()}
    set {_uniqueStorage()._previousTableID = newValue}
  }
  /// Returns true if `previousTableID` has been explicitly set.
  var hasPreviousTableID: Bool {return _storage._previousTableID != nil}
  /// Clears the value of `previousTableID`. Subsequent reads from it will return its default value.
  mutating func clearPreviousTableID() {_uniqueStorage()._previousTableID = nil}

  var sheetName: String {
    get {return _storage._sheetName ?? String()}
    set {_uniqueStorage()._sheetName = newValue}
  }
  /// Returns true if `sheetName` has been explicitly set.
  var hasSheetName: Bool {return _storage._sheetName != nil}
  /// Clears the value of `sheetName`. Subsequent reads from it will return its default value.
  mutating func clearSheetName() {_uniqueStorage()._sheetName = nil}

  var previousSheetName: String {
    get {return _storage._previousSheetName ?? String()}
    set {_uniqueStorage()._previousSheetName = newValue}
  }
  /// Returns true if `previousSheetName` has been explicitly set.
  var hasPreviousSheetName: Bool {return _storage._previousSheetName != nil}
  /// Clears the value of `previousSheetName`. Subsequent reads from it will return its default value.
  mutating func clearPreviousSheetName() {_uniqueStorage()._previousSheetName = nil}

  var sheetID: TSP_UUID {
    get {return _storage._sheetID ?? TSP_UUID()}
    set {_uniqueStorage()._sheetID = newValue}
  }
  /// Returns true if `sheetID` has been explicitly set.
  var hasSheetID: Bool {return _storage._sheetID != nil}
  /// Clears the value of `sheetID`. Subsequent reads from it will return its default value.
  mutating func clearSheetID() {_uniqueStorage()._sheetID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TN_CommandSheetInsertDrawablesArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var sheetID: TSP_UUID {
    get {return _storage._sheetID ?? TSP_UUID()}
    set {_uniqueStorage()._sheetID = newValue}
  }
  /// Returns true if `sheetID` has been explicitly set.
  var hasSheetID: Bool {return _storage._sheetID != nil}
  /// Clears the value of `sheetID`. Subsequent reads from it will return its default value.
  mutating func clearSheetID() {_uniqueStorage()._sheetID = nil}

  var drawables: [TSP_Reference] {
    get {return _storage._drawables}
    set {_uniqueStorage()._drawables = newValue}
  }

  var argsList: [TSCK_AddIdOperationArgs] {
    get {return _storage._argsList}
    set {_uniqueStorage()._argsList = newValue}
  }

  var forPaste: Bool {
    get {return _storage._forPaste ?? false}
    set {_uniqueStorage()._forPaste = newValue}
  }
  /// Returns true if `forPaste` has been explicitly set.
  var hasForPaste: Bool {return _storage._forPaste != nil}
  /// Clears the value of `forPaste`. Subsequent reads from it will return its default value.
  mutating func clearForPaste() {_uniqueStorage()._forPaste = nil}

  var customFormatKeys: [TSP_UUID] {
    get {return _storage._customFormatKeys}
    set {_uniqueStorage()._customFormatKeys = newValue}
  }

  var drawableUndoObject: TSP_Reference {
    get {return _storage._drawableUndoObject ?? TSP_Reference()}
    set {_uniqueStorage()._drawableUndoObject = newValue}
  }
  /// Returns true if `drawableUndoObject` has been explicitly set.
  var hasDrawableUndoObject: Bool {return _storage._drawableUndoObject != nil}
  /// Clears the value of `drawableUndoObject`. Subsequent reads from it will return its default value.
  mutating func clearDrawableUndoObject() {_uniqueStorage()._drawableUndoObject = nil}

  var formulaRewriteCommandForUndo: TSP_Reference {
    get {return _storage._formulaRewriteCommandForUndo ?? TSP_Reference()}
    set {_uniqueStorage()._formulaRewriteCommandForUndo = newValue}
  }
  /// Returns true if `formulaRewriteCommandForUndo` has been explicitly set.
  var hasFormulaRewriteCommandForUndo: Bool {return _storage._formulaRewriteCommandForUndo != nil}
  /// Clears the value of `formulaRewriteCommandForUndo`. Subsequent reads from it will return its default value.
  mutating func clearFormulaRewriteCommandForUndo() {_uniqueStorage()._formulaRewriteCommandForUndo = nil}

  var savedNextUntitledResolverIndex: UInt32 {
    get {return _storage._savedNextUntitledResolverIndex ?? 0}
    set {_uniqueStorage()._savedNextUntitledResolverIndex = newValue}
  }
  /// Returns true if `savedNextUntitledResolverIndex` has been explicitly set.
  var hasSavedNextUntitledResolverIndex: Bool {return _storage._savedNextUntitledResolverIndex != nil}
  /// Clears the value of `savedNextUntitledResolverIndex`. Subsequent reads from it will return its default value.
  mutating func clearSavedNextUntitledResolverIndex() {_uniqueStorage()._savedNextUntitledResolverIndex = nil}

  var chartEntityUidForBackingTables: [TSP_UUID] {
    get {return _storage._chartEntityUidForBackingTables}
    set {_uniqueStorage()._chartEntityUidForBackingTables = newValue}
  }

  var backingTables: [TSP_Reference] {
    get {return _storage._backingTables}
    set {_uniqueStorage()._backingTables = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TN_CommandSheetRemoveDrawablesArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var sheetID: TSP_UUID {
    get {return _storage._sheetID ?? TSP_UUID()}
    set {_uniqueStorage()._sheetID = newValue}
  }
  /// Returns true if `sheetID` has been explicitly set.
  var hasSheetID: Bool {return _storage._sheetID != nil}
  /// Clears the value of `sheetID`. Subsequent reads from it will return its default value.
  mutating func clearSheetID() {_uniqueStorage()._sheetID = nil}

  var argsList: [TSCK_RemoveIdOperationArgs] {
    get {return _storage._argsList}
    set {_uniqueStorage()._argsList = newValue}
  }

  var drawables: [TSP_Reference] {
    get {return _storage._drawables}
    set {_uniqueStorage()._drawables = newValue}
  }

  var chartEntityUidForBackingTables: [TSP_UUID] {
    get {return _storage._chartEntityUidForBackingTables}
    set {_uniqueStorage()._chartEntityUidForBackingTables = newValue}
  }

  var backingTableUids: [TSP_UUID] {
    get {return _storage._backingTableUids}
    set {_uniqueStorage()._backingTableUids = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TN_CommandSheetMoveDrawableZOrderArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var sheetID: TSP_UUID {
    get {return _sheetID ?? TSP_UUID()}
    set {_sheetID = newValue}
  }
  /// Returns true if `sheetID` has been explicitly set.
  var hasSheetID: Bool {return self._sheetID != nil}
  /// Clears the value of `sheetID`. Subsequent reads from it will return its default value.
  mutating func clearSheetID() {self._sheetID = nil}

  var argsList: [TSCK_RearrangeIdOperationArgs] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _sheetID: TSP_UUID? = nil
}

struct TN_CommandDocumentInsertSheetArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var argsList: [TSCK_AddIdOperationArgs] {
    get {return _storage._argsList}
    set {_uniqueStorage()._argsList = newValue}
  }

  var sheets: [TSP_Reference] {
    get {return _storage._sheets}
    set {_uniqueStorage()._sheets = newValue}
  }

  var allowSameSheetNameAsForms: Bool {
    get {return _storage._allowSameSheetNameAsForms ?? false}
    set {_uniqueStorage()._allowSameSheetNameAsForms = newValue}
  }
  /// Returns true if `allowSameSheetNameAsForms` has been explicitly set.
  var hasAllowSameSheetNameAsForms: Bool {return _storage._allowSameSheetNameAsForms != nil}
  /// Clears the value of `allowSameSheetNameAsForms`. Subsequent reads from it will return its default value.
  mutating func clearAllowSameSheetNameAsForms() {_uniqueStorage()._allowSameSheetNameAsForms = nil}

  var customFormatKeys: [TSP_UUID] {
    get {return _storage._customFormatKeys}
    set {_uniqueStorage()._customFormatKeys = newValue}
  }

  var drawableUndoObject: TSP_Reference {
    get {return _storage._drawableUndoObject ?? TSP_Reference()}
    set {_uniqueStorage()._drawableUndoObject = newValue}
  }
  /// Returns true if `drawableUndoObject` has been explicitly set.
  var hasDrawableUndoObject: Bool {return _storage._drawableUndoObject != nil}
  /// Clears the value of `drawableUndoObject`. Subsequent reads from it will return its default value.
  mutating func clearDrawableUndoObject() {_uniqueStorage()._drawableUndoObject = nil}

  var sheetUistates: [TN_UUIDSheetUIStateDictionaryArchive] {
    get {return _storage._sheetUistates}
    set {_uniqueStorage()._sheetUistates = newValue}
  }

  var forPaste: Bool {
    get {return _storage._forPaste ?? false}
    set {_uniqueStorage()._forPaste = newValue}
  }
  /// Returns true if `forPaste` has been explicitly set.
  var hasForPaste: Bool {return _storage._forPaste != nil}
  /// Clears the value of `forPaste`. Subsequent reads from it will return its default value.
  mutating func clearForPaste() {_uniqueStorage()._forPaste = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TN_CommandDocumentRemoveSheetArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var argsList: [TSCK_RemoveIdOperationArgs] = []

  var sheets: [TSP_Reference] = []

  var rescueID: String {
    get {return _rescueID ?? String()}
    set {_rescueID = newValue}
  }
  /// Returns true if `rescueID` has been explicitly set.
  var hasRescueID: Bool {return self._rescueID != nil}
  /// Clears the value of `rescueID`. Subsequent reads from it will return its default value.
  mutating func clearRescueID() {self._rescueID = nil}

  var sheetUistates: [TN_UUIDSheetUIStateDictionaryArchive] = []

  var isUndoPaste: Bool {
    get {return _isUndoPaste ?? false}
    set {_isUndoPaste = newValue}
  }
  /// Returns true if `isUndoPaste` has been explicitly set.
  var hasIsUndoPaste: Bool {return self._isUndoPaste != nil}
  /// Clears the value of `isUndoPaste`. Subsequent reads from it will return its default value.
  mutating func clearIsUndoPaste() {self._isUndoPaste = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _rescueID: String? = nil
  fileprivate var _isUndoPaste: Bool? = nil
}

struct TN_CommandDocumentReorderSheetArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var argsList: [TSCK_RearrangeIdOperationArgs] = []

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
}

struct TN_CommandSetSheetNameArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var newname: String {
    get {return _newname ?? String()}
    set {_newname = newValue}
  }
  /// Returns true if `newname` has been explicitly set.
  var hasNewname: Bool {return self._newname != nil}
  /// Clears the value of `newname`. Subsequent reads from it will return its default value.
  mutating func clearNewname() {self._newname = nil}

  var sheetUid: TSP_UUID {
    get {return _sheetUid ?? TSP_UUID()}
    set {_sheetUid = newValue}
  }
  /// Returns true if `sheetUid` has been explicitly set.
  var hasSheetUid: Bool {return self._sheetUid != nil}
  /// Clears the value of `sheetUid`. Subsequent reads from it will return its default value.
  mutating func clearSheetUid() {self._sheetUid = nil}

  var oldname: String {
    get {return _oldname ?? String()}
    set {_oldname = newValue}
  }
  /// Returns true if `oldname` has been explicitly set.
  var hasOldname: Bool {return self._oldname != nil}
  /// Clears the value of `oldname`. Subsequent reads from it will return its default value.
  mutating func clearOldname() {self._oldname = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _newname: String? = nil
  fileprivate var _sheetUid: TSP_UUID? = nil
  fileprivate var _oldname: String? = nil
}

struct TN_CommandSetSheetShouldPrintCommentsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var newShouldPrintComments: Bool {
    get {return _newShouldPrintComments ?? false}
    set {_newShouldPrintComments = newValue}
  }
  /// Returns true if `newShouldPrintComments` has been explicitly set.
  var hasNewShouldPrintComments: Bool {return self._newShouldPrintComments != nil}
  /// Clears the value of `newShouldPrintComments`. Subsequent reads from it will return its default value.
  mutating func clearNewShouldPrintComments() {self._newShouldPrintComments = nil}

  var sheetUid: TSP_UUID {
    get {return _sheetUid ?? TSP_UUID()}
    set {_sheetUid = newValue}
  }
  /// Returns true if `sheetUid` has been explicitly set.
  var hasSheetUid: Bool {return self._sheetUid != nil}
  /// Clears the value of `sheetUid`. Subsequent reads from it will return its default value.
  mutating func clearSheetUid() {self._sheetUid = nil}

  var oldShouldPrintComments: Bool {
    get {return _oldShouldPrintComments ?? false}
    set {_oldShouldPrintComments = newValue}
  }
  /// Returns true if `oldShouldPrintComments` has been explicitly set.
  var hasOldShouldPrintComments: Bool {return self._oldShouldPrintComments != nil}
  /// Clears the value of `oldShouldPrintComments`. Subsequent reads from it will return its default value.
  mutating func clearOldShouldPrintComments() {self._oldShouldPrintComments = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _newShouldPrintComments: Bool? = nil
  fileprivate var _sheetUid: TSP_UUID? = nil
  fileprivate var _oldShouldPrintComments: Bool? = nil
}

struct TN_CommandSetSheetDirectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var newDirection: TN_PageLayoutDirection {
    get {return _newDirection ?? .leftToRight}
    set {_newDirection = newValue}
  }
  /// Returns true if `newDirection` has been explicitly set.
  var hasNewDirection: Bool {return self._newDirection != nil}
  /// Clears the value of `newDirection`. Subsequent reads from it will return its default value.
  mutating func clearNewDirection() {self._newDirection = nil}

  var sheetUid: TSP_UUID {
    get {return _sheetUid ?? TSP_UUID()}
    set {_sheetUid = newValue}
  }
  /// Returns true if `sheetUid` has been explicitly set.
  var hasSheetUid: Bool {return self._sheetUid != nil}
  /// Clears the value of `sheetUid`. Subsequent reads from it will return its default value.
  mutating func clearSheetUid() {self._sheetUid = nil}

  var oldDirection: TN_PageLayoutDirection {
    get {return _oldDirection ?? .leftToRight}
    set {_oldDirection = newValue}
  }
  /// Returns true if `oldDirection` has been explicitly set.
  var hasOldDirection: Bool {return self._oldDirection != nil}
  /// Clears the value of `oldDirection`. Subsequent reads from it will return its default value.
  mutating func clearOldDirection() {self._oldDirection = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _newDirection: TN_PageLayoutDirection? = nil
  fileprivate var _sheetUid: TSP_UUID? = nil
  fileprivate var _oldDirection: TN_PageLayoutDirection? = nil
}

struct TN_CommandSetPageOrientationArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inPortraitPageOrientation: Bool {
    get {return _inPortraitPageOrientation ?? false}
    set {_inPortraitPageOrientation = newValue}
  }
  /// Returns true if `inPortraitPageOrientation` has been explicitly set.
  var hasInPortraitPageOrientation: Bool {return self._inPortraitPageOrientation != nil}
  /// Clears the value of `inPortraitPageOrientation`. Subsequent reads from it will return its default value.
  mutating func clearInPortraitPageOrientation() {self._inPortraitPageOrientation = nil}

  var sheetUid: TSP_UUID {
    get {return _sheetUid ?? TSP_UUID()}
    set {_sheetUid = newValue}
  }
  /// Returns true if `sheetUid` has been explicitly set.
  var hasSheetUid: Bool {return self._sheetUid != nil}
  /// Clears the value of `sheetUid`. Subsequent reads from it will return its default value.
  mutating func clearSheetUid() {self._sheetUid = nil}

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var prevInPortraitPageOrientation: Bool {
    get {return _prevInPortraitPageOrientation ?? false}
    set {_prevInPortraitPageOrientation = newValue}
  }
  /// Returns true if `prevInPortraitPageOrientation` has been explicitly set.
  var hasPrevInPortraitPageOrientation: Bool {return self._prevInPortraitPageOrientation != nil}
  /// Clears the value of `prevInPortraitPageOrientation`. Subsequent reads from it will return its default value.
  mutating func clearPrevInPortraitPageOrientation() {self._prevInPortraitPageOrientation = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _inPortraitPageOrientation: Bool? = nil
  fileprivate var _sheetUid: TSP_UUID? = nil
  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _prevInPortraitPageOrientation: Bool? = nil
}

struct TN_CommandSetShowPageNumbersValueArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var showPageNumbers: Bool {
    get {return _showPageNumbers ?? false}
    set {_showPageNumbers = newValue}
  }
  /// Returns true if `showPageNumbers` has been explicitly set.
  var hasShowPageNumbers: Bool {return self._showPageNumbers != nil}
  /// Clears the value of `showPageNumbers`. Subsequent reads from it will return its default value.
  mutating func clearShowPageNumbers() {self._showPageNumbers = nil}

  var sheet: TSP_Reference {
    get {return _sheet ?? TSP_Reference()}
    set {_sheet = newValue}
  }
  /// Returns true if `sheet` has been explicitly set.
  var hasSheet: Bool {return self._sheet != nil}
  /// Clears the value of `sheet`. Subsequent reads from it will return its default value.
  mutating func clearSheet() {self._sheet = nil}

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _showPageNumbers: Bool? = nil
  fileprivate var _sheet: TSP_Reference? = nil
  fileprivate var _super: TSK_CommandArchive? = nil
}

struct TN_CommandSetRepeatingHeadersValueArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var showRepeatingHeaders: Bool {
    get {return _showRepeatingHeaders ?? false}
    set {_showRepeatingHeaders = newValue}
  }
  /// Returns true if `showRepeatingHeaders` has been explicitly set.
  var hasShowRepeatingHeaders: Bool {return self._showRepeatingHeaders != nil}
  /// Clears the value of `showRepeatingHeaders`. Subsequent reads from it will return its default value.
  mutating func clearShowRepeatingHeaders() {self._showRepeatingHeaders = nil}

  var sheet: TSP_Reference {
    get {return _sheet ?? TSP_Reference()}
    set {_sheet = newValue}
  }
  /// Returns true if `sheet` has been explicitly set.
  var hasSheet: Bool {return self._sheet != nil}
  /// Clears the value of `sheet`. Subsequent reads from it will return its default value.
  mutating func clearSheet() {self._sheet = nil}

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _showRepeatingHeaders: Bool? = nil
  fileprivate var _sheet: TSP_Reference? = nil
  fileprivate var _super: TSK_CommandArchive? = nil
}

struct TN_CommandSetContentScaleArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var oldContentScale: Float {
    get {return _oldContentScale ?? 0}
    set {_oldContentScale = newValue}
  }
  /// Returns true if `oldContentScale` has been explicitly set.
  var hasOldContentScale: Bool {return self._oldContentScale != nil}
  /// Clears the value of `oldContentScale`. Subsequent reads from it will return its default value.
  mutating func clearOldContentScale() {self._oldContentScale = nil}

  var contentScale: Float {
    get {return _contentScale ?? 0}
    set {_contentScale = newValue}
  }
  /// Returns true if `contentScale` has been explicitly set.
  var hasContentScale: Bool {return self._contentScale != nil}
  /// Clears the value of `contentScale`. Subsequent reads from it will return its default value.
  mutating func clearContentScale() {self._contentScale = nil}

  var sheetUid: TSP_UUID {
    get {return _sheetUid ?? TSP_UUID()}
    set {_sheetUid = newValue}
  }
  /// Returns true if `sheetUid` has been explicitly set.
  var hasSheetUid: Bool {return self._sheetUid != nil}
  /// Clears the value of `sheetUid`. Subsequent reads from it will return its default value.
  mutating func clearSheetUid() {self._sheetUid = nil}

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var toggledAutoFit: Bool {
    get {return _toggledAutoFit ?? false}
    set {_toggledAutoFit = newValue}
  }
  /// Returns true if `toggledAutoFit` has been explicitly set.
  var hasToggledAutoFit: Bool {return self._toggledAutoFit != nil}
  /// Clears the value of `toggledAutoFit`. Subsequent reads from it will return its default value.
  mutating func clearToggledAutoFit() {self._toggledAutoFit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _oldContentScale: Float? = nil
  fileprivate var _contentScale: Float? = nil
  fileprivate var _sheetUid: TSP_UUID? = nil
  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _toggledAutoFit: Bool? = nil
}

struct TN_CommandSetDocumentPaperSize: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var paperID: String {
    get {return _storage._paperID ?? String()}
    set {_uniqueStorage()._paperID = newValue}
  }
  /// Returns true if `paperID` has been explicitly set.
  var hasPaperID: Bool {return _storage._paperID != nil}
  /// Clears the value of `paperID`. Subsequent reads from it will return its default value.
  mutating func clearPaperID() {_uniqueStorage()._paperID = nil}

  var pageSize: TSP_Size {
    get {return _storage._pageSize ?? TSP_Size()}
    set {_uniqueStorage()._pageSize = newValue}
  }
  /// Returns true if `pageSize` has been explicitly set.
  var hasPageSize: Bool {return _storage._pageSize != nil}
  /// Clears the value of `pageSize`. Subsequent reads from it will return its default value.
  mutating func clearPageSize() {_uniqueStorage()._pageSize = nil}

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var oldPaperID: String {
    get {return _storage._oldPaperID ?? String()}
    set {_uniqueStorage()._oldPaperID = newValue}
  }
  /// Returns true if `oldPaperID` has been explicitly set.
  var hasOldPaperID: Bool {return _storage._oldPaperID != nil}
  /// Clears the value of `oldPaperID`. Subsequent reads from it will return its default value.
  mutating func clearOldPaperID() {_uniqueStorage()._oldPaperID = nil}

  var oldPageSize: TSP_Size {
    get {return _storage._oldPageSize ?? TSP_Size()}
    set {_uniqueStorage()._oldPageSize = newValue}
  }
  /// Returns true if `oldPageSize` has been explicitly set.
  var hasOldPageSize: Bool {return _storage._oldPageSize != nil}
  /// Clears the value of `oldPageSize`. Subsequent reads from it will return its default value.
  mutating func clearOldPageSize() {_uniqueStorage()._oldPageSize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TN_CommandEnterPrintPreviewModeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
}

struct TN_CommandExitPrintPreviewModeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
}

struct TN_CommandSetPrinterMarginsArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var newPrintMargins: TSD_EdgeInsetsArchive {
    get {return _storage._newPrintMargins ?? TSD_EdgeInsetsArchive()}
    set {_uniqueStorage()._newPrintMargins = newValue}
  }
  /// Returns true if `newPrintMargins` has been explicitly set.
  var hasNewPrintMargins: Bool {return _storage._newPrintMargins != nil}
  /// Clears the value of `newPrintMargins`. Subsequent reads from it will return its default value.
  mutating func clearNewPrintMargins() {_uniqueStorage()._newPrintMargins = nil}

  var oldPrintMargins: TSD_EdgeInsetsArchive {
    get {return _storage._oldPrintMargins ?? TSD_EdgeInsetsArchive()}
    set {_uniqueStorage()._oldPrintMargins = newValue}
  }
  /// Returns true if `oldPrintMargins` has been explicitly set.
  var hasOldPrintMargins: Bool {return _storage._oldPrintMargins != nil}
  /// Clears the value of `oldPrintMargins`. Subsequent reads from it will return its default value.
  mutating func clearOldPrintMargins() {_uniqueStorage()._oldPrintMargins = nil}

  var sheetUid: TSP_UUID {
    get {return _storage._sheetUid ?? TSP_UUID()}
    set {_uniqueStorage()._sheetUid = newValue}
  }
  /// Returns true if `sheetUid` has been explicitly set.
  var hasSheetUid: Bool {return _storage._sheetUid != nil}
  /// Clears the value of `sheetUid`. Subsequent reads from it will return its default value.
  mutating func clearSheetUid() {_uniqueStorage()._sheetUid = nil}

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TN_CommandSetPrintBackgroundsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sheetUid: TSP_UUID {
    get {return _sheetUid ?? TSP_UUID()}
    set {_sheetUid = newValue}
  }
  /// Returns true if `sheetUid` has been explicitly set.
  var hasSheetUid: Bool {return self._sheetUid != nil}
  /// Clears the value of `sheetUid`. Subsequent reads from it will return its default value.
  mutating func clearSheetUid() {self._sheetUid = nil}

  var printBackgrounds: Bool {
    get {return _printBackgrounds ?? false}
    set {_printBackgrounds = newValue}
  }
  /// Returns true if `printBackgrounds` has been explicitly set.
  var hasPrintBackgrounds: Bool {return self._printBackgrounds != nil}
  /// Clears the value of `printBackgrounds`. Subsequent reads from it will return its default value.
  mutating func clearPrintBackgrounds() {self._printBackgrounds = nil}

  var oldPrintBackgrounds: Bool {
    get {return _oldPrintBackgrounds ?? false}
    set {_oldPrintBackgrounds = newValue}
  }
  /// Returns true if `oldPrintBackgrounds` has been explicitly set.
  var hasOldPrintBackgrounds: Bool {return self._oldPrintBackgrounds != nil}
  /// Clears the value of `oldPrintBackgrounds`. Subsequent reads from it will return its default value.
  mutating func clearOldPrintBackgrounds() {self._oldPrintBackgrounds = nil}

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sheetUid: TSP_UUID? = nil
  fileprivate var _printBackgrounds: Bool? = nil
  fileprivate var _oldPrintBackgrounds: Bool? = nil
  fileprivate var _super: TSK_CommandArchive? = nil
}

struct TN_CommandSetHeaderFooterInsetsArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var oldHeaderInset: Float {
    get {return _storage._oldHeaderInset ?? 0}
    set {_uniqueStorage()._oldHeaderInset = newValue}
  }
  /// Returns true if `oldHeaderInset` has been explicitly set.
  var hasOldHeaderInset: Bool {return _storage._oldHeaderInset != nil}
  /// Clears the value of `oldHeaderInset`. Subsequent reads from it will return its default value.
  mutating func clearOldHeaderInset() {_uniqueStorage()._oldHeaderInset = nil}

  var oldFooterInset: Float {
    get {return _storage._oldFooterInset ?? 0}
    set {_uniqueStorage()._oldFooterInset = newValue}
  }
  /// Returns true if `oldFooterInset` has been explicitly set.
  var hasOldFooterInset: Bool {return _storage._oldFooterInset != nil}
  /// Clears the value of `oldFooterInset`. Subsequent reads from it will return its default value.
  mutating func clearOldFooterInset() {_uniqueStorage()._oldFooterInset = nil}

  var headerInset: Float {
    get {return _storage._headerInset ?? 0}
    set {_uniqueStorage()._headerInset = newValue}
  }
  /// Returns true if `headerInset` has been explicitly set.
  var hasHeaderInset: Bool {return _storage._headerInset != nil}
  /// Clears the value of `headerInset`. Subsequent reads from it will return its default value.
  mutating func clearHeaderInset() {_uniqueStorage()._headerInset = nil}

  var footerInset: Float {
    get {return _storage._footerInset ?? 0}
    set {_uniqueStorage()._footerInset = newValue}
  }
  /// Returns true if `footerInset` has been explicitly set.
  var hasFooterInset: Bool {return _storage._footerInset != nil}
  /// Clears the value of `footerInset`. Subsequent reads from it will return its default value.
  mutating func clearFooterInset() {_uniqueStorage()._footerInset = nil}

  var sheetUid: TSP_UUID {
    get {return _storage._sheetUid ?? TSP_UUID()}
    set {_uniqueStorage()._sheetUid = newValue}
  }
  /// Returns true if `sheetUid` has been explicitly set.
  var hasSheetUid: Bool {return _storage._sheetUid != nil}
  /// Clears the value of `sheetUid`. Subsequent reads from it will return its default value.
  mutating func clearSheetUid() {_uniqueStorage()._sheetUid = nil}

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TN_CommandSetPageOrderArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var oldPageOrder: UInt32 {
    get {return _oldPageOrder ?? 0}
    set {_oldPageOrder = newValue}
  }
  /// Returns true if `oldPageOrder` has been explicitly set.
  var hasOldPageOrder: Bool {return self._oldPageOrder != nil}
  /// Clears the value of `oldPageOrder`. Subsequent reads from it will return its default value.
  mutating func clearOldPageOrder() {self._oldPageOrder = nil}

  var pageOrder: UInt32 {
    get {return _pageOrder ?? 0}
    set {_pageOrder = newValue}
  }
  /// Returns true if `pageOrder` has been explicitly set.
  var hasPageOrder: Bool {return self._pageOrder != nil}
  /// Clears the value of `pageOrder`. Subsequent reads from it will return its default value.
  mutating func clearPageOrder() {self._pageOrder = nil}

  var sheetUid: TSP_UUID {
    get {return _sheetUid ?? TSP_UUID()}
    set {_sheetUid = newValue}
  }
  /// Returns true if `sheetUid` has been explicitly set.
  var hasSheetUid: Bool {return self._sheetUid != nil}
  /// Clears the value of `sheetUid`. Subsequent reads from it will return its default value.
  mutating func clearSheetUid() {self._sheetUid = nil}

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _oldPageOrder: UInt32? = nil
  fileprivate var _pageOrder: UInt32? = nil
  fileprivate var _sheetUid: TSP_UUID? = nil
  fileprivate var _super: TSK_CommandArchive? = nil
}

struct TN_CommandSetUsingStartPageNumberArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var usingStartPageNumber: Bool {
    get {return _usingStartPageNumber ?? false}
    set {_usingStartPageNumber = newValue}
  }
  /// Returns true if `usingStartPageNumber` has been explicitly set.
  var hasUsingStartPageNumber: Bool {return self._usingStartPageNumber != nil}
  /// Clears the value of `usingStartPageNumber`. Subsequent reads from it will return its default value.
  mutating func clearUsingStartPageNumber() {self._usingStartPageNumber = nil}

  var sheetUid: TSP_UUID {
    get {return _sheetUid ?? TSP_UUID()}
    set {_sheetUid = newValue}
  }
  /// Returns true if `sheetUid` has been explicitly set.
  var hasSheetUid: Bool {return self._sheetUid != nil}
  /// Clears the value of `sheetUid`. Subsequent reads from it will return its default value.
  mutating func clearSheetUid() {self._sheetUid = nil}

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var prevUsingStartPageNumber: Bool {
    get {return _prevUsingStartPageNumber ?? false}
    set {_prevUsingStartPageNumber = newValue}
  }
  /// Returns true if `prevUsingStartPageNumber` has been explicitly set.
  var hasPrevUsingStartPageNumber: Bool {return self._prevUsingStartPageNumber != nil}
  /// Clears the value of `prevUsingStartPageNumber`. Subsequent reads from it will return its default value.
  mutating func clearPrevUsingStartPageNumber() {self._prevUsingStartPageNumber = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _usingStartPageNumber: Bool? = nil
  fileprivate var _sheetUid: TSP_UUID? = nil
  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _prevUsingStartPageNumber: Bool? = nil
}

struct TN_CommandSetStartPageNumberArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var oldStartPageNumber: Int32 {
    get {return _oldStartPageNumber ?? 0}
    set {_oldStartPageNumber = newValue}
  }
  /// Returns true if `oldStartPageNumber` has been explicitly set.
  var hasOldStartPageNumber: Bool {return self._oldStartPageNumber != nil}
  /// Clears the value of `oldStartPageNumber`. Subsequent reads from it will return its default value.
  mutating func clearOldStartPageNumber() {self._oldStartPageNumber = nil}

  var startPageNumber: Int32 {
    get {return _startPageNumber ?? 0}
    set {_startPageNumber = newValue}
  }
  /// Returns true if `startPageNumber` has been explicitly set.
  var hasStartPageNumber: Bool {return self._startPageNumber != nil}
  /// Clears the value of `startPageNumber`. Subsequent reads from it will return its default value.
  mutating func clearStartPageNumber() {self._startPageNumber = nil}

  var sheetUid: TSP_UUID {
    get {return _sheetUid ?? TSP_UUID()}
    set {_sheetUid = newValue}
  }
  /// Returns true if `sheetUid` has been explicitly set.
  var hasSheetUid: Bool {return self._sheetUid != nil}
  /// Clears the value of `sheetUid`. Subsequent reads from it will return its default value.
  mutating func clearSheetUid() {self._sheetUid = nil}

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _oldStartPageNumber: Int32? = nil
  fileprivate var _startPageNumber: Int32? = nil
  fileprivate var _sheetUid: TSP_UUID? = nil
  fileprivate var _super: TSK_CommandArchive? = nil
}

struct TN_CommandReorderSidebarItemChildrenAchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var sheet: TSP_Reference {
    get {return _sheet ?? TSP_Reference()}
    set {_sheet = newValue}
  }
  /// Returns true if `sheet` has been explicitly set.
  var hasSheet: Bool {return self._sheet != nil}
  /// Clears the value of `sheet`. Subsequent reads from it will return its default value.
  mutating func clearSheet() {self._sheet = nil}

  var oldChildren: [TSP_Reference] = []

  var newChildren: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _sheet: TSP_Reference? = nil
}

struct TN_CommandChartMediatorSetEditingState: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSCH_ChartCommandArchive {
    get {return _storage._super ?? TSCH_ChartCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var oldFormulas: TN_ChartMediatorFormulaStorage {
    get {return _storage._oldFormulas ?? TN_ChartMediatorFormulaStorage()}
    set {_uniqueStorage()._oldFormulas = newValue}
  }
  /// Returns true if `oldFormulas` has been explicitly set.
  var hasOldFormulas: Bool {return _storage._oldFormulas != nil}
  /// Clears the value of `oldFormulas`. Subsequent reads from it will return its default value.
  mutating func clearOldFormulas() {_uniqueStorage()._oldFormulas = nil}

  var newFormulas: TN_ChartMediatorFormulaStorage {
    get {return _storage._newFormulas ?? TN_ChartMediatorFormulaStorage()}
    set {_uniqueStorage()._newFormulas = newValue}
  }
  /// Returns true if `newFormulas` has been explicitly set.
  var hasNewFormulas: Bool {return _storage._newFormulas != nil}
  /// Clears the value of `newFormulas`. Subsequent reads from it will return its default value.
  mutating func clearNewFormulas() {_uniqueStorage()._newFormulas = nil}

  var oldDirection: Int32 {
    get {return _storage._oldDirection ?? 0}
    set {_uniqueStorage()._oldDirection = newValue}
  }
  /// Returns true if `oldDirection` has been explicitly set.
  var hasOldDirection: Bool {return _storage._oldDirection != nil}
  /// Clears the value of `oldDirection`. Subsequent reads from it will return its default value.
  mutating func clearOldDirection() {_uniqueStorage()._oldDirection = nil}

  var newDirection: Int32 {
    get {return _storage._newDirection ?? 0}
    set {_uniqueStorage()._newDirection = newValue}
  }
  /// Returns true if `newDirection` has been explicitly set.
  var hasNewDirection: Bool {return _storage._newDirection != nil}
  /// Clears the value of `newDirection`. Subsequent reads from it will return its default value.
  mutating func clearNewDirection() {_uniqueStorage()._newDirection = nil}

  var oldScatterFormat: Int32 {
    get {return _storage._oldScatterFormat ?? 0}
    set {_uniqueStorage()._oldScatterFormat = newValue}
  }
  /// Returns true if `oldScatterFormat` has been explicitly set.
  var hasOldScatterFormat: Bool {return _storage._oldScatterFormat != nil}
  /// Clears the value of `oldScatterFormat`. Subsequent reads from it will return its default value.
  mutating func clearOldScatterFormat() {_uniqueStorage()._oldScatterFormat = nil}

  var newScatterFormat: Int32 {
    get {return _storage._newScatterFormat ?? 0}
    set {_uniqueStorage()._newScatterFormat = newValue}
  }
  /// Returns true if `newScatterFormat` has been explicitly set.
  var hasNewScatterFormat: Bool {return _storage._newScatterFormat != nil}
  /// Clears the value of `newScatterFormat`. Subsequent reads from it will return its default value.
  mutating func clearNewScatterFormat() {_uniqueStorage()._newScatterFormat = nil}

  var forFormulaRewrite: Bool {
    get {return _storage._forFormulaRewrite ?? false}
    set {_uniqueStorage()._forFormulaRewrite = newValue}
  }
  /// Returns true if `forFormulaRewrite` has been explicitly set.
  var hasForFormulaRewrite: Bool {return _storage._forFormulaRewrite != nil}
  /// Clears the value of `forFormulaRewrite`. Subsequent reads from it will return its default value.
  mutating func clearForFormulaRewrite() {_uniqueStorage()._forFormulaRewrite = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TN_CommandChartMediatorSetGridDirection: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSCH_ChartCommandArchive {
    get {return _super ?? TSCH_ChartCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var oldDirection: UInt32 {
    get {return _oldDirection ?? 0}
    set {_oldDirection = newValue}
  }
  /// Returns true if `oldDirection` has been explicitly set.
  var hasOldDirection: Bool {return self._oldDirection != nil}
  /// Clears the value of `oldDirection`. Subsequent reads from it will return its default value.
  mutating func clearOldDirection() {self._oldDirection = nil}

  var newDirection: UInt32 {
    get {return _newDirection ?? 0}
    set {_newDirection = newValue}
  }
  /// Returns true if `newDirection` has been explicitly set.
  var hasNewDirection: Bool {return self._newDirection != nil}
  /// Clears the value of `newDirection`. Subsequent reads from it will return its default value.
  mutating func clearNewDirection() {self._newDirection = nil}

  var oldFormulaStorage: TN_ChartMediatorFormulaStorage {
    get {return _oldFormulaStorage ?? TN_ChartMediatorFormulaStorage()}
    set {_oldFormulaStorage = newValue}
  }
  /// Returns true if `oldFormulaStorage` has been explicitly set.
  var hasOldFormulaStorage: Bool {return self._oldFormulaStorage != nil}
  /// Clears the value of `oldFormulaStorage`. Subsequent reads from it will return its default value.
  mutating func clearOldFormulaStorage() {self._oldFormulaStorage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSCH_ChartCommandArchive? = nil
  fileprivate var _oldDirection: UInt32? = nil
  fileprivate var _newDirection: UInt32? = nil
  fileprivate var _oldFormulaStorage: TN_ChartMediatorFormulaStorage? = nil
}

struct TN_CommandChartMediatorSetSeriesOrder: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSCH_ChartCommandArchive {
    get {return _storage._super ?? TSCH_ChartCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var seriesID: TSP_UUID {
    get {return _storage._seriesID ?? TSP_UUID()}
    set {_uniqueStorage()._seriesID = newValue}
  }
  /// Returns true if `seriesID` has been explicitly set.
  var hasSeriesID: Bool {return _storage._seriesID != nil}
  /// Clears the value of `seriesID`. Subsequent reads from it will return its default value.
  mutating func clearSeriesID() {_uniqueStorage()._seriesID = nil}

  var precedingSeriesID: TSP_UUID {
    get {return _storage._precedingSeriesID ?? TSP_UUID()}
    set {_uniqueStorage()._precedingSeriesID = newValue}
  }
  /// Returns true if `precedingSeriesID` has been explicitly set.
  var hasPrecedingSeriesID: Bool {return _storage._precedingSeriesID != nil}
  /// Clears the value of `precedingSeriesID`. Subsequent reads from it will return its default value.
  mutating func clearPrecedingSeriesID() {_uniqueStorage()._precedingSeriesID = nil}

  var inverseSeriesID: TSP_UUID {
    get {return _storage._inverseSeriesID ?? TSP_UUID()}
    set {_uniqueStorage()._inverseSeriesID = newValue}
  }
  /// Returns true if `inverseSeriesID` has been explicitly set.
  var hasInverseSeriesID: Bool {return _storage._inverseSeriesID != nil}
  /// Clears the value of `inverseSeriesID`. Subsequent reads from it will return its default value.
  mutating func clearInverseSeriesID() {_uniqueStorage()._inverseSeriesID = nil}

  var inversePrecedingSeriesID: TSP_UUID {
    get {return _storage._inversePrecedingSeriesID ?? TSP_UUID()}
    set {_uniqueStorage()._inversePrecedingSeriesID = newValue}
  }
  /// Returns true if `inversePrecedingSeriesID` has been explicitly set.
  var hasInversePrecedingSeriesID: Bool {return _storage._inversePrecedingSeriesID != nil}
  /// Clears the value of `inversePrecedingSeriesID`. Subsequent reads from it will return its default value.
  mutating func clearInversePrecedingSeriesID() {_uniqueStorage()._inversePrecedingSeriesID = nil}

  var undoCurrentIndex: Int32 {
    get {return _storage._undoCurrentIndex ?? 0}
    set {_uniqueStorage()._undoCurrentIndex = newValue}
  }
  /// Returns true if `undoCurrentIndex` has been explicitly set.
  var hasUndoCurrentIndex: Bool {return _storage._undoCurrentIndex != nil}
  /// Clears the value of `undoCurrentIndex`. Subsequent reads from it will return its default value.
  mutating func clearUndoCurrentIndex() {_uniqueStorage()._undoCurrentIndex = nil}

  var undoNewIndex: Int32 {
    get {return _storage._undoNewIndex ?? 0}
    set {_uniqueStorage()._undoNewIndex = newValue}
  }
  /// Returns true if `undoNewIndex` has been explicitly set.
  var hasUndoNewIndex: Bool {return _storage._undoNewIndex != nil}
  /// Clears the value of `undoNewIndex`. Subsequent reads from it will return its default value.
  mutating func clearUndoNewIndex() {_uniqueStorage()._undoNewIndex = nil}

  var oldFormulaStorage: TN_ChartMediatorFormulaStorage {
    get {return _storage._oldFormulaStorage ?? TN_ChartMediatorFormulaStorage()}
    set {_uniqueStorage()._oldFormulaStorage = newValue}
  }
  /// Returns true if `oldFormulaStorage` has been explicitly set.
  var hasOldFormulaStorage: Bool {return _storage._oldFormulaStorage != nil}
  /// Clears the value of `oldFormulaStorage`. Subsequent reads from it will return its default value.
  mutating func clearOldFormulaStorage() {_uniqueStorage()._oldFormulaStorage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TN_CommandChartMediatorUpdateForEntityDelete: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSCH_ChartCommandArchive {
    get {return _super ?? TSCH_ChartCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var cmd: TSP_Reference {
    get {return _cmd ?? TSP_Reference()}
    set {_cmd = newValue}
  }
  /// Returns true if `cmd` has been explicitly set.
  var hasCmd: Bool {return self._cmd != nil}
  /// Clears the value of `cmd`. Subsequent reads from it will return its default value.
  mutating func clearCmd() {self._cmd = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSCH_ChartCommandArchive? = nil
  fileprivate var _cmd: TSP_Reference? = nil
}

struct TN_CommandChartMediatorSetFormula: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSCH_ChartCommandArchive {
    get {return _super ?? TSCH_ChartCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var modelUpdateDataType: Int32 {
    get {return _modelUpdateDataType ?? 0}
    set {_modelUpdateDataType = newValue}
  }
  /// Returns true if `modelUpdateDataType` has been explicitly set.
  var hasModelUpdateDataType: Bool {return self._modelUpdateDataType != nil}
  /// Clears the value of `modelUpdateDataType`. Subsequent reads from it will return its default value.
  mutating func clearModelUpdateDataType() {self._modelUpdateDataType = nil}

  var formulae: [TSCE_FormulaArchive] = []

  var oldFormulae: [TSCE_FormulaArchive] = []

  var seriesIndex: UInt32 {
    get {return _seriesIndex ?? 0}
    set {_seriesIndex = newValue}
  }
  /// Returns true if `seriesIndex` has been explicitly set.
  var hasSeriesIndex: Bool {return self._seriesIndex != nil}
  /// Clears the value of `seriesIndex`. Subsequent reads from it will return its default value.
  mutating func clearSeriesIndex() {self._seriesIndex = nil}

  var axisType: Int32 {
    get {return _axisType ?? 0}
    set {_axisType = newValue}
  }
  /// Returns true if `axisType` has been explicitly set.
  var hasAxisType: Bool {return self._axisType != nil}
  /// Clears the value of `axisType`. Subsequent reads from it will return its default value.
  mutating func clearAxisType() {self._axisType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSCH_ChartCommandArchive? = nil
  fileprivate var _modelUpdateDataType: Int32? = nil
  fileprivate var _seriesIndex: UInt32? = nil
  fileprivate var _axisType: Int32? = nil
}

struct TN_CommandSheetSetBackgroundFillArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var sheetID: TSP_UUID {
    get {return _sheetID ?? TSP_UUID()}
    set {_sheetID = newValue}
  }
  /// Returns true if `sheetID` has been explicitly set.
  var hasSheetID: Bool {return self._sheetID != nil}
  /// Clears the value of `sheetID`. Subsequent reads from it will return its default value.
  mutating func clearSheetID() {self._sheetID = nil}

  var newFill: TSD_FillArchive {
    get {return _newFill ?? TSD_FillArchive()}
    set {_newFill = newValue}
  }
  /// Returns true if `newFill` has been explicitly set.
  var hasNewFill: Bool {return self._newFill != nil}
  /// Clears the value of `newFill`. Subsequent reads from it will return its default value.
  mutating func clearNewFill() {self._newFill = nil}

  var oldFill: TSD_FillArchive {
    get {return _oldFill ?? TSD_FillArchive()}
    set {_oldFill = newValue}
  }
  /// Returns true if `oldFill` has been explicitly set.
  var hasOldFill: Bool {return self._oldFill != nil}
  /// Clears the value of `oldFill`. Subsequent reads from it will return its default value.
  mutating func clearOldFill() {self._oldFill = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _sheetID: TSP_UUID? = nil
  fileprivate var _newFill: TSD_FillArchive? = nil
  fileprivate var _oldFill: TSD_FillArchive? = nil
}

struct TN_CommandSheetSetStyleArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var sheetID: TSP_UUID {
    get {return _storage._sheetID ?? TSP_UUID()}
    set {_uniqueStorage()._sheetID = newValue}
  }
  /// Returns true if `sheetID` has been explicitly set.
  var hasSheetID: Bool {return _storage._sheetID != nil}
  /// Clears the value of `sheetID`. Subsequent reads from it will return its default value.
  mutating func clearSheetID() {_uniqueStorage()._sheetID = nil}

  var sheetStyle: TSP_Reference {
    get {return _storage._sheetStyle ?? TSP_Reference()}
    set {_uniqueStorage()._sheetStyle = newValue}
  }
  /// Returns true if `sheetStyle` has been explicitly set.
  var hasSheetStyle: Bool {return _storage._sheetStyle != nil}
  /// Clears the value of `sheetStyle`. Subsequent reads from it will return its default value.
  mutating func clearSheetStyle() {_uniqueStorage()._sheetStyle = nil}

  var oldSheetStyle: TSP_Reference {
    get {return _storage._oldSheetStyle ?? TSP_Reference()}
    set {_uniqueStorage()._oldSheetStyle = newValue}
  }
  /// Returns true if `oldSheetStyle` has been explicitly set.
  var hasOldSheetStyle: Bool {return _storage._oldSheetStyle != nil}
  /// Clears the value of `oldSheetStyle`. Subsequent reads from it will return its default value.
  mutating func clearOldSheetStyle() {_uniqueStorage()._oldSheetStyle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TN_DocumentSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var documentSelection: TSP_Reference {
    get {return _documentSelection ?? TSP_Reference()}
    set {_documentSelection = newValue}
  }
  /// Returns true if `documentSelection` has been explicitly set.
  var hasDocumentSelection: Bool {return self._documentSelection != nil}
  /// Clears the value of `documentSelection`. Subsequent reads from it will return its default value.
  mutating func clearDocumentSelection() {self._documentSelection = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _documentSelection: TSP_Reference? = nil
}

struct TN_SheetSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sheetUuid: TSP_UUID {
    get {return _sheetUuid ?? TSP_UUID()}
    set {_sheetUuid = newValue}
  }
  /// Returns true if `sheetUuid` has been explicitly set.
  var hasSheetUuid: Bool {return self._sheetUuid != nil}
  /// Clears the value of `sheetUuid`. Subsequent reads from it will return its default value.
  mutating func clearSheetUuid() {self._sheetUuid = nil}

  var paginated: Bool {
    get {return _paginated ?? false}
    set {_paginated = newValue}
  }
  /// Returns true if `paginated` has been explicitly set.
  var hasPaginated: Bool {return self._paginated != nil}
  /// Clears the value of `paginated`. Subsequent reads from it will return its default value.
  mutating func clearPaginated() {self._paginated = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sheetUuid: TSP_UUID? = nil
  fileprivate var _paginated: Bool? = nil
}

struct TN_FormSheetSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TN_SheetSelectionTransformerArchive {
    get {return _super ?? TN_SheetSelectionTransformerArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var tableUuid: TSP_UUID {
    get {return _tableUuid ?? TSP_UUID()}
    set {_tableUuid = newValue}
  }
  /// Returns true if `tableUuid` has been explicitly set.
  var hasTableUuid: Bool {return self._tableUuid != nil}
  /// Clears the value of `tableUuid`. Subsequent reads from it will return its default value.
  mutating func clearTableUuid() {self._tableUuid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TN_SheetSelectionTransformerArchive? = nil
  fileprivate var _tableUuid: TSP_UUID? = nil
}

struct TN_CanvasSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transformerHelper: TSD_InfoCollectionSelectionTransformerHelperArchive {
    get {return _transformerHelper ?? TSD_InfoCollectionSelectionTransformerHelperArchive()}
    set {_transformerHelper = newValue}
  }
  /// Returns true if `transformerHelper` has been explicitly set.
  var hasTransformerHelper: Bool {return self._transformerHelper != nil}
  /// Clears the value of `transformerHelper`. Subsequent reads from it will return its default value.
  mutating func clearTransformerHelper() {self._transformerHelper = nil}

  var headerStorageUuidPath: TSP_UUIDPath {
    get {return _headerStorageUuidPath ?? TSP_UUIDPath()}
    set {_headerStorageUuidPath = newValue}
  }
  /// Returns true if `headerStorageUuidPath` has been explicitly set.
  var hasHeaderStorageUuidPath: Bool {return self._headerStorageUuidPath != nil}
  /// Clears the value of `headerStorageUuidPath`. Subsequent reads from it will return its default value.
  mutating func clearHeaderStorageUuidPath() {self._headerStorageUuidPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transformerHelper: TSD_InfoCollectionSelectionTransformerHelperArchive? = nil
  fileprivate var _headerStorageUuidPath: TSP_UUIDPath? = nil
}

struct TN_FormTableChooserSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TN_FormBuilderSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tableUuid: TSP_UUID {
    get {return _tableUuid ?? TSP_UUID()}
    set {_tableUuid = newValue}
  }
  /// Returns true if `tableUuid` has been explicitly set.
  var hasTableUuid: Bool {return self._tableUuid != nil}
  /// Clears the value of `tableUuid`. Subsequent reads from it will return its default value.
  mutating func clearTableUuid() {self._tableUuid = nil}

  var viewingRecordUuid: TSP_UUID {
    get {return _viewingRecordUuid ?? TSP_UUID()}
    set {_viewingRecordUuid = newValue}
  }
  /// Returns true if `viewingRecordUuid` has been explicitly set.
  var hasViewingRecordUuid: Bool {return self._viewingRecordUuid != nil}
  /// Clears the value of `viewingRecordUuid`. Subsequent reads from it will return its default value.
  mutating func clearViewingRecordUuid() {self._viewingRecordUuid = nil}

  var fieldUuid: TSP_UUID {
    get {return _fieldUuid ?? TSP_UUID()}
    set {_fieldUuid = newValue}
  }
  /// Returns true if `fieldUuid` has been explicitly set.
  var hasFieldUuid: Bool {return self._fieldUuid != nil}
  /// Clears the value of `fieldUuid`. Subsequent reads from it will return its default value.
  mutating func clearFieldUuid() {self._fieldUuid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tableUuid: TSP_UUID? = nil
  fileprivate var _viewingRecordUuid: TSP_UUID? = nil
  fileprivate var _fieldUuid: TSP_UUID? = nil
}

struct TN_FormViewerSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tableUuid: TSP_UUID {
    get {return _tableUuid ?? TSP_UUID()}
    set {_tableUuid = newValue}
  }
  /// Returns true if `tableUuid` has been explicitly set.
  var hasTableUuid: Bool {return self._tableUuid != nil}
  /// Clears the value of `tableUuid`. Subsequent reads from it will return its default value.
  mutating func clearTableUuid() {self._tableUuid = nil}

  var recordUuid: TSP_UUID {
    get {return _recordUuid ?? TSP_UUID()}
    set {_recordUuid = newValue}
  }
  /// Returns true if `recordUuid` has been explicitly set.
  var hasRecordUuid: Bool {return self._recordUuid != nil}
  /// Clears the value of `recordUuid`. Subsequent reads from it will return its default value.
  mutating func clearRecordUuid() {self._recordUuid = nil}

  var fieldUuid: TSP_UUID {
    get {return _fieldUuid ?? TSP_UUID()}
    set {_fieldUuid = newValue}
  }
  /// Returns true if `fieldUuid` has been explicitly set.
  var hasFieldUuid: Bool {return self._fieldUuid != nil}
  /// Clears the value of `fieldUuid`. Subsequent reads from it will return its default value.
  mutating func clearFieldUuid() {self._fieldUuid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tableUuid: TSP_UUID? = nil
  fileprivate var _recordUuid: TSP_UUID? = nil
  fileprivate var _fieldUuid: TSP_UUID? = nil
}

struct TN_SheetChangeBaseArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sheetID: TSP_UUID {
    get {return _sheetID ?? TSP_UUID()}
    set {_sheetID = newValue}
  }
  /// Returns true if `sheetID` has been explicitly set.
  var hasSheetID: Bool {return self._sheetID != nil}
  /// Clears the value of `sheetID`. Subsequent reads from it will return its default value.
  mutating func clearSheetID() {self._sheetID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sheetID: TSP_UUID? = nil
}

struct TN_SheetChangeSheetNameArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TN_SheetChangeBaseArchive {
    get {return _super ?? TN_SheetChangeBaseArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var sheetName: String {
    get {return _sheetName ?? String()}
    set {_sheetName = newValue}
  }
  /// Returns true if `sheetName` has been explicitly set.
  var hasSheetName: Bool {return self._sheetName != nil}
  /// Clears the value of `sheetName`. Subsequent reads from it will return its default value.
  mutating func clearSheetName() {self._sheetName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TN_SheetChangeBaseArchive? = nil
  fileprivate var _sheetName: String? = nil
}

struct TN_CommandInducedSheetChangeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var sheetChanges: [TN_SheetChangeSheetNameArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TN"

extension TN_CommandFormChooseTargetTableArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandFormChooseTargetTableArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}table_id\0\u{3}previous_table_id\0\u{3}sheet_name\0\u{3}previous_sheet_name\0\u{3}sheet_id\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _tableID: TSP_UUID? = nil
    var _previousTableID: TSP_UUID? = nil
    var _sheetName: String? = nil
    var _previousSheetName: String? = nil
    var _sheetID: TSP_UUID? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _tableID = source._tableID
      _previousTableID = source._previousTableID
      _sheetName = source._sheetName
      _previousSheetName = source._previousSheetName
      _sheetID = source._sheetID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._tableID == nil {return false}
      if _storage._sheetName == nil {return false}
      if _storage._sheetID == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._tableID, !v.isInitialized {return false}
      if let v = _storage._previousTableID, !v.isInitialized {return false}
      if let v = _storage._sheetID, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._tableID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._previousTableID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._sheetName) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._previousSheetName) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._sheetID) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._tableID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._previousTableID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._sheetName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._previousSheetName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._sheetID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandFormChooseTargetTableArchive, rhs: TN_CommandFormChooseTargetTableArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._tableID != rhs_storage._tableID {return false}
        if _storage._previousTableID != rhs_storage._previousTableID {return false}
        if _storage._sheetName != rhs_storage._sheetName {return false}
        if _storage._previousSheetName != rhs_storage._previousSheetName {return false}
        if _storage._sheetID != rhs_storage._sheetID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandSheetInsertDrawablesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSheetInsertDrawablesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}sheet_id\0\u{1}drawables\0\u{3}args_list\0\u{1}forPaste\0\u{3}custom_format_keys\0\u{3}drawable_undo_object\0\u{4}\u{2}formula_rewrite_command_for_undo\0\u{3}saved_next_untitled_resolver_index\0\u{3}chart_entity_uid_for_backing_tables\0\u{3}backing_tables\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _sheetID: TSP_UUID? = nil
    var _drawables: [TSP_Reference] = []
    var _argsList: [TSCK_AddIdOperationArgs] = []
    var _forPaste: Bool? = nil
    var _customFormatKeys: [TSP_UUID] = []
    var _drawableUndoObject: TSP_Reference? = nil
    var _formulaRewriteCommandForUndo: TSP_Reference? = nil
    var _savedNextUntitledResolverIndex: UInt32? = nil
    var _chartEntityUidForBackingTables: [TSP_UUID] = []
    var _backingTables: [TSP_Reference] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _sheetID = source._sheetID
      _drawables = source._drawables
      _argsList = source._argsList
      _forPaste = source._forPaste
      _customFormatKeys = source._customFormatKeys
      _drawableUndoObject = source._drawableUndoObject
      _formulaRewriteCommandForUndo = source._formulaRewriteCommandForUndo
      _savedNextUntitledResolverIndex = source._savedNextUntitledResolverIndex
      _chartEntityUidForBackingTables = source._chartEntityUidForBackingTables
      _backingTables = source._backingTables
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._sheetID == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._sheetID, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._drawables) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._argsList) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._customFormatKeys) {return false}
      if let v = _storage._drawableUndoObject, !v.isInitialized {return false}
      if let v = _storage._formulaRewriteCommandForUndo, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._chartEntityUidForBackingTables) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._backingTables) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._sheetID) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._drawables) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._argsList) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._forPaste) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._customFormatKeys) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._drawableUndoObject) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._formulaRewriteCommandForUndo) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._savedNextUntitledResolverIndex) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._chartEntityUidForBackingTables) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._backingTables) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._sheetID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._drawables.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._drawables, fieldNumber: 3)
      }
      if !_storage._argsList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._argsList, fieldNumber: 4)
      }
      try { if let v = _storage._forPaste {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      if !_storage._customFormatKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._customFormatKeys, fieldNumber: 6)
      }
      try { if let v = _storage._drawableUndoObject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._formulaRewriteCommandForUndo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._savedNextUntitledResolverIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
      } }()
      if !_storage._chartEntityUidForBackingTables.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chartEntityUidForBackingTables, fieldNumber: 11)
      }
      if !_storage._backingTables.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._backingTables, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandSheetInsertDrawablesArchive, rhs: TN_CommandSheetInsertDrawablesArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._sheetID != rhs_storage._sheetID {return false}
        if _storage._drawables != rhs_storage._drawables {return false}
        if _storage._argsList != rhs_storage._argsList {return false}
        if _storage._forPaste != rhs_storage._forPaste {return false}
        if _storage._customFormatKeys != rhs_storage._customFormatKeys {return false}
        if _storage._drawableUndoObject != rhs_storage._drawableUndoObject {return false}
        if _storage._formulaRewriteCommandForUndo != rhs_storage._formulaRewriteCommandForUndo {return false}
        if _storage._savedNextUntitledResolverIndex != rhs_storage._savedNextUntitledResolverIndex {return false}
        if _storage._chartEntityUidForBackingTables != rhs_storage._chartEntityUidForBackingTables {return false}
        if _storage._backingTables != rhs_storage._backingTables {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandSheetRemoveDrawablesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSheetRemoveDrawablesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}sheet_id\0\u{3}args_list\0\u{1}drawables\0\u{4}\u{2}chart_entity_uid_for_backing_tables\0\u{3}backing_table_uids\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _sheetID: TSP_UUID? = nil
    var _argsList: [TSCK_RemoveIdOperationArgs] = []
    var _drawables: [TSP_Reference] = []
    var _chartEntityUidForBackingTables: [TSP_UUID] = []
    var _backingTableUids: [TSP_UUID] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _sheetID = source._sheetID
      _argsList = source._argsList
      _drawables = source._drawables
      _chartEntityUidForBackingTables = source._chartEntityUidForBackingTables
      _backingTableUids = source._backingTableUids
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._sheetID == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._sheetID, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._argsList) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._drawables) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._chartEntityUidForBackingTables) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._backingTableUids) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._sheetID) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._argsList) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._drawables) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._chartEntityUidForBackingTables) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._backingTableUids) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._sheetID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._argsList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._argsList, fieldNumber: 3)
      }
      if !_storage._drawables.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._drawables, fieldNumber: 4)
      }
      if !_storage._chartEntityUidForBackingTables.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chartEntityUidForBackingTables, fieldNumber: 6)
      }
      if !_storage._backingTableUids.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._backingTableUids, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandSheetRemoveDrawablesArchive, rhs: TN_CommandSheetRemoveDrawablesArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._sheetID != rhs_storage._sheetID {return false}
        if _storage._argsList != rhs_storage._argsList {return false}
        if _storage._drawables != rhs_storage._drawables {return false}
        if _storage._chartEntityUidForBackingTables != rhs_storage._chartEntityUidForBackingTables {return false}
        if _storage._backingTableUids != rhs_storage._backingTableUids {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandSheetMoveDrawableZOrderArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSheetMoveDrawableZOrderArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}sheet_id\0\u{3}args_list\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._sheetID == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._sheetID, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.argsList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sheetID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.argsList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sheetID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.argsList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.argsList, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandSheetMoveDrawableZOrderArchive, rhs: TN_CommandSheetMoveDrawableZOrderArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._sheetID != rhs._sheetID {return false}
    if lhs.argsList != rhs.argsList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandDocumentInsertSheetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandDocumentInsertSheetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}argsList\0\u{1}sheets\0\u{1}allowSameSheetNameAsForms\0\u{3}custom_format_keys\0\u{3}drawable_undo_object\0\u{3}sheet_uistates\0\u{3}for_paste\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _argsList: [TSCK_AddIdOperationArgs] = []
    var _sheets: [TSP_Reference] = []
    var _allowSameSheetNameAsForms: Bool? = nil
    var _customFormatKeys: [TSP_UUID] = []
    var _drawableUndoObject: TSP_Reference? = nil
    var _sheetUistates: [TN_UUIDSheetUIStateDictionaryArchive] = []
    var _forPaste: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _argsList = source._argsList
      _sheets = source._sheets
      _allowSameSheetNameAsForms = source._allowSameSheetNameAsForms
      _customFormatKeys = source._customFormatKeys
      _drawableUndoObject = source._drawableUndoObject
      _sheetUistates = source._sheetUistates
      _forPaste = source._forPaste
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._argsList) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._sheets) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._customFormatKeys) {return false}
      if let v = _storage._drawableUndoObject, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._sheetUistates) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._argsList) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._sheets) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._allowSameSheetNameAsForms) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._customFormatKeys) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._drawableUndoObject) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._sheetUistates) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._forPaste) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._argsList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._argsList, fieldNumber: 2)
      }
      if !_storage._sheets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sheets, fieldNumber: 3)
      }
      try { if let v = _storage._allowSameSheetNameAsForms {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      if !_storage._customFormatKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._customFormatKeys, fieldNumber: 5)
      }
      try { if let v = _storage._drawableUndoObject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._sheetUistates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sheetUistates, fieldNumber: 7)
      }
      try { if let v = _storage._forPaste {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandDocumentInsertSheetArchive, rhs: TN_CommandDocumentInsertSheetArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._argsList != rhs_storage._argsList {return false}
        if _storage._sheets != rhs_storage._sheets {return false}
        if _storage._allowSameSheetNameAsForms != rhs_storage._allowSameSheetNameAsForms {return false}
        if _storage._customFormatKeys != rhs_storage._customFormatKeys {return false}
        if _storage._drawableUndoObject != rhs_storage._drawableUndoObject {return false}
        if _storage._sheetUistates != rhs_storage._sheetUistates {return false}
        if _storage._forPaste != rhs_storage._forPaste {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandDocumentRemoveSheetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandDocumentRemoveSheetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}argsList\0\u{1}sheets\0\u{1}rescueId\0\u{3}sheet_uistates\0\u{3}is_undo_paste\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._rescueID == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.argsList) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.sheets) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.sheetUistates) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.argsList) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.sheets) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._rescueID) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.sheetUistates) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._isUndoPaste) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.argsList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.argsList, fieldNumber: 2)
    }
    if !self.sheets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sheets, fieldNumber: 3)
    }
    try { if let v = self._rescueID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    if !self.sheetUistates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sheetUistates, fieldNumber: 5)
    }
    try { if let v = self._isUndoPaste {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandDocumentRemoveSheetArchive, rhs: TN_CommandDocumentRemoveSheetArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.argsList != rhs.argsList {return false}
    if lhs.sheets != rhs.sheets {return false}
    if lhs._rescueID != rhs._rescueID {return false}
    if lhs.sheetUistates != rhs.sheetUistates {return false}
    if lhs._isUndoPaste != rhs._isUndoPaste {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandDocumentReorderSheetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandDocumentReorderSheetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}argsList\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.argsList) {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.argsList) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.argsList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.argsList, fieldNumber: 1)
    }
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandDocumentReorderSheetArchive, rhs: TN_CommandDocumentReorderSheetArchive) -> Bool {
    if lhs.argsList != rhs.argsList {return false}
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandSetSheetNameArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetSheetNameArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}newname\0\u{3}sheet_uid\0\u{1}oldname\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._newname == nil {return false}
    if self._sheetUid == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._sheetUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._newname) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._sheetUid) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._oldname) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sheetUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._oldname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandSetSheetNameArchive, rhs: TN_CommandSetSheetNameArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._newname != rhs._newname {return false}
    if lhs._sheetUid != rhs._sheetUid {return false}
    if lhs._oldname != rhs._oldname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandSetSheetShouldPrintCommentsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetSheetShouldPrintCommentsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}new_should_print_comments\0\u{3}sheet_uid\0\u{3}old_should_print_comments\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._newShouldPrintComments == nil {return false}
    if self._sheetUid == nil {return false}
    if self._oldShouldPrintComments == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._sheetUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._newShouldPrintComments) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._sheetUid) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._oldShouldPrintComments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newShouldPrintComments {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sheetUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._oldShouldPrintComments {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandSetSheetShouldPrintCommentsArchive, rhs: TN_CommandSetSheetShouldPrintCommentsArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._newShouldPrintComments != rhs._newShouldPrintComments {return false}
    if lhs._sheetUid != rhs._sheetUid {return false}
    if lhs._oldShouldPrintComments != rhs._oldShouldPrintComments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandSetSheetDirectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetSheetDirectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}newDirection\0\u{3}sheet_uid\0\u{1}oldDirection\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._newDirection == nil {return false}
    if self._sheetUid == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._sheetUid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._newDirection) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._sheetUid) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._oldDirection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newDirection {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sheetUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._oldDirection {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandSetSheetDirectionArchive, rhs: TN_CommandSetSheetDirectionArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._newDirection != rhs._newDirection {return false}
    if lhs._sheetUid != rhs._sheetUid {return false}
    if lhs._oldDirection != rhs._oldDirection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandSetPageOrientationArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetPageOrientationArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}in_portrait_page_orientation\0\u{3}sheet_uid\0\u{1}super\0\u{3}prev_in_portrait_page_orientation\0")

  public var isInitialized: Bool {
    if self._inPortraitPageOrientation == nil {return false}
    if self._sheetUid == nil {return false}
    if self._super == nil {return false}
    if self._prevInPortraitPageOrientation == nil {return false}
    if let v = self._sheetUid, !v.isInitialized {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._inPortraitPageOrientation) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sheetUid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._prevInPortraitPageOrientation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._inPortraitPageOrientation {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sheetUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._prevInPortraitPageOrientation {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandSetPageOrientationArchive, rhs: TN_CommandSetPageOrientationArchive) -> Bool {
    if lhs._inPortraitPageOrientation != rhs._inPortraitPageOrientation {return false}
    if lhs._sheetUid != rhs._sheetUid {return false}
    if lhs._super != rhs._super {return false}
    if lhs._prevInPortraitPageOrientation != rhs._prevInPortraitPageOrientation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandSetShowPageNumbersValueArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetShowPageNumbersValueArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}show_page_numbers\0\u{1}sheet\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._showPageNumbers == nil {return false}
    if self._sheet == nil {return false}
    if self._super == nil {return false}
    if let v = self._sheet, !v.isInitialized {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._showPageNumbers) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sheet) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._showPageNumbers {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sheet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandSetShowPageNumbersValueArchive, rhs: TN_CommandSetShowPageNumbersValueArchive) -> Bool {
    if lhs._showPageNumbers != rhs._showPageNumbers {return false}
    if lhs._sheet != rhs._sheet {return false}
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandSetRepeatingHeadersValueArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetRepeatingHeadersValueArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}show_repeating_headers\0\u{1}sheet\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._showRepeatingHeaders == nil {return false}
    if self._sheet == nil {return false}
    if self._super == nil {return false}
    if let v = self._sheet, !v.isInitialized {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._showRepeatingHeaders) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sheet) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._showRepeatingHeaders {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sheet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandSetRepeatingHeadersValueArchive, rhs: TN_CommandSetRepeatingHeadersValueArchive) -> Bool {
    if lhs._showRepeatingHeaders != rhs._showRepeatingHeaders {return false}
    if lhs._sheet != rhs._sheet {return false}
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandSetContentScaleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetContentScaleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{2}old_content_scale\0\u{3}content_scale\0\u{3}sheet_uid\0\u{1}super\0\u{3}toggled_auto_fit\0")

  public var isInitialized: Bool {
    if self._contentScale == nil {return false}
    if self._sheetUid == nil {return false}
    if self._super == nil {return false}
    if self._toggledAutoFit == nil {return false}
    if let v = self._sheetUid, !v.isInitialized {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularFloatField(value: &self._oldContentScale) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._contentScale) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._sheetUid) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._toggledAutoFit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._oldContentScale {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._contentScale {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._sheetUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._toggledAutoFit {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandSetContentScaleArchive, rhs: TN_CommandSetContentScaleArchive) -> Bool {
    if lhs._oldContentScale != rhs._oldContentScale {return false}
    if lhs._contentScale != rhs._contentScale {return false}
    if lhs._sheetUid != rhs._sheetUid {return false}
    if lhs._super != rhs._super {return false}
    if lhs._toggledAutoFit != rhs._toggledAutoFit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandSetDocumentPaperSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetDocumentPaperSize"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}paper_id\0\u{3}page_size\0\u{1}super\0\u{3}old_paper_id\0\u{3}old_page_size\0")

  fileprivate class _StorageClass {
    var _paperID: String? = nil
    var _pageSize: TSP_Size? = nil
    var _super: TSK_CommandArchive? = nil
    var _oldPaperID: String? = nil
    var _oldPageSize: TSP_Size? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paperID = source._paperID
      _pageSize = source._pageSize
      _super = source._super
      _oldPaperID = source._oldPaperID
      _oldPageSize = source._oldPageSize
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._paperID == nil {return false}
      if _storage._pageSize == nil {return false}
      if _storage._super == nil {return false}
      if _storage._oldPaperID == nil {return false}
      if _storage._oldPageSize == nil {return false}
      if let v = _storage._pageSize, !v.isInitialized {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._oldPageSize, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._paperID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._pageSize) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._oldPaperID) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._oldPageSize) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._paperID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._pageSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._oldPaperID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._oldPageSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandSetDocumentPaperSize, rhs: TN_CommandSetDocumentPaperSize) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paperID != rhs_storage._paperID {return false}
        if _storage._pageSize != rhs_storage._pageSize {return false}
        if _storage._super != rhs_storage._super {return false}
        if _storage._oldPaperID != rhs_storage._oldPaperID {return false}
        if _storage._oldPageSize != rhs_storage._oldPageSize {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandEnterPrintPreviewModeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandEnterPrintPreviewModeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandEnterPrintPreviewModeArchive, rhs: TN_CommandEnterPrintPreviewModeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandExitPrintPreviewModeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandExitPrintPreviewModeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandExitPrintPreviewModeArchive, rhs: TN_CommandExitPrintPreviewModeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandSetPrinterMarginsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetPrinterMarginsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}new_print_margins\0\u{3}old_print_margins\0\u{3}sheet_uid\0\u{1}super\0")

  fileprivate class _StorageClass {
    var _newPrintMargins: TSD_EdgeInsetsArchive? = nil
    var _oldPrintMargins: TSD_EdgeInsetsArchive? = nil
    var _sheetUid: TSP_UUID? = nil
    var _super: TSK_CommandArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _newPrintMargins = source._newPrintMargins
      _oldPrintMargins = source._oldPrintMargins
      _sheetUid = source._sheetUid
      _super = source._super
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._newPrintMargins == nil {return false}
      if _storage._sheetUid == nil {return false}
      if _storage._super == nil {return false}
      if let v = _storage._newPrintMargins, !v.isInitialized {return false}
      if let v = _storage._oldPrintMargins, !v.isInitialized {return false}
      if let v = _storage._sheetUid, !v.isInitialized {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._newPrintMargins) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._oldPrintMargins) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._sheetUid) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._newPrintMargins {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._oldPrintMargins {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._sheetUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandSetPrinterMarginsArchive, rhs: TN_CommandSetPrinterMarginsArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._newPrintMargins != rhs_storage._newPrintMargins {return false}
        if _storage._oldPrintMargins != rhs_storage._oldPrintMargins {return false}
        if _storage._sheetUid != rhs_storage._sheetUid {return false}
        if _storage._super != rhs_storage._super {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandSetPrintBackgroundsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetPrintBackgroundsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}sheet_uid\0\u{3}print_backgrounds\0\u{3}old_print_backgrounds\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._sheetUid == nil {return false}
    if self._printBackgrounds == nil {return false}
    if self._oldPrintBackgrounds == nil {return false}
    if self._super == nil {return false}
    if let v = self._sheetUid, !v.isInitialized {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sheetUid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._printBackgrounds) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._oldPrintBackgrounds) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sheetUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._printBackgrounds {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._oldPrintBackgrounds {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandSetPrintBackgroundsArchive, rhs: TN_CommandSetPrintBackgroundsArchive) -> Bool {
    if lhs._sheetUid != rhs._sheetUid {return false}
    if lhs._printBackgrounds != rhs._printBackgrounds {return false}
    if lhs._oldPrintBackgrounds != rhs._oldPrintBackgrounds {return false}
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandSetHeaderFooterInsetsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetHeaderFooterInsetsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}old_header_inset\0\u{3}old_footer_inset\0\u{3}header_inset\0\u{3}footer_inset\0\u{3}sheet_uid\0\u{1}super\0")

  fileprivate class _StorageClass {
    var _oldHeaderInset: Float? = nil
    var _oldFooterInset: Float? = nil
    var _headerInset: Float? = nil
    var _footerInset: Float? = nil
    var _sheetUid: TSP_UUID? = nil
    var _super: TSK_CommandArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _oldHeaderInset = source._oldHeaderInset
      _oldFooterInset = source._oldFooterInset
      _headerInset = source._headerInset
      _footerInset = source._footerInset
      _sheetUid = source._sheetUid
      _super = source._super
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._headerInset == nil {return false}
      if _storage._footerInset == nil {return false}
      if _storage._sheetUid == nil {return false}
      if _storage._super == nil {return false}
      if let v = _storage._sheetUid, !v.isInitialized {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularFloatField(value: &_storage._oldHeaderInset) }()
        case 2: try { try decoder.decodeSingularFloatField(value: &_storage._oldFooterInset) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._headerInset) }()
        case 4: try { try decoder.decodeSingularFloatField(value: &_storage._footerInset) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._sheetUid) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._oldHeaderInset {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._oldFooterInset {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._headerInset {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._footerInset {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._sheetUid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandSetHeaderFooterInsetsArchive, rhs: TN_CommandSetHeaderFooterInsetsArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._oldHeaderInset != rhs_storage._oldHeaderInset {return false}
        if _storage._oldFooterInset != rhs_storage._oldFooterInset {return false}
        if _storage._headerInset != rhs_storage._headerInset {return false}
        if _storage._footerInset != rhs_storage._footerInset {return false}
        if _storage._sheetUid != rhs_storage._sheetUid {return false}
        if _storage._super != rhs_storage._super {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandSetPageOrderArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetPageOrderArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}old_page_order\0\u{3}page_order\0\u{3}sheet_uid\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._oldPageOrder == nil {return false}
    if self._pageOrder == nil {return false}
    if self._sheetUid == nil {return false}
    if self._super == nil {return false}
    if let v = self._sheetUid, !v.isInitialized {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._oldPageOrder) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._pageOrder) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._sheetUid) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._oldPageOrder {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pageOrder {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sheetUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandSetPageOrderArchive, rhs: TN_CommandSetPageOrderArchive) -> Bool {
    if lhs._oldPageOrder != rhs._oldPageOrder {return false}
    if lhs._pageOrder != rhs._pageOrder {return false}
    if lhs._sheetUid != rhs._sheetUid {return false}
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandSetUsingStartPageNumberArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetUsingStartPageNumberArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}using_start_page_number\0\u{3}sheet_uid\0\u{1}super\0\u{3}prev_using_start_page_number\0")

  public var isInitialized: Bool {
    if self._usingStartPageNumber == nil {return false}
    if self._sheetUid == nil {return false}
    if self._super == nil {return false}
    if self._prevUsingStartPageNumber == nil {return false}
    if let v = self._sheetUid, !v.isInitialized {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._usingStartPageNumber) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sheetUid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._prevUsingStartPageNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._usingStartPageNumber {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sheetUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._prevUsingStartPageNumber {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandSetUsingStartPageNumberArchive, rhs: TN_CommandSetUsingStartPageNumberArchive) -> Bool {
    if lhs._usingStartPageNumber != rhs._usingStartPageNumber {return false}
    if lhs._sheetUid != rhs._sheetUid {return false}
    if lhs._super != rhs._super {return false}
    if lhs._prevUsingStartPageNumber != rhs._prevUsingStartPageNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandSetStartPageNumberArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSetStartPageNumberArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}old_start_page_number\0\u{3}start_page_number\0\u{3}sheet_uid\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._oldStartPageNumber == nil {return false}
    if self._startPageNumber == nil {return false}
    if self._sheetUid == nil {return false}
    if self._super == nil {return false}
    if let v = self._sheetUid, !v.isInitialized {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._oldStartPageNumber) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._startPageNumber) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._sheetUid) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._oldStartPageNumber {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._startPageNumber {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sheetUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandSetStartPageNumberArchive, rhs: TN_CommandSetStartPageNumberArchive) -> Bool {
    if lhs._oldStartPageNumber != rhs._oldStartPageNumber {return false}
    if lhs._startPageNumber != rhs._startPageNumber {return false}
    if lhs._sheetUid != rhs._sheetUid {return false}
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandReorderSidebarItemChildrenAchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandReorderSidebarItemChildrenAchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}sheet\0\u{3}old_children\0\u{3}new_children\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._sheet == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._sheet, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldChildren) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.newChildren) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sheet) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.oldChildren) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.newChildren) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sheet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.oldChildren.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldChildren, fieldNumber: 3)
    }
    if !self.newChildren.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.newChildren, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandReorderSidebarItemChildrenAchive, rhs: TN_CommandReorderSidebarItemChildrenAchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._sheet != rhs._sheet {return false}
    if lhs.oldChildren != rhs.oldChildren {return false}
    if lhs.newChildren != rhs.newChildren {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandChartMediatorSetEditingState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandChartMediatorSetEditingState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{2}old_formulas\0\u{3}new_formulas\0\u{3}old_direction\0\u{3}new_direction\0\u{3}old_scatter_format\0\u{3}new_scatter_format\0\u{3}for_formula_rewrite\0")

  fileprivate class _StorageClass {
    var _super: TSCH_ChartCommandArchive? = nil
    var _oldFormulas: TN_ChartMediatorFormulaStorage? = nil
    var _newFormulas: TN_ChartMediatorFormulaStorage? = nil
    var _oldDirection: Int32? = nil
    var _newDirection: Int32? = nil
    var _oldScatterFormat: Int32? = nil
    var _newScatterFormat: Int32? = nil
    var _forFormulaRewrite: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _oldFormulas = source._oldFormulas
      _newFormulas = source._newFormulas
      _oldDirection = source._oldDirection
      _newDirection = source._newDirection
      _oldScatterFormat = source._oldScatterFormat
      _newScatterFormat = source._newScatterFormat
      _forFormulaRewrite = source._forFormulaRewrite
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._oldFormulas, !v.isInitialized {return false}
      if let v = _storage._newFormulas, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._oldFormulas) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._newFormulas) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._oldDirection) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._newDirection) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._oldScatterFormat) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._newScatterFormat) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._forFormulaRewrite) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._oldFormulas {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._newFormulas {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._oldDirection {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._newDirection {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._oldScatterFormat {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._newScatterFormat {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._forFormulaRewrite {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandChartMediatorSetEditingState, rhs: TN_CommandChartMediatorSetEditingState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._oldFormulas != rhs_storage._oldFormulas {return false}
        if _storage._newFormulas != rhs_storage._newFormulas {return false}
        if _storage._oldDirection != rhs_storage._oldDirection {return false}
        if _storage._newDirection != rhs_storage._newDirection {return false}
        if _storage._oldScatterFormat != rhs_storage._oldScatterFormat {return false}
        if _storage._newScatterFormat != rhs_storage._newScatterFormat {return false}
        if _storage._forFormulaRewrite != rhs_storage._forFormulaRewrite {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandChartMediatorSetGridDirection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandChartMediatorSetGridDirection"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}old_direction\0\u{3}new_direction\0\u{3}old_formula_storage\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._oldDirection == nil {return false}
    if self._newDirection == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._oldFormulaStorage, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._oldDirection) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._newDirection) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._oldFormulaStorage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oldDirection {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newDirection {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._oldFormulaStorage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandChartMediatorSetGridDirection, rhs: TN_CommandChartMediatorSetGridDirection) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._oldDirection != rhs._oldDirection {return false}
    if lhs._newDirection != rhs._newDirection {return false}
    if lhs._oldFormulaStorage != rhs._oldFormulaStorage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandChartMediatorSetSeriesOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandChartMediatorSetSeriesOrder"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}series_id\0\u{3}preceding_series_id\0\u{3}inverse_series_id\0\u{3}inverse_preceding_series_id\0\u{3}undo_current_index\0\u{3}undo_new_index\0\u{3}old_formula_storage\0")

  fileprivate class _StorageClass {
    var _super: TSCH_ChartCommandArchive? = nil
    var _seriesID: TSP_UUID? = nil
    var _precedingSeriesID: TSP_UUID? = nil
    var _inverseSeriesID: TSP_UUID? = nil
    var _inversePrecedingSeriesID: TSP_UUID? = nil
    var _undoCurrentIndex: Int32? = nil
    var _undoNewIndex: Int32? = nil
    var _oldFormulaStorage: TN_ChartMediatorFormulaStorage? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _seriesID = source._seriesID
      _precedingSeriesID = source._precedingSeriesID
      _inverseSeriesID = source._inverseSeriesID
      _inversePrecedingSeriesID = source._inversePrecedingSeriesID
      _undoCurrentIndex = source._undoCurrentIndex
      _undoNewIndex = source._undoNewIndex
      _oldFormulaStorage = source._oldFormulaStorage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._undoCurrentIndex == nil {return false}
      if _storage._undoNewIndex == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._seriesID, !v.isInitialized {return false}
      if let v = _storage._precedingSeriesID, !v.isInitialized {return false}
      if let v = _storage._inverseSeriesID, !v.isInitialized {return false}
      if let v = _storage._inversePrecedingSeriesID, !v.isInitialized {return false}
      if let v = _storage._oldFormulaStorage, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._seriesID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._precedingSeriesID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._inverseSeriesID) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._inversePrecedingSeriesID) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._undoCurrentIndex) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._undoNewIndex) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._oldFormulaStorage) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._seriesID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._precedingSeriesID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._inverseSeriesID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._inversePrecedingSeriesID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._undoCurrentIndex {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._undoNewIndex {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._oldFormulaStorage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandChartMediatorSetSeriesOrder, rhs: TN_CommandChartMediatorSetSeriesOrder) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._seriesID != rhs_storage._seriesID {return false}
        if _storage._precedingSeriesID != rhs_storage._precedingSeriesID {return false}
        if _storage._inverseSeriesID != rhs_storage._inverseSeriesID {return false}
        if _storage._inversePrecedingSeriesID != rhs_storage._inversePrecedingSeriesID {return false}
        if _storage._undoCurrentIndex != rhs_storage._undoCurrentIndex {return false}
        if _storage._undoNewIndex != rhs_storage._undoNewIndex {return false}
        if _storage._oldFormulaStorage != rhs_storage._oldFormulaStorage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandChartMediatorUpdateForEntityDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandChartMediatorUpdateForEntityDelete"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{2}\u{2}cmd\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._cmd, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cmd) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cmd {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandChartMediatorUpdateForEntityDelete, rhs: TN_CommandChartMediatorUpdateForEntityDelete) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._cmd != rhs._cmd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandChartMediatorSetFormula: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandChartMediatorSetFormula"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}model_update_data_type\0\u{1}formulae\0\u{3}old_formulae\0\u{3}series_index\0\u{3}axis_type\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._modelUpdateDataType == nil {return false}
    if self._seriesIndex == nil {return false}
    if self._axisType == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.formulae) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.oldFormulae) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._modelUpdateDataType) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.formulae) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.oldFormulae) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._seriesIndex) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._axisType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._modelUpdateDataType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    if !self.formulae.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.formulae, fieldNumber: 3)
    }
    if !self.oldFormulae.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldFormulae, fieldNumber: 4)
    }
    try { if let v = self._seriesIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._axisType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandChartMediatorSetFormula, rhs: TN_CommandChartMediatorSetFormula) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._modelUpdateDataType != rhs._modelUpdateDataType {return false}
    if lhs.formulae != rhs.formulae {return false}
    if lhs.oldFormulae != rhs.oldFormulae {return false}
    if lhs._seriesIndex != rhs._seriesIndex {return false}
    if lhs._axisType != rhs._axisType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandSheetSetBackgroundFillArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSheetSetBackgroundFillArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}sheet_id\0\u{3}new_fill\0\u{3}old_fill\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._sheetID == nil {return false}
    if self._newFill == nil {return false}
    if self._oldFill == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._sheetID, !v.isInitialized {return false}
    if let v = self._newFill, !v.isInitialized {return false}
    if let v = self._oldFill, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sheetID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newFill) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._oldFill) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sheetID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newFill {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._oldFill {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandSheetSetBackgroundFillArchive, rhs: TN_CommandSheetSetBackgroundFillArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._sheetID != rhs._sheetID {return false}
    if lhs._newFill != rhs._newFill {return false}
    if lhs._oldFill != rhs._oldFill {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandSheetSetStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandSheetSetStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}sheet_id\0\u{3}sheet_style\0\u{3}old_sheet_style\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _sheetID: TSP_UUID? = nil
    var _sheetStyle: TSP_Reference? = nil
    var _oldSheetStyle: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _sheetID = source._sheetID
      _sheetStyle = source._sheetStyle
      _oldSheetStyle = source._oldSheetStyle
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._sheetID == nil {return false}
      if _storage._sheetStyle == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._sheetID, !v.isInitialized {return false}
      if let v = _storage._sheetStyle, !v.isInitialized {return false}
      if let v = _storage._oldSheetStyle, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._sheetID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._sheetStyle) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._oldSheetStyle) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._sheetID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._sheetStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._oldSheetStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandSheetSetStyleArchive, rhs: TN_CommandSheetSetStyleArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._sheetID != rhs_storage._sheetID {return false}
        if _storage._sheetStyle != rhs_storage._sheetStyle {return false}
        if _storage._oldSheetStyle != rhs_storage._oldSheetStyle {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_DocumentSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}document_selection\0")

  public var isInitialized: Bool {
    if let v = self._documentSelection, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._documentSelection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._documentSelection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_DocumentSelectionTransformerArchive, rhs: TN_DocumentSelectionTransformerArchive) -> Bool {
    if lhs._documentSelection != rhs._documentSelection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_SheetSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SheetSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}sheet_uuid\0\u{1}paginated\0")

  public var isInitialized: Bool {
    if self._paginated == nil {return false}
    if let v = self._sheetUuid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sheetUuid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._paginated) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sheetUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._paginated {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_SheetSelectionTransformerArchive, rhs: TN_SheetSelectionTransformerArchive) -> Bool {
    if lhs._sheetUuid != rhs._sheetUuid {return false}
    if lhs._paginated != rhs._paginated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_FormSheetSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormSheetSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}table_uuid\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._tableUuid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tableUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tableUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_FormSheetSelectionTransformerArchive, rhs: TN_FormSheetSelectionTransformerArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._tableUuid != rhs._tableUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CanvasSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CanvasSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}transformer_helper\0\u{3}header_storage_uuid_path\0")

  public var isInitialized: Bool {
    if self._transformerHelper == nil {return false}
    if let v = self._transformerHelper, !v.isInitialized {return false}
    if let v = self._headerStorageUuidPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transformerHelper) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._headerStorageUuidPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transformerHelper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._headerStorageUuidPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CanvasSelectionTransformerArchive, rhs: TN_CanvasSelectionTransformerArchive) -> Bool {
    if lhs._transformerHelper != rhs._transformerHelper {return false}
    if lhs._headerStorageUuidPath != rhs._headerStorageUuidPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_FormTableChooserSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormTableChooserSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_FormTableChooserSelectionTransformerArchive, rhs: TN_FormTableChooserSelectionTransformerArchive) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_FormBuilderSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormBuilderSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}table_uuid\0\u{3}viewing_record_uuid\0\u{3}field_uuid\0")

  public var isInitialized: Bool {
    if self._tableUuid == nil {return false}
    if self._viewingRecordUuid == nil {return false}
    if self._fieldUuid == nil {return false}
    if let v = self._tableUuid, !v.isInitialized {return false}
    if let v = self._viewingRecordUuid, !v.isInitialized {return false}
    if let v = self._fieldUuid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tableUuid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._viewingRecordUuid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._fieldUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tableUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._viewingRecordUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._fieldUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_FormBuilderSelectionTransformerArchive, rhs: TN_FormBuilderSelectionTransformerArchive) -> Bool {
    if lhs._tableUuid != rhs._tableUuid {return false}
    if lhs._viewingRecordUuid != rhs._viewingRecordUuid {return false}
    if lhs._fieldUuid != rhs._fieldUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_FormViewerSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormViewerSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}table_uuid\0\u{3}record_uuid\0\u{3}field_uuid\0")

  public var isInitialized: Bool {
    if self._tableUuid == nil {return false}
    if self._recordUuid == nil {return false}
    if self._fieldUuid == nil {return false}
    if let v = self._tableUuid, !v.isInitialized {return false}
    if let v = self._recordUuid, !v.isInitialized {return false}
    if let v = self._fieldUuid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tableUuid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._recordUuid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._fieldUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tableUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._recordUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._fieldUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_FormViewerSelectionTransformerArchive, rhs: TN_FormViewerSelectionTransformerArchive) -> Bool {
    if lhs._tableUuid != rhs._tableUuid {return false}
    if lhs._recordUuid != rhs._recordUuid {return false}
    if lhs._fieldUuid != rhs._fieldUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_SheetChangeBaseArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SheetChangeBaseArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}sheet_id\0")

  public var isInitialized: Bool {
    if self._sheetID == nil {return false}
    if let v = self._sheetID, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sheetID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sheetID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_SheetChangeBaseArchive, rhs: TN_SheetChangeBaseArchive) -> Bool {
    if lhs._sheetID != rhs._sheetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_SheetChangeSheetNameArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SheetChangeSheetNameArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}sheet_name\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._sheetName == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._sheetName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sheetName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_SheetChangeSheetNameArchive, rhs: TN_SheetChangeSheetNameArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._sheetName != rhs._sheetName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_CommandInducedSheetChangeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandInducedSheetChangeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}sheet_changes\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.sheetChanges) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.sheetChanges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.sheetChanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sheetChanges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_CommandInducedSheetChangeArchive, rhs: TN_CommandInducedSheetChangeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.sheetChanges != rhs.sheetChanges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
