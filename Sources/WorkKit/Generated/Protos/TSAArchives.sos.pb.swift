// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TSAArchives.sos.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct TSASOS_InducedVerifyActivityStreamWithServerCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var serverActivities: [TSP_Reference] {
    get {return _storage._serverActivities}
    set {_uniqueStorage()._serverActivities = newValue}
  }

  var serverActivitiesUndefined: Bool {
    get {return _storage._serverActivitiesUndefined ?? false}
    set {_uniqueStorage()._serverActivitiesUndefined = newValue}
  }
  /// Returns true if `serverActivitiesUndefined` has been explicitly set.
  var hasServerActivitiesUndefined: Bool {return _storage._serverActivitiesUndefined != nil}
  /// Clears the value of `serverActivitiesUndefined`. Subsequent reads from it will return its default value.
  mutating func clearServerActivitiesUndefined() {_uniqueStorage()._serverActivitiesUndefined = nil}

  var timestampOfLastActivityWhenLastActivityCoalescing: Double {
    get {return _storage._timestampOfLastActivityWhenLastActivityCoalescing ?? 0}
    set {_uniqueStorage()._timestampOfLastActivityWhenLastActivityCoalescing = newValue}
  }
  /// Returns true if `timestampOfLastActivityWhenLastActivityCoalescing` has been explicitly set.
  var hasTimestampOfLastActivityWhenLastActivityCoalescing: Bool {return _storage._timestampOfLastActivityWhenLastActivityCoalescing != nil}
  /// Clears the value of `timestampOfLastActivityWhenLastActivityCoalescing`. Subsequent reads from it will return its default value.
  mutating func clearTimestampOfLastActivityWhenLastActivityCoalescing() {_uniqueStorage()._timestampOfLastActivityWhenLastActivityCoalescing = nil}

  var nextActivityToTransformIndex: Int32 {
    get {return _storage._nextActivityToTransformIndex ?? 0}
    set {_uniqueStorage()._nextActivityToTransformIndex = newValue}
  }
  /// Returns true if `nextActivityToTransformIndex` has been explicitly set.
  var hasNextActivityToTransformIndex: Bool {return _storage._nextActivityToTransformIndex != nil}
  /// Clears the value of `nextActivityToTransformIndex`. Subsequent reads from it will return its default value.
  mutating func clearNextActivityToTransformIndex() {_uniqueStorage()._nextActivityToTransformIndex = nil}

  var authorIdentifiersToVerify: [TSP_UUID] {
    get {return _storage._authorIdentifiersToVerify}
    set {_uniqueStorage()._authorIdentifiersToVerify = newValue}
  }

  var authorIdentifiersToVerifyUndefined: Bool {
    get {return _storage._authorIdentifiersToVerifyUndefined ?? false}
    set {_uniqueStorage()._authorIdentifiersToVerifyUndefined = newValue}
  }
  /// Returns true if `authorIdentifiersToVerifyUndefined` has been explicitly set.
  var hasAuthorIdentifiersToVerifyUndefined: Bool {return _storage._authorIdentifiersToVerifyUndefined != nil}
  /// Clears the value of `authorIdentifiersToVerifyUndefined`. Subsequent reads from it will return its default value.
  mutating func clearAuthorIdentifiersToVerifyUndefined() {_uniqueStorage()._authorIdentifiersToVerifyUndefined = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSASOS_DrawableZOrderListArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var containerID: TSP_UUID {
    get {return _containerID ?? TSP_UUID()}
    set {_containerID = newValue}
  }
  /// Returns true if `containerID` has been explicitly set.
  var hasContainerID: Bool {return self._containerID != nil}
  /// Clears the value of `containerID`. Subsequent reads from it will return its default value.
  mutating func clearContainerID() {self._containerID = nil}

  var drawableIDList: [TSP_UUID] = []

  var drawableIDListUndefined: Bool {
    get {return _drawableIDListUndefined ?? false}
    set {_drawableIDListUndefined = newValue}
  }
  /// Returns true if `drawableIDListUndefined` has been explicitly set.
  var hasDrawableIDListUndefined: Bool {return self._drawableIDListUndefined != nil}
  /// Clears the value of `drawableIDListUndefined`. Subsequent reads from it will return its default value.
  mutating func clearDrawableIDListUndefined() {self._drawableIDListUndefined = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _containerID: TSP_UUID? = nil
  fileprivate var _drawableIDListUndefined: Bool? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TSASOS"

extension TSASOS_InducedVerifyActivityStreamWithServerCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InducedVerifyActivityStreamWithServerCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}server_activities\0\u{3}server_activities_undefined\0\u{3}timestamp_of_last_activity_when_last_activity_coalescing\0\u{3}next_activity_to_transform_index\0\u{3}author_identifiers_to_verify\0\u{3}author_identifiers_to_verify_undefined\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _serverActivities: [TSP_Reference] = []
    var _serverActivitiesUndefined: Bool? = nil
    var _timestampOfLastActivityWhenLastActivityCoalescing: Double? = nil
    var _nextActivityToTransformIndex: Int32? = nil
    var _authorIdentifiersToVerify: [TSP_UUID] = []
    var _authorIdentifiersToVerifyUndefined: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _serverActivities = source._serverActivities
      _serverActivitiesUndefined = source._serverActivitiesUndefined
      _timestampOfLastActivityWhenLastActivityCoalescing = source._timestampOfLastActivityWhenLastActivityCoalescing
      _nextActivityToTransformIndex = source._nextActivityToTransformIndex
      _authorIdentifiersToVerify = source._authorIdentifiersToVerify
      _authorIdentifiersToVerifyUndefined = source._authorIdentifiersToVerifyUndefined
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._timestampOfLastActivityWhenLastActivityCoalescing == nil {return false}
      if _storage._nextActivityToTransformIndex == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._serverActivities) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._authorIdentifiersToVerify) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._serverActivities) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._serverActivitiesUndefined) }()
        case 4: try { try decoder.decodeSingularDoubleField(value: &_storage._timestampOfLastActivityWhenLastActivityCoalescing) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._nextActivityToTransformIndex) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._authorIdentifiersToVerify) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._authorIdentifiersToVerifyUndefined) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._serverActivities.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._serverActivities, fieldNumber: 2)
      }
      try { if let v = _storage._serverActivitiesUndefined {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._timestampOfLastActivityWhenLastActivityCoalescing {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._nextActivityToTransformIndex {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
      } }()
      if !_storage._authorIdentifiersToVerify.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._authorIdentifiersToVerify, fieldNumber: 6)
      }
      try { if let v = _storage._authorIdentifiersToVerifyUndefined {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSASOS_InducedVerifyActivityStreamWithServerCommandArchive, rhs: TSASOS_InducedVerifyActivityStreamWithServerCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._serverActivities != rhs_storage._serverActivities {return false}
        if _storage._serverActivitiesUndefined != rhs_storage._serverActivitiesUndefined {return false}
        if _storage._timestampOfLastActivityWhenLastActivityCoalescing != rhs_storage._timestampOfLastActivityWhenLastActivityCoalescing {return false}
        if _storage._nextActivityToTransformIndex != rhs_storage._nextActivityToTransformIndex {return false}
        if _storage._authorIdentifiersToVerify != rhs_storage._authorIdentifiersToVerify {return false}
        if _storage._authorIdentifiersToVerifyUndefined != rhs_storage._authorIdentifiersToVerifyUndefined {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSASOS_DrawableZOrderListArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawableZOrderListArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}container_id\0\u{3}drawable_id_list\0\u{3}drawable_id_list_undefined\0")

  public var isInitialized: Bool {
    if let v = self._containerID, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.drawableIDList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._containerID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.drawableIDList) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._drawableIDListUndefined) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._containerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.drawableIDList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.drawableIDList, fieldNumber: 2)
    }
    try { if let v = self._drawableIDListUndefined {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSASOS_DrawableZOrderListArchive, rhs: TSASOS_DrawableZOrderListArchive) -> Bool {
    if lhs._containerID != rhs._containerID {return false}
    if lhs.drawableIDList != rhs.drawableIDList {return false}
    if lhs._drawableIDListUndefined != rhs._drawableIDListUndefined {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
