// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TNArchives.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum TN_PageOrder: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case topToBottom = 0
  case leftToRight = 1

  init() {
    self = .topToBottom
  }

}

enum TN_PageLayoutDirection: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case leftToRight = 0
  case rightToLeft = 1

  init() {
    self = .leftToRight
  }

}

struct TN_SheetUIStateArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var viewScale: Float {
    get {return _storage._viewScale ?? 0}
    set {_uniqueStorage()._viewScale = newValue}
  }
  /// Returns true if `viewScale` has been explicitly set.
  var hasViewScale: Bool {return _storage._viewScale != nil}
  /// Clears the value of `viewScale`. Subsequent reads from it will return its default value.
  mutating func clearViewScale() {_uniqueStorage()._viewScale = nil}

  var scrollPosition: TSP_Point {
    get {return _storage._scrollPosition ?? TSP_Point()}
    set {_uniqueStorage()._scrollPosition = newValue}
  }
  /// Returns true if `scrollPosition` has been explicitly set.
  var hasScrollPosition: Bool {return _storage._scrollPosition != nil}
  /// Clears the value of `scrollPosition`. Subsequent reads from it will return its default value.
  mutating func clearScrollPosition() {_uniqueStorage()._scrollPosition = nil}

  var previousViewScale: Float {
    get {return _storage._previousViewScale ?? 0}
    set {_uniqueStorage()._previousViewScale = newValue}
  }
  /// Returns true if `previousViewScale` has been explicitly set.
  var hasPreviousViewScale: Bool {return _storage._previousViewScale != nil}
  /// Clears the value of `previousViewScale`. Subsequent reads from it will return its default value.
  mutating func clearPreviousViewScale() {_uniqueStorage()._previousViewScale = nil}

  var scrollPositionIsUnscaled: Bool {
    get {return _storage._scrollPositionIsUnscaled ?? false}
    set {_uniqueStorage()._scrollPositionIsUnscaled = newValue}
  }
  /// Returns true if `scrollPositionIsUnscaled` has been explicitly set.
  var hasScrollPositionIsUnscaled: Bool {return _storage._scrollPositionIsUnscaled != nil}
  /// Clears the value of `scrollPositionIsUnscaled`. Subsequent reads from it will return its default value.
  mutating func clearScrollPositionIsUnscaled() {_uniqueStorage()._scrollPositionIsUnscaled = nil}

  var previousScrollPosition: TSP_Point {
    get {return _storage._previousScrollPosition ?? TSP_Point()}
    set {_uniqueStorage()._previousScrollPosition = newValue}
  }
  /// Returns true if `previousScrollPosition` has been explicitly set.
  var hasPreviousScrollPosition: Bool {return _storage._previousScrollPosition != nil}
  /// Clears the value of `previousScrollPosition`. Subsequent reads from it will return its default value.
  mutating func clearPreviousScrollPosition() {_uniqueStorage()._previousScrollPosition = nil}

  var scrollPositionValid: Bool {
    get {return _storage._scrollPositionValid ?? false}
    set {_uniqueStorage()._scrollPositionValid = newValue}
  }
  /// Returns true if `scrollPositionValid` has been explicitly set.
  var hasScrollPositionValid: Bool {return _storage._scrollPositionValid != nil}
  /// Clears the value of `scrollPositionValid`. Subsequent reads from it will return its default value.
  mutating func clearScrollPositionValid() {_uniqueStorage()._scrollPositionValid = nil}

  var previousScrollPositionValid: Bool {
    get {return _storage._previousScrollPositionValid ?? false}
    set {_uniqueStorage()._previousScrollPositionValid = newValue}
  }
  /// Returns true if `previousScrollPositionValid` has been explicitly set.
  var hasPreviousScrollPositionValid: Bool {return _storage._previousScrollPositionValid != nil}
  /// Clears the value of `previousScrollPositionValid`. Subsequent reads from it will return its default value.
  mutating func clearPreviousScrollPositionValid() {_uniqueStorage()._previousScrollPositionValid = nil}

  var visibleSize: TSP_Size {
    get {return _storage._visibleSize ?? TSP_Size()}
    set {_uniqueStorage()._visibleSize = newValue}
  }
  /// Returns true if `visibleSize` has been explicitly set.
  var hasVisibleSize: Bool {return _storage._visibleSize != nil}
  /// Clears the value of `visibleSize`. Subsequent reads from it will return its default value.
  mutating func clearVisibleSize() {_uniqueStorage()._visibleSize = nil}

  var previousVisibleSize: TSP_Size {
    get {return _storage._previousVisibleSize ?? TSP_Size()}
    set {_uniqueStorage()._previousVisibleSize = newValue}
  }
  /// Returns true if `previousVisibleSize` has been explicitly set.
  var hasPreviousVisibleSize: Bool {return _storage._previousVisibleSize != nil}
  /// Clears the value of `previousVisibleSize`. Subsequent reads from it will return its default value.
  mutating func clearPreviousVisibleSize() {_uniqueStorage()._previousVisibleSize = nil}

  var deviceIdiom: UInt32 {
    get {return _storage._deviceIdiom ?? 0}
    set {_uniqueStorage()._deviceIdiom = newValue}
  }
  /// Returns true if `deviceIdiom` has been explicitly set.
  var hasDeviceIdiom: Bool {return _storage._deviceIdiom != nil}
  /// Clears the value of `deviceIdiom`. Subsequent reads from it will return its default value.
  mutating func clearDeviceIdiom() {_uniqueStorage()._deviceIdiom = nil}

  var selectionPath: TSK_SelectionPathArchive {
    get {return _storage._selectionPath ?? TSK_SelectionPathArchive()}
    set {_uniqueStorage()._selectionPath = newValue}
  }
  /// Returns true if `selectionPath` has been explicitly set.
  var hasSelectionPath: Bool {return _storage._selectionPath != nil}
  /// Clears the value of `selectionPath`. Subsequent reads from it will return its default value.
  mutating func clearSelectionPath() {_uniqueStorage()._selectionPath = nil}

  var selectionPathTransformer: TSP_Reference {
    get {return _storage._selectionPathTransformer ?? TSP_Reference()}
    set {_uniqueStorage()._selectionPathTransformer = newValue}
  }
  /// Returns true if `selectionPathTransformer` has been explicitly set.
  var hasSelectionPathTransformer: Bool {return _storage._selectionPathTransformer != nil}
  /// Clears the value of `selectionPathTransformer`. Subsequent reads from it will return its default value.
  mutating func clearSelectionPathTransformer() {_uniqueStorage()._selectionPathTransformer = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TN_SheetUIStateDictionaryEntryArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sheet: TSP_Reference {
    get {return _sheet ?? TSP_Reference()}
    set {_sheet = newValue}
  }
  /// Returns true if `sheet` has been explicitly set.
  var hasSheet: Bool {return self._sheet != nil}
  /// Clears the value of `sheet`. Subsequent reads from it will return its default value.
  mutating func clearSheet() {self._sheet = nil}

  var sheetUistate: TN_SheetUIStateArchive {
    get {return _sheetUistate ?? TN_SheetUIStateArchive()}
    set {_sheetUistate = newValue}
  }
  /// Returns true if `sheetUistate` has been explicitly set.
  var hasSheetUistate: Bool {return self._sheetUistate != nil}
  /// Clears the value of `sheetUistate`. Subsequent reads from it will return its default value.
  mutating func clearSheetUistate() {self._sheetUistate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sheet: TSP_Reference? = nil
  fileprivate var _sheetUistate: TN_SheetUIStateArchive? = nil
}

struct TN_UUIDSheetUIStateDictionaryArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sheetUuid: TSP_UUID {
    get {return _sheetUuid ?? TSP_UUID()}
    set {_sheetUuid = newValue}
  }
  /// Returns true if `sheetUuid` has been explicitly set.
  var hasSheetUuid: Bool {return self._sheetUuid != nil}
  /// Clears the value of `sheetUuid`. Subsequent reads from it will return its default value.
  mutating func clearSheetUuid() {self._sheetUuid = nil}

  var sheetUistate: TN_SheetUIStateArchive {
    get {return _sheetUistate ?? TN_SheetUIStateArchive()}
    set {_sheetUistate = newValue}
  }
  /// Returns true if `sheetUistate` has been explicitly set.
  var hasSheetUistate: Bool {return self._sheetUistate != nil}
  /// Clears the value of `sheetUistate`. Subsequent reads from it will return its default value.
  mutating func clearSheetUistate() {self._sheetUistate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sheetUuid: TSP_UUID? = nil
  fileprivate var _sheetUistate: TN_SheetUIStateArchive? = nil
}

struct TN_UIStateArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// NOTE: This field was marked as deprecated in the .proto file.
  var activeSheetIndex: UInt32 {
    get {return _storage._activeSheetIndex ?? 0}
    set {_uniqueStorage()._activeSheetIndex = newValue}
  }
  /// Returns true if `activeSheetIndex` has been explicitly set.
  var hasActiveSheetIndex: Bool {return _storage._activeSheetIndex != nil}
  /// Clears the value of `activeSheetIndex`. Subsequent reads from it will return its default value.
  mutating func clearActiveSheetIndex() {_uniqueStorage()._activeSheetIndex = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var selectedInfo: [TSP_Reference] {
    get {return _storage._selectedInfo}
    set {_uniqueStorage()._selectedInfo = newValue}
  }

  /// NOTE: This field was marked as deprecated in the .proto file.
  var sheetUistateDictionaryEntry: [TN_SheetUIStateDictionaryEntryArchive] {
    get {return _storage._sheetUistateDictionaryEntry}
    set {_uniqueStorage()._sheetUistateDictionaryEntry = newValue}
  }

  /// NOTE: This field was marked as deprecated in the .proto file.
  var tableSelection: TST_SelectionArchive {
    get {return _storage._tableSelection ?? TST_SelectionArchive()}
    set {_uniqueStorage()._tableSelection = newValue}
  }
  /// Returns true if `tableSelection` has been explicitly set.
  var hasTableSelection: Bool {return _storage._tableSelection != nil}
  /// Clears the value of `tableSelection`. Subsequent reads from it will return its default value.
  mutating func clearTableSelection() {_uniqueStorage()._tableSelection = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var editingSheetIndex: UInt32 {
    get {return _storage._editingSheetIndex ?? 0}
    set {_uniqueStorage()._editingSheetIndex = newValue}
  }
  /// Returns true if `editingSheetIndex` has been explicitly set.
  var hasEditingSheetIndex: Bool {return _storage._editingSheetIndex != nil}
  /// Clears the value of `editingSheetIndex`. Subsequent reads from it will return its default value.
  mutating func clearEditingSheetIndex() {_uniqueStorage()._editingSheetIndex = nil}

  var documentMode: Int32 {
    get {return _storage._documentMode ?? 0}
    set {_uniqueStorage()._documentMode = newValue}
  }
  /// Returns true if `documentMode` has been explicitly set.
  var hasDocumentMode: Bool {return _storage._documentMode != nil}
  /// Clears the value of `documentMode`. Subsequent reads from it will return its default value.
  mutating func clearDocumentMode() {_uniqueStorage()._documentMode = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var editModeSheetUistateDictionaryEntry: [TN_SheetUIStateDictionaryEntryArchive] {
    get {return _storage._editModeSheetUistateDictionaryEntry}
    set {_uniqueStorage()._editModeSheetUistateDictionaryEntry = newValue}
  }

  /// NOTE: This field was marked as deprecated in the .proto file.
  var tableEditingMode: Int32 {
    get {return _storage._tableEditingMode ?? 0}
    set {_uniqueStorage()._tableEditingMode = newValue}
  }
  /// Returns true if `tableEditingMode` has been explicitly set.
  var hasTableEditingMode: Bool {return _storage._tableEditingMode != nil}
  /// Clears the value of `tableEditingMode`. Subsequent reads from it will return its default value.
  mutating func clearTableEditingMode() {_uniqueStorage()._tableEditingMode = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var formFocusedRecordIndex: UInt32 {
    get {return _storage._formFocusedRecordIndex ?? 0}
    set {_uniqueStorage()._formFocusedRecordIndex = newValue}
  }
  /// Returns true if `formFocusedRecordIndex` has been explicitly set.
  var hasFormFocusedRecordIndex: Bool {return _storage._formFocusedRecordIndex != nil}
  /// Clears the value of `formFocusedRecordIndex`. Subsequent reads from it will return its default value.
  mutating func clearFormFocusedRecordIndex() {_uniqueStorage()._formFocusedRecordIndex = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var formFocusedFieldIndex: UInt32 {
    get {return _storage._formFocusedFieldIndex ?? 0}
    set {_uniqueStorage()._formFocusedFieldIndex = newValue}
  }
  /// Returns true if `formFocusedFieldIndex` has been explicitly set.
  var hasFormFocusedFieldIndex: Bool {return _storage._formFocusedFieldIndex != nil}
  /// Clears the value of `formFocusedFieldIndex`. Subsequent reads from it will return its default value.
  mutating func clearFormFocusedFieldIndex() {_uniqueStorage()._formFocusedFieldIndex = nil}

  var inChartMode: Bool {
    get {return _storage._inChartMode ?? false}
    set {_uniqueStorage()._inChartMode = newValue}
  }
  /// Returns true if `inChartMode` has been explicitly set.
  var hasInChartMode: Bool {return _storage._inChartMode != nil}
  /// Clears the value of `inChartMode`. Subsequent reads from it will return its default value.
  mutating func clearInChartMode() {_uniqueStorage()._inChartMode = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var chartSelection: TN_ChartSelectionArchive {
    get {return _storage._chartSelection ?? TN_ChartSelectionArchive()}
    set {_uniqueStorage()._chartSelection = newValue}
  }
  /// Returns true if `chartSelection` has been explicitly set.
  var hasChartSelection: Bool {return _storage._chartSelection != nil}
  /// Clears the value of `chartSelection`. Subsequent reads from it will return its default value.
  mutating func clearChartSelection() {_uniqueStorage()._chartSelection = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var sheetSelection: TSP_Reference {
    get {return _storage._sheetSelection ?? TSP_Reference()}
    set {_uniqueStorage()._sheetSelection = newValue}
  }
  /// Returns true if `sheetSelection` has been explicitly set.
  var hasSheetSelection: Bool {return _storage._sheetSelection != nil}
  /// Clears the value of `sheetSelection`. Subsequent reads from it will return its default value.
  mutating func clearSheetSelection() {_uniqueStorage()._sheetSelection = nil}

  var inspectorPaneVisible: Bool {
    get {return _storage._inspectorPaneVisible ?? true}
    set {_uniqueStorage()._inspectorPaneVisible = newValue}
  }
  /// Returns true if `inspectorPaneVisible` has been explicitly set.
  var hasInspectorPaneVisible: Bool {return _storage._inspectorPaneVisible != nil}
  /// Clears the value of `inspectorPaneVisible`. Subsequent reads from it will return its default value.
  mutating func clearInspectorPaneVisible() {_uniqueStorage()._inspectorPaneVisible = nil}

  var inspectorPaneViewMode: TN_UIStateArchive.InspectorPaneViewMode {
    get {return _storage._inspectorPaneViewMode ?? .kInspectorPaneViewModeFormat}
    set {_uniqueStorage()._inspectorPaneViewMode = newValue}
  }
  /// Returns true if `inspectorPaneViewMode` has been explicitly set.
  var hasInspectorPaneViewMode: Bool {return _storage._inspectorPaneViewMode != nil}
  /// Clears the value of `inspectorPaneViewMode`. Subsequent reads from it will return its default value.
  mutating func clearInspectorPaneViewMode() {_uniqueStorage()._inspectorPaneViewMode = nil}

  var selectedQuickCalcFunctions: [UInt32] {
    get {return _storage._selectedQuickCalcFunctions}
    set {_uniqueStorage()._selectedQuickCalcFunctions = newValue}
  }

  var removedAllQuickCalcFunctions: Bool {
    get {return _storage._removedAllQuickCalcFunctions ?? false}
    set {_uniqueStorage()._removedAllQuickCalcFunctions = newValue}
  }
  /// Returns true if `removedAllQuickCalcFunctions` has been explicitly set.
  var hasRemovedAllQuickCalcFunctions: Bool {return _storage._removedAllQuickCalcFunctions != nil}
  /// Clears the value of `removedAllQuickCalcFunctions`. Subsequent reads from it will return its default value.
  mutating func clearRemovedAllQuickCalcFunctions() {_uniqueStorage()._removedAllQuickCalcFunctions = nil}

  var showCanvasGuides: Bool {
    get {return _storage._showCanvasGuides ?? false}
    set {_uniqueStorage()._showCanvasGuides = newValue}
  }
  /// Returns true if `showCanvasGuides` has been explicitly set.
  var hasShowCanvasGuides: Bool {return _storage._showCanvasGuides != nil}
  /// Clears the value of `showCanvasGuides`. Subsequent reads from it will return its default value.
  mutating func clearShowCanvasGuides() {_uniqueStorage()._showCanvasGuides = nil}

  var showsComments: Bool {
    get {return _storage._showsComments ?? false}
    set {_uniqueStorage()._showsComments = newValue}
  }
  /// Returns true if `showsComments` has been explicitly set.
  var hasShowsComments: Bool {return _storage._showsComments != nil}
  /// Clears the value of `showsComments`. Subsequent reads from it will return its default value.
  mutating func clearShowsComments() {_uniqueStorage()._showsComments = nil}

  var desktopWindowOrigin: TSP_Point {
    get {return _storage._desktopWindowOrigin ?? TSP_Point()}
    set {_uniqueStorage()._desktopWindowOrigin = newValue}
  }
  /// Returns true if `desktopWindowOrigin` has been explicitly set.
  var hasDesktopWindowOrigin: Bool {return _storage._desktopWindowOrigin != nil}
  /// Clears the value of `desktopWindowOrigin`. Subsequent reads from it will return its default value.
  mutating func clearDesktopWindowOrigin() {_uniqueStorage()._desktopWindowOrigin = nil}

  var desktopWindowSize: TSP_Size {
    get {return _storage._desktopWindowSize ?? TSP_Size()}
    set {_uniqueStorage()._desktopWindowSize = newValue}
  }
  /// Returns true if `desktopWindowSize` has been explicitly set.
  var hasDesktopWindowSize: Bool {return _storage._desktopWindowSize != nil}
  /// Clears the value of `desktopWindowSize`. Subsequent reads from it will return its default value.
  mutating func clearDesktopWindowSize() {_uniqueStorage()._desktopWindowSize = nil}

  var desktopScreenSize: TSP_Size {
    get {return _storage._desktopScreenSize ?? TSP_Size()}
    set {_uniqueStorage()._desktopScreenSize = newValue}
  }
  /// Returns true if `desktopScreenSize` has been explicitly set.
  var hasDesktopScreenSize: Bool {return _storage._desktopScreenSize != nil}
  /// Clears the value of `desktopScreenSize`. Subsequent reads from it will return its default value.
  mutating func clearDesktopScreenSize() {_uniqueStorage()._desktopScreenSize = nil}

  var chartUiState: [TSCH_ChartUIState] {
    get {return _storage._chartUiState}
    set {_uniqueStorage()._chartUiState = newValue}
  }

  var selectionPath: TSK_SelectionPathArchive {
    get {return _storage._selectionPath ?? TSK_SelectionPathArchive()}
    set {_uniqueStorage()._selectionPath = newValue}
  }
  /// Returns true if `selectionPath` has been explicitly set.
  var hasSelectionPath: Bool {return _storage._selectionPath != nil}
  /// Clears the value of `selectionPath`. Subsequent reads from it will return its default value.
  mutating func clearSelectionPath() {_uniqueStorage()._selectionPath = nil}

  var inspectorPaneAutohidden: Bool {
    get {return _storage._inspectorPaneAutohidden ?? false}
    set {_uniqueStorage()._inspectorPaneAutohidden = newValue}
  }
  /// Returns true if `inspectorPaneAutohidden` has been explicitly set.
  var hasInspectorPaneAutohidden: Bool {return _storage._inspectorPaneAutohidden != nil}
  /// Clears the value of `inspectorPaneAutohidden`. Subsequent reads from it will return its default value.
  mutating func clearInspectorPaneAutohidden() {_uniqueStorage()._inspectorPaneAutohidden = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var showsSidebar: Bool {
    get {return _storage._showsSidebar ?? false}
    set {_uniqueStorage()._showsSidebar = newValue}
  }
  /// Returns true if `showsSidebar` has been explicitly set.
  var hasShowsSidebar: Bool {return _storage._showsSidebar != nil}
  /// Clears the value of `showsSidebar`. Subsequent reads from it will return its default value.
  mutating func clearShowsSidebar() {_uniqueStorage()._showsSidebar = nil}

  var showsRulers: Bool {
    get {return _storage._showsRulers ?? false}
    set {_uniqueStorage()._showsRulers = newValue}
  }
  /// Returns true if `showsRulers` has been explicitly set.
  var hasShowsRulers: Bool {return _storage._showsRulers != nil}
  /// Clears the value of `showsRulers`. Subsequent reads from it will return its default value.
  mutating func clearShowsRulers() {_uniqueStorage()._showsRulers = nil}

  var uuidSheetUistateDictionary: [TN_UUIDSheetUIStateDictionaryArchive] {
    get {return _storage._uuidSheetUistateDictionary}
    set {_uniqueStorage()._uuidSheetUistateDictionary = newValue}
  }

  var freehandDrawingToolkitState: TSP_Reference {
    get {return _storage._freehandDrawingToolkitState ?? TSP_Reference()}
    set {_uniqueStorage()._freehandDrawingToolkitState = newValue}
  }
  /// Returns true if `freehandDrawingToolkitState` has been explicitly set.
  var hasFreehandDrawingToolkitState: Bool {return _storage._freehandDrawingToolkitState != nil}
  /// Clears the value of `freehandDrawingToolkitState`. Subsequent reads from it will return its default value.
  mutating func clearFreehandDrawingToolkitState() {_uniqueStorage()._freehandDrawingToolkitState = nil}

  var selectionPathTransformer: TSP_Reference {
    get {return _storage._selectionPathTransformer ?? TSP_Reference()}
    set {_uniqueStorage()._selectionPathTransformer = newValue}
  }
  /// Returns true if `selectionPathTransformer` has been explicitly set.
  var hasSelectionPathTransformer: Bool {return _storage._selectionPathTransformer != nil}
  /// Clears the value of `selectionPathTransformer`. Subsequent reads from it will return its default value.
  mutating func clearSelectionPathTransformer() {_uniqueStorage()._selectionPathTransformer = nil}

  var editingDisabled: Bool {
    get {return _storage._editingDisabled ?? false}
    set {_uniqueStorage()._editingDisabled = newValue}
  }
  /// Returns true if `editingDisabled` has been explicitly set.
  var hasEditingDisabled: Bool {return _storage._editingDisabled != nil}
  /// Clears the value of `editingDisabled`. Subsequent reads from it will return its default value.
  mutating func clearEditingDisabled() {_uniqueStorage()._editingDisabled = nil}

  var sidebarVisible: Bool {
    get {return _storage._sidebarVisible ?? false}
    set {_uniqueStorage()._sidebarVisible = newValue}
  }
  /// Returns true if `sidebarVisible` has been explicitly set.
  var hasSidebarVisible: Bool {return _storage._sidebarVisible != nil}
  /// Clears the value of `sidebarVisible`. Subsequent reads from it will return its default value.
  mutating func clearSidebarVisible() {_uniqueStorage()._sidebarVisible = nil}

  var sidebarWidth: Float {
    get {return _storage._sidebarWidth ?? 0}
    set {_uniqueStorage()._sidebarWidth = newValue}
  }
  /// Returns true if `sidebarWidth` has been explicitly set.
  var hasSidebarWidth: Bool {return _storage._sidebarWidth != nil}
  /// Clears the value of `sidebarWidth`. Subsequent reads from it will return its default value.
  mutating func clearSidebarWidth() {_uniqueStorage()._sidebarWidth = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum InspectorPaneViewMode: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kInspectorPaneViewModeFormat = 0
    case kInspectorPaneViewModeFilter = 1

    init() {
      self = .kInspectorPaneViewModeFormat
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TN_SheetSelectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sheet: TSP_Reference {
    get {return _sheet ?? TSP_Reference()}
    set {_sheet = newValue}
  }
  /// Returns true if `sheet` has been explicitly set.
  var hasSheet: Bool {return self._sheet != nil}
  /// Clears the value of `sheet`. Subsequent reads from it will return its default value.
  mutating func clearSheet() {self._sheet = nil}

  var paginated: Bool {
    get {return _paginated ?? false}
    set {_paginated = newValue}
  }
  /// Returns true if `paginated` has been explicitly set.
  var hasPaginated: Bool {return self._paginated != nil}
  /// Clears the value of `paginated`. Subsequent reads from it will return its default value.
  mutating func clearPaginated() {self._paginated = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sheet: TSP_Reference? = nil
  fileprivate var _paginated: Bool? = nil
}

struct TN_FormSelectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var recordIndex: UInt32 {
    get {return _recordIndex ?? 0}
    set {_recordIndex = newValue}
  }
  /// Returns true if `recordIndex` has been explicitly set.
  var hasRecordIndex: Bool {return self._recordIndex != nil}
  /// Clears the value of `recordIndex`. Subsequent reads from it will return its default value.
  mutating func clearRecordIndex() {self._recordIndex = nil}

  var fieldIndex: UInt32 {
    get {return _fieldIndex ?? 0}
    set {_fieldIndex = newValue}
  }
  /// Returns true if `fieldIndex` has been explicitly set.
  var hasFieldIndex: Bool {return self._fieldIndex != nil}
  /// Clears the value of `fieldIndex`. Subsequent reads from it will return its default value.
  mutating func clearFieldIndex() {self._fieldIndex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _recordIndex: UInt32? = nil
  fileprivate var _fieldIndex: UInt32? = nil
}

struct TN_FormBuilderSelectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var viewingRecordIndex: UInt32 {
    get {return _viewingRecordIndex ?? 0}
    set {_viewingRecordIndex = newValue}
  }
  /// Returns true if `viewingRecordIndex` has been explicitly set.
  var hasViewingRecordIndex: Bool {return self._viewingRecordIndex != nil}
  /// Clears the value of `viewingRecordIndex`. Subsequent reads from it will return its default value.
  mutating func clearViewingRecordIndex() {self._viewingRecordIndex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _viewingRecordIndex: UInt32? = nil
}

struct TN_FormTableChooserSelectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TN_UndoRedoStateArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uiState: TN_UIStateArchive {
    get {return _uiState ?? TN_UIStateArchive()}
    set {_uiState = newValue}
  }
  /// Returns true if `uiState` has been explicitly set.
  var hasUiState: Bool {return self._uiState != nil}
  /// Clears the value of `uiState`. Subsequent reads from it will return its default value.
  mutating func clearUiState() {self._uiState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _uiState: TN_UIStateArchive? = nil
}

struct TN_DocumentArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sheets: [TSP_Reference] {
    get {return _storage._sheets}
    set {_uniqueStorage()._sheets = newValue}
  }

  var `super`: TSA_DocumentArchive {
    get {return _storage._super ?? TSA_DocumentArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var calculationEngine: TSP_Reference {
    get {return _storage._calculationEngine ?? TSP_Reference()}
    set {_uniqueStorage()._calculationEngine = newValue}
  }
  /// Returns true if `calculationEngine` has been explicitly set.
  var hasCalculationEngine: Bool {return _storage._calculationEngine != nil}
  /// Clears the value of `calculationEngine`. Subsequent reads from it will return its default value.
  mutating func clearCalculationEngine() {_uniqueStorage()._calculationEngine = nil}

  var stylesheet: TSP_Reference {
    get {return _storage._stylesheet ?? TSP_Reference()}
    set {_uniqueStorage()._stylesheet = newValue}
  }
  /// Returns true if `stylesheet` has been explicitly set.
  var hasStylesheet: Bool {return _storage._stylesheet != nil}
  /// Clears the value of `stylesheet`. Subsequent reads from it will return its default value.
  mutating func clearStylesheet() {_uniqueStorage()._stylesheet = nil}

  var sidebarOrder: TSP_Reference {
    get {return _storage._sidebarOrder ?? TSP_Reference()}
    set {_uniqueStorage()._sidebarOrder = newValue}
  }
  /// Returns true if `sidebarOrder` has been explicitly set.
  var hasSidebarOrder: Bool {return _storage._sidebarOrder != nil}
  /// Clears the value of `sidebarOrder`. Subsequent reads from it will return its default value.
  mutating func clearSidebarOrder() {_uniqueStorage()._sidebarOrder = nil}

  var theme: TSP_Reference {
    get {return _storage._theme ?? TSP_Reference()}
    set {_uniqueStorage()._theme = newValue}
  }
  /// Returns true if `theme` has been explicitly set.
  var hasTheme: Bool {return _storage._theme != nil}
  /// Clears the value of `theme`. Subsequent reads from it will return its default value.
  mutating func clearTheme() {_uniqueStorage()._theme = nil}

  var uistate: TN_UIStateArchive {
    get {return _storage._uistate ?? TN_UIStateArchive()}
    set {_uniqueStorage()._uistate = newValue}
  }
  /// Returns true if `uistate` has been explicitly set.
  var hasUistate: Bool {return _storage._uistate != nil}
  /// Clears the value of `uistate`. Subsequent reads from it will return its default value.
  mutating func clearUistate() {_uniqueStorage()._uistate = nil}

  var customFormatList: TSP_Reference {
    get {return _storage._customFormatList ?? TSP_Reference()}
    set {_uniqueStorage()._customFormatList = newValue}
  }
  /// Returns true if `customFormatList` has been explicitly set.
  var hasCustomFormatList: Bool {return _storage._customFormatList != nil}
  /// Clears the value of `customFormatList`. Subsequent reads from it will return its default value.
  mutating func clearCustomFormatList() {_uniqueStorage()._customFormatList = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var printerID: String {
    get {return _storage._printerID ?? String()}
    set {_uniqueStorage()._printerID = newValue}
  }
  /// Returns true if `printerID` has been explicitly set.
  var hasPrinterID: Bool {return _storage._printerID != nil}
  /// Clears the value of `printerID`. Subsequent reads from it will return its default value.
  mutating func clearPrinterID() {_uniqueStorage()._printerID = nil}

  var paperID: String {
    get {return _storage._paperID ?? String()}
    set {_uniqueStorage()._paperID = newValue}
  }
  /// Returns true if `paperID` has been explicitly set.
  var hasPaperID: Bool {return _storage._paperID != nil}
  /// Clears the value of `paperID`. Subsequent reads from it will return its default value.
  mutating func clearPaperID() {_uniqueStorage()._paperID = nil}

  var pageSize: TSP_Size {
    get {return _storage._pageSize ?? TSP_Size()}
    set {_uniqueStorage()._pageSize = newValue}
  }
  /// Returns true if `pageSize` has been explicitly set.
  var hasPageSize: Bool {return _storage._pageSize != nil}
  /// Clears the value of `pageSize`. Subsequent reads from it will return its default value.
  mutating func clearPageSize() {_uniqueStorage()._pageSize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TN_PlaceholderArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_ShapeInfoArchive {
    get {return _super ?? TSWP_ShapeInfoArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_ShapeInfoArchive? = nil
}

struct TN_SheetArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  var drawableInfos: [TSP_Reference] {
    get {return _storage._drawableInfos}
    set {_uniqueStorage()._drawableInfos = newValue}
  }

  var inPortraitPageOrientation: Bool {
    get {return _storage._inPortraitPageOrientation ?? false}
    set {_uniqueStorage()._inPortraitPageOrientation = newValue}
  }
  /// Returns true if `inPortraitPageOrientation` has been explicitly set.
  var hasInPortraitPageOrientation: Bool {return _storage._inPortraitPageOrientation != nil}
  /// Clears the value of `inPortraitPageOrientation`. Subsequent reads from it will return its default value.
  mutating func clearInPortraitPageOrientation() {_uniqueStorage()._inPortraitPageOrientation = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var showRepeatingHeaders: Bool {
    get {return _storage._showRepeatingHeaders ?? false}
    set {_uniqueStorage()._showRepeatingHeaders = newValue}
  }
  /// Returns true if `showRepeatingHeaders` has been explicitly set.
  var hasShowRepeatingHeaders: Bool {return _storage._showRepeatingHeaders != nil}
  /// Clears the value of `showRepeatingHeaders`. Subsequent reads from it will return its default value.
  mutating func clearShowRepeatingHeaders() {_uniqueStorage()._showRepeatingHeaders = nil}

  var showPageNumbers: Bool {
    get {return _storage._showPageNumbers ?? false}
    set {_uniqueStorage()._showPageNumbers = newValue}
  }
  /// Returns true if `showPageNumbers` has been explicitly set.
  var hasShowPageNumbers: Bool {return _storage._showPageNumbers != nil}
  /// Clears the value of `showPageNumbers`. Subsequent reads from it will return its default value.
  mutating func clearShowPageNumbers() {_uniqueStorage()._showPageNumbers = nil}

  var isAutofitOn: Bool {
    get {return _storage._isAutofitOn ?? false}
    set {_uniqueStorage()._isAutofitOn = newValue}
  }
  /// Returns true if `isAutofitOn` has been explicitly set.
  var hasIsAutofitOn: Bool {return _storage._isAutofitOn != nil}
  /// Clears the value of `isAutofitOn`. Subsequent reads from it will return its default value.
  mutating func clearIsAutofitOn() {_uniqueStorage()._isAutofitOn = nil}

  var contentScale: Float {
    get {return _storage._contentScale ?? 0}
    set {_uniqueStorage()._contentScale = newValue}
  }
  /// Returns true if `contentScale` has been explicitly set.
  var hasContentScale: Bool {return _storage._contentScale != nil}
  /// Clears the value of `contentScale`. Subsequent reads from it will return its default value.
  mutating func clearContentScale() {_uniqueStorage()._contentScale = nil}

  var pageOrder: TN_PageOrder {
    get {return _storage._pageOrder ?? .topToBottom}
    set {_uniqueStorage()._pageOrder = newValue}
  }
  /// Returns true if `pageOrder` has been explicitly set.
  var hasPageOrder: Bool {return _storage._pageOrder != nil}
  /// Clears the value of `pageOrder`. Subsequent reads from it will return its default value.
  mutating func clearPageOrder() {_uniqueStorage()._pageOrder = nil}

  var printMargins: TSD_EdgeInsetsArchive {
    get {return _storage._printMargins ?? TSD_EdgeInsetsArchive()}
    set {_uniqueStorage()._printMargins = newValue}
  }
  /// Returns true if `printMargins` has been explicitly set.
  var hasPrintMargins: Bool {return _storage._printMargins != nil}
  /// Clears the value of `printMargins`. Subsequent reads from it will return its default value.
  mutating func clearPrintMargins() {_uniqueStorage()._printMargins = nil}

  var usingStartPageNumber: Bool {
    get {return _storage._usingStartPageNumber ?? false}
    set {_uniqueStorage()._usingStartPageNumber = newValue}
  }
  /// Returns true if `usingStartPageNumber` has been explicitly set.
  var hasUsingStartPageNumber: Bool {return _storage._usingStartPageNumber != nil}
  /// Clears the value of `usingStartPageNumber`. Subsequent reads from it will return its default value.
  mutating func clearUsingStartPageNumber() {_uniqueStorage()._usingStartPageNumber = nil}

  var startPageNumber: Int32 {
    get {return _storage._startPageNumber ?? 0}
    set {_uniqueStorage()._startPageNumber = newValue}
  }
  /// Returns true if `startPageNumber` has been explicitly set.
  var hasStartPageNumber: Bool {return _storage._startPageNumber != nil}
  /// Clears the value of `startPageNumber`. Subsequent reads from it will return its default value.
  mutating func clearStartPageNumber() {_uniqueStorage()._startPageNumber = nil}

  var pageHeaderInset: Float {
    get {return _storage._pageHeaderInset ?? 0}
    set {_uniqueStorage()._pageHeaderInset = newValue}
  }
  /// Returns true if `pageHeaderInset` has been explicitly set.
  var hasPageHeaderInset: Bool {return _storage._pageHeaderInset != nil}
  /// Clears the value of `pageHeaderInset`. Subsequent reads from it will return its default value.
  mutating func clearPageHeaderInset() {_uniqueStorage()._pageHeaderInset = nil}

  var pageFooterInset: Float {
    get {return _storage._pageFooterInset ?? 0}
    set {_uniqueStorage()._pageFooterInset = newValue}
  }
  /// Returns true if `pageFooterInset` has been explicitly set.
  var hasPageFooterInset: Bool {return _storage._pageFooterInset != nil}
  /// Clears the value of `pageFooterInset`. Subsequent reads from it will return its default value.
  mutating func clearPageFooterInset() {_uniqueStorage()._pageFooterInset = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var headerStorage: TSP_Reference {
    get {return _storage._headerStorage ?? TSP_Reference()}
    set {_uniqueStorage()._headerStorage = newValue}
  }
  /// Returns true if `headerStorage` has been explicitly set.
  var hasHeaderStorage: Bool {return _storage._headerStorage != nil}
  /// Clears the value of `headerStorage`. Subsequent reads from it will return its default value.
  mutating func clearHeaderStorage() {_uniqueStorage()._headerStorage = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var footerStorage: TSP_Reference {
    get {return _storage._footerStorage ?? TSP_Reference()}
    set {_uniqueStorage()._footerStorage = newValue}
  }
  /// Returns true if `footerStorage` has been explicitly set.
  var hasFooterStorage: Bool {return _storage._footerStorage != nil}
  /// Clears the value of `footerStorage`. Subsequent reads from it will return its default value.
  mutating func clearFooterStorage() {_uniqueStorage()._footerStorage = nil}

  var userDefinedGuideStorage: TSP_Reference {
    get {return _storage._userDefinedGuideStorage ?? TSP_Reference()}
    set {_uniqueStorage()._userDefinedGuideStorage = newValue}
  }
  /// Returns true if `userDefinedGuideStorage` has been explicitly set.
  var hasUserDefinedGuideStorage: Bool {return _storage._userDefinedGuideStorage != nil}
  /// Clears the value of `userDefinedGuideStorage`. Subsequent reads from it will return its default value.
  mutating func clearUserDefinedGuideStorage() {_uniqueStorage()._userDefinedGuideStorage = nil}

  var headers: [TSP_Reference] {
    get {return _storage._headers}
    set {_uniqueStorage()._headers = newValue}
  }

  var footers: [TSP_Reference] {
    get {return _storage._footers}
    set {_uniqueStorage()._footers = newValue}
  }

  var usesSingleHeaderFooter: Bool {
    get {return _storage._usesSingleHeaderFooter ?? false}
    set {_uniqueStorage()._usesSingleHeaderFooter = newValue}
  }
  /// Returns true if `usesSingleHeaderFooter` has been explicitly set.
  var hasUsesSingleHeaderFooter: Bool {return _storage._usesSingleHeaderFooter != nil}
  /// Clears the value of `usesSingleHeaderFooter`. Subsequent reads from it will return its default value.
  mutating func clearUsesSingleHeaderFooter() {_uniqueStorage()._usesSingleHeaderFooter = nil}

  var layoutDirection: TN_PageLayoutDirection {
    get {return _storage._layoutDirection ?? .leftToRight}
    set {_uniqueStorage()._layoutDirection = newValue}
  }
  /// Returns true if `layoutDirection` has been explicitly set.
  var hasLayoutDirection: Bool {return _storage._layoutDirection != nil}
  /// Clears the value of `layoutDirection`. Subsequent reads from it will return its default value.
  mutating func clearLayoutDirection() {_uniqueStorage()._layoutDirection = nil}

  var style: TSP_Reference {
    get {return _storage._style ?? TSP_Reference()}
    set {_uniqueStorage()._style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  var hasStyle: Bool {return _storage._style != nil}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  mutating func clearStyle() {_uniqueStorage()._style = nil}

  var printBackgrounds: Bool {
    get {return _storage._printBackgrounds ?? false}
    set {_uniqueStorage()._printBackgrounds = newValue}
  }
  /// Returns true if `printBackgrounds` has been explicitly set.
  var hasPrintBackgrounds: Bool {return _storage._printBackgrounds != nil}
  /// Clears the value of `printBackgrounds`. Subsequent reads from it will return its default value.
  mutating func clearPrintBackgrounds() {_uniqueStorage()._printBackgrounds = nil}

  var shouldPrintComments: Bool {
    get {return _storage._shouldPrintComments ?? false}
    set {_uniqueStorage()._shouldPrintComments = newValue}
  }
  /// Returns true if `shouldPrintComments` has been explicitly set.
  var hasShouldPrintComments: Bool {return _storage._shouldPrintComments != nil}
  /// Clears the value of `shouldPrintComments`. Subsequent reads from it will return its default value.
  mutating func clearShouldPrintComments() {_uniqueStorage()._shouldPrintComments = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TN_SheetStylePropertiesArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fill: TSD_FillArchive {
    get {return _fill ?? TSD_FillArchive()}
    set {_fill = newValue}
  }
  /// Returns true if `fill` has been explicitly set.
  var hasFill: Bool {return self._fill != nil}
  /// Clears the value of `fill`. Subsequent reads from it will return its default value.
  mutating func clearFill() {self._fill = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fill: TSD_FillArchive? = nil
}

struct TN_SheetStyleArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_StyleArchive {
    get {return _super ?? TSS_StyleArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var overrideCount: UInt32 {
    get {return _overrideCount ?? 0}
    set {_overrideCount = newValue}
  }
  /// Returns true if `overrideCount` has been explicitly set.
  var hasOverrideCount: Bool {return self._overrideCount != nil}
  /// Clears the value of `overrideCount`. Subsequent reads from it will return its default value.
  mutating func clearOverrideCount() {self._overrideCount = nil}

  var sheetProperties: TN_SheetStylePropertiesArchive {
    get {return _sheetProperties ?? TN_SheetStylePropertiesArchive()}
    set {_sheetProperties = newValue}
  }
  /// Returns true if `sheetProperties` has been explicitly set.
  var hasSheetProperties: Bool {return self._sheetProperties != nil}
  /// Clears the value of `sheetProperties`. Subsequent reads from it will return its default value.
  mutating func clearSheetProperties() {self._sheetProperties = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSS_StyleArchive? = nil
  fileprivate var _overrideCount: UInt32? = nil
  fileprivate var _sheetProperties: TN_SheetStylePropertiesArchive? = nil
}

struct TN_FormBasedSheetArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TN_SheetArchive {
    get {return _super ?? TN_SheetArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var tableID: TSP_CFUUIDArchive {
    get {return _tableID ?? TSP_CFUUIDArchive()}
    set {_tableID = newValue}
  }
  /// Returns true if `tableID` has been explicitly set.
  var hasTableID: Bool {return self._tableID != nil}
  /// Clears the value of `tableID`. Subsequent reads from it will return its default value.
  mutating func clearTableID() {self._tableID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TN_SheetArchive? = nil
  fileprivate var _tableID: TSP_CFUUIDArchive? = nil
}

struct TN_ThemeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_ThemeArchive {
    get {return _super ?? TSS_ThemeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var prototypes: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSS_ThemeArchive? = nil
}

struct TN_PasteboardNativeStorageArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sheet: TSP_Reference {
    get {return _sheet ?? TSP_Reference()}
    set {_sheet = newValue}
  }
  /// Returns true if `sheet` has been explicitly set.
  var hasSheet: Bool {return self._sheet != nil}
  /// Clears the value of `sheet`. Subsequent reads from it will return its default value.
  mutating func clearSheet() {self._sheet = nil}

  var uiState: TN_SheetUIStateArchive {
    get {return _uiState ?? TN_SheetUIStateArchive()}
    set {_uiState = newValue}
  }
  /// Returns true if `uiState` has been explicitly set.
  var hasUiState: Bool {return self._uiState != nil}
  /// Clears the value of `uiState`. Subsequent reads from it will return its default value.
  mutating func clearUiState() {self._uiState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sheet: TSP_Reference? = nil
  fileprivate var _uiState: TN_SheetUIStateArchive? = nil
}

struct TN_ChartMediatorFormulaStorage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dataFormulae: [TSCE_FormulaArchive] = []

  var rowLabelFormulae: [TSCE_FormulaArchive] = []

  var colLabelFormulae: [TSCE_FormulaArchive] = []

  var direction: Int32 {
    get {return _direction ?? 0}
    set {_direction = newValue}
  }
  /// Returns true if `direction` has been explicitly set.
  var hasDirection: Bool {return self._direction != nil}
  /// Clears the value of `direction`. Subsequent reads from it will return its default value.
  mutating func clearDirection() {self._direction = nil}

  var errorCustomPosFormulae: [TSCE_FormulaArchive] = []

  var errorCustomNegFormulae: [TSCE_FormulaArchive] = []

  var errorCustomPosScatterXFormulae: [TSCE_FormulaArchive] = []

  var errorCustomNegScatterXFormulae: [TSCE_FormulaArchive] = []

  var scheme: Int32 {
    get {return _scheme ?? 0}
    set {_scheme = newValue}
  }
  /// Returns true if `scheme` has been explicitly set.
  var hasScheme: Bool {return self._scheme != nil}
  /// Clears the value of `scheme`. Subsequent reads from it will return its default value.
  mutating func clearScheme() {self._scheme = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _direction: Int32? = nil
  fileprivate var _scheme: Int32? = nil
}

struct TN_ChartMediatorArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSCH_ChartMediatorArchive {
    get {return _storage._super ?? TSCH_ChartMediatorArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var entityID: String {
    get {return _storage._entityID ?? String()}
    set {_uniqueStorage()._entityID = newValue}
  }
  /// Returns true if `entityID` has been explicitly set.
  var hasEntityID: Bool {return _storage._entityID != nil}
  /// Clears the value of `entityID`. Subsequent reads from it will return its default value.
  mutating func clearEntityID() {_uniqueStorage()._entityID = nil}

  var formulas: TN_ChartMediatorFormulaStorage {
    get {return _storage._formulas ?? TN_ChartMediatorFormulaStorage()}
    set {_uniqueStorage()._formulas = newValue}
  }
  /// Returns true if `formulas` has been explicitly set.
  var hasFormulas: Bool {return _storage._formulas != nil}
  /// Clears the value of `formulas`. Subsequent reads from it will return its default value.
  mutating func clearFormulas() {_uniqueStorage()._formulas = nil}

  var columnsAreSeries: Bool {
    get {return _storage._columnsAreSeries ?? false}
    set {_uniqueStorage()._columnsAreSeries = newValue}
  }
  /// Returns true if `columnsAreSeries` has been explicitly set.
  var hasColumnsAreSeries: Bool {return _storage._columnsAreSeries != nil}
  /// Clears the value of `columnsAreSeries`. Subsequent reads from it will return its default value.
  mutating func clearColumnsAreSeries() {_uniqueStorage()._columnsAreSeries = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var isRegisteredWithCalcEngine: Bool {
    get {return _storage._isRegisteredWithCalcEngine ?? false}
    set {_uniqueStorage()._isRegisteredWithCalcEngine = newValue}
  }
  /// Returns true if `isRegisteredWithCalcEngine` has been explicitly set.
  var hasIsRegisteredWithCalcEngine: Bool {return _storage._isRegisteredWithCalcEngine != nil}
  /// Clears the value of `isRegisteredWithCalcEngine`. Subsequent reads from it will return its default value.
  mutating func clearIsRegisteredWithCalcEngine() {_uniqueStorage()._isRegisteredWithCalcEngine = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TN_ChartSelectionArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reference: TSCE_RangeReferenceArchive {
    get {return _storage._reference ?? TSCE_RangeReferenceArchive()}
    set {_uniqueStorage()._reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  var hasReference: Bool {return _storage._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  mutating func clearReference() {_uniqueStorage()._reference = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var deprecatedSuper: TSCH_ChartSelectionArchive {
    get {return _storage._deprecatedSuper ?? TSCH_ChartSelectionArchive()}
    set {_uniqueStorage()._deprecatedSuper = newValue}
  }
  /// Returns true if `deprecatedSuper` has been explicitly set.
  var hasDeprecatedSuper: Bool {return _storage._deprecatedSuper != nil}
  /// Clears the value of `deprecatedSuper`. Subsequent reads from it will return its default value.
  mutating func clearDeprecatedSuper() {_uniqueStorage()._deprecatedSuper = nil}

  var chart: TSP_Reference {
    get {return _storage._chart ?? TSP_Reference()}
    set {_uniqueStorage()._chart = newValue}
  }
  /// Returns true if `chart` has been explicitly set.
  var hasChart: Bool {return _storage._chart != nil}
  /// Clears the value of `chart`. Subsequent reads from it will return its default value.
  mutating func clearChart() {_uniqueStorage()._chart = nil}

  var `super`: TSD_DrawableSelectionArchive {
    get {return _storage._super ?? TSD_DrawableSelectionArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TN_FormCommandActivityBehaviorArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSCK_CommandActivityBehaviorArchive {
    get {return _super ?? TSCK_CommandActivityBehaviorArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSCK_CommandActivityBehaviorArchive? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TN"

extension TN_PageOrder: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PageOrderTopToBottom\0\u{1}PageOrderLeftToRight\0")
}

extension TN_PageLayoutDirection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PageLayoutDirectionLeftToRight\0\u{1}PageLayoutDirectionRightToLeft\0")
}

extension TN_SheetUIStateArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SheetUIStateArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}view_scale\0\u{3}scroll_position\0\u{3}previous_view_scale\0\u{3}scroll_position_is_unscaled\0\u{3}previous_scroll_position\0\u{3}scroll_position_valid\0\u{3}previous_scroll_position_valid\0\u{3}visible_size\0\u{3}previous_visible_size\0\u{3}device_idiom\0\u{3}selection_path\0\u{3}selection_path_transformer\0")

  fileprivate class _StorageClass {
    var _viewScale: Float? = nil
    var _scrollPosition: TSP_Point? = nil
    var _previousViewScale: Float? = nil
    var _scrollPositionIsUnscaled: Bool? = nil
    var _previousScrollPosition: TSP_Point? = nil
    var _scrollPositionValid: Bool? = nil
    var _previousScrollPositionValid: Bool? = nil
    var _visibleSize: TSP_Size? = nil
    var _previousVisibleSize: TSP_Size? = nil
    var _deviceIdiom: UInt32? = nil
    var _selectionPath: TSK_SelectionPathArchive? = nil
    var _selectionPathTransformer: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _viewScale = source._viewScale
      _scrollPosition = source._scrollPosition
      _previousViewScale = source._previousViewScale
      _scrollPositionIsUnscaled = source._scrollPositionIsUnscaled
      _previousScrollPosition = source._previousScrollPosition
      _scrollPositionValid = source._scrollPositionValid
      _previousScrollPositionValid = source._previousScrollPositionValid
      _visibleSize = source._visibleSize
      _previousVisibleSize = source._previousVisibleSize
      _deviceIdiom = source._deviceIdiom
      _selectionPath = source._selectionPath
      _selectionPathTransformer = source._selectionPathTransformer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._viewScale == nil {return false}
      if _storage._scrollPosition == nil {return false}
      if let v = _storage._scrollPosition, !v.isInitialized {return false}
      if let v = _storage._previousScrollPosition, !v.isInitialized {return false}
      if let v = _storage._visibleSize, !v.isInitialized {return false}
      if let v = _storage._previousVisibleSize, !v.isInitialized {return false}
      if let v = _storage._selectionPath, !v.isInitialized {return false}
      if let v = _storage._selectionPathTransformer, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularFloatField(value: &_storage._viewScale) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._scrollPosition) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._previousViewScale) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._scrollPositionIsUnscaled) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._previousScrollPosition) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._scrollPositionValid) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._previousScrollPositionValid) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._visibleSize) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._previousVisibleSize) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._deviceIdiom) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._selectionPath) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._selectionPathTransformer) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._viewScale {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._scrollPosition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._previousViewScale {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._scrollPositionIsUnscaled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._previousScrollPosition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._scrollPositionValid {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._previousScrollPositionValid {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._visibleSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._previousVisibleSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._deviceIdiom {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._selectionPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._selectionPathTransformer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_SheetUIStateArchive, rhs: TN_SheetUIStateArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._viewScale != rhs_storage._viewScale {return false}
        if _storage._scrollPosition != rhs_storage._scrollPosition {return false}
        if _storage._previousViewScale != rhs_storage._previousViewScale {return false}
        if _storage._scrollPositionIsUnscaled != rhs_storage._scrollPositionIsUnscaled {return false}
        if _storage._previousScrollPosition != rhs_storage._previousScrollPosition {return false}
        if _storage._scrollPositionValid != rhs_storage._scrollPositionValid {return false}
        if _storage._previousScrollPositionValid != rhs_storage._previousScrollPositionValid {return false}
        if _storage._visibleSize != rhs_storage._visibleSize {return false}
        if _storage._previousVisibleSize != rhs_storage._previousVisibleSize {return false}
        if _storage._deviceIdiom != rhs_storage._deviceIdiom {return false}
        if _storage._selectionPath != rhs_storage._selectionPath {return false}
        if _storage._selectionPathTransformer != rhs_storage._selectionPathTransformer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_SheetUIStateDictionaryEntryArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SheetUIStateDictionaryEntryArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}sheet\0\u{3}sheet_uistate\0")

  public var isInitialized: Bool {
    if self._sheet == nil {return false}
    if self._sheetUistate == nil {return false}
    if let v = self._sheet, !v.isInitialized {return false}
    if let v = self._sheetUistate, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sheet) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sheetUistate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sheet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sheetUistate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_SheetUIStateDictionaryEntryArchive, rhs: TN_SheetUIStateDictionaryEntryArchive) -> Bool {
    if lhs._sheet != rhs._sheet {return false}
    if lhs._sheetUistate != rhs._sheetUistate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_UUIDSheetUIStateDictionaryArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UUIDSheetUIStateDictionaryArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}sheet_uuid\0\u{3}sheet_uistate\0")

  public var isInitialized: Bool {
    if self._sheetUuid == nil {return false}
    if self._sheetUistate == nil {return false}
    if let v = self._sheetUuid, !v.isInitialized {return false}
    if let v = self._sheetUistate, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sheetUuid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sheetUistate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sheetUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sheetUistate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_UUIDSheetUIStateDictionaryArchive, rhs: TN_UUIDSheetUIStateDictionaryArchive) -> Bool {
    if lhs._sheetUuid != rhs._sheetUuid {return false}
    if lhs._sheetUistate != rhs._sheetUistate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_UIStateArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIStateArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}active_sheet_index\0\u{3}selected_info\0\u{3}sheet_uistate_dictionary_entry\0\u{3}table_selection\0\u{3}editing_sheet_index\0\u{3}document_mode\0\u{3}edit_mode_sheet_uistate_dictionary_entry\0\u{3}table_editing_mode\0\u{3}form_focused_record_index\0\u{3}form_focused_field_index\0\u{3}in_chart_mode\0\u{3}chart_selection\0\u{3}sheet_selection\0\u{3}inspector_pane_visible\0\u{3}inspector_pane_view_mode\0\u{3}selected_quick_calc_functions\0\u{3}removed_all_quick_calc_functions\0\u{3}show_canvas_guides\0\u{3}shows_comments\0\u{3}desktop_window_origin\0\u{3}desktop_window_size\0\u{3}desktop_screen_size\0\u{3}chart_ui_state\0\u{3}selection_path\0\u{3}inspector_pane_autohidden\0\u{3}shows_sidebar\0\u{3}shows_rulers\0\u{3}uuid_sheet_uistate_dictionary\0\u{3}freehand_drawing_toolkit_state\0\u{3}selection_path_transformer\0\u{3}editing_disabled\0\u{3}sidebar_visible\0\u{3}sidebar_width\0")

  fileprivate class _StorageClass {
    var _activeSheetIndex: UInt32? = nil
    var _selectedInfo: [TSP_Reference] = []
    var _sheetUistateDictionaryEntry: [TN_SheetUIStateDictionaryEntryArchive] = []
    var _tableSelection: TST_SelectionArchive? = nil
    var _editingSheetIndex: UInt32? = nil
    var _documentMode: Int32? = nil
    var _editModeSheetUistateDictionaryEntry: [TN_SheetUIStateDictionaryEntryArchive] = []
    var _tableEditingMode: Int32? = nil
    var _formFocusedRecordIndex: UInt32? = nil
    var _formFocusedFieldIndex: UInt32? = nil
    var _inChartMode: Bool? = nil
    var _chartSelection: TN_ChartSelectionArchive? = nil
    var _sheetSelection: TSP_Reference? = nil
    var _inspectorPaneVisible: Bool? = nil
    var _inspectorPaneViewMode: TN_UIStateArchive.InspectorPaneViewMode? = nil
    var _selectedQuickCalcFunctions: [UInt32] = []
    var _removedAllQuickCalcFunctions: Bool? = nil
    var _showCanvasGuides: Bool? = nil
    var _showsComments: Bool? = nil
    var _desktopWindowOrigin: TSP_Point? = nil
    var _desktopWindowSize: TSP_Size? = nil
    var _desktopScreenSize: TSP_Size? = nil
    var _chartUiState: [TSCH_ChartUIState] = []
    var _selectionPath: TSK_SelectionPathArchive? = nil
    var _inspectorPaneAutohidden: Bool? = nil
    var _showsSidebar: Bool? = nil
    var _showsRulers: Bool? = nil
    var _uuidSheetUistateDictionary: [TN_UUIDSheetUIStateDictionaryArchive] = []
    var _freehandDrawingToolkitState: TSP_Reference? = nil
    var _selectionPathTransformer: TSP_Reference? = nil
    var _editingDisabled: Bool? = nil
    var _sidebarVisible: Bool? = nil
    var _sidebarWidth: Float? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _activeSheetIndex = source._activeSheetIndex
      _selectedInfo = source._selectedInfo
      _sheetUistateDictionaryEntry = source._sheetUistateDictionaryEntry
      _tableSelection = source._tableSelection
      _editingSheetIndex = source._editingSheetIndex
      _documentMode = source._documentMode
      _editModeSheetUistateDictionaryEntry = source._editModeSheetUistateDictionaryEntry
      _tableEditingMode = source._tableEditingMode
      _formFocusedRecordIndex = source._formFocusedRecordIndex
      _formFocusedFieldIndex = source._formFocusedFieldIndex
      _inChartMode = source._inChartMode
      _chartSelection = source._chartSelection
      _sheetSelection = source._sheetSelection
      _inspectorPaneVisible = source._inspectorPaneVisible
      _inspectorPaneViewMode = source._inspectorPaneViewMode
      _selectedQuickCalcFunctions = source._selectedQuickCalcFunctions
      _removedAllQuickCalcFunctions = source._removedAllQuickCalcFunctions
      _showCanvasGuides = source._showCanvasGuides
      _showsComments = source._showsComments
      _desktopWindowOrigin = source._desktopWindowOrigin
      _desktopWindowSize = source._desktopWindowSize
      _desktopScreenSize = source._desktopScreenSize
      _chartUiState = source._chartUiState
      _selectionPath = source._selectionPath
      _inspectorPaneAutohidden = source._inspectorPaneAutohidden
      _showsSidebar = source._showsSidebar
      _showsRulers = source._showsRulers
      _uuidSheetUistateDictionary = source._uuidSheetUistateDictionary
      _freehandDrawingToolkitState = source._freehandDrawingToolkitState
      _selectionPathTransformer = source._selectionPathTransformer
      _editingDisabled = source._editingDisabled
      _sidebarVisible = source._sidebarVisible
      _sidebarWidth = source._sidebarWidth
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._activeSheetIndex == nil {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._selectedInfo) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._sheetUistateDictionaryEntry) {return false}
      if let v = _storage._tableSelection, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._editModeSheetUistateDictionaryEntry) {return false}
      if let v = _storage._chartSelection, !v.isInitialized {return false}
      if let v = _storage._sheetSelection, !v.isInitialized {return false}
      if let v = _storage._desktopWindowOrigin, !v.isInitialized {return false}
      if let v = _storage._desktopWindowSize, !v.isInitialized {return false}
      if let v = _storage._desktopScreenSize, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._chartUiState) {return false}
      if let v = _storage._selectionPath, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._uuidSheetUistateDictionary) {return false}
      if let v = _storage._freehandDrawingToolkitState, !v.isInitialized {return false}
      if let v = _storage._selectionPathTransformer, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._activeSheetIndex) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._selectedInfo) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._sheetUistateDictionaryEntry) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._tableSelection) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._editingSheetIndex) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._documentMode) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._editModeSheetUistateDictionaryEntry) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._tableEditingMode) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._formFocusedRecordIndex) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._formFocusedFieldIndex) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._inChartMode) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._chartSelection) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._sheetSelection) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._inspectorPaneVisible) }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._inspectorPaneViewMode) }()
        case 16: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._selectedQuickCalcFunctions) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._removedAllQuickCalcFunctions) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._showCanvasGuides) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._showsComments) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._desktopWindowOrigin) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._desktopWindowSize) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._desktopScreenSize) }()
        case 23: try { try decoder.decodeRepeatedMessageField(value: &_storage._chartUiState) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._selectionPath) }()
        case 25: try { try decoder.decodeSingularBoolField(value: &_storage._inspectorPaneAutohidden) }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._showsSidebar) }()
        case 27: try { try decoder.decodeSingularBoolField(value: &_storage._showsRulers) }()
        case 28: try { try decoder.decodeRepeatedMessageField(value: &_storage._uuidSheetUistateDictionary) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._freehandDrawingToolkitState) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._selectionPathTransformer) }()
        case 31: try { try decoder.decodeSingularBoolField(value: &_storage._editingDisabled) }()
        case 32: try { try decoder.decodeSingularBoolField(value: &_storage._sidebarVisible) }()
        case 33: try { try decoder.decodeSingularFloatField(value: &_storage._sidebarWidth) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._activeSheetIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
      } }()
      if !_storage._selectedInfo.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._selectedInfo, fieldNumber: 2)
      }
      if !_storage._sheetUistateDictionaryEntry.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sheetUistateDictionaryEntry, fieldNumber: 3)
      }
      try { if let v = _storage._tableSelection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._editingSheetIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._documentMode {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
      } }()
      if !_storage._editModeSheetUistateDictionaryEntry.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._editModeSheetUistateDictionaryEntry, fieldNumber: 7)
      }
      try { if let v = _storage._tableEditingMode {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._formFocusedRecordIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._formFocusedFieldIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._inChartMode {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._chartSelection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._sheetSelection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._inspectorPaneVisible {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._inspectorPaneViewMode {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 15)
      } }()
      if !_storage._selectedQuickCalcFunctions.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._selectedQuickCalcFunctions, fieldNumber: 16)
      }
      try { if let v = _storage._removedAllQuickCalcFunctions {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._showCanvasGuides {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._showsComments {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._desktopWindowOrigin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._desktopWindowSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._desktopScreenSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      if !_storage._chartUiState.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chartUiState, fieldNumber: 23)
      }
      try { if let v = _storage._selectionPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._inspectorPaneAutohidden {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._showsSidebar {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._showsRulers {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 27)
      } }()
      if !_storage._uuidSheetUistateDictionary.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._uuidSheetUistateDictionary, fieldNumber: 28)
      }
      try { if let v = _storage._freehandDrawingToolkitState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._selectionPathTransformer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._editingDisabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._sidebarVisible {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._sidebarWidth {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 33)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_UIStateArchive, rhs: TN_UIStateArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._activeSheetIndex != rhs_storage._activeSheetIndex {return false}
        if _storage._selectedInfo != rhs_storage._selectedInfo {return false}
        if _storage._sheetUistateDictionaryEntry != rhs_storage._sheetUistateDictionaryEntry {return false}
        if _storage._tableSelection != rhs_storage._tableSelection {return false}
        if _storage._editingSheetIndex != rhs_storage._editingSheetIndex {return false}
        if _storage._documentMode != rhs_storage._documentMode {return false}
        if _storage._editModeSheetUistateDictionaryEntry != rhs_storage._editModeSheetUistateDictionaryEntry {return false}
        if _storage._tableEditingMode != rhs_storage._tableEditingMode {return false}
        if _storage._formFocusedRecordIndex != rhs_storage._formFocusedRecordIndex {return false}
        if _storage._formFocusedFieldIndex != rhs_storage._formFocusedFieldIndex {return false}
        if _storage._inChartMode != rhs_storage._inChartMode {return false}
        if _storage._chartSelection != rhs_storage._chartSelection {return false}
        if _storage._sheetSelection != rhs_storage._sheetSelection {return false}
        if _storage._inspectorPaneVisible != rhs_storage._inspectorPaneVisible {return false}
        if _storage._inspectorPaneViewMode != rhs_storage._inspectorPaneViewMode {return false}
        if _storage._selectedQuickCalcFunctions != rhs_storage._selectedQuickCalcFunctions {return false}
        if _storage._removedAllQuickCalcFunctions != rhs_storage._removedAllQuickCalcFunctions {return false}
        if _storage._showCanvasGuides != rhs_storage._showCanvasGuides {return false}
        if _storage._showsComments != rhs_storage._showsComments {return false}
        if _storage._desktopWindowOrigin != rhs_storage._desktopWindowOrigin {return false}
        if _storage._desktopWindowSize != rhs_storage._desktopWindowSize {return false}
        if _storage._desktopScreenSize != rhs_storage._desktopScreenSize {return false}
        if _storage._chartUiState != rhs_storage._chartUiState {return false}
        if _storage._selectionPath != rhs_storage._selectionPath {return false}
        if _storage._inspectorPaneAutohidden != rhs_storage._inspectorPaneAutohidden {return false}
        if _storage._showsSidebar != rhs_storage._showsSidebar {return false}
        if _storage._showsRulers != rhs_storage._showsRulers {return false}
        if _storage._uuidSheetUistateDictionary != rhs_storage._uuidSheetUistateDictionary {return false}
        if _storage._freehandDrawingToolkitState != rhs_storage._freehandDrawingToolkitState {return false}
        if _storage._selectionPathTransformer != rhs_storage._selectionPathTransformer {return false}
        if _storage._editingDisabled != rhs_storage._editingDisabled {return false}
        if _storage._sidebarVisible != rhs_storage._sidebarVisible {return false}
        if _storage._sidebarWidth != rhs_storage._sidebarWidth {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_UIStateArchive.InspectorPaneViewMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kInspectorPaneViewModeFormat\0\u{1}kInspectorPaneViewModeFilter\0")
}

extension TN_SheetSelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SheetSelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}sheet\0\u{1}paginated\0")

  public var isInitialized: Bool {
    if let v = self._sheet, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sheet) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._paginated) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sheet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._paginated {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_SheetSelectionArchive, rhs: TN_SheetSelectionArchive) -> Bool {
    if lhs._sheet != rhs._sheet {return false}
    if lhs._paginated != rhs._paginated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_FormSelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormSelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}record_index\0\u{3}field_index\0")

  public var isInitialized: Bool {
    if self._recordIndex == nil {return false}
    if self._fieldIndex == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._recordIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._fieldIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._recordIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fieldIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_FormSelectionArchive, rhs: TN_FormSelectionArchive) -> Bool {
    if lhs._recordIndex != rhs._recordIndex {return false}
    if lhs._fieldIndex != rhs._fieldIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_FormBuilderSelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormBuilderSelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}viewing_record_index\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._viewingRecordIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._viewingRecordIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_FormBuilderSelectionArchive, rhs: TN_FormBuilderSelectionArchive) -> Bool {
    if lhs._viewingRecordIndex != rhs._viewingRecordIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_FormTableChooserSelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormTableChooserSelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_FormTableChooserSelectionArchive, rhs: TN_FormTableChooserSelectionArchive) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_UndoRedoStateArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UndoRedoStateArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}ui_state\0")

  public var isInitialized: Bool {
    if self._uiState == nil {return false}
    if let v = self._uiState, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uiState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uiState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_UndoRedoStateArchive, rhs: TN_UndoRedoStateArchive) -> Bool {
    if lhs._uiState != rhs._uiState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_DocumentArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}sheets\0\u{4}\u{2}calculation_engine\0\u{1}stylesheet\0\u{3}sidebar_order\0\u{1}theme\0\u{1}uistate\0\u{1}super\0\u{3}custom_format_list\0\u{3}printer_id\0\u{3}paper_id\0\u{3}page_size\0")

  fileprivate class _StorageClass {
    var _sheets: [TSP_Reference] = []
    var _super: TSA_DocumentArchive? = nil
    var _calculationEngine: TSP_Reference? = nil
    var _stylesheet: TSP_Reference? = nil
    var _sidebarOrder: TSP_Reference? = nil
    var _theme: TSP_Reference? = nil
    var _uistate: TN_UIStateArchive? = nil
    var _customFormatList: TSP_Reference? = nil
    var _printerID: String? = nil
    var _paperID: String? = nil
    var _pageSize: TSP_Size? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sheets = source._sheets
      _super = source._super
      _calculationEngine = source._calculationEngine
      _stylesheet = source._stylesheet
      _sidebarOrder = source._sidebarOrder
      _theme = source._theme
      _uistate = source._uistate
      _customFormatList = source._customFormatList
      _printerID = source._printerID
      _paperID = source._paperID
      _pageSize = source._pageSize
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._stylesheet == nil {return false}
      if _storage._sidebarOrder == nil {return false}
      if _storage._theme == nil {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._sheets) {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._calculationEngine, !v.isInitialized {return false}
      if let v = _storage._stylesheet, !v.isInitialized {return false}
      if let v = _storage._sidebarOrder, !v.isInitialized {return false}
      if let v = _storage._theme, !v.isInitialized {return false}
      if let v = _storage._uistate, !v.isInitialized {return false}
      if let v = _storage._customFormatList, !v.isInitialized {return false}
      if let v = _storage._pageSize, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._sheets) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._calculationEngine) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._stylesheet) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._sidebarOrder) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._theme) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._uistate) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._customFormatList) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._printerID) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._paperID) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._pageSize) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._sheets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sheets, fieldNumber: 1)
      }
      try { if let v = _storage._calculationEngine {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._stylesheet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._sidebarOrder {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._theme {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._uistate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._customFormatList {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._printerID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._paperID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._pageSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_DocumentArchive, rhs: TN_DocumentArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sheets != rhs_storage._sheets {return false}
        if _storage._super != rhs_storage._super {return false}
        if _storage._calculationEngine != rhs_storage._calculationEngine {return false}
        if _storage._stylesheet != rhs_storage._stylesheet {return false}
        if _storage._sidebarOrder != rhs_storage._sidebarOrder {return false}
        if _storage._theme != rhs_storage._theme {return false}
        if _storage._uistate != rhs_storage._uistate {return false}
        if _storage._customFormatList != rhs_storage._customFormatList {return false}
        if _storage._printerID != rhs_storage._printerID {return false}
        if _storage._paperID != rhs_storage._paperID {return false}
        if _storage._pageSize != rhs_storage._pageSize {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_PlaceholderArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlaceholderArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_PlaceholderArchive, rhs: TN_PlaceholderArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_SheetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SheetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}drawable_infos\0\u{3}in_portrait_page_orientation\0\u{3}show_repeating_headers\0\u{3}show_page_numbers\0\u{3}is_autofit_on\0\u{3}content_scale\0\u{3}page_order\0\u{4}\u{2}print_margins\0\u{3}using_start_page_number\0\u{3}start_page_number\0\u{3}page_header_inset\0\u{3}page_footer_inset\0\u{3}header_storage\0\u{3}footer_storage\0\u{1}userDefinedGuideStorage\0\u{1}headers\0\u{1}footers\0\u{3}uses_single_header_footer\0\u{3}layout_direction\0\u{1}style\0\u{3}print_backgrounds\0\u{3}should_print_comments\0")

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _drawableInfos: [TSP_Reference] = []
    var _inPortraitPageOrientation: Bool? = nil
    var _showRepeatingHeaders: Bool? = nil
    var _showPageNumbers: Bool? = nil
    var _isAutofitOn: Bool? = nil
    var _contentScale: Float? = nil
    var _pageOrder: TN_PageOrder? = nil
    var _printMargins: TSD_EdgeInsetsArchive? = nil
    var _usingStartPageNumber: Bool? = nil
    var _startPageNumber: Int32? = nil
    var _pageHeaderInset: Float? = nil
    var _pageFooterInset: Float? = nil
    var _headerStorage: TSP_Reference? = nil
    var _footerStorage: TSP_Reference? = nil
    var _userDefinedGuideStorage: TSP_Reference? = nil
    var _headers: [TSP_Reference] = []
    var _footers: [TSP_Reference] = []
    var _usesSingleHeaderFooter: Bool? = nil
    var _layoutDirection: TN_PageLayoutDirection? = nil
    var _style: TSP_Reference? = nil
    var _printBackgrounds: Bool? = nil
    var _shouldPrintComments: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _drawableInfos = source._drawableInfos
      _inPortraitPageOrientation = source._inPortraitPageOrientation
      _showRepeatingHeaders = source._showRepeatingHeaders
      _showPageNumbers = source._showPageNumbers
      _isAutofitOn = source._isAutofitOn
      _contentScale = source._contentScale
      _pageOrder = source._pageOrder
      _printMargins = source._printMargins
      _usingStartPageNumber = source._usingStartPageNumber
      _startPageNumber = source._startPageNumber
      _pageHeaderInset = source._pageHeaderInset
      _pageFooterInset = source._pageFooterInset
      _headerStorage = source._headerStorage
      _footerStorage = source._footerStorage
      _userDefinedGuideStorage = source._userDefinedGuideStorage
      _headers = source._headers
      _footers = source._footers
      _usesSingleHeaderFooter = source._usesSingleHeaderFooter
      _layoutDirection = source._layoutDirection
      _style = source._style
      _printBackgrounds = source._printBackgrounds
      _shouldPrintComments = source._shouldPrintComments
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._name == nil {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._drawableInfos) {return false}
      if let v = _storage._printMargins, !v.isInitialized {return false}
      if let v = _storage._headerStorage, !v.isInitialized {return false}
      if let v = _storage._footerStorage, !v.isInitialized {return false}
      if let v = _storage._userDefinedGuideStorage, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._headers) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._footers) {return false}
      if let v = _storage._style, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._drawableInfos) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._inPortraitPageOrientation) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._showRepeatingHeaders) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._showPageNumbers) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._isAutofitOn) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._contentScale) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._pageOrder) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._printMargins) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._usingStartPageNumber) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._startPageNumber) }()
        case 13: try { try decoder.decodeSingularFloatField(value: &_storage._pageHeaderInset) }()
        case 14: try { try decoder.decodeSingularFloatField(value: &_storage._pageFooterInset) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._headerStorage) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._footerStorage) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._userDefinedGuideStorage) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._headers) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._footers) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._usesSingleHeaderFooter) }()
        case 21: try { try decoder.decodeSingularEnumField(value: &_storage._layoutDirection) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._style) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._printBackgrounds) }()
        case 24: try { try decoder.decodeSingularBoolField(value: &_storage._shouldPrintComments) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      if !_storage._drawableInfos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._drawableInfos, fieldNumber: 2)
      }
      try { if let v = _storage._inPortraitPageOrientation {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._showRepeatingHeaders {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._showPageNumbers {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._isAutofitOn {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._contentScale {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._pageOrder {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._printMargins {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._usingStartPageNumber {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._startPageNumber {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._pageHeaderInset {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._pageFooterInset {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._headerStorage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._footerStorage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._userDefinedGuideStorage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._headers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._headers, fieldNumber: 18)
      }
      if !_storage._footers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._footers, fieldNumber: 19)
      }
      try { if let v = _storage._usesSingleHeaderFooter {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._layoutDirection {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._printBackgrounds {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._shouldPrintComments {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 24)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_SheetArchive, rhs: TN_SheetArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._drawableInfos != rhs_storage._drawableInfos {return false}
        if _storage._inPortraitPageOrientation != rhs_storage._inPortraitPageOrientation {return false}
        if _storage._showRepeatingHeaders != rhs_storage._showRepeatingHeaders {return false}
        if _storage._showPageNumbers != rhs_storage._showPageNumbers {return false}
        if _storage._isAutofitOn != rhs_storage._isAutofitOn {return false}
        if _storage._contentScale != rhs_storage._contentScale {return false}
        if _storage._pageOrder != rhs_storage._pageOrder {return false}
        if _storage._printMargins != rhs_storage._printMargins {return false}
        if _storage._usingStartPageNumber != rhs_storage._usingStartPageNumber {return false}
        if _storage._startPageNumber != rhs_storage._startPageNumber {return false}
        if _storage._pageHeaderInset != rhs_storage._pageHeaderInset {return false}
        if _storage._pageFooterInset != rhs_storage._pageFooterInset {return false}
        if _storage._headerStorage != rhs_storage._headerStorage {return false}
        if _storage._footerStorage != rhs_storage._footerStorage {return false}
        if _storage._userDefinedGuideStorage != rhs_storage._userDefinedGuideStorage {return false}
        if _storage._headers != rhs_storage._headers {return false}
        if _storage._footers != rhs_storage._footers {return false}
        if _storage._usesSingleHeaderFooter != rhs_storage._usesSingleHeaderFooter {return false}
        if _storage._layoutDirection != rhs_storage._layoutDirection {return false}
        if _storage._style != rhs_storage._style {return false}
        if _storage._printBackgrounds != rhs_storage._printBackgrounds {return false}
        if _storage._shouldPrintComments != rhs_storage._shouldPrintComments {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_SheetStylePropertiesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SheetStylePropertiesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}fill\0")

  public var isInitialized: Bool {
    if let v = self._fill, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fill) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fill {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_SheetStylePropertiesArchive, rhs: TN_SheetStylePropertiesArchive) -> Bool {
    if lhs._fill != rhs._fill {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_SheetStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SheetStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}override_count\0\u{3}sheet_properties\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._sheetProperties, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._overrideCount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._sheetProperties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._overrideCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sheetProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_SheetStyleArchive, rhs: TN_SheetStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._overrideCount != rhs._overrideCount {return false}
    if lhs._sheetProperties != rhs._sheetProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_FormBasedSheetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormBasedSheetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}table_id\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tableID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tableID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_FormBasedSheetArchive, rhs: TN_FormBasedSheetArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._tableID != rhs._tableID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_ThemeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThemeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}prototypes\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.prototypes) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.prototypes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.prototypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.prototypes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_ThemeArchive, rhs: TN_ThemeArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.prototypes != rhs.prototypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_PasteboardNativeStorageArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PasteboardNativeStorageArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}sheet\0\u{3}ui_state\0")

  public var isInitialized: Bool {
    if let v = self._sheet, !v.isInitialized {return false}
    if let v = self._uiState, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sheet) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._uiState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sheet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._uiState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_PasteboardNativeStorageArchive, rhs: TN_PasteboardNativeStorageArchive) -> Bool {
    if lhs._sheet != rhs._sheet {return false}
    if lhs._uiState != rhs._uiState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_ChartMediatorFormulaStorage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChartMediatorFormulaStorage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}data_formulae\0\u{4}\u{2}row_label_formulae\0\u{3}col_label_formulae\0\u{1}direction\0\u{3}error_custom_pos_formulae\0\u{3}error_custom_neg_formulae\0\u{3}error_custom_pos_scatterX_formulae\0\u{3}error_custom_neg_scatterX_formulae\0\u{1}scheme\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.dataFormulae) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rowLabelFormulae) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.colLabelFormulae) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.errorCustomPosFormulae) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.errorCustomNegFormulae) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.errorCustomPosScatterXFormulae) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.errorCustomNegScatterXFormulae) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataFormulae) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.rowLabelFormulae) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.colLabelFormulae) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._direction) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.errorCustomPosFormulae) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.errorCustomNegFormulae) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.errorCustomPosScatterXFormulae) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.errorCustomNegScatterXFormulae) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self._scheme) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.dataFormulae.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataFormulae, fieldNumber: 1)
    }
    if !self.rowLabelFormulae.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rowLabelFormulae, fieldNumber: 3)
    }
    if !self.colLabelFormulae.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.colLabelFormulae, fieldNumber: 4)
    }
    try { if let v = self._direction {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    if !self.errorCustomPosFormulae.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errorCustomPosFormulae, fieldNumber: 6)
    }
    if !self.errorCustomNegFormulae.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errorCustomNegFormulae, fieldNumber: 7)
    }
    if !self.errorCustomPosScatterXFormulae.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errorCustomPosScatterXFormulae, fieldNumber: 8)
    }
    if !self.errorCustomNegScatterXFormulae.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errorCustomNegScatterXFormulae, fieldNumber: 9)
    }
    try { if let v = self._scheme {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_ChartMediatorFormulaStorage, rhs: TN_ChartMediatorFormulaStorage) -> Bool {
    if lhs.dataFormulae != rhs.dataFormulae {return false}
    if lhs.rowLabelFormulae != rhs.rowLabelFormulae {return false}
    if lhs.colLabelFormulae != rhs.colLabelFormulae {return false}
    if lhs._direction != rhs._direction {return false}
    if lhs.errorCustomPosFormulae != rhs.errorCustomPosFormulae {return false}
    if lhs.errorCustomNegFormulae != rhs.errorCustomNegFormulae {return false}
    if lhs.errorCustomPosScatterXFormulae != rhs.errorCustomPosScatterXFormulae {return false}
    if lhs.errorCustomNegScatterXFormulae != rhs.errorCustomNegScatterXFormulae {return false}
    if lhs._scheme != rhs._scheme {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_ChartMediatorArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChartMediatorArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}entity_id\0\u{1}formulas\0\u{3}columns_are_series\0\u{3}is_registered_with_calc_engine\0")

  fileprivate class _StorageClass {
    var _super: TSCH_ChartMediatorArchive? = nil
    var _entityID: String? = nil
    var _formulas: TN_ChartMediatorFormulaStorage? = nil
    var _columnsAreSeries: Bool? = nil
    var _isRegisteredWithCalcEngine: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _entityID = source._entityID
      _formulas = source._formulas
      _columnsAreSeries = source._columnsAreSeries
      _isRegisteredWithCalcEngine = source._isRegisteredWithCalcEngine
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._entityID == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._formulas, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._entityID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._formulas) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._columnsAreSeries) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._isRegisteredWithCalcEngine) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._entityID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._formulas {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._columnsAreSeries {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._isRegisteredWithCalcEngine {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_ChartMediatorArchive, rhs: TN_ChartMediatorArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._entityID != rhs_storage._entityID {return false}
        if _storage._formulas != rhs_storage._formulas {return false}
        if _storage._columnsAreSeries != rhs_storage._columnsAreSeries {return false}
        if _storage._isRegisteredWithCalcEngine != rhs_storage._isRegisteredWithCalcEngine {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_ChartSelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChartSelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}reference\0\u{3}deprecated_super\0\u{1}chart\0\u{1}super\0")

  fileprivate class _StorageClass {
    var _reference: TSCE_RangeReferenceArchive? = nil
    var _deprecatedSuper: TSCH_ChartSelectionArchive? = nil
    var _chart: TSP_Reference? = nil
    var _super: TSD_DrawableSelectionArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _reference = source._reference
      _deprecatedSuper = source._deprecatedSuper
      _chart = source._chart
      _super = source._super
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._reference, !v.isInitialized {return false}
      if let v = _storage._deprecatedSuper, !v.isInitialized {return false}
      if let v = _storage._chart, !v.isInitialized {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._reference) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._deprecatedSuper) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._chart) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._reference {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._deprecatedSuper {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._chart {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_ChartSelectionArchive, rhs: TN_ChartSelectionArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._reference != rhs_storage._reference {return false}
        if _storage._deprecatedSuper != rhs_storage._deprecatedSuper {return false}
        if _storage._chart != rhs_storage._chart {return false}
        if _storage._super != rhs_storage._super {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TN_FormCommandActivityBehaviorArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormCommandActivityBehaviorArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TN_FormCommandActivityBehaviorArchive, rhs: TN_FormCommandActivityBehaviorArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
