// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TSWPArchives.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum TSWP_SelectionType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case normalDeprecated = 0
  case listLabel = 1
  case listTopic = 2
  case replace = 3
  case copyPasteStyle = 4
  case replace2 = 5
  case smartField = 6
  case visual = 7
  case logical = 8

  init() {
    self = .normalDeprecated
  }

}

enum TSWP_StyleInsertionBehavior: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case noGrow = 0
  case growLeft = 1
  case growRight = 2

  init() {
    self = .noGrow
  }

}

enum TSWP_CaretAffinity: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case start = 0
  case end = 1

  init() {
    self = .start
  }

}

enum TSWP_WritingDirectionType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case kWritingDirectionNatural = -1
  case kWritingDirectionLeftToRight = 0
  case kWritingDirectionRightToLeft = 1

  init() {
    self = .kWritingDirectionNatural
  }

}

struct TSWP_SelectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// NOTE: This field was marked as deprecated in the .proto file.
  var deprecatedType: TSWP_SelectionType {
    get {return _deprecatedType ?? .normalDeprecated}
    set {_deprecatedType = newValue}
  }
  /// Returns true if `deprecatedType` has been explicitly set.
  var hasDeprecatedType: Bool {return self._deprecatedType != nil}
  /// Clears the value of `deprecatedType`. Subsequent reads from it will return its default value.
  mutating func clearDeprecatedType() {self._deprecatedType = nil}

  var visualDefinitionRange: TSP_Range {
    get {return _visualDefinitionRange ?? TSP_Range()}
    set {_visualDefinitionRange = newValue}
  }
  /// Returns true if `visualDefinitionRange` has been explicitly set.
  var hasVisualDefinitionRange: Bool {return self._visualDefinitionRange != nil}
  /// Clears the value of `visualDefinitionRange`. Subsequent reads from it will return its default value.
  mutating func clearVisualDefinitionRange() {self._visualDefinitionRange = nil}

  var styleInsertionBehavior: TSWP_StyleInsertionBehavior {
    get {return _styleInsertionBehavior ?? .noGrow}
    set {_styleInsertionBehavior = newValue}
  }
  /// Returns true if `styleInsertionBehavior` has been explicitly set.
  var hasStyleInsertionBehavior: Bool {return self._styleInsertionBehavior != nil}
  /// Clears the value of `styleInsertionBehavior`. Subsequent reads from it will return its default value.
  mutating func clearStyleInsertionBehavior() {self._styleInsertionBehavior = nil}

  var caretAffinity: TSWP_CaretAffinity {
    get {return _caretAffinity ?? .start}
    set {_caretAffinity = newValue}
  }
  /// Returns true if `caretAffinity` has been explicitly set.
  var hasCaretAffinity: Bool {return self._caretAffinity != nil}
  /// Clears the value of `caretAffinity`. Subsequent reads from it will return its default value.
  mutating func clearCaretAffinity() {self._caretAffinity = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var smartFieldRange: TSP_Range {
    get {return _smartFieldRange ?? TSP_Range()}
    set {_smartFieldRange = newValue}
  }
  /// Returns true if `smartFieldRange` has been explicitly set.
  var hasSmartFieldRange: Bool {return self._smartFieldRange != nil}
  /// Clears the value of `smartFieldRange`. Subsequent reads from it will return its default value.
  mutating func clearSmartFieldRange() {self._smartFieldRange = nil}

  var leadingEdge: Bool {
    get {return _leadingEdge ?? false}
    set {_leadingEdge = newValue}
  }
  /// Returns true if `leadingEdge` has been explicitly set.
  var hasLeadingEdge: Bool {return self._leadingEdge != nil}
  /// Clears the value of `leadingEdge`. Subsequent reads from it will return its default value.
  mutating func clearLeadingEdge() {self._leadingEdge = nil}

  var leadingCharIndex: UInt32 {
    get {return _leadingCharIndex ?? 0}
    set {_leadingCharIndex = newValue}
  }
  /// Returns true if `leadingCharIndex` has been explicitly set.
  var hasLeadingCharIndex: Bool {return self._leadingCharIndex != nil}
  /// Clears the value of `leadingCharIndex`. Subsequent reads from it will return its default value.
  mutating func clearLeadingCharIndex() {self._leadingCharIndex = nil}

  var type: TSWP_SelectionType {
    get {return _type ?? .normalDeprecated}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var ranges: [TSP_Range] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _deprecatedType: TSWP_SelectionType? = nil
  fileprivate var _visualDefinitionRange: TSP_Range? = nil
  fileprivate var _styleInsertionBehavior: TSWP_StyleInsertionBehavior? = nil
  fileprivate var _caretAffinity: TSWP_CaretAffinity? = nil
  fileprivate var _smartFieldRange: TSP_Range? = nil
  fileprivate var _leadingEdge: Bool? = nil
  fileprivate var _leadingCharIndex: UInt32? = nil
  fileprivate var _type: TSWP_SelectionType? = nil
}

struct TSWP_ObjectAttributeTable: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [TSWP_ObjectAttributeTable.ObjectAttribute] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ObjectAttribute: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var characterIndex: UInt32 {
      get {return _characterIndex ?? 0}
      set {_characterIndex = newValue}
    }
    /// Returns true if `characterIndex` has been explicitly set.
    var hasCharacterIndex: Bool {return self._characterIndex != nil}
    /// Clears the value of `characterIndex`. Subsequent reads from it will return its default value.
    mutating func clearCharacterIndex() {self._characterIndex = nil}

    var object: TSP_Reference {
      get {return _object ?? TSP_Reference()}
      set {_object = newValue}
    }
    /// Returns true if `object` has been explicitly set.
    var hasObject: Bool {return self._object != nil}
    /// Clears the value of `object`. Subsequent reads from it will return its default value.
    mutating func clearObject() {self._object = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _characterIndex: UInt32? = nil
    fileprivate var _object: TSP_Reference? = nil
  }

  init() {}
}

struct TSWP_StringAttributeTable: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [TSWP_StringAttributeTable.StringAttribute] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct StringAttribute: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var characterIndex: UInt32 {
      get {return _characterIndex ?? 0}
      set {_characterIndex = newValue}
    }
    /// Returns true if `characterIndex` has been explicitly set.
    var hasCharacterIndex: Bool {return self._characterIndex != nil}
    /// Clears the value of `characterIndex`. Subsequent reads from it will return its default value.
    mutating func clearCharacterIndex() {self._characterIndex = nil}

    var object: String {
      get {return _object ?? String()}
      set {_object = newValue}
    }
    /// Returns true if `object` has been explicitly set.
    var hasObject: Bool {return self._object != nil}
    /// Clears the value of `object`. Subsequent reads from it will return its default value.
    mutating func clearObject() {self._object = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _characterIndex: UInt32? = nil
    fileprivate var _object: String? = nil
  }

  init() {}
}

struct TSWP_ParaDataAttributeTable: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [TSWP_ParaDataAttributeTable.ParaDataAttribute] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ParaDataAttribute: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var characterIndex: UInt32 {
      get {return _characterIndex ?? 0}
      set {_characterIndex = newValue}
    }
    /// Returns true if `characterIndex` has been explicitly set.
    var hasCharacterIndex: Bool {return self._characterIndex != nil}
    /// Clears the value of `characterIndex`. Subsequent reads from it will return its default value.
    mutating func clearCharacterIndex() {self._characterIndex = nil}

    var first: UInt32 {
      get {return _first ?? 0}
      set {_first = newValue}
    }
    /// Returns true if `first` has been explicitly set.
    var hasFirst: Bool {return self._first != nil}
    /// Clears the value of `first`. Subsequent reads from it will return its default value.
    mutating func clearFirst() {self._first = nil}

    var second: UInt32 {
      get {return _second ?? 0}
      set {_second = newValue}
    }
    /// Returns true if `second` has been explicitly set.
    var hasSecond: Bool {return self._second != nil}
    /// Clears the value of `second`. Subsequent reads from it will return its default value.
    mutating func clearSecond() {self._second = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _characterIndex: UInt32? = nil
    fileprivate var _first: UInt32? = nil
    fileprivate var _second: UInt32? = nil
  }

  init() {}
}

struct TSWP_OverlappingFieldAttributeTable: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [TSWP_OverlappingFieldAttributeTable.OverlappingFieldAttribute] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct OverlappingFieldAttribute: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var range: TSP_Range {
      get {return _range ?? TSP_Range()}
      set {_range = newValue}
    }
    /// Returns true if `range` has been explicitly set.
    var hasRange: Bool {return self._range != nil}
    /// Clears the value of `range`. Subsequent reads from it will return its default value.
    mutating func clearRange() {self._range = nil}

    var field: TSP_Reference {
      get {return _field ?? TSP_Reference()}
      set {_field = newValue}
    }
    /// Returns true if `field` has been explicitly set.
    var hasField: Bool {return self._field != nil}
    /// Clears the value of `field`. Subsequent reads from it will return its default value.
    mutating func clearField() {self._field = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _range: TSP_Range? = nil
    fileprivate var _field: TSP_Reference? = nil
  }

  init() {}
}

struct TSWP_StorageArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: TSWP_StorageArchive.KindType {
    get {return _storage._kind ?? .textbox}
    set {_uniqueStorage()._kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return _storage._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {_uniqueStorage()._kind = nil}

  var styleSheet: TSP_Reference {
    get {return _storage._styleSheet ?? TSP_Reference()}
    set {_uniqueStorage()._styleSheet = newValue}
  }
  /// Returns true if `styleSheet` has been explicitly set.
  var hasStyleSheet: Bool {return _storage._styleSheet != nil}
  /// Clears the value of `styleSheet`. Subsequent reads from it will return its default value.
  mutating func clearStyleSheet() {_uniqueStorage()._styleSheet = nil}

  var text: [String] {
    get {return _storage._text}
    set {_uniqueStorage()._text = newValue}
  }

  var hasItext_p: Bool {
    get {return _storage._hasItext_p ?? false}
    set {_uniqueStorage()._hasItext_p = newValue}
  }
  /// Returns true if `hasItext_p` has been explicitly set.
  var hasHasItext_p: Bool {return _storage._hasItext_p != nil}
  /// Clears the value of `hasItext_p`. Subsequent reads from it will return its default value.
  mutating func clearHasItext_p() {_uniqueStorage()._hasItext_p = nil}

  var inDocument: Bool {
    get {return _storage._inDocument ?? false}
    set {_uniqueStorage()._inDocument = newValue}
  }
  /// Returns true if `inDocument` has been explicitly set.
  var hasInDocument: Bool {return _storage._inDocument != nil}
  /// Clears the value of `inDocument`. Subsequent reads from it will return its default value.
  mutating func clearInDocument() {_uniqueStorage()._inDocument = nil}

  var tableParaStyle: TSWP_ObjectAttributeTable {
    get {return _storage._tableParaStyle ?? TSWP_ObjectAttributeTable()}
    set {_uniqueStorage()._tableParaStyle = newValue}
  }
  /// Returns true if `tableParaStyle` has been explicitly set.
  var hasTableParaStyle: Bool {return _storage._tableParaStyle != nil}
  /// Clears the value of `tableParaStyle`. Subsequent reads from it will return its default value.
  mutating func clearTableParaStyle() {_uniqueStorage()._tableParaStyle = nil}

  var tableParaData: TSWP_ParaDataAttributeTable {
    get {return _storage._tableParaData ?? TSWP_ParaDataAttributeTable()}
    set {_uniqueStorage()._tableParaData = newValue}
  }
  /// Returns true if `tableParaData` has been explicitly set.
  var hasTableParaData: Bool {return _storage._tableParaData != nil}
  /// Clears the value of `tableParaData`. Subsequent reads from it will return its default value.
  mutating func clearTableParaData() {_uniqueStorage()._tableParaData = nil}

  var tableListStyle: TSWP_ObjectAttributeTable {
    get {return _storage._tableListStyle ?? TSWP_ObjectAttributeTable()}
    set {_uniqueStorage()._tableListStyle = newValue}
  }
  /// Returns true if `tableListStyle` has been explicitly set.
  var hasTableListStyle: Bool {return _storage._tableListStyle != nil}
  /// Clears the value of `tableListStyle`. Subsequent reads from it will return its default value.
  mutating func clearTableListStyle() {_uniqueStorage()._tableListStyle = nil}

  var tableCharStyle: TSWP_ObjectAttributeTable {
    get {return _storage._tableCharStyle ?? TSWP_ObjectAttributeTable()}
    set {_uniqueStorage()._tableCharStyle = newValue}
  }
  /// Returns true if `tableCharStyle` has been explicitly set.
  var hasTableCharStyle: Bool {return _storage._tableCharStyle != nil}
  /// Clears the value of `tableCharStyle`. Subsequent reads from it will return its default value.
  mutating func clearTableCharStyle() {_uniqueStorage()._tableCharStyle = nil}

  var tableAttachment: TSWP_ObjectAttributeTable {
    get {return _storage._tableAttachment ?? TSWP_ObjectAttributeTable()}
    set {_uniqueStorage()._tableAttachment = newValue}
  }
  /// Returns true if `tableAttachment` has been explicitly set.
  var hasTableAttachment: Bool {return _storage._tableAttachment != nil}
  /// Clears the value of `tableAttachment`. Subsequent reads from it will return its default value.
  mutating func clearTableAttachment() {_uniqueStorage()._tableAttachment = nil}

  var tableSmartfield: TSWP_ObjectAttributeTable {
    get {return _storage._tableSmartfield ?? TSWP_ObjectAttributeTable()}
    set {_uniqueStorage()._tableSmartfield = newValue}
  }
  /// Returns true if `tableSmartfield` has been explicitly set.
  var hasTableSmartfield: Bool {return _storage._tableSmartfield != nil}
  /// Clears the value of `tableSmartfield`. Subsequent reads from it will return its default value.
  mutating func clearTableSmartfield() {_uniqueStorage()._tableSmartfield = nil}

  var tableLayoutStyle: TSWP_ObjectAttributeTable {
    get {return _storage._tableLayoutStyle ?? TSWP_ObjectAttributeTable()}
    set {_uniqueStorage()._tableLayoutStyle = newValue}
  }
  /// Returns true if `tableLayoutStyle` has been explicitly set.
  var hasTableLayoutStyle: Bool {return _storage._tableLayoutStyle != nil}
  /// Clears the value of `tableLayoutStyle`. Subsequent reads from it will return its default value.
  mutating func clearTableLayoutStyle() {_uniqueStorage()._tableLayoutStyle = nil}

  var tableParaStarts: TSWP_ParaDataAttributeTable {
    get {return _storage._tableParaStarts ?? TSWP_ParaDataAttributeTable()}
    set {_uniqueStorage()._tableParaStarts = newValue}
  }
  /// Returns true if `tableParaStarts` has been explicitly set.
  var hasTableParaStarts: Bool {return _storage._tableParaStarts != nil}
  /// Clears the value of `tableParaStarts`. Subsequent reads from it will return its default value.
  mutating func clearTableParaStarts() {_uniqueStorage()._tableParaStarts = nil}

  var tableBookmark: TSWP_ObjectAttributeTable {
    get {return _storage._tableBookmark ?? TSWP_ObjectAttributeTable()}
    set {_uniqueStorage()._tableBookmark = newValue}
  }
  /// Returns true if `tableBookmark` has been explicitly set.
  var hasTableBookmark: Bool {return _storage._tableBookmark != nil}
  /// Clears the value of `tableBookmark`. Subsequent reads from it will return its default value.
  mutating func clearTableBookmark() {_uniqueStorage()._tableBookmark = nil}

  var tableFootnote: TSWP_ObjectAttributeTable {
    get {return _storage._tableFootnote ?? TSWP_ObjectAttributeTable()}
    set {_uniqueStorage()._tableFootnote = newValue}
  }
  /// Returns true if `tableFootnote` has been explicitly set.
  var hasTableFootnote: Bool {return _storage._tableFootnote != nil}
  /// Clears the value of `tableFootnote`. Subsequent reads from it will return its default value.
  mutating func clearTableFootnote() {_uniqueStorage()._tableFootnote = nil}

  var tableSection: TSWP_ObjectAttributeTable {
    get {return _storage._tableSection ?? TSWP_ObjectAttributeTable()}
    set {_uniqueStorage()._tableSection = newValue}
  }
  /// Returns true if `tableSection` has been explicitly set.
  var hasTableSection: Bool {return _storage._tableSection != nil}
  /// Clears the value of `tableSection`. Subsequent reads from it will return its default value.
  mutating func clearTableSection() {_uniqueStorage()._tableSection = nil}

  var tableRubyfield: TSWP_ObjectAttributeTable {
    get {return _storage._tableRubyfield ?? TSWP_ObjectAttributeTable()}
    set {_uniqueStorage()._tableRubyfield = newValue}
  }
  /// Returns true if `tableRubyfield` has been explicitly set.
  var hasTableRubyfield: Bool {return _storage._tableRubyfield != nil}
  /// Clears the value of `tableRubyfield`. Subsequent reads from it will return its default value.
  mutating func clearTableRubyfield() {_uniqueStorage()._tableRubyfield = nil}

  var tableLanguage: TSWP_StringAttributeTable {
    get {return _storage._tableLanguage ?? TSWP_StringAttributeTable()}
    set {_uniqueStorage()._tableLanguage = newValue}
  }
  /// Returns true if `tableLanguage` has been explicitly set.
  var hasTableLanguage: Bool {return _storage._tableLanguage != nil}
  /// Clears the value of `tableLanguage`. Subsequent reads from it will return its default value.
  mutating func clearTableLanguage() {_uniqueStorage()._tableLanguage = nil}

  var tableDictation: TSWP_StringAttributeTable {
    get {return _storage._tableDictation ?? TSWP_StringAttributeTable()}
    set {_uniqueStorage()._tableDictation = newValue}
  }
  /// Returns true if `tableDictation` has been explicitly set.
  var hasTableDictation: Bool {return _storage._tableDictation != nil}
  /// Clears the value of `tableDictation`. Subsequent reads from it will return its default value.
  mutating func clearTableDictation() {_uniqueStorage()._tableDictation = nil}

  var tableInsertion: TSWP_ObjectAttributeTable {
    get {return _storage._tableInsertion ?? TSWP_ObjectAttributeTable()}
    set {_uniqueStorage()._tableInsertion = newValue}
  }
  /// Returns true if `tableInsertion` has been explicitly set.
  var hasTableInsertion: Bool {return _storage._tableInsertion != nil}
  /// Clears the value of `tableInsertion`. Subsequent reads from it will return its default value.
  mutating func clearTableInsertion() {_uniqueStorage()._tableInsertion = nil}

  var tableDeletion: TSWP_ObjectAttributeTable {
    get {return _storage._tableDeletion ?? TSWP_ObjectAttributeTable()}
    set {_uniqueStorage()._tableDeletion = newValue}
  }
  /// Returns true if `tableDeletion` has been explicitly set.
  var hasTableDeletion: Bool {return _storage._tableDeletion != nil}
  /// Clears the value of `tableDeletion`. Subsequent reads from it will return its default value.
  mutating func clearTableDeletion() {_uniqueStorage()._tableDeletion = nil}

  var tableHighlight: TSWP_ObjectAttributeTable {
    get {return _storage._tableHighlight ?? TSWP_ObjectAttributeTable()}
    set {_uniqueStorage()._tableHighlight = newValue}
  }
  /// Returns true if `tableHighlight` has been explicitly set.
  var hasTableHighlight: Bool {return _storage._tableHighlight != nil}
  /// Clears the value of `tableHighlight`. Subsequent reads from it will return its default value.
  mutating func clearTableHighlight() {_uniqueStorage()._tableHighlight = nil}

  var tableParaBidi: TSWP_ParaDataAttributeTable {
    get {return _storage._tableParaBidi ?? TSWP_ParaDataAttributeTable()}
    set {_uniqueStorage()._tableParaBidi = newValue}
  }
  /// Returns true if `tableParaBidi` has been explicitly set.
  var hasTableParaBidi: Bool {return _storage._tableParaBidi != nil}
  /// Clears the value of `tableParaBidi`. Subsequent reads from it will return its default value.
  mutating func clearTableParaBidi() {_uniqueStorage()._tableParaBidi = nil}

  var tableOverlappingHighlight: TSWP_OverlappingFieldAttributeTable {
    get {return _storage._tableOverlappingHighlight ?? TSWP_OverlappingFieldAttributeTable()}
    set {_uniqueStorage()._tableOverlappingHighlight = newValue}
  }
  /// Returns true if `tableOverlappingHighlight` has been explicitly set.
  var hasTableOverlappingHighlight: Bool {return _storage._tableOverlappingHighlight != nil}
  /// Clears the value of `tableOverlappingHighlight`. Subsequent reads from it will return its default value.
  mutating func clearTableOverlappingHighlight() {_uniqueStorage()._tableOverlappingHighlight = nil}

  var tablePencilAnnotation: TSWP_OverlappingFieldAttributeTable {
    get {return _storage._tablePencilAnnotation ?? TSWP_OverlappingFieldAttributeTable()}
    set {_uniqueStorage()._tablePencilAnnotation = newValue}
  }
  /// Returns true if `tablePencilAnnotation` has been explicitly set.
  var hasTablePencilAnnotation: Bool {return _storage._tablePencilAnnotation != nil}
  /// Clears the value of `tablePencilAnnotation`. Subsequent reads from it will return its default value.
  mutating func clearTablePencilAnnotation() {_uniqueStorage()._tablePencilAnnotation = nil}

  var tableTatechuyoko: TSWP_ObjectAttributeTable {
    get {return _storage._tableTatechuyoko ?? TSWP_ObjectAttributeTable()}
    set {_uniqueStorage()._tableTatechuyoko = newValue}
  }
  /// Returns true if `tableTatechuyoko` has been explicitly set.
  var hasTableTatechuyoko: Bool {return _storage._tableTatechuyoko != nil}
  /// Clears the value of `tableTatechuyoko`. Subsequent reads from it will return its default value.
  mutating func clearTableTatechuyoko() {_uniqueStorage()._tableTatechuyoko = nil}

  var tableDropCapStyle: TSWP_ObjectAttributeTable {
    get {return _storage._tableDropCapStyle ?? TSWP_ObjectAttributeTable()}
    set {_uniqueStorage()._tableDropCapStyle = newValue}
  }
  /// Returns true if `tableDropCapStyle` has been explicitly set.
  var hasTableDropCapStyle: Bool {return _storage._tableDropCapStyle != nil}
  /// Clears the value of `tableDropCapStyle`. Subsequent reads from it will return its default value.
  mutating func clearTableDropCapStyle() {_uniqueStorage()._tableDropCapStyle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum KindType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case body = 0
    case header = 1
    case footnote = 2
    case textbox = 3
    case note = 4
    case cell = 5
    case unclassified = 6
    case tableofcontents = 7
    case undefined = 8

    init() {
      self = .body
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_HighlightArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var commentStorage: TSP_Reference {
    get {return _commentStorage ?? TSP_Reference()}
    set {_commentStorage = newValue}
  }
  /// Returns true if `commentStorage` has been explicitly set.
  var hasCommentStorage: Bool {return self._commentStorage != nil}
  /// Clears the value of `commentStorage`. Subsequent reads from it will return its default value.
  mutating func clearCommentStorage() {self._commentStorage = nil}

  var textAttributeUuidString: String {
    get {return _textAttributeUuidString ?? String()}
    set {_textAttributeUuidString = newValue}
  }
  /// Returns true if `textAttributeUuidString` has been explicitly set.
  var hasTextAttributeUuidString: Bool {return self._textAttributeUuidString != nil}
  /// Clears the value of `textAttributeUuidString`. Subsequent reads from it will return its default value.
  mutating func clearTextAttributeUuidString() {self._textAttributeUuidString = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commentStorage: TSP_Reference? = nil
  fileprivate var _textAttributeUuidString: String? = nil
}

struct TSWP_PencilAnnotationArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pencilAnnotationStorage: TSP_Reference {
    get {return _pencilAnnotationStorage ?? TSP_Reference()}
    set {_pencilAnnotationStorage = newValue}
  }
  /// Returns true if `pencilAnnotationStorage` has been explicitly set.
  var hasPencilAnnotationStorage: Bool {return self._pencilAnnotationStorage != nil}
  /// Clears the value of `pencilAnnotationStorage`. Subsequent reads from it will return its default value.
  mutating func clearPencilAnnotationStorage() {self._pencilAnnotationStorage = nil}

  var textAttributeUuidString: String {
    get {return _textAttributeUuidString ?? String()}
    set {_textAttributeUuidString = newValue}
  }
  /// Returns true if `textAttributeUuidString` has been explicitly set.
  var hasTextAttributeUuidString: Bool {return self._textAttributeUuidString != nil}
  /// Clears the value of `textAttributeUuidString`. Subsequent reads from it will return its default value.
  mutating func clearTextAttributeUuidString() {self._textAttributeUuidString = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pencilAnnotationStorage: TSP_Reference? = nil
  fileprivate var _textAttributeUuidString: String? = nil
}

struct TSWP_FontFeatureArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var featureType: UInt32 {
    get {return _featureType ?? 0}
    set {_featureType = newValue}
  }
  /// Returns true if `featureType` has been explicitly set.
  var hasFeatureType: Bool {return self._featureType != nil}
  /// Clears the value of `featureType`. Subsequent reads from it will return its default value.
  mutating func clearFeatureType() {self._featureType = nil}

  var featureSelector: UInt32 {
    get {return _featureSelector ?? 0}
    set {_featureSelector = newValue}
  }
  /// Returns true if `featureSelector` has been explicitly set.
  var hasFeatureSelector: Bool {return self._featureSelector != nil}
  /// Clears the value of `featureSelector`. Subsequent reads from it will return its default value.
  mutating func clearFeatureSelector() {self._featureSelector = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _featureType: UInt32? = nil
  fileprivate var _featureSelector: UInt32? = nil
}

struct TSWP_CharacterStylePropertiesArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bold: Bool {
    get {return _storage._bold ?? false}
    set {_uniqueStorage()._bold = newValue}
  }
  /// Returns true if `bold` has been explicitly set.
  var hasBold: Bool {return _storage._bold != nil}
  /// Clears the value of `bold`. Subsequent reads from it will return its default value.
  mutating func clearBold() {_uniqueStorage()._bold = nil}

  var italic: Bool {
    get {return _storage._italic ?? false}
    set {_uniqueStorage()._italic = newValue}
  }
  /// Returns true if `italic` has been explicitly set.
  var hasItalic: Bool {return _storage._italic != nil}
  /// Clears the value of `italic`. Subsequent reads from it will return its default value.
  mutating func clearItalic() {_uniqueStorage()._italic = nil}

  var fontSize: Float {
    get {return _storage._fontSize ?? 0}
    set {_uniqueStorage()._fontSize = newValue}
  }
  /// Returns true if `fontSize` has been explicitly set.
  var hasFontSize: Bool {return _storage._fontSize != nil}
  /// Clears the value of `fontSize`. Subsequent reads from it will return its default value.
  mutating func clearFontSize() {_uniqueStorage()._fontSize = nil}

  var fontNameNull: Bool {
    get {return _storage._fontNameNull ?? false}
    set {_uniqueStorage()._fontNameNull = newValue}
  }
  /// Returns true if `fontNameNull` has been explicitly set.
  var hasFontNameNull: Bool {return _storage._fontNameNull != nil}
  /// Clears the value of `fontNameNull`. Subsequent reads from it will return its default value.
  mutating func clearFontNameNull() {_uniqueStorage()._fontNameNull = nil}

  var fontName: String {
    get {return _storage._fontName ?? String()}
    set {_uniqueStorage()._fontName = newValue}
  }
  /// Returns true if `fontName` has been explicitly set.
  var hasFontName: Bool {return _storage._fontName != nil}
  /// Clears the value of `fontName`. Subsequent reads from it will return its default value.
  mutating func clearFontName() {_uniqueStorage()._fontName = nil}

  var fontColorNull: Bool {
    get {return _storage._fontColorNull ?? false}
    set {_uniqueStorage()._fontColorNull = newValue}
  }
  /// Returns true if `fontColorNull` has been explicitly set.
  var hasFontColorNull: Bool {return _storage._fontColorNull != nil}
  /// Clears the value of `fontColorNull`. Subsequent reads from it will return its default value.
  mutating func clearFontColorNull() {_uniqueStorage()._fontColorNull = nil}

  var fontColor: TSP_Color {
    get {return _storage._fontColor ?? TSP_Color()}
    set {_uniqueStorage()._fontColor = newValue}
  }
  /// Returns true if `fontColor` has been explicitly set.
  var hasFontColor: Bool {return _storage._fontColor != nil}
  /// Clears the value of `fontColor`. Subsequent reads from it will return its default value.
  mutating func clearFontColor() {_uniqueStorage()._fontColor = nil}

  var languageNull: Bool {
    get {return _storage._languageNull ?? false}
    set {_uniqueStorage()._languageNull = newValue}
  }
  /// Returns true if `languageNull` has been explicitly set.
  var hasLanguageNull: Bool {return _storage._languageNull != nil}
  /// Clears the value of `languageNull`. Subsequent reads from it will return its default value.
  mutating func clearLanguageNull() {_uniqueStorage()._languageNull = nil}

  var language: String {
    get {return _storage._language ?? String()}
    set {_uniqueStorage()._language = newValue}
  }
  /// Returns true if `language` has been explicitly set.
  var hasLanguage: Bool {return _storage._language != nil}
  /// Clears the value of `language`. Subsequent reads from it will return its default value.
  mutating func clearLanguage() {_uniqueStorage()._language = nil}

  var superscript: TSWP_CharacterStylePropertiesArchive.SuperscriptType {
    get {return _storage._superscript ?? .kNoScript}
    set {_uniqueStorage()._superscript = newValue}
  }
  /// Returns true if `superscript` has been explicitly set.
  var hasSuperscript: Bool {return _storage._superscript != nil}
  /// Clears the value of `superscript`. Subsequent reads from it will return its default value.
  mutating func clearSuperscript() {_uniqueStorage()._superscript = nil}

  var underline: TSWP_CharacterStylePropertiesArchive.UnderlineType {
    get {return _storage._underline ?? .kNoUnderline}
    set {_uniqueStorage()._underline = newValue}
  }
  /// Returns true if `underline` has been explicitly set.
  var hasUnderline: Bool {return _storage._underline != nil}
  /// Clears the value of `underline`. Subsequent reads from it will return its default value.
  mutating func clearUnderline() {_uniqueStorage()._underline = nil}

  var strikethru: TSWP_CharacterStylePropertiesArchive.StrikethruType {
    get {return _storage._strikethru ?? .kNoStrikethru}
    set {_uniqueStorage()._strikethru = newValue}
  }
  /// Returns true if `strikethru` has been explicitly set.
  var hasStrikethru: Bool {return _storage._strikethru != nil}
  /// Clears the value of `strikethru`. Subsequent reads from it will return its default value.
  mutating func clearStrikethru() {_uniqueStorage()._strikethru = nil}

  var capitalization: TSWP_CharacterStylePropertiesArchive.CapitalizationType {
    get {return _storage._capitalization ?? .kNoCaps}
    set {_uniqueStorage()._capitalization = newValue}
  }
  /// Returns true if `capitalization` has been explicitly set.
  var hasCapitalization: Bool {return _storage._capitalization != nil}
  /// Clears the value of `capitalization`. Subsequent reads from it will return its default value.
  mutating func clearCapitalization() {_uniqueStorage()._capitalization = nil}

  var baselineShift: Float {
    get {return _storage._baselineShift ?? 0}
    set {_uniqueStorage()._baselineShift = newValue}
  }
  /// Returns true if `baselineShift` has been explicitly set.
  var hasBaselineShift: Bool {return _storage._baselineShift != nil}
  /// Clears the value of `baselineShift`. Subsequent reads from it will return its default value.
  mutating func clearBaselineShift() {_uniqueStorage()._baselineShift = nil}

  var kerning: Float {
    get {return _storage._kerning ?? 0}
    set {_uniqueStorage()._kerning = newValue}
  }
  /// Returns true if `kerning` has been explicitly set.
  var hasKerning: Bool {return _storage._kerning != nil}
  /// Clears the value of `kerning`. Subsequent reads from it will return its default value.
  mutating func clearKerning() {_uniqueStorage()._kerning = nil}

  var ligatures: TSWP_CharacterStylePropertiesArchive.LigaturesType {
    get {return _storage._ligatures ?? .kRequiredLigatures}
    set {_uniqueStorage()._ligatures = newValue}
  }
  /// Returns true if `ligatures` has been explicitly set.
  var hasLigatures: Bool {return _storage._ligatures != nil}
  /// Clears the value of `ligatures`. Subsequent reads from it will return its default value.
  mutating func clearLigatures() {_uniqueStorage()._ligatures = nil}

  var outlineColorNull: Bool {
    get {return _storage._outlineColorNull ?? false}
    set {_uniqueStorage()._outlineColorNull = newValue}
  }
  /// Returns true if `outlineColorNull` has been explicitly set.
  var hasOutlineColorNull: Bool {return _storage._outlineColorNull != nil}
  /// Clears the value of `outlineColorNull`. Subsequent reads from it will return its default value.
  mutating func clearOutlineColorNull() {_uniqueStorage()._outlineColorNull = nil}

  var outlineColor: TSP_Color {
    get {return _storage._outlineColor ?? TSP_Color()}
    set {_uniqueStorage()._outlineColor = newValue}
  }
  /// Returns true if `outlineColor` has been explicitly set.
  var hasOutlineColor: Bool {return _storage._outlineColor != nil}
  /// Clears the value of `outlineColor`. Subsequent reads from it will return its default value.
  mutating func clearOutlineColor() {_uniqueStorage()._outlineColor = nil}

  var outline: Float {
    get {return _storage._outline ?? 0}
    set {_uniqueStorage()._outline = newValue}
  }
  /// Returns true if `outline` has been explicitly set.
  var hasOutline: Bool {return _storage._outline != nil}
  /// Clears the value of `outline`. Subsequent reads from it will return its default value.
  mutating func clearOutline() {_uniqueStorage()._outline = nil}

  var shadowNull: Bool {
    get {return _storage._shadowNull ?? false}
    set {_uniqueStorage()._shadowNull = newValue}
  }
  /// Returns true if `shadowNull` has been explicitly set.
  var hasShadowNull: Bool {return _storage._shadowNull != nil}
  /// Clears the value of `shadowNull`. Subsequent reads from it will return its default value.
  mutating func clearShadowNull() {_uniqueStorage()._shadowNull = nil}

  var shadow: TSD_ShadowArchive {
    get {return _storage._shadow ?? TSD_ShadowArchive()}
    set {_uniqueStorage()._shadow = newValue}
  }
  /// Returns true if `shadow` has been explicitly set.
  var hasShadow: Bool {return _storage._shadow != nil}
  /// Clears the value of `shadow`. Subsequent reads from it will return its default value.
  mutating func clearShadow() {_uniqueStorage()._shadow = nil}

  var strikethruColorNull: Bool {
    get {return _storage._strikethruColorNull ?? false}
    set {_uniqueStorage()._strikethruColorNull = newValue}
  }
  /// Returns true if `strikethruColorNull` has been explicitly set.
  var hasStrikethruColorNull: Bool {return _storage._strikethruColorNull != nil}
  /// Clears the value of `strikethruColorNull`. Subsequent reads from it will return its default value.
  mutating func clearStrikethruColorNull() {_uniqueStorage()._strikethruColorNull = nil}

  var strikethruColor: TSP_Color {
    get {return _storage._strikethruColor ?? TSP_Color()}
    set {_uniqueStorage()._strikethruColor = newValue}
  }
  /// Returns true if `strikethruColor` has been explicitly set.
  var hasStrikethruColor: Bool {return _storage._strikethruColor != nil}
  /// Clears the value of `strikethruColor`. Subsequent reads from it will return its default value.
  mutating func clearStrikethruColor() {_uniqueStorage()._strikethruColor = nil}

  var strikethruWidth: Float {
    get {return _storage._strikethruWidth ?? 0}
    set {_uniqueStorage()._strikethruWidth = newValue}
  }
  /// Returns true if `strikethruWidth` has been explicitly set.
  var hasStrikethruWidth: Bool {return _storage._strikethruWidth != nil}
  /// Clears the value of `strikethruWidth`. Subsequent reads from it will return its default value.
  mutating func clearStrikethruWidth() {_uniqueStorage()._strikethruWidth = nil}

  var backgroundColorNull: Bool {
    get {return _storage._backgroundColorNull ?? false}
    set {_uniqueStorage()._backgroundColorNull = newValue}
  }
  /// Returns true if `backgroundColorNull` has been explicitly set.
  var hasBackgroundColorNull: Bool {return _storage._backgroundColorNull != nil}
  /// Clears the value of `backgroundColorNull`. Subsequent reads from it will return its default value.
  mutating func clearBackgroundColorNull() {_uniqueStorage()._backgroundColorNull = nil}

  var backgroundColor: TSP_Color {
    get {return _storage._backgroundColor ?? TSP_Color()}
    set {_uniqueStorage()._backgroundColor = newValue}
  }
  /// Returns true if `backgroundColor` has been explicitly set.
  var hasBackgroundColor: Bool {return _storage._backgroundColor != nil}
  /// Clears the value of `backgroundColor`. Subsequent reads from it will return its default value.
  mutating func clearBackgroundColor() {_uniqueStorage()._backgroundColor = nil}

  var tracking: Float {
    get {return _storage._tracking ?? 0}
    set {_uniqueStorage()._tracking = newValue}
  }
  /// Returns true if `tracking` has been explicitly set.
  var hasTracking: Bool {return _storage._tracking != nil}
  /// Clears the value of `tracking`. Subsequent reads from it will return its default value.
  mutating func clearTracking() {_uniqueStorage()._tracking = nil}

  var underlineColorNull: Bool {
    get {return _storage._underlineColorNull ?? false}
    set {_uniqueStorage()._underlineColorNull = newValue}
  }
  /// Returns true if `underlineColorNull` has been explicitly set.
  var hasUnderlineColorNull: Bool {return _storage._underlineColorNull != nil}
  /// Clears the value of `underlineColorNull`. Subsequent reads from it will return its default value.
  mutating func clearUnderlineColorNull() {_uniqueStorage()._underlineColorNull = nil}

  var underlineColor: TSP_Color {
    get {return _storage._underlineColor ?? TSP_Color()}
    set {_uniqueStorage()._underlineColor = newValue}
  }
  /// Returns true if `underlineColor` has been explicitly set.
  var hasUnderlineColor: Bool {return _storage._underlineColor != nil}
  /// Clears the value of `underlineColor`. Subsequent reads from it will return its default value.
  mutating func clearUnderlineColor() {_uniqueStorage()._underlineColor = nil}

  var underlineWidth: Float {
    get {return _storage._underlineWidth ?? 0}
    set {_uniqueStorage()._underlineWidth = newValue}
  }
  /// Returns true if `underlineWidth` has been explicitly set.
  var hasUnderlineWidth: Bool {return _storage._underlineWidth != nil}
  /// Clears the value of `underlineWidth`. Subsequent reads from it will return its default value.
  mutating func clearUnderlineWidth() {_uniqueStorage()._underlineWidth = nil}

  var wordStrikethru: Bool {
    get {return _storage._wordStrikethru ?? false}
    set {_uniqueStorage()._wordStrikethru = newValue}
  }
  /// Returns true if `wordStrikethru` has been explicitly set.
  var hasWordStrikethru: Bool {return _storage._wordStrikethru != nil}
  /// Clears the value of `wordStrikethru`. Subsequent reads from it will return its default value.
  mutating func clearWordStrikethru() {_uniqueStorage()._wordStrikethru = nil}

  var wordUnderline: Bool {
    get {return _storage._wordUnderline ?? false}
    set {_uniqueStorage()._wordUnderline = newValue}
  }
  /// Returns true if `wordUnderline` has been explicitly set.
  var hasWordUnderline: Bool {return _storage._wordUnderline != nil}
  /// Clears the value of `wordUnderline`. Subsequent reads from it will return its default value.
  mutating func clearWordUnderline() {_uniqueStorage()._wordUnderline = nil}

  var fontFeaturesNull: Bool {
    get {return _storage._fontFeaturesNull ?? false}
    set {_uniqueStorage()._fontFeaturesNull = newValue}
  }
  /// Returns true if `fontFeaturesNull` has been explicitly set.
  var hasFontFeaturesNull: Bool {return _storage._fontFeaturesNull != nil}
  /// Clears the value of `fontFeaturesNull`. Subsequent reads from it will return its default value.
  mutating func clearFontFeaturesNull() {_uniqueStorage()._fontFeaturesNull = nil}

  var fontFeatures: [TSWP_FontFeatureArchive] {
    get {return _storage._fontFeatures}
    set {_uniqueStorage()._fontFeatures = newValue}
  }

  var writingDirection: TSWP_WritingDirectionType {
    get {return _storage._writingDirection ?? .kWritingDirectionNatural}
    set {_uniqueStorage()._writingDirection = newValue}
  }
  /// Returns true if `writingDirection` has been explicitly set.
  var hasWritingDirection: Bool {return _storage._writingDirection != nil}
  /// Clears the value of `writingDirection`. Subsequent reads from it will return its default value.
  mutating func clearWritingDirection() {_uniqueStorage()._writingDirection = nil}

  var emphasisMarksNull: Bool {
    get {return _storage._emphasisMarksNull ?? false}
    set {_uniqueStorage()._emphasisMarksNull = newValue}
  }
  /// Returns true if `emphasisMarksNull` has been explicitly set.
  var hasEmphasisMarksNull: Bool {return _storage._emphasisMarksNull != nil}
  /// Clears the value of `emphasisMarksNull`. Subsequent reads from it will return its default value.
  mutating func clearEmphasisMarksNull() {_uniqueStorage()._emphasisMarksNull = nil}

  var emphasisMarks: String {
    get {return _storage._emphasisMarks ?? String()}
    set {_uniqueStorage()._emphasisMarks = newValue}
  }
  /// Returns true if `emphasisMarks` has been explicitly set.
  var hasEmphasisMarks: Bool {return _storage._emphasisMarks != nil}
  /// Clears the value of `emphasisMarks`. Subsequent reads from it will return its default value.
  mutating func clearEmphasisMarks() {_uniqueStorage()._emphasisMarks = nil}

  var compatibilityFontNameNull: Bool {
    get {return _storage._compatibilityFontNameNull ?? false}
    set {_uniqueStorage()._compatibilityFontNameNull = newValue}
  }
  /// Returns true if `compatibilityFontNameNull` has been explicitly set.
  var hasCompatibilityFontNameNull: Bool {return _storage._compatibilityFontNameNull != nil}
  /// Clears the value of `compatibilityFontNameNull`. Subsequent reads from it will return its default value.
  mutating func clearCompatibilityFontNameNull() {_uniqueStorage()._compatibilityFontNameNull = nil}

  var compatibilityFontName: String {
    get {return _storage._compatibilityFontName ?? String()}
    set {_uniqueStorage()._compatibilityFontName = newValue}
  }
  /// Returns true if `compatibilityFontName` has been explicitly set.
  var hasCompatibilityFontName: Bool {return _storage._compatibilityFontName != nil}
  /// Clears the value of `compatibilityFontName`. Subsequent reads from it will return its default value.
  mutating func clearCompatibilityFontName() {_uniqueStorage()._compatibilityFontName = nil}

  var isNamedPointSize: Bool {
    get {return _storage._isNamedPointSize ?? false}
    set {_uniqueStorage()._isNamedPointSize = newValue}
  }
  /// Returns true if `isNamedPointSize` has been explicitly set.
  var hasIsNamedPointSize: Bool {return _storage._isNamedPointSize != nil}
  /// Clears the value of `isNamedPointSize`. Subsequent reads from it will return its default value.
  mutating func clearIsNamedPointSize() {_uniqueStorage()._isNamedPointSize = nil}

  var capitalizationUsesLinguistics: Bool {
    get {return _storage._capitalizationUsesLinguistics ?? false}
    set {_uniqueStorage()._capitalizationUsesLinguistics = newValue}
  }
  /// Returns true if `capitalizationUsesLinguistics` has been explicitly set.
  var hasCapitalizationUsesLinguistics: Bool {return _storage._capitalizationUsesLinguistics != nil}
  /// Clears the value of `capitalizationUsesLinguistics`. Subsequent reads from it will return its default value.
  mutating func clearCapitalizationUsesLinguistics() {_uniqueStorage()._capitalizationUsesLinguistics = nil}

  var tateChuYoko: Bool {
    get {return _storage._tateChuYoko ?? false}
    set {_uniqueStorage()._tateChuYoko = newValue}
  }
  /// Returns true if `tateChuYoko` has been explicitly set.
  var hasTateChuYoko: Bool {return _storage._tateChuYoko != nil}
  /// Clears the value of `tateChuYoko`. Subsequent reads from it will return its default value.
  mutating func clearTateChuYoko() {_uniqueStorage()._tateChuYoko = nil}

  var tsdStrokeNull: Bool {
    get {return _storage._tsdStrokeNull ?? false}
    set {_uniqueStorage()._tsdStrokeNull = newValue}
  }
  /// Returns true if `tsdStrokeNull` has been explicitly set.
  var hasTsdStrokeNull: Bool {return _storage._tsdStrokeNull != nil}
  /// Clears the value of `tsdStrokeNull`. Subsequent reads from it will return its default value.
  mutating func clearTsdStrokeNull() {_uniqueStorage()._tsdStrokeNull = nil}

  var tsdStroke: TSD_StrokeArchive {
    get {return _storage._tsdStroke ?? TSD_StrokeArchive()}
    set {_uniqueStorage()._tsdStroke = newValue}
  }
  /// Returns true if `tsdStroke` has been explicitly set.
  var hasTsdStroke: Bool {return _storage._tsdStroke != nil}
  /// Clears the value of `tsdStroke`. Subsequent reads from it will return its default value.
  mutating func clearTsdStroke() {_uniqueStorage()._tsdStroke = nil}

  var tsdFillNull: Bool {
    get {return _storage._tsdFillNull ?? false}
    set {_uniqueStorage()._tsdFillNull = newValue}
  }
  /// Returns true if `tsdFillNull` has been explicitly set.
  var hasTsdFillNull: Bool {return _storage._tsdFillNull != nil}
  /// Clears the value of `tsdFillNull`. Subsequent reads from it will return its default value.
  mutating func clearTsdFillNull() {_uniqueStorage()._tsdFillNull = nil}

  var tsdFill: TSD_FillArchive {
    get {return _storage._tsdFill ?? TSD_FillArchive()}
    set {_uniqueStorage()._tsdFill = newValue}
  }
  /// Returns true if `tsdFill` has been explicitly set.
  var hasTsdFill: Bool {return _storage._tsdFill != nil}
  /// Clears the value of `tsdFill`. Subsequent reads from it will return its default value.
  mutating func clearTsdFill() {_uniqueStorage()._tsdFill = nil}

  var tsdFillShouldFillTextContainer: Bool {
    get {return _storage._tsdFillShouldFillTextContainer ?? false}
    set {_uniqueStorage()._tsdFillShouldFillTextContainer = newValue}
  }
  /// Returns true if `tsdFillShouldFillTextContainer` has been explicitly set.
  var hasTsdFillShouldFillTextContainer: Bool {return _storage._tsdFillShouldFillTextContainer != nil}
  /// Clears the value of `tsdFillShouldFillTextContainer`. Subsequent reads from it will return its default value.
  mutating func clearTsdFillShouldFillTextContainer() {_uniqueStorage()._tsdFillShouldFillTextContainer = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum CapitalizationType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kNoCaps = 0
    case kAllCaps = 1
    case kSmallCaps = 2
    case kTitled = 3

    init() {
      self = .kNoCaps
    }

  }

  enum UnderlineType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kNoUnderline = 0
    case kSingleUnderline = 1
    case kDoubleUnderline = 2
    case kWavyUnderline = 3

    init() {
      self = .kNoUnderline
    }

  }

  enum LigaturesType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kRequiredLigatures = 0
    case kStandardLigatures = 1
    case kAllLigatures = 2

    init() {
      self = .kRequiredLigatures
    }

  }

  enum StrikethruType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kNoStrikethru = 0
    case kSingleStrikethru = 1
    case kDoubleStrikethru = 2
    case kTripleStrikethru = 3

    init() {
      self = .kNoStrikethru
    }

  }

  enum SuperscriptType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kNoScript = 0
    case kSuperscript = 1
    case kSubscript = 2

    init() {
      self = .kNoScript
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_CharacterStyleArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_StyleArchive {
    get {return _super ?? TSS_StyleArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var overrideCount: UInt32 {
    get {return _overrideCount ?? 0}
    set {_overrideCount = newValue}
  }
  /// Returns true if `overrideCount` has been explicitly set.
  var hasOverrideCount: Bool {return self._overrideCount != nil}
  /// Clears the value of `overrideCount`. Subsequent reads from it will return its default value.
  mutating func clearOverrideCount() {self._overrideCount = nil}

  var charProperties: TSWP_CharacterStylePropertiesArchive {
    get {return _charProperties ?? TSWP_CharacterStylePropertiesArchive()}
    set {_charProperties = newValue}
  }
  /// Returns true if `charProperties` has been explicitly set.
  var hasCharProperties: Bool {return self._charProperties != nil}
  /// Clears the value of `charProperties`. Subsequent reads from it will return its default value.
  mutating func clearCharProperties() {self._charProperties = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSS_StyleArchive? = nil
  fileprivate var _overrideCount: UInt32? = nil
  fileprivate var _charProperties: TSWP_CharacterStylePropertiesArchive? = nil
}

struct TSWP_TabArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var position: Float {
    get {return _position ?? 0}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var alignment: TSWP_TabArchive.TabAlignmentType {
    get {return _alignment ?? .kTabAlignmentLeft}
    set {_alignment = newValue}
  }
  /// Returns true if `alignment` has been explicitly set.
  var hasAlignment: Bool {return self._alignment != nil}
  /// Clears the value of `alignment`. Subsequent reads from it will return its default value.
  mutating func clearAlignment() {self._alignment = nil}

  var leader: String {
    get {return _leader ?? String()}
    set {_leader = newValue}
  }
  /// Returns true if `leader` has been explicitly set.
  var hasLeader: Bool {return self._leader != nil}
  /// Clears the value of `leader`. Subsequent reads from it will return its default value.
  mutating func clearLeader() {self._leader = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TabAlignmentType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kTabAlignmentLeft = 0
    case kTabAlignmentCenter = 1
    case kTabAlignmentRight = 2
    case kTabAlignmentDecimal = 3

    init() {
      self = .kTabAlignmentLeft
    }

  }

  init() {}

  fileprivate var _position: Float? = nil
  fileprivate var _alignment: TSWP_TabArchive.TabAlignmentType? = nil
  fileprivate var _leader: String? = nil
}

struct TSWP_TabsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tabs: [TSWP_TabArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSWP_LineSpacingArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mode: TSWP_LineSpacingArchive.LineSpacingModeType {
    get {return _mode ?? .kRelativeLineSpacing}
    set {_mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  var hasMode: Bool {return self._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  mutating func clearMode() {self._mode = nil}

  var amount: Float {
    get {return _amount ?? 0}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var baselineRule: Float {
    get {return _baselineRule ?? 0}
    set {_baselineRule = newValue}
  }
  /// Returns true if `baselineRule` has been explicitly set.
  var hasBaselineRule: Bool {return self._baselineRule != nil}
  /// Clears the value of `baselineRule`. Subsequent reads from it will return its default value.
  mutating func clearBaselineRule() {self._baselineRule = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum LineSpacingModeType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kRelativeLineSpacing = 0
    case kMinimumLineSpacing = 1
    case kExactLineSpacing = 2
    case kMaximumLineSpacing = 3
    case kSpaceBetweenLineSpacing = 4

    init() {
      self = .kRelativeLineSpacing
    }

  }

  init() {}

  fileprivate var _mode: TSWP_LineSpacingArchive.LineSpacingModeType? = nil
  fileprivate var _amount: Float? = nil
  fileprivate var _baselineRule: Float? = nil
}

struct TSWP_ParagraphStylePropertiesArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var alignment: TSWP_ParagraphStylePropertiesArchive.TextAlignmentType {
    get {return _storage._alignment ?? .tatvalue0}
    set {_uniqueStorage()._alignment = newValue}
  }
  /// Returns true if `alignment` has been explicitly set.
  var hasAlignment: Bool {return _storage._alignment != nil}
  /// Clears the value of `alignment`. Subsequent reads from it will return its default value.
  mutating func clearAlignment() {_uniqueStorage()._alignment = nil}

  var decimalTabNull: Bool {
    get {return _storage._decimalTabNull ?? false}
    set {_uniqueStorage()._decimalTabNull = newValue}
  }
  /// Returns true if `decimalTabNull` has been explicitly set.
  var hasDecimalTabNull: Bool {return _storage._decimalTabNull != nil}
  /// Clears the value of `decimalTabNull`. Subsequent reads from it will return its default value.
  mutating func clearDecimalTabNull() {_uniqueStorage()._decimalTabNull = nil}

  var decimalTab: String {
    get {return _storage._decimalTab ?? String()}
    set {_uniqueStorage()._decimalTab = newValue}
  }
  /// Returns true if `decimalTab` has been explicitly set.
  var hasDecimalTab: Bool {return _storage._decimalTab != nil}
  /// Clears the value of `decimalTab`. Subsequent reads from it will return its default value.
  mutating func clearDecimalTab() {_uniqueStorage()._decimalTab = nil}

  var defaultTabStops: Float {
    get {return _storage._defaultTabStops ?? 0}
    set {_uniqueStorage()._defaultTabStops = newValue}
  }
  /// Returns true if `defaultTabStops` has been explicitly set.
  var hasDefaultTabStops: Bool {return _storage._defaultTabStops != nil}
  /// Clears the value of `defaultTabStops`. Subsequent reads from it will return its default value.
  mutating func clearDefaultTabStops() {_uniqueStorage()._defaultTabStops = nil}

  var fillNull: Bool {
    get {return _storage._fillNull ?? false}
    set {_uniqueStorage()._fillNull = newValue}
  }
  /// Returns true if `fillNull` has been explicitly set.
  var hasFillNull: Bool {return _storage._fillNull != nil}
  /// Clears the value of `fillNull`. Subsequent reads from it will return its default value.
  mutating func clearFillNull() {_uniqueStorage()._fillNull = nil}

  var fill: TSP_Color {
    get {return _storage._fill ?? TSP_Color()}
    set {_uniqueStorage()._fill = newValue}
  }
  /// Returns true if `fill` has been explicitly set.
  var hasFill: Bool {return _storage._fill != nil}
  /// Clears the value of `fill`. Subsequent reads from it will return its default value.
  mutating func clearFill() {_uniqueStorage()._fill = nil}

  var firstLineIndent: Float {
    get {return _storage._firstLineIndent ?? 0}
    set {_uniqueStorage()._firstLineIndent = newValue}
  }
  /// Returns true if `firstLineIndent` has been explicitly set.
  var hasFirstLineIndent: Bool {return _storage._firstLineIndent != nil}
  /// Clears the value of `firstLineIndent`. Subsequent reads from it will return its default value.
  mutating func clearFirstLineIndent() {_uniqueStorage()._firstLineIndent = nil}

  var hyphenate: Bool {
    get {return _storage._hyphenate ?? false}
    set {_uniqueStorage()._hyphenate = newValue}
  }
  /// Returns true if `hyphenate` has been explicitly set.
  var hasHyphenate: Bool {return _storage._hyphenate != nil}
  /// Clears the value of `hyphenate`. Subsequent reads from it will return its default value.
  mutating func clearHyphenate() {_uniqueStorage()._hyphenate = nil}

  var keepLinesTogether: Bool {
    get {return _storage._keepLinesTogether ?? false}
    set {_uniqueStorage()._keepLinesTogether = newValue}
  }
  /// Returns true if `keepLinesTogether` has been explicitly set.
  var hasKeepLinesTogether: Bool {return _storage._keepLinesTogether != nil}
  /// Clears the value of `keepLinesTogether`. Subsequent reads from it will return its default value.
  mutating func clearKeepLinesTogether() {_uniqueStorage()._keepLinesTogether = nil}

  var keepWithNext: Bool {
    get {return _storage._keepWithNext ?? false}
    set {_uniqueStorage()._keepWithNext = newValue}
  }
  /// Returns true if `keepWithNext` has been explicitly set.
  var hasKeepWithNext: Bool {return _storage._keepWithNext != nil}
  /// Clears the value of `keepWithNext`. Subsequent reads from it will return its default value.
  mutating func clearKeepWithNext() {_uniqueStorage()._keepWithNext = nil}

  var leftIndent: Float {
    get {return _storage._leftIndent ?? 0}
    set {_uniqueStorage()._leftIndent = newValue}
  }
  /// Returns true if `leftIndent` has been explicitly set.
  var hasLeftIndent: Bool {return _storage._leftIndent != nil}
  /// Clears the value of `leftIndent`. Subsequent reads from it will return its default value.
  mutating func clearLeftIndent() {_uniqueStorage()._leftIndent = nil}

  var lineSpacingNull: Bool {
    get {return _storage._lineSpacingNull ?? false}
    set {_uniqueStorage()._lineSpacingNull = newValue}
  }
  /// Returns true if `lineSpacingNull` has been explicitly set.
  var hasLineSpacingNull: Bool {return _storage._lineSpacingNull != nil}
  /// Clears the value of `lineSpacingNull`. Subsequent reads from it will return its default value.
  mutating func clearLineSpacingNull() {_uniqueStorage()._lineSpacingNull = nil}

  var lineSpacing: TSWP_LineSpacingArchive {
    get {return _storage._lineSpacing ?? TSWP_LineSpacingArchive()}
    set {_uniqueStorage()._lineSpacing = newValue}
  }
  /// Returns true if `lineSpacing` has been explicitly set.
  var hasLineSpacing: Bool {return _storage._lineSpacing != nil}
  /// Clears the value of `lineSpacing`. Subsequent reads from it will return its default value.
  mutating func clearLineSpacing() {_uniqueStorage()._lineSpacing = nil}

  var pageBreakBefore: Bool {
    get {return _storage._pageBreakBefore ?? false}
    set {_uniqueStorage()._pageBreakBefore = newValue}
  }
  /// Returns true if `pageBreakBefore` has been explicitly set.
  var hasPageBreakBefore: Bool {return _storage._pageBreakBefore != nil}
  /// Clears the value of `pageBreakBefore`. Subsequent reads from it will return its default value.
  mutating func clearPageBreakBefore() {_uniqueStorage()._pageBreakBefore = nil}

  var deprecatedBorders: TSWP_ParagraphStylePropertiesArchive.DeprecatedParagraphBorderType {
    get {return _storage._deprecatedBorders ?? .pbtvalue0}
    set {_uniqueStorage()._deprecatedBorders = newValue}
  }
  /// Returns true if `deprecatedBorders` has been explicitly set.
  var hasDeprecatedBorders: Bool {return _storage._deprecatedBorders != nil}
  /// Clears the value of `deprecatedBorders`. Subsequent reads from it will return its default value.
  mutating func clearDeprecatedBorders() {_uniqueStorage()._deprecatedBorders = nil}

  var historicalRuleOffsetNull: Bool {
    get {return _storage._historicalRuleOffsetNull ?? false}
    set {_uniqueStorage()._historicalRuleOffsetNull = newValue}
  }
  /// Returns true if `historicalRuleOffsetNull` has been explicitly set.
  var hasHistoricalRuleOffsetNull: Bool {return _storage._historicalRuleOffsetNull != nil}
  /// Clears the value of `historicalRuleOffsetNull`. Subsequent reads from it will return its default value.
  mutating func clearHistoricalRuleOffsetNull() {_uniqueStorage()._historicalRuleOffsetNull = nil}

  var historicalRuleOffset: TSP_Point {
    get {return _storage._historicalRuleOffset ?? TSP_Point()}
    set {_uniqueStorage()._historicalRuleOffset = newValue}
  }
  /// Returns true if `historicalRuleOffset` has been explicitly set.
  var hasHistoricalRuleOffset: Bool {return _storage._historicalRuleOffset != nil}
  /// Clears the value of `historicalRuleOffset`. Subsequent reads from it will return its default value.
  mutating func clearHistoricalRuleOffset() {_uniqueStorage()._historicalRuleOffset = nil}

  var ruleWidth: Float {
    get {return _storage._ruleWidth ?? 0}
    set {_uniqueStorage()._ruleWidth = newValue}
  }
  /// Returns true if `ruleWidth` has been explicitly set.
  var hasRuleWidth: Bool {return _storage._ruleWidth != nil}
  /// Clears the value of `ruleWidth`. Subsequent reads from it will return its default value.
  mutating func clearRuleWidth() {_uniqueStorage()._ruleWidth = nil}

  var rightIndent: Float {
    get {return _storage._rightIndent ?? 0}
    set {_uniqueStorage()._rightIndent = newValue}
  }
  /// Returns true if `rightIndent` has been explicitly set.
  var hasRightIndent: Bool {return _storage._rightIndent != nil}
  /// Clears the value of `rightIndent`. Subsequent reads from it will return its default value.
  mutating func clearRightIndent() {_uniqueStorage()._rightIndent = nil}

  var spaceAfter: Float {
    get {return _storage._spaceAfter ?? 0}
    set {_uniqueStorage()._spaceAfter = newValue}
  }
  /// Returns true if `spaceAfter` has been explicitly set.
  var hasSpaceAfter: Bool {return _storage._spaceAfter != nil}
  /// Clears the value of `spaceAfter`. Subsequent reads from it will return its default value.
  mutating func clearSpaceAfter() {_uniqueStorage()._spaceAfter = nil}

  var spaceBefore: Float {
    get {return _storage._spaceBefore ?? 0}
    set {_uniqueStorage()._spaceBefore = newValue}
  }
  /// Returns true if `spaceBefore` has been explicitly set.
  var hasSpaceBefore: Bool {return _storage._spaceBefore != nil}
  /// Clears the value of `spaceBefore`. Subsequent reads from it will return its default value.
  mutating func clearSpaceBefore() {_uniqueStorage()._spaceBefore = nil}

  var tabsNull: Bool {
    get {return _storage._tabsNull ?? false}
    set {_uniqueStorage()._tabsNull = newValue}
  }
  /// Returns true if `tabsNull` has been explicitly set.
  var hasTabsNull: Bool {return _storage._tabsNull != nil}
  /// Clears the value of `tabsNull`. Subsequent reads from it will return its default value.
  mutating func clearTabsNull() {_uniqueStorage()._tabsNull = nil}

  var tabs: TSWP_TabsArchive {
    get {return _storage._tabs ?? TSWP_TabsArchive()}
    set {_uniqueStorage()._tabs = newValue}
  }
  /// Returns true if `tabs` has been explicitly set.
  var hasTabs: Bool {return _storage._tabs != nil}
  /// Clears the value of `tabs`. Subsequent reads from it will return its default value.
  mutating func clearTabs() {_uniqueStorage()._tabs = nil}

  var widowControl: Bool {
    get {return _storage._widowControl ?? false}
    set {_uniqueStorage()._widowControl = newValue}
  }
  /// Returns true if `widowControl` has been explicitly set.
  var hasWidowControl: Bool {return _storage._widowControl != nil}
  /// Clears the value of `widowControl`. Subsequent reads from it will return its default value.
  mutating func clearWidowControl() {_uniqueStorage()._widowControl = nil}

  var outlineLevel: UInt32 {
    get {return _storage._outlineLevel ?? 0}
    set {_uniqueStorage()._outlineLevel = newValue}
  }
  /// Returns true if `outlineLevel` has been explicitly set.
  var hasOutlineLevel: Bool {return _storage._outlineLevel != nil}
  /// Clears the value of `outlineLevel`. Subsequent reads from it will return its default value.
  mutating func clearOutlineLevel() {_uniqueStorage()._outlineLevel = nil}

  var outlineStyle: TSWP_ParagraphStylePropertiesArchive.OutlineStyleType {
    get {return _storage._outlineStyle ?? .ostvalue0}
    set {_uniqueStorage()._outlineStyle = newValue}
  }
  /// Returns true if `outlineStyle` has been explicitly set.
  var hasOutlineStyle: Bool {return _storage._outlineStyle != nil}
  /// Clears the value of `outlineStyle`. Subsequent reads from it will return its default value.
  mutating func clearOutlineStyle() {_uniqueStorage()._outlineStyle = nil}

  var followingStyleIDNull: Bool {
    get {return _storage._followingStyleIDNull ?? false}
    set {_uniqueStorage()._followingStyleIDNull = newValue}
  }
  /// Returns true if `followingStyleIDNull` has been explicitly set.
  var hasFollowingStyleIDNull: Bool {return _storage._followingStyleIDNull != nil}
  /// Clears the value of `followingStyleIDNull`. Subsequent reads from it will return its default value.
  mutating func clearFollowingStyleIDNull() {_uniqueStorage()._followingStyleIDNull = nil}

  var followingStyleID: String {
    get {return _storage._followingStyleID ?? String()}
    set {_uniqueStorage()._followingStyleID = newValue}
  }
  /// Returns true if `followingStyleID` has been explicitly set.
  var hasFollowingStyleID: Bool {return _storage._followingStyleID != nil}
  /// Clears the value of `followingStyleID`. Subsequent reads from it will return its default value.
  mutating func clearFollowingStyleID() {_uniqueStorage()._followingStyleID = nil}

  var strokeNull: Bool {
    get {return _storage._strokeNull ?? false}
    set {_uniqueStorage()._strokeNull = newValue}
  }
  /// Returns true if `strokeNull` has been explicitly set.
  var hasStrokeNull: Bool {return _storage._strokeNull != nil}
  /// Clears the value of `strokeNull`. Subsequent reads from it will return its default value.
  mutating func clearStrokeNull() {_uniqueStorage()._strokeNull = nil}

  var stroke: TSD_StrokeArchive {
    get {return _storage._stroke ?? TSD_StrokeArchive()}
    set {_uniqueStorage()._stroke = newValue}
  }
  /// Returns true if `stroke` has been explicitly set.
  var hasStroke: Bool {return _storage._stroke != nil}
  /// Clears the value of `stroke`. Subsequent reads from it will return its default value.
  mutating func clearStroke() {_uniqueStorage()._stroke = nil}

  var showInToc: Bool {
    get {return _storage._showInToc ?? false}
    set {_uniqueStorage()._showInToc = newValue}
  }
  /// Returns true if `showInToc` has been explicitly set.
  var hasShowInToc: Bool {return _storage._showInToc != nil}
  /// Clears the value of `showInToc`. Subsequent reads from it will return its default value.
  mutating func clearShowInToc() {_uniqueStorage()._showInToc = nil}

  var tocStyleIDNull: Bool {
    get {return _storage._tocStyleIDNull ?? false}
    set {_uniqueStorage()._tocStyleIDNull = newValue}
  }
  /// Returns true if `tocStyleIDNull` has been explicitly set.
  var hasTocStyleIDNull: Bool {return _storage._tocStyleIDNull != nil}
  /// Clears the value of `tocStyleIDNull`. Subsequent reads from it will return its default value.
  mutating func clearTocStyleIDNull() {_uniqueStorage()._tocStyleIDNull = nil}

  var tocStyleID: String {
    get {return _storage._tocStyleID ?? String()}
    set {_uniqueStorage()._tocStyleID = newValue}
  }
  /// Returns true if `tocStyleID` has been explicitly set.
  var hasTocStyleID: Bool {return _storage._tocStyleID != nil}
  /// Clears the value of `tocStyleID`. Subsequent reads from it will return its default value.
  mutating func clearTocStyleID() {_uniqueStorage()._tocStyleID = nil}

  var writingDirection: TSWP_WritingDirectionType {
    get {return _storage._writingDirection ?? .kWritingDirectionNatural}
    set {_uniqueStorage()._writingDirection = newValue}
  }
  /// Returns true if `writingDirection` has been explicitly set.
  var hasWritingDirection: Bool {return _storage._writingDirection != nil}
  /// Clears the value of `writingDirection`. Subsequent reads from it will return its default value.
  mutating func clearWritingDirection() {_uniqueStorage()._writingDirection = nil}

  var listStyleNull: Bool {
    get {return _storage._listStyleNull ?? false}
    set {_uniqueStorage()._listStyleNull = newValue}
  }
  /// Returns true if `listStyleNull` has been explicitly set.
  var hasListStyleNull: Bool {return _storage._listStyleNull != nil}
  /// Clears the value of `listStyleNull`. Subsequent reads from it will return its default value.
  mutating func clearListStyleNull() {_uniqueStorage()._listStyleNull = nil}

  var listStyle: TSP_Reference {
    get {return _storage._listStyle ?? TSP_Reference()}
    set {_uniqueStorage()._listStyle = newValue}
  }
  /// Returns true if `listStyle` has been explicitly set.
  var hasListStyle: Bool {return _storage._listStyle != nil}
  /// Clears the value of `listStyle`. Subsequent reads from it will return its default value.
  mutating func clearListStyle() {_uniqueStorage()._listStyle = nil}

  var followingStyleNull: Bool {
    get {return _storage._followingStyleNull ?? false}
    set {_uniqueStorage()._followingStyleNull = newValue}
  }
  /// Returns true if `followingStyleNull` has been explicitly set.
  var hasFollowingStyleNull: Bool {return _storage._followingStyleNull != nil}
  /// Clears the value of `followingStyleNull`. Subsequent reads from it will return its default value.
  mutating func clearFollowingStyleNull() {_uniqueStorage()._followingStyleNull = nil}

  var followingStyle: TSP_Reference {
    get {return _storage._followingStyle ?? TSP_Reference()}
    set {_uniqueStorage()._followingStyle = newValue}
  }
  /// Returns true if `followingStyle` has been explicitly set.
  var hasFollowingStyle: Bool {return _storage._followingStyle != nil}
  /// Clears the value of `followingStyle`. Subsequent reads from it will return its default value.
  mutating func clearFollowingStyle() {_uniqueStorage()._followingStyle = nil}

  var showInBookmarksList: Bool {
    get {return _storage._showInBookmarksList ?? false}
    set {_uniqueStorage()._showInBookmarksList = newValue}
  }
  /// Returns true if `showInBookmarksList` has been explicitly set.
  var hasShowInBookmarksList: Bool {return _storage._showInBookmarksList != nil}
  /// Clears the value of `showInBookmarksList`. Subsequent reads from it will return its default value.
  mutating func clearShowInBookmarksList() {_uniqueStorage()._showInBookmarksList = nil}

  var showInTocNavigator: Bool {
    get {return _storage._showInTocNavigator ?? false}
    set {_uniqueStorage()._showInTocNavigator = newValue}
  }
  /// Returns true if `showInTocNavigator` has been explicitly set.
  var hasShowInTocNavigator: Bool {return _storage._showInTocNavigator != nil}
  /// Clears the value of `showInTocNavigator`. Subsequent reads from it will return its default value.
  mutating func clearShowInTocNavigator() {_uniqueStorage()._showInTocNavigator = nil}

  var borderPositions: Int32 {
    get {return _storage._borderPositions ?? 0}
    set {_uniqueStorage()._borderPositions = newValue}
  }
  /// Returns true if `borderPositions` has been explicitly set.
  var hasBorderPositions: Bool {return _storage._borderPositions != nil}
  /// Clears the value of `borderPositions`. Subsequent reads from it will return its default value.
  mutating func clearBorderPositions() {_uniqueStorage()._borderPositions = nil}

  var roundedCorners: Bool {
    get {return _storage._roundedCorners ?? false}
    set {_uniqueStorage()._roundedCorners = newValue}
  }
  /// Returns true if `roundedCorners` has been explicitly set.
  var hasRoundedCorners: Bool {return _storage._roundedCorners != nil}
  /// Clears the value of `roundedCorners`. Subsequent reads from it will return its default value.
  mutating func clearRoundedCorners() {_uniqueStorage()._roundedCorners = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TextAlignmentType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case tatvalue0 = 0
    case tatvalue1 = 1
    case tatvalue2 = 2
    case tatvalue3 = 3
    case tatvalue4 = 4

    init() {
      self = .tatvalue0
    }

  }

  enum DeprecatedParagraphBorderType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case pbtvalue0 = 0
    case pbtvalue1 = 1
    case pbtvalue2 = 2
    case pbtvalue3 = 3
    case pbtvalue4 = 4
    case pbtvalue5 = 8
    case pbtvalue6 = 9
    case pbtvalue7 = 10
    case pbtvalue8 = 11
    case pbtvalue9 = 16
    case pbtvalue10 = 17
    case pbtvalue11 = 18
    case pbtvalue12 = 19
    case pbtvalue13 = 24
    case pbtvalue14 = 25
    case pbtvalue15 = 26

    init() {
      self = .pbtvalue0
    }

  }

  enum OutlineStyleType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case ostvalue0 = 0
    case ostvalue1 = 1
    case ostvalue2 = 2

    init() {
      self = .ostvalue0
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_ParagraphStyleArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_StyleArchive {
    get {return _super ?? TSS_StyleArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var overrideCount: UInt32 {
    get {return _overrideCount ?? 0}
    set {_overrideCount = newValue}
  }
  /// Returns true if `overrideCount` has been explicitly set.
  var hasOverrideCount: Bool {return self._overrideCount != nil}
  /// Clears the value of `overrideCount`. Subsequent reads from it will return its default value.
  mutating func clearOverrideCount() {self._overrideCount = nil}

  var charProperties: TSWP_CharacterStylePropertiesArchive {
    get {return _charProperties ?? TSWP_CharacterStylePropertiesArchive()}
    set {_charProperties = newValue}
  }
  /// Returns true if `charProperties` has been explicitly set.
  var hasCharProperties: Bool {return self._charProperties != nil}
  /// Clears the value of `charProperties`. Subsequent reads from it will return its default value.
  mutating func clearCharProperties() {self._charProperties = nil}

  var paraProperties: TSWP_ParagraphStylePropertiesArchive {
    get {return _paraProperties ?? TSWP_ParagraphStylePropertiesArchive()}
    set {_paraProperties = newValue}
  }
  /// Returns true if `paraProperties` has been explicitly set.
  var hasParaProperties: Bool {return self._paraProperties != nil}
  /// Clears the value of `paraProperties`. Subsequent reads from it will return its default value.
  mutating func clearParaProperties() {self._paraProperties = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSS_StyleArchive? = nil
  fileprivate var _overrideCount: UInt32? = nil
  fileprivate var _charProperties: TSWP_CharacterStylePropertiesArchive? = nil
  fileprivate var _paraProperties: TSWP_ParagraphStylePropertiesArchive? = nil
}

struct TSWP_ListStyleArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_StyleArchive {
    get {return _storage._super ?? TSS_StyleArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var overrideCount: UInt32 {
    get {return _storage._overrideCount ?? 0}
    set {_uniqueStorage()._overrideCount = newValue}
  }
  /// Returns true if `overrideCount` has been explicitly set.
  var hasOverrideCount: Bool {return _storage._overrideCount != nil}
  /// Clears the value of `overrideCount`. Subsequent reads from it will return its default value.
  mutating func clearOverrideCount() {_uniqueStorage()._overrideCount = nil}

  var labelTypes: [TSWP_ListStyleArchive.LabelType] {
    get {return _storage._labelTypes}
    set {_uniqueStorage()._labelTypes = newValue}
  }

  var textIndents: [Float] {
    get {return _storage._textIndents}
    set {_uniqueStorage()._textIndents = newValue}
  }

  var indents: [Float] {
    get {return _storage._indents}
    set {_uniqueStorage()._indents = newValue}
  }

  var geometries: [TSWP_ListStyleArchive.LabelGeometry] {
    get {return _storage._geometries}
    set {_uniqueStorage()._geometries = newValue}
  }

  var numberTypes: [TSWP_ListStyleArchive.NumberType] {
    get {return _storage._numberTypes}
    set {_uniqueStorage()._numberTypes = newValue}
  }

  var strings: [String] {
    get {return _storage._strings}
    set {_uniqueStorage()._strings = newValue}
  }

  var images: [TSWP_ListStyleArchive.LabelImage] {
    get {return _storage._images}
    set {_uniqueStorage()._images = newValue}
  }

  var shadowNull: Bool {
    get {return _storage._shadowNull ?? false}
    set {_uniqueStorage()._shadowNull = newValue}
  }
  /// Returns true if `shadowNull` has been explicitly set.
  var hasShadowNull: Bool {return _storage._shadowNull != nil}
  /// Clears the value of `shadowNull`. Subsequent reads from it will return its default value.
  mutating func clearShadowNull() {_uniqueStorage()._shadowNull = nil}

  var shadow: TSD_ShadowArchive {
    get {return _storage._shadow ?? TSD_ShadowArchive()}
    set {_uniqueStorage()._shadow = newValue}
  }
  /// Returns true if `shadow` has been explicitly set.
  var hasShadow: Bool {return _storage._shadow != nil}
  /// Clears the value of `shadow`. Subsequent reads from it will return its default value.
  mutating func clearShadow() {_uniqueStorage()._shadow = nil}

  var fontColorNull: Bool {
    get {return _storage._fontColorNull ?? false}
    set {_uniqueStorage()._fontColorNull = newValue}
  }
  /// Returns true if `fontColorNull` has been explicitly set.
  var hasFontColorNull: Bool {return _storage._fontColorNull != nil}
  /// Clears the value of `fontColorNull`. Subsequent reads from it will return its default value.
  mutating func clearFontColorNull() {_uniqueStorage()._fontColorNull = nil}

  var fontColor: TSP_Color {
    get {return _storage._fontColor ?? TSP_Color()}
    set {_uniqueStorage()._fontColor = newValue}
  }
  /// Returns true if `fontColor` has been explicitly set.
  var hasFontColor: Bool {return _storage._fontColor != nil}
  /// Clears the value of `fontColor`. Subsequent reads from it will return its default value.
  mutating func clearFontColor() {_uniqueStorage()._fontColor = nil}

  var fontNameNull: Bool {
    get {return _storage._fontNameNull ?? false}
    set {_uniqueStorage()._fontNameNull = newValue}
  }
  /// Returns true if `fontNameNull` has been explicitly set.
  var hasFontNameNull: Bool {return _storage._fontNameNull != nil}
  /// Clears the value of `fontNameNull`. Subsequent reads from it will return its default value.
  mutating func clearFontNameNull() {_uniqueStorage()._fontNameNull = nil}

  var fontName: String {
    get {return _storage._fontName ?? String()}
    set {_uniqueStorage()._fontName = newValue}
  }
  /// Returns true if `fontName` has been explicitly set.
  var hasFontName: Bool {return _storage._fontName != nil}
  /// Clears the value of `fontName`. Subsequent reads from it will return its default value.
  mutating func clearFontName() {_uniqueStorage()._fontName = nil}

  var writingDirection: TSWP_WritingDirectionType {
    get {return _storage._writingDirection ?? .kWritingDirectionNatural}
    set {_uniqueStorage()._writingDirection = newValue}
  }
  /// Returns true if `writingDirection` has been explicitly set.
  var hasWritingDirection: Bool {return _storage._writingDirection != nil}
  /// Clears the value of `writingDirection`. Subsequent reads from it will return its default value.
  mutating func clearWritingDirection() {_uniqueStorage()._writingDirection = nil}

  var tieredNumbers: [Bool] {
    get {return _storage._tieredNumbers}
    set {_uniqueStorage()._tieredNumbers = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum LabelType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kNone = 0
    case kImage = 1
    case kString = 2
    case kNumber = 3

    init() {
      self = .kNone
    }

  }

  enum NumberType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kNumericDecimal = 0
    case kNumericDoubleParen = 1
    case kNumericRightParen = 2
    case kRomanUpperDecimal = 3
    case kRomanUpperDoubleParen = 4
    case kRomanUpperRightParen = 5
    case kRomanLowerDecimal = 6
    case kRomanLowerDoubleParen = 7
    case kRomanLowerRightParen = 8
    case kAlphaUpperDecimal = 9
    case kAlphaUpperDoubleParen = 10
    case kAlphaUpperRightParen = 11
    case kAlphaLowerDecimal = 12
    case kAlphaLowerDoubleParen = 13
    case kAlphaLowerRightParen = 14
    case kIdeographicJapaneseDecimalKind = 15
    case kIdeographicJapaneseDoubleParenKind = 16
    case kIdeographicJapaneseRightParenKind = 17
    case kHiraganaDecimalKind = 18
    case kHiraganaDoubleParenKind = 19
    case kHiraganaRightParenKind = 20
    case kKatakanaDecimalKind = 21
    case kKatakanaDoubleParenKind = 22
    case kKatakanaRightParenKind = 23
    case kHiraganaIrohaDecimalKind = 24
    case kHiraganaIrohaDoubleParenKind = 25
    case kHiraganaIrohaRightParenKind = 26
    case kKatakanaIrohaDecimalKind = 27
    case kKatakanaIrohaDoubleParenKind = 28
    case kKatakanaIrohaRightParenKind = 29
    case kIdeographicSimplifiedChineseDecimalKind = 30
    case kIdeographicSimplifiedChineseDoubleParenKind = 31
    case kIdeographicSimplifiedChineseRightParenKind = 32
    case kIdeographicTraditionalChineseDecimalKind = 33
    case kIdeographicTraditionalChineseDoubleParenKind = 34
    case kIdeographicTraditionalChineseRightParenKind = 35
    case kIdeographicFormalJapaneseDecimalKind = 36
    case kIdeographicFormalJapaneseDoubleParenKind = 37
    case kIdeographicFormalJapaneseRightParenKind = 38
    case kIdeographicFormalSimplifiedChineseDecimalKind = 39
    case kIdeographicFormalSimplifiedChineseDoubleParenKind = 40
    case kIdeographicFormalSimplifiedChineseRightParenKind = 41
    case kIdeographicFormalTraditionalChineseDecimalKind = 42
    case kIdeographicFormalTraditionalChineseDoubleParenKind = 43
    case kIdeographicFormalTraditionalChineseRightParenKind = 44
    case kKoreanAlphabetDecimalKind = 45
    case kKoreanAlphabetDoubleParenKind = 46
    case kKoreanAlphabetRightParenKind = 47
    case kCircledNumberKind = 48
    case kArabianNumericDecimalKind = 49
    case kArabianNumericDoubleParenKind = 50
    case kArabianNumericRightParenKind = 51
    case kArabianAlphaDecimalKind = 52
    case kArabianAlphaDoubleParenKind = 53
    case kArabianAlphaRightParenKind = 54
    case kArabianAbjadDecimalKind = 55
    case kArabianAbjadDoubleParenKind = 56
    case kArabianAbjadRightParenKind = 57
    case kHebrewAlphaDecimalKind = 58
    case kHebrewAlphaDoubleParenKind = 59
    case kHebrewAlphaRightParenKind = 60
    case kHebrewBiblicalStandardKind = 61
    case kHebrewBiblicalDecimalKind = 62
    case kHebrewBiblicalDoubleParenKind = 63
    case kHebrewBiblicalRightParenKind = 64

    init() {
      self = .kNumericDecimal
    }

  }

  struct LabelGeometry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var scale: Float {
      get {return _scale ?? 1}
      set {_scale = newValue}
    }
    /// Returns true if `scale` has been explicitly set.
    var hasScale: Bool {return self._scale != nil}
    /// Clears the value of `scale`. Subsequent reads from it will return its default value.
    mutating func clearScale() {self._scale = nil}

    var baselineOffset: Float {
      get {return _baselineOffset ?? 0}
      set {_baselineOffset = newValue}
    }
    /// Returns true if `baselineOffset` has been explicitly set.
    var hasBaselineOffset: Bool {return self._baselineOffset != nil}
    /// Clears the value of `baselineOffset`. Subsequent reads from it will return its default value.
    mutating func clearBaselineOffset() {self._baselineOffset = nil}

    var scaleWithText: Bool {
      get {return _scaleWithText ?? true}
      set {_scaleWithText = newValue}
    }
    /// Returns true if `scaleWithText` has been explicitly set.
    var hasScaleWithText: Bool {return self._scaleWithText != nil}
    /// Clears the value of `scaleWithText`. Subsequent reads from it will return its default value.
    mutating func clearScaleWithText() {self._scaleWithText = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _scale: Float? = nil
    fileprivate var _baselineOffset: Float? = nil
    fileprivate var _scaleWithText: Bool? = nil
  }

  struct LabelImage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var image: TSP_DataReference {
      get {return _image ?? TSP_DataReference()}
      set {_image = newValue}
    }
    /// Returns true if `image` has been explicitly set.
    var hasImage: Bool {return self._image != nil}
    /// Clears the value of `image`. Subsequent reads from it will return its default value.
    mutating func clearImage() {self._image = nil}

    var imageNull: Bool {
      get {return _imageNull ?? false}
      set {_imageNull = newValue}
    }
    /// Returns true if `imageNull` has been explicitly set.
    var hasImageNull: Bool {return self._imageNull != nil}
    /// Clears the value of `imageNull`. Subsequent reads from it will return its default value.
    mutating func clearImageNull() {self._imageNull = nil}

    var databaseImage: TSP_Reference {
      get {return _databaseImage ?? TSP_Reference()}
      set {_databaseImage = newValue}
    }
    /// Returns true if `databaseImage` has been explicitly set.
    var hasDatabaseImage: Bool {return self._databaseImage != nil}
    /// Clears the value of `databaseImage`. Subsequent reads from it will return its default value.
    mutating func clearDatabaseImage() {self._databaseImage = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _image: TSP_DataReference? = nil
    fileprivate var _imageNull: Bool? = nil
    fileprivate var _databaseImage: TSP_Reference? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_TextStylePresetArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var presetIdentifier: String {
    get {return _presetIdentifier ?? String()}
    set {_presetIdentifier = newValue}
  }
  /// Returns true if `presetIdentifier` has been explicitly set.
  var hasPresetIdentifier: Bool {return self._presetIdentifier != nil}
  /// Clears the value of `presetIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearPresetIdentifier() {self._presetIdentifier = nil}

  var paragraphStyle: TSP_Reference {
    get {return _paragraphStyle ?? TSP_Reference()}
    set {_paragraphStyle = newValue}
  }
  /// Returns true if `paragraphStyle` has been explicitly set.
  var hasParagraphStyle: Bool {return self._paragraphStyle != nil}
  /// Clears the value of `paragraphStyle`. Subsequent reads from it will return its default value.
  mutating func clearParagraphStyle() {self._paragraphStyle = nil}

  var listStyle: TSP_Reference {
    get {return _listStyle ?? TSP_Reference()}
    set {_listStyle = newValue}
  }
  /// Returns true if `listStyle` has been explicitly set.
  var hasListStyle: Bool {return self._listStyle != nil}
  /// Clears the value of `listStyle`. Subsequent reads from it will return its default value.
  mutating func clearListStyle() {self._listStyle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _presetIdentifier: String? = nil
  fileprivate var _paragraphStyle: TSP_Reference? = nil
  fileprivate var _listStyle: TSP_Reference? = nil
}

struct TSWP_ColumnsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var equalColumns: TSWP_ColumnsArchive.EqualColumnsArchive {
    get {return _equalColumns ?? TSWP_ColumnsArchive.EqualColumnsArchive()}
    set {_equalColumns = newValue}
  }
  /// Returns true if `equalColumns` has been explicitly set.
  var hasEqualColumns: Bool {return self._equalColumns != nil}
  /// Clears the value of `equalColumns`. Subsequent reads from it will return its default value.
  mutating func clearEqualColumns() {self._equalColumns = nil}

  var nonEqualColumns: TSWP_ColumnsArchive.NonEqualColumnsArchive {
    get {return _nonEqualColumns ?? TSWP_ColumnsArchive.NonEqualColumnsArchive()}
    set {_nonEqualColumns = newValue}
  }
  /// Returns true if `nonEqualColumns` has been explicitly set.
  var hasNonEqualColumns: Bool {return self._nonEqualColumns != nil}
  /// Clears the value of `nonEqualColumns`. Subsequent reads from it will return its default value.
  mutating func clearNonEqualColumns() {self._nonEqualColumns = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct EqualColumnsArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var count: UInt32 {
      get {return _count ?? 0}
      set {_count = newValue}
    }
    /// Returns true if `count` has been explicitly set.
    var hasCount: Bool {return self._count != nil}
    /// Clears the value of `count`. Subsequent reads from it will return its default value.
    mutating func clearCount() {self._count = nil}

    var gap: Float {
      get {return _gap ?? 0}
      set {_gap = newValue}
    }
    /// Returns true if `gap` has been explicitly set.
    var hasGap: Bool {return self._gap != nil}
    /// Clears the value of `gap`. Subsequent reads from it will return its default value.
    mutating func clearGap() {self._gap = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _count: UInt32? = nil
    fileprivate var _gap: Float? = nil
  }

  struct NonEqualColumnsArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var first: Float {
      get {return _first ?? 0}
      set {_first = newValue}
    }
    /// Returns true if `first` has been explicitly set.
    var hasFirst: Bool {return self._first != nil}
    /// Clears the value of `first`. Subsequent reads from it will return its default value.
    mutating func clearFirst() {self._first = nil}

    var following: [TSWP_ColumnsArchive.NonEqualColumnsArchive.GapWidthArchive] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct GapWidthArchive: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var gap: Float {
        get {return _gap ?? 0}
        set {_gap = newValue}
      }
      /// Returns true if `gap` has been explicitly set.
      var hasGap: Bool {return self._gap != nil}
      /// Clears the value of `gap`. Subsequent reads from it will return its default value.
      mutating func clearGap() {self._gap = nil}

      var width: Float {
        get {return _width ?? 0}
        set {_width = newValue}
      }
      /// Returns true if `width` has been explicitly set.
      var hasWidth: Bool {return self._width != nil}
      /// Clears the value of `width`. Subsequent reads from it will return its default value.
      mutating func clearWidth() {self._width = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _gap: Float? = nil
      fileprivate var _width: Float? = nil
    }

    init() {}

    fileprivate var _first: Float? = nil
  }

  init() {}

  fileprivate var _equalColumns: TSWP_ColumnsArchive.EqualColumnsArchive? = nil
  fileprivate var _nonEqualColumns: TSWP_ColumnsArchive.NonEqualColumnsArchive? = nil
}

struct TSWP_PaddingArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var left: Float {
    get {return _left ?? 0}
    set {_left = newValue}
  }
  /// Returns true if `left` has been explicitly set.
  var hasLeft: Bool {return self._left != nil}
  /// Clears the value of `left`. Subsequent reads from it will return its default value.
  mutating func clearLeft() {self._left = nil}

  var top: Float {
    get {return _top ?? 0}
    set {_top = newValue}
  }
  /// Returns true if `top` has been explicitly set.
  var hasTop: Bool {return self._top != nil}
  /// Clears the value of `top`. Subsequent reads from it will return its default value.
  mutating func clearTop() {self._top = nil}

  var right: Float {
    get {return _right ?? 0}
    set {_right = newValue}
  }
  /// Returns true if `right` has been explicitly set.
  var hasRight: Bool {return self._right != nil}
  /// Clears the value of `right`. Subsequent reads from it will return its default value.
  mutating func clearRight() {self._right = nil}

  var bottom: Float {
    get {return _bottom ?? 0}
    set {_bottom = newValue}
  }
  /// Returns true if `bottom` has been explicitly set.
  var hasBottom: Bool {return self._bottom != nil}
  /// Clears the value of `bottom`. Subsequent reads from it will return its default value.
  mutating func clearBottom() {self._bottom = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _left: Float? = nil
  fileprivate var _top: Float? = nil
  fileprivate var _right: Float? = nil
  fileprivate var _bottom: Float? = nil
}

struct TSWP_ColumnStylePropertiesArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var continuous: Bool {
    get {return _storage._continuous ?? false}
    set {_uniqueStorage()._continuous = newValue}
  }
  /// Returns true if `continuous` has been explicitly set.
  var hasContinuous: Bool {return _storage._continuous != nil}
  /// Clears the value of `continuous`. Subsequent reads from it will return its default value.
  mutating func clearContinuous() {_uniqueStorage()._continuous = nil}

  var shrinkToFit: Bool {
    get {return _storage._shrinkToFit ?? false}
    set {_uniqueStorage()._shrinkToFit = newValue}
  }
  /// Returns true if `shrinkToFit` has been explicitly set.
  var hasShrinkToFit: Bool {return _storage._shrinkToFit != nil}
  /// Clears the value of `shrinkToFit`. Subsequent reads from it will return its default value.
  mutating func clearShrinkToFit() {_uniqueStorage()._shrinkToFit = nil}

  var verticalText: Bool {
    get {return _storage._verticalText ?? false}
    set {_uniqueStorage()._verticalText = newValue}
  }
  /// Returns true if `verticalText` has been explicitly set.
  var hasVerticalText: Bool {return _storage._verticalText != nil}
  /// Clears the value of `verticalText`. Subsequent reads from it will return its default value.
  mutating func clearVerticalText() {_uniqueStorage()._verticalText = nil}

  var minHorizontalInset: Float {
    get {return _storage._minHorizontalInset ?? 0}
    set {_uniqueStorage()._minHorizontalInset = newValue}
  }
  /// Returns true if `minHorizontalInset` has been explicitly set.
  var hasMinHorizontalInset: Bool {return _storage._minHorizontalInset != nil}
  /// Clears the value of `minHorizontalInset`. Subsequent reads from it will return its default value.
  mutating func clearMinHorizontalInset() {_uniqueStorage()._minHorizontalInset = nil}

  var verticalAlignment: TSWP_ColumnStylePropertiesArchive.VerticalAlignmentType {
    get {return _storage._verticalAlignment ?? .kFrameAlignTop}
    set {_uniqueStorage()._verticalAlignment = newValue}
  }
  /// Returns true if `verticalAlignment` has been explicitly set.
  var hasVerticalAlignment: Bool {return _storage._verticalAlignment != nil}
  /// Clears the value of `verticalAlignment`. Subsequent reads from it will return its default value.
  mutating func clearVerticalAlignment() {_uniqueStorage()._verticalAlignment = nil}

  var columnsNull: Bool {
    get {return _storage._columnsNull ?? false}
    set {_uniqueStorage()._columnsNull = newValue}
  }
  /// Returns true if `columnsNull` has been explicitly set.
  var hasColumnsNull: Bool {return _storage._columnsNull != nil}
  /// Clears the value of `columnsNull`. Subsequent reads from it will return its default value.
  mutating func clearColumnsNull() {_uniqueStorage()._columnsNull = nil}

  var columns: TSWP_ColumnsArchive {
    get {return _storage._columns ?? TSWP_ColumnsArchive()}
    set {_uniqueStorage()._columns = newValue}
  }
  /// Returns true if `columns` has been explicitly set.
  var hasColumns: Bool {return _storage._columns != nil}
  /// Clears the value of `columns`. Subsequent reads from it will return its default value.
  mutating func clearColumns() {_uniqueStorage()._columns = nil}

  var marginsNull: Bool {
    get {return _storage._marginsNull ?? false}
    set {_uniqueStorage()._marginsNull = newValue}
  }
  /// Returns true if `marginsNull` has been explicitly set.
  var hasMarginsNull: Bool {return _storage._marginsNull != nil}
  /// Clears the value of `marginsNull`. Subsequent reads from it will return its default value.
  mutating func clearMarginsNull() {_uniqueStorage()._marginsNull = nil}

  var margins: TSWP_PaddingArchive {
    get {return _storage._margins ?? TSWP_PaddingArchive()}
    set {_uniqueStorage()._margins = newValue}
  }
  /// Returns true if `margins` has been explicitly set.
  var hasMargins: Bool {return _storage._margins != nil}
  /// Clears the value of `margins`. Subsequent reads from it will return its default value.
  mutating func clearMargins() {_uniqueStorage()._margins = nil}

  var paddingNull: Bool {
    get {return _storage._paddingNull ?? false}
    set {_uniqueStorage()._paddingNull = newValue}
  }
  /// Returns true if `paddingNull` has been explicitly set.
  var hasPaddingNull: Bool {return _storage._paddingNull != nil}
  /// Clears the value of `paddingNull`. Subsequent reads from it will return its default value.
  mutating func clearPaddingNull() {_uniqueStorage()._paddingNull = nil}

  var padding: TSWP_PaddingArchive {
    get {return _storage._padding ?? TSWP_PaddingArchive()}
    set {_uniqueStorage()._padding = newValue}
  }
  /// Returns true if `padding` has been explicitly set.
  var hasPadding: Bool {return _storage._padding != nil}
  /// Clears the value of `padding`. Subsequent reads from it will return its default value.
  mutating func clearPadding() {_uniqueStorage()._padding = nil}

  var writingDirection: TSWP_WritingDirectionType {
    get {return _storage._writingDirection ?? .kWritingDirectionNatural}
    set {_uniqueStorage()._writingDirection = newValue}
  }
  /// Returns true if `writingDirection` has been explicitly set.
  var hasWritingDirection: Bool {return _storage._writingDirection != nil}
  /// Clears the value of `writingDirection`. Subsequent reads from it will return its default value.
  mutating func clearWritingDirection() {_uniqueStorage()._writingDirection = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum VerticalAlignmentType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kFrameAlignTop = 0
    case kFrameAlignMiddle = 1
    case kFrameAlignBottom = 2
    case kFrameAlignJustify = 3

    init() {
      self = .kFrameAlignTop
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_ColumnStyleArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_StyleArchive {
    get {return _super ?? TSS_StyleArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var overrideCount: UInt32 {
    get {return _overrideCount ?? 0}
    set {_overrideCount = newValue}
  }
  /// Returns true if `overrideCount` has been explicitly set.
  var hasOverrideCount: Bool {return self._overrideCount != nil}
  /// Clears the value of `overrideCount`. Subsequent reads from it will return its default value.
  mutating func clearOverrideCount() {self._overrideCount = nil}

  var columnProperties: TSWP_ColumnStylePropertiesArchive {
    get {return _columnProperties ?? TSWP_ColumnStylePropertiesArchive()}
    set {_columnProperties = newValue}
  }
  /// Returns true if `columnProperties` has been explicitly set.
  var hasColumnProperties: Bool {return self._columnProperties != nil}
  /// Clears the value of `columnProperties`. Subsequent reads from it will return its default value.
  mutating func clearColumnProperties() {self._columnProperties = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSS_StyleArchive? = nil
  fileprivate var _overrideCount: UInt32? = nil
  fileprivate var _columnProperties: TSWP_ColumnStylePropertiesArchive? = nil
}

struct TSWP_ShapeStylePropertiesArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var shrinkToFit: Bool {
    get {return _storage._shrinkToFit ?? false}
    set {_uniqueStorage()._shrinkToFit = newValue}
  }
  /// Returns true if `shrinkToFit` has been explicitly set.
  var hasShrinkToFit: Bool {return _storage._shrinkToFit != nil}
  /// Clears the value of `shrinkToFit`. Subsequent reads from it will return its default value.
  mutating func clearShrinkToFit() {_uniqueStorage()._shrinkToFit = nil}

  var verticalAlignment: TSWP_ShapeStylePropertiesArchive.VerticalAlignmentType {
    get {return _storage._verticalAlignment ?? .kFrameAlignTop}
    set {_uniqueStorage()._verticalAlignment = newValue}
  }
  /// Returns true if `verticalAlignment` has been explicitly set.
  var hasVerticalAlignment: Bool {return _storage._verticalAlignment != nil}
  /// Clears the value of `verticalAlignment`. Subsequent reads from it will return its default value.
  mutating func clearVerticalAlignment() {_uniqueStorage()._verticalAlignment = nil}

  var columnsNull: Bool {
    get {return _storage._columnsNull ?? false}
    set {_uniqueStorage()._columnsNull = newValue}
  }
  /// Returns true if `columnsNull` has been explicitly set.
  var hasColumnsNull: Bool {return _storage._columnsNull != nil}
  /// Clears the value of `columnsNull`. Subsequent reads from it will return its default value.
  mutating func clearColumnsNull() {_uniqueStorage()._columnsNull = nil}

  var columns: TSWP_ColumnsArchive {
    get {return _storage._columns ?? TSWP_ColumnsArchive()}
    set {_uniqueStorage()._columns = newValue}
  }
  /// Returns true if `columns` has been explicitly set.
  var hasColumns: Bool {return _storage._columns != nil}
  /// Clears the value of `columns`. Subsequent reads from it will return its default value.
  mutating func clearColumns() {_uniqueStorage()._columns = nil}

  var paddingNull: Bool {
    get {return _storage._paddingNull ?? false}
    set {_uniqueStorage()._paddingNull = newValue}
  }
  /// Returns true if `paddingNull` has been explicitly set.
  var hasPaddingNull: Bool {return _storage._paddingNull != nil}
  /// Clears the value of `paddingNull`. Subsequent reads from it will return its default value.
  mutating func clearPaddingNull() {_uniqueStorage()._paddingNull = nil}

  var padding: TSWP_PaddingArchive {
    get {return _storage._padding ?? TSWP_PaddingArchive()}
    set {_uniqueStorage()._padding = newValue}
  }
  /// Returns true if `padding` has been explicitly set.
  var hasPadding: Bool {return _storage._padding != nil}
  /// Clears the value of `padding`. Subsequent reads from it will return its default value.
  mutating func clearPadding() {_uniqueStorage()._padding = nil}

  var defaultTextPresetIndex: UInt32 {
    get {return _storage._defaultTextPresetIndex ?? 0}
    set {_uniqueStorage()._defaultTextPresetIndex = newValue}
  }
  /// Returns true if `defaultTextPresetIndex` has been explicitly set.
  var hasDefaultTextPresetIndex: Bool {return _storage._defaultTextPresetIndex != nil}
  /// Clears the value of `defaultTextPresetIndex`. Subsequent reads from it will return its default value.
  mutating func clearDefaultTextPresetIndex() {_uniqueStorage()._defaultTextPresetIndex = nil}

  var verticalText: Bool {
    get {return _storage._verticalText ?? false}
    set {_uniqueStorage()._verticalText = newValue}
  }
  /// Returns true if `verticalText` has been explicitly set.
  var hasVerticalText: Bool {return _storage._verticalText != nil}
  /// Clears the value of `verticalText`. Subsequent reads from it will return its default value.
  mutating func clearVerticalText() {_uniqueStorage()._verticalText = nil}

  var paragraphStyleNull: Bool {
    get {return _storage._paragraphStyleNull ?? false}
    set {_uniqueStorage()._paragraphStyleNull = newValue}
  }
  /// Returns true if `paragraphStyleNull` has been explicitly set.
  var hasParagraphStyleNull: Bool {return _storage._paragraphStyleNull != nil}
  /// Clears the value of `paragraphStyleNull`. Subsequent reads from it will return its default value.
  mutating func clearParagraphStyleNull() {_uniqueStorage()._paragraphStyleNull = nil}

  var paragraphStyle: TSP_Reference {
    get {return _storage._paragraphStyle ?? TSP_Reference()}
    set {_uniqueStorage()._paragraphStyle = newValue}
  }
  /// Returns true if `paragraphStyle` has been explicitly set.
  var hasParagraphStyle: Bool {return _storage._paragraphStyle != nil}
  /// Clears the value of `paragraphStyle`. Subsequent reads from it will return its default value.
  mutating func clearParagraphStyle() {_uniqueStorage()._paragraphStyle = nil}

  var verticalText40: Bool {
    get {return _storage._verticalText40 ?? false}
    set {_uniqueStorage()._verticalText40 = newValue}
  }
  /// Returns true if `verticalText40` has been explicitly set.
  var hasVerticalText40: Bool {return _storage._verticalText40 != nil}
  /// Clears the value of `verticalText40`. Subsequent reads from it will return its default value.
  mutating func clearVerticalText40() {_uniqueStorage()._verticalText40 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum VerticalAlignmentType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kFrameAlignTop = 0
    case kFrameAlignMiddle = 1
    case kFrameAlignBottom = 2
    case kFrameAlignJustify = 3

    init() {
      self = .kFrameAlignTop
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_ShapeStyleArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_ShapeStyleArchive {
    get {return _super ?? TSD_ShapeStyleArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var overrideCount: UInt32 {
    get {return _overrideCount ?? 0}
    set {_overrideCount = newValue}
  }
  /// Returns true if `overrideCount` has been explicitly set.
  var hasOverrideCount: Bool {return self._overrideCount != nil}
  /// Clears the value of `overrideCount`. Subsequent reads from it will return its default value.
  mutating func clearOverrideCount() {self._overrideCount = nil}

  var shapeProperties: TSWP_ShapeStylePropertiesArchive {
    get {return _shapeProperties ?? TSWP_ShapeStylePropertiesArchive()}
    set {_shapeProperties = newValue}
  }
  /// Returns true if `shapeProperties` has been explicitly set.
  var hasShapeProperties: Bool {return self._shapeProperties != nil}
  /// Clears the value of `shapeProperties`. Subsequent reads from it will return its default value.
  mutating func clearShapeProperties() {self._shapeProperties = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_ShapeStyleArchive? = nil
  fileprivate var _overrideCount: UInt32? = nil
  fileprivate var _shapeProperties: TSWP_ShapeStylePropertiesArchive? = nil
}

struct TSWP_ThemePresetsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var listStylePresets: [TSP_Reference] = []

  var textStylePresets: [TSP_Reference] = []

  var importedTextStylePresets: [TSP_Reference] = []

  var tocEntryStylePresets: [TSP_Reference] = []

  var tocSettingsPresets: [TSP_Reference] = []

  var characterStylePresets: [TSP_Reference] = []

  var paragraphStylePresets: [TSP_Reference] = []

  var dropcapStylePresets: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSWP_TextPresetDisplayItemArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var preset: TSP_Reference {
    get {return _preset ?? TSP_Reference()}
    set {_preset = newValue}
  }
  /// Returns true if `preset` has been explicitly set.
  var hasPreset: Bool {return self._preset != nil}
  /// Clears the value of `preset`. Subsequent reads from it will return its default value.
  mutating func clearPreset() {self._preset = nil}

  var displayName: String {
    get {return _displayName ?? String()}
    set {_displayName = newValue}
  }
  /// Returns true if `displayName` has been explicitly set.
  var hasDisplayName: Bool {return self._displayName != nil}
  /// Clears the value of `displayName`. Subsequent reads from it will return its default value.
  mutating func clearDisplayName() {self._displayName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _preset: TSP_Reference? = nil
  fileprivate var _displayName: String? = nil
}

struct TSWP_TOCEntryStylePropertiesArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pageNumberStyleNull: Bool {
    get {return _pageNumberStyleNull ?? false}
    set {_pageNumberStyleNull = newValue}
  }
  /// Returns true if `pageNumberStyleNull` has been explicitly set.
  var hasPageNumberStyleNull: Bool {return self._pageNumberStyleNull != nil}
  /// Clears the value of `pageNumberStyleNull`. Subsequent reads from it will return its default value.
  mutating func clearPageNumberStyleNull() {self._pageNumberStyleNull = nil}

  var pageNumberStyle: TSP_Reference {
    get {return _pageNumberStyle ?? TSP_Reference()}
    set {_pageNumberStyle = newValue}
  }
  /// Returns true if `pageNumberStyle` has been explicitly set.
  var hasPageNumberStyle: Bool {return self._pageNumberStyle != nil}
  /// Clears the value of `pageNumberStyle`. Subsequent reads from it will return its default value.
  mutating func clearPageNumberStyle() {self._pageNumberStyle = nil}

  var showPageNumber: Bool {
    get {return _showPageNumber ?? false}
    set {_showPageNumber = newValue}
  }
  /// Returns true if `showPageNumber` has been explicitly set.
  var hasShowPageNumber: Bool {return self._showPageNumber != nil}
  /// Clears the value of `showPageNumber`. Subsequent reads from it will return its default value.
  mutating func clearShowPageNumber() {self._showPageNumber = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pageNumberStyleNull: Bool? = nil
  fileprivate var _pageNumberStyle: TSP_Reference? = nil
  fileprivate var _showPageNumber: Bool? = nil
}

struct TSWP_TOCEntryStyleArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_ParagraphStyleArchive {
    get {return _storage._super ?? TSWP_ParagraphStyleArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var tocProperties: TSWP_TOCEntryStylePropertiesArchive {
    get {return _storage._tocProperties ?? TSWP_TOCEntryStylePropertiesArchive()}
    set {_uniqueStorage()._tocProperties = newValue}
  }
  /// Returns true if `tocProperties` has been explicitly set.
  var hasTocProperties: Bool {return _storage._tocProperties != nil}
  /// Clears the value of `tocProperties`. Subsequent reads from it will return its default value.
  mutating func clearTocProperties() {_uniqueStorage()._tocProperties = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_TOCSettingsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tocName: String {
    get {return _tocName ?? String()}
    set {_tocName = newValue}
  }
  /// Returns true if `tocName` has been explicitly set.
  var hasTocName: Bool {return self._tocName != nil}
  /// Clears the value of `tocName`. Subsequent reads from it will return its default value.
  mutating func clearTocName() {self._tocName = nil}

  var tocScope: UInt32 {
    get {return _tocScope ?? 0}
    set {_tocScope = newValue}
  }
  /// Returns true if `tocScope` has been explicitly set.
  var hasTocScope: Bool {return self._tocScope != nil}
  /// Clears the value of `tocScope`. Subsequent reads from it will return its default value.
  mutating func clearTocScope() {self._tocScope = nil}

  var entries: [TSWP_TOCSettingsArchive.TOCEntryData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct TOCEntryData: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var paragraphStyle: TSP_Reference {
      get {return _paragraphStyle ?? TSP_Reference()}
      set {_paragraphStyle = newValue}
    }
    /// Returns true if `paragraphStyle` has been explicitly set.
    var hasParagraphStyle: Bool {return self._paragraphStyle != nil}
    /// Clears the value of `paragraphStyle`. Subsequent reads from it will return its default value.
    mutating func clearParagraphStyle() {self._paragraphStyle = nil}

    var tocEntryStyle: TSP_Reference {
      get {return _tocEntryStyle ?? TSP_Reference()}
      set {_tocEntryStyle = newValue}
    }
    /// Returns true if `tocEntryStyle` has been explicitly set.
    var hasTocEntryStyle: Bool {return self._tocEntryStyle != nil}
    /// Clears the value of `tocEntryStyle`. Subsequent reads from it will return its default value.
    mutating func clearTocEntryStyle() {self._tocEntryStyle = nil}

    var showInToc: Bool {
      get {return _showInToc ?? false}
      set {_showInToc = newValue}
    }
    /// Returns true if `showInToc` has been explicitly set.
    var hasShowInToc: Bool {return self._showInToc != nil}
    /// Clears the value of `showInToc`. Subsequent reads from it will return its default value.
    mutating func clearShowInToc() {self._showInToc = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _paragraphStyle: TSP_Reference? = nil
    fileprivate var _tocEntryStyle: TSP_Reference? = nil
    fileprivate var _showInToc: Bool? = nil
  }

  init() {}

  fileprivate var _tocName: String? = nil
  fileprivate var _tocScope: UInt32? = nil
}

struct TSWP_TOCEntryInstanceArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var paragraphIndex: UInt32 {
    get {return _paragraphIndex ?? 0}
    set {_paragraphIndex = newValue}
  }
  /// Returns true if `paragraphIndex` has been explicitly set.
  var hasParagraphIndex: Bool {return self._paragraphIndex != nil}
  /// Clears the value of `paragraphIndex`. Subsequent reads from it will return its default value.
  mutating func clearParagraphIndex() {self._paragraphIndex = nil}

  var pageNumber: UInt32 {
    get {return _pageNumber ?? 0}
    set {_pageNumber = newValue}
  }
  /// Returns true if `pageNumber` has been explicitly set.
  var hasPageNumber: Bool {return self._pageNumber != nil}
  /// Clears the value of `pageNumber`. Subsequent reads from it will return its default value.
  mutating func clearPageNumber() {self._pageNumber = nil}

  var numberFormat: UInt32 {
    get {return _numberFormat ?? 0}
    set {_numberFormat = newValue}
  }
  /// Returns true if `numberFormat` has been explicitly set.
  var hasNumberFormat: Bool {return self._numberFormat != nil}
  /// Clears the value of `numberFormat`. Subsequent reads from it will return its default value.
  mutating func clearNumberFormat() {self._numberFormat = nil}

  var heading: String {
    get {return _heading ?? String()}
    set {_heading = newValue}
  }
  /// Returns true if `heading` has been explicitly set.
  var hasHeading: Bool {return self._heading != nil}
  /// Clears the value of `heading`. Subsequent reads from it will return its default value.
  mutating func clearHeading() {self._heading = nil}

  var indexedStyle: TSP_Reference {
    get {return _indexedStyle ?? TSP_Reference()}
    set {_indexedStyle = newValue}
  }
  /// Returns true if `indexedStyle` has been explicitly set.
  var hasIndexedStyle: Bool {return self._indexedStyle != nil}
  /// Clears the value of `indexedStyle`. Subsequent reads from it will return its default value.
  mutating func clearIndexedStyle() {self._indexedStyle = nil}

  var indexedListStyle: TSP_Reference {
    get {return _indexedListStyle ?? TSP_Reference()}
    set {_indexedListStyle = newValue}
  }
  /// Returns true if `indexedListStyle` has been explicitly set.
  var hasIndexedListStyle: Bool {return self._indexedListStyle != nil}
  /// Clears the value of `indexedListStyle`. Subsequent reads from it will return its default value.
  mutating func clearIndexedListStyle() {self._indexedListStyle = nil}

  var indexedListStart: UInt32 {
    get {return _indexedListStart ?? 0}
    set {_indexedListStart = newValue}
  }
  /// Returns true if `indexedListStart` has been explicitly set.
  var hasIndexedListStart: Bool {return self._indexedListStart != nil}
  /// Clears the value of `indexedListStart`. Subsequent reads from it will return its default value.
  mutating func clearIndexedListStart() {self._indexedListStart = nil}

  var indexedParagraphLevel: UInt32 {
    get {return _indexedParagraphLevel ?? 0}
    set {_indexedParagraphLevel = newValue}
  }
  /// Returns true if `indexedParagraphLevel` has been explicitly set.
  var hasIndexedParagraphLevel: Bool {return self._indexedParagraphLevel != nil}
  /// Clears the value of `indexedParagraphLevel`. Subsequent reads from it will return its default value.
  mutating func clearIndexedParagraphLevel() {self._indexedParagraphLevel = nil}

  var numberFormatName: String {
    get {return _numberFormatName ?? String()}
    set {_numberFormatName = newValue}
  }
  /// Returns true if `numberFormatName` has been explicitly set.
  var hasNumberFormatName: Bool {return self._numberFormatName != nil}
  /// Clears the value of `numberFormatName`. Subsequent reads from it will return its default value.
  mutating func clearNumberFormatName() {self._numberFormatName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _paragraphIndex: UInt32? = nil
  fileprivate var _pageNumber: UInt32? = nil
  fileprivate var _numberFormat: UInt32? = nil
  fileprivate var _heading: String? = nil
  fileprivate var _indexedStyle: TSP_Reference? = nil
  fileprivate var _indexedListStyle: TSP_Reference? = nil
  fileprivate var _indexedListStart: UInt32? = nil
  fileprivate var _indexedParagraphLevel: UInt32? = nil
  fileprivate var _numberFormatName: String? = nil
}

struct TSWP_UndoTransaction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [TSWP_UndoTransaction.UnionTransaction] = []

  var groupEntries: [TSWP_UndoTransaction.StorageActionGroup] = []

  var flags: UInt32 {
    get {return _flags ?? 0}
    set {_flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  var hasFlags: Bool {return self._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  mutating func clearFlags() {self._flags = nil}

  var version: UInt32 {
    get {return _version ?? 0}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum UndoKind: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case replaceText = 1
    case insertAttribute = 2
    case deleteAttribute = 3
    case adjustCharIndexes = 4
    case comprAdjustCharIndexes = 5
    case replaceCharIndex = 6
    case replaceObject = 7
    case replaceParagraphData = 8
    case objectDolc = 9
    case ctDate = 10

    init() {
      self = .replaceText
    }

  }

  enum ActionKind: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case actionUndefined = 0
    case actionText = 1
    case actionAttribute = 2

    init() {
      self = .actionUndefined
    }

  }

  enum ActionGroupKind: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case actionGroupUndefined = 0
    case actionGroupText = 1
    case actionGroupAttribute = 2

    init() {
      self = .actionGroupUndefined
    }

  }

  struct GenericTransaction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value1: UInt32 {
      get {return _value1 ?? 0}
      set {_value1 = newValue}
    }
    /// Returns true if `value1` has been explicitly set.
    var hasValue1: Bool {return self._value1 != nil}
    /// Clears the value of `value1`. Subsequent reads from it will return its default value.
    mutating func clearValue1() {self._value1 = nil}

    var value2: UInt32 {
      get {return _value2 ?? 0}
      set {_value2 = newValue}
    }
    /// Returns true if `value2` has been explicitly set.
    var hasValue2: Bool {return self._value2 != nil}
    /// Clears the value of `value2`. Subsequent reads from it will return its default value.
    mutating func clearValue2() {self._value2 = nil}

    var value3: UInt32 {
      get {return _value3 ?? 0}
      set {_value3 = newValue}
    }
    /// Returns true if `value3` has been explicitly set.
    var hasValue3: Bool {return self._value3 != nil}
    /// Clears the value of `value3`. Subsequent reads from it will return its default value.
    mutating func clearValue3() {self._value3 = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _value1: UInt32? = nil
    fileprivate var _value2: UInt32? = nil
    fileprivate var _value3: UInt32? = nil
  }

  struct TextTransaction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var insertLocation: UInt32 {
      get {return _insertLocation ?? 0}
      set {_insertLocation = newValue}
    }
    /// Returns true if `insertLocation` has been explicitly set.
    var hasInsertLocation: Bool {return self._insertLocation != nil}
    /// Clears the value of `insertLocation`. Subsequent reads from it will return its default value.
    mutating func clearInsertLocation() {self._insertLocation = nil}

    var insertLength: UInt32 {
      get {return _insertLength ?? 0}
      set {_insertLength = newValue}
    }
    /// Returns true if `insertLength` has been explicitly set.
    var hasInsertLength: Bool {return self._insertLength != nil}
    /// Clears the value of `insertLength`. Subsequent reads from it will return its default value.
    mutating func clearInsertLength() {self._insertLength = nil}

    var stringToDelete: String {
      get {return _stringToDelete ?? String()}
      set {_stringToDelete = newValue}
    }
    /// Returns true if `stringToDelete` has been explicitly set.
    var hasStringToDelete: Bool {return self._stringToDelete != nil}
    /// Clears the value of `stringToDelete`. Subsequent reads from it will return its default value.
    mutating func clearStringToDelete() {self._stringToDelete = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _insertLocation: UInt32? = nil
    fileprivate var _insertLength: UInt32? = nil
    fileprivate var _stringToDelete: String? = nil
  }

  struct CharIndexTransaction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var charIndex: UInt32 {
      get {return _charIndex ?? 0}
      set {_charIndex = newValue}
    }
    /// Returns true if `charIndex` has been explicitly set.
    var hasCharIndex: Bool {return self._charIndex != nil}
    /// Clears the value of `charIndex`. Subsequent reads from it will return its default value.
    mutating func clearCharIndex() {self._charIndex = nil}

    var count: UInt32 {
      get {return _count ?? 0}
      set {_count = newValue}
    }
    /// Returns true if `count` has been explicitly set.
    var hasCount: Bool {return self._count != nil}
    /// Clears the value of `count`. Subsequent reads from it will return its default value.
    mutating func clearCount() {self._count = nil}

    var object: TSP_Reference {
      get {return _object ?? TSP_Reference()}
      set {_object = newValue}
    }
    /// Returns true if `object` has been explicitly set.
    var hasObject: Bool {return self._object != nil}
    /// Clears the value of `object`. Subsequent reads from it will return its default value.
    mutating func clearObject() {self._object = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _charIndex: UInt32? = nil
    fileprivate var _count: UInt32? = nil
    fileprivate var _object: TSP_Reference? = nil
  }

  struct ReplaceCharIndexTransaction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var attributeIndex: UInt32 {
      get {return _attributeIndex ?? 0}
      set {_attributeIndex = newValue}
    }
    /// Returns true if `attributeIndex` has been explicitly set.
    var hasAttributeIndex: Bool {return self._attributeIndex != nil}
    /// Clears the value of `attributeIndex`. Subsequent reads from it will return its default value.
    mutating func clearAttributeIndex() {self._attributeIndex = nil}

    var charIndex: UInt32 {
      get {return _charIndex ?? 0}
      set {_charIndex = newValue}
    }
    /// Returns true if `charIndex` has been explicitly set.
    var hasCharIndex: Bool {return self._charIndex != nil}
    /// Clears the value of `charIndex`. Subsequent reads from it will return its default value.
    mutating func clearCharIndex() {self._charIndex = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _attributeIndex: UInt32? = nil
    fileprivate var _charIndex: UInt32? = nil
  }

  struct AttributeIndexTransaction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var attributeIndex: UInt32 {
      get {return _attributeIndex ?? 0}
      set {_attributeIndex = newValue}
    }
    /// Returns true if `attributeIndex` has been explicitly set.
    var hasAttributeIndex: Bool {return self._attributeIndex != nil}
    /// Clears the value of `attributeIndex`. Subsequent reads from it will return its default value.
    mutating func clearAttributeIndex() {self._attributeIndex = nil}

    var charIndex: UInt32 {
      get {return _charIndex ?? 0}
      set {_charIndex = newValue}
    }
    /// Returns true if `charIndex` has been explicitly set.
    var hasCharIndex: Bool {return self._charIndex != nil}
    /// Clears the value of `charIndex`. Subsequent reads from it will return its default value.
    mutating func clearCharIndex() {self._charIndex = nil}

    var object: TSP_Reference {
      get {return _object ?? TSP_Reference()}
      set {_object = newValue}
    }
    /// Returns true if `object` has been explicitly set.
    var hasObject: Bool {return self._object != nil}
    /// Clears the value of `object`. Subsequent reads from it will return its default value.
    mutating func clearObject() {self._object = nil}

    var string: String {
      get {return _string ?? String()}
      set {_string = newValue}
    }
    /// Returns true if `string` has been explicitly set.
    var hasString: Bool {return self._string != nil}
    /// Clears the value of `string`. Subsequent reads from it will return its default value.
    mutating func clearString() {self._string = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _attributeIndex: UInt32? = nil
    fileprivate var _charIndex: UInt32? = nil
    fileprivate var _object: TSP_Reference? = nil
    fileprivate var _string: String? = nil
  }

  struct InsertAttributeTransaction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var attributeIndex: UInt32 {
      get {return _attributeIndex ?? 0}
      set {_attributeIndex = newValue}
    }
    /// Returns true if `attributeIndex` has been explicitly set.
    var hasAttributeIndex: Bool {return self._attributeIndex != nil}
    /// Clears the value of `attributeIndex`. Subsequent reads from it will return its default value.
    mutating func clearAttributeIndex() {self._attributeIndex = nil}

    var attributeCount: UInt32 {
      get {return _attributeCount ?? 0}
      set {_attributeCount = newValue}
    }
    /// Returns true if `attributeCount` has been explicitly set.
    var hasAttributeCount: Bool {return self._attributeCount != nil}
    /// Clears the value of `attributeCount`. Subsequent reads from it will return its default value.
    mutating func clearAttributeCount() {self._attributeCount = nil}

    var object: TSP_Reference {
      get {return _object ?? TSP_Reference()}
      set {_object = newValue}
    }
    /// Returns true if `object` has been explicitly set.
    var hasObject: Bool {return self._object != nil}
    /// Clears the value of `object`. Subsequent reads from it will return its default value.
    mutating func clearObject() {self._object = nil}

    var string: String {
      get {return _string ?? String()}
      set {_string = newValue}
    }
    /// Returns true if `string` has been explicitly set.
    var hasString: Bool {return self._string != nil}
    /// Clears the value of `string`. Subsequent reads from it will return its default value.
    mutating func clearString() {self._string = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _attributeIndex: UInt32? = nil
    fileprivate var _attributeCount: UInt32? = nil
    fileprivate var _object: TSP_Reference? = nil
    fileprivate var _string: String? = nil
  }

  struct InsertNilTransaction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var attributeIndex: UInt32 {
      get {return _attributeIndex ?? 0}
      set {_attributeIndex = newValue}
    }
    /// Returns true if `attributeIndex` has been explicitly set.
    var hasAttributeIndex: Bool {return self._attributeIndex != nil}
    /// Clears the value of `attributeIndex`. Subsequent reads from it will return its default value.
    mutating func clearAttributeIndex() {self._attributeIndex = nil}

    var attributeCount: UInt32 {
      get {return _attributeCount ?? 0}
      set {_attributeCount = newValue}
    }
    /// Returns true if `attributeCount` has been explicitly set.
    var hasAttributeCount: Bool {return self._attributeCount != nil}
    /// Clears the value of `attributeCount`. Subsequent reads from it will return its default value.
    mutating func clearAttributeCount() {self._attributeCount = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _attributeIndex: UInt32? = nil
    fileprivate var _attributeCount: UInt32? = nil
  }

  struct CharDeltaTransaction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var charIndex: UInt32 {
      get {return _charIndex ?? 0}
      set {_charIndex = newValue}
    }
    /// Returns true if `charIndex` has been explicitly set.
    var hasCharIndex: Bool {return self._charIndex != nil}
    /// Clears the value of `charIndex`. Subsequent reads from it will return its default value.
    mutating func clearCharIndex() {self._charIndex = nil}

    var attributeIndex: UInt32 {
      get {return _attributeIndex ?? 0}
      set {_attributeIndex = newValue}
    }
    /// Returns true if `attributeIndex` has been explicitly set.
    var hasAttributeIndex: Bool {return self._attributeIndex != nil}
    /// Clears the value of `attributeIndex`. Subsequent reads from it will return its default value.
    mutating func clearAttributeIndex() {self._attributeIndex = nil}

    var charDelta: Int32 {
      get {return _charDelta ?? 0}
      set {_charDelta = newValue}
    }
    /// Returns true if `charDelta` has been explicitly set.
    var hasCharDelta: Bool {return self._charDelta != nil}
    /// Clears the value of `charDelta`. Subsequent reads from it will return its default value.
    mutating func clearCharDelta() {self._charDelta = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _charIndex: UInt32? = nil
    fileprivate var _attributeIndex: UInt32? = nil
    fileprivate var _charDelta: Int32? = nil
  }

  struct ParagraphDataTransaction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var attributeIndex: UInt32 {
      get {return _attributeIndex ?? 0}
      set {_attributeIndex = newValue}
    }
    /// Returns true if `attributeIndex` has been explicitly set.
    var hasAttributeIndex: Bool {return self._attributeIndex != nil}
    /// Clears the value of `attributeIndex`. Subsequent reads from it will return its default value.
    mutating func clearAttributeIndex() {self._attributeIndex = nil}

    var first: UInt32 {
      get {return _first ?? 0}
      set {_first = newValue}
    }
    /// Returns true if `first` has been explicitly set.
    var hasFirst: Bool {return self._first != nil}
    /// Clears the value of `first`. Subsequent reads from it will return its default value.
    mutating func clearFirst() {self._first = nil}

    var second: UInt32 {
      get {return _second ?? 0}
      set {_second = newValue}
    }
    /// Returns true if `second` has been explicitly set.
    var hasSecond: Bool {return self._second != nil}
    /// Clears the value of `second`. Subsequent reads from it will return its default value.
    mutating func clearSecond() {self._second = nil}

    var charIndex: UInt32 {
      get {return _charIndex ?? 0}
      set {_charIndex = newValue}
    }
    /// Returns true if `charIndex` has been explicitly set.
    var hasCharIndex: Bool {return self._charIndex != nil}
    /// Clears the value of `charIndex`. Subsequent reads from it will return its default value.
    mutating func clearCharIndex() {self._charIndex = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _attributeIndex: UInt32? = nil
    fileprivate var _first: UInt32? = nil
    fileprivate var _second: UInt32? = nil
    fileprivate var _charIndex: UInt32? = nil
  }

  struct ObjectDOLCTransaction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var flags: UInt32 {
      get {return _flags ?? 0}
      set {_flags = newValue}
    }
    /// Returns true if `flags` has been explicitly set.
    var hasFlags: Bool {return self._flags != nil}
    /// Clears the value of `flags`. Subsequent reads from it will return its default value.
    mutating func clearFlags() {self._flags = nil}

    var object: TSP_Reference {
      get {return _object ?? TSP_Reference()}
      set {_object = newValue}
    }
    /// Returns true if `object` has been explicitly set.
    var hasObject: Bool {return self._object != nil}
    /// Clears the value of `object`. Subsequent reads from it will return its default value.
    mutating func clearObject() {self._object = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _flags: UInt32? = nil
    fileprivate var _object: TSP_Reference? = nil
  }

  struct CTDateTransaction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var attributeIndex: UInt32 {
      get {return _attributeIndex ?? 0}
      set {_attributeIndex = newValue}
    }
    /// Returns true if `attributeIndex` has been explicitly set.
    var hasAttributeIndex: Bool {return self._attributeIndex != nil}
    /// Clears the value of `attributeIndex`. Subsequent reads from it will return its default value.
    mutating func clearAttributeIndex() {self._attributeIndex = nil}

    var date: TSP_Date {
      get {return _date ?? TSP_Date()}
      set {_date = newValue}
    }
    /// Returns true if `date` has been explicitly set.
    var hasDate: Bool {return self._date != nil}
    /// Clears the value of `date`. Subsequent reads from it will return its default value.
    mutating func clearDate() {self._date = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _attributeIndex: UInt32? = nil
    fileprivate var _date: TSP_Date? = nil
  }

  struct UnionTransaction: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var kind: TSWP_UndoTransaction.UndoKind {
      get {return _storage._kind ?? .replaceText}
      set {_uniqueStorage()._kind = newValue}
    }
    /// Returns true if `kind` has been explicitly set.
    var hasKind: Bool {return _storage._kind != nil}
    /// Clears the value of `kind`. Subsequent reads from it will return its default value.
    mutating func clearKind() {_uniqueStorage()._kind = nil}

    var table: UInt32 {
      get {return _storage._table ?? 0}
      set {_uniqueStorage()._table = newValue}
    }
    /// Returns true if `table` has been explicitly set.
    var hasTable: Bool {return _storage._table != nil}
    /// Clears the value of `table`. Subsequent reads from it will return its default value.
    mutating func clearTable() {_uniqueStorage()._table = nil}

    var generic: TSWP_UndoTransaction.GenericTransaction {
      get {return _storage._generic ?? TSWP_UndoTransaction.GenericTransaction()}
      set {_uniqueStorage()._generic = newValue}
    }
    /// Returns true if `generic` has been explicitly set.
    var hasGeneric: Bool {return _storage._generic != nil}
    /// Clears the value of `generic`. Subsequent reads from it will return its default value.
    mutating func clearGeneric() {_uniqueStorage()._generic = nil}

    var text: TSWP_UndoTransaction.TextTransaction {
      get {return _storage._text ?? TSWP_UndoTransaction.TextTransaction()}
      set {_uniqueStorage()._text = newValue}
    }
    /// Returns true if `text` has been explicitly set.
    var hasText: Bool {return _storage._text != nil}
    /// Clears the value of `text`. Subsequent reads from it will return its default value.
    mutating func clearText() {_uniqueStorage()._text = nil}

    var charIndex: TSWP_UndoTransaction.CharIndexTransaction {
      get {return _storage._charIndex ?? TSWP_UndoTransaction.CharIndexTransaction()}
      set {_uniqueStorage()._charIndex = newValue}
    }
    /// Returns true if `charIndex` has been explicitly set.
    var hasCharIndex: Bool {return _storage._charIndex != nil}
    /// Clears the value of `charIndex`. Subsequent reads from it will return its default value.
    mutating func clearCharIndex() {_uniqueStorage()._charIndex = nil}

    var replaceCharIndex: TSWP_UndoTransaction.ReplaceCharIndexTransaction {
      get {return _storage._replaceCharIndex ?? TSWP_UndoTransaction.ReplaceCharIndexTransaction()}
      set {_uniqueStorage()._replaceCharIndex = newValue}
    }
    /// Returns true if `replaceCharIndex` has been explicitly set.
    var hasReplaceCharIndex: Bool {return _storage._replaceCharIndex != nil}
    /// Clears the value of `replaceCharIndex`. Subsequent reads from it will return its default value.
    mutating func clearReplaceCharIndex() {_uniqueStorage()._replaceCharIndex = nil}

    var attributeIndex: TSWP_UndoTransaction.AttributeIndexTransaction {
      get {return _storage._attributeIndex ?? TSWP_UndoTransaction.AttributeIndexTransaction()}
      set {_uniqueStorage()._attributeIndex = newValue}
    }
    /// Returns true if `attributeIndex` has been explicitly set.
    var hasAttributeIndex: Bool {return _storage._attributeIndex != nil}
    /// Clears the value of `attributeIndex`. Subsequent reads from it will return its default value.
    mutating func clearAttributeIndex() {_uniqueStorage()._attributeIndex = nil}

    var insertNil: TSWP_UndoTransaction.InsertNilTransaction {
      get {return _storage._insertNil ?? TSWP_UndoTransaction.InsertNilTransaction()}
      set {_uniqueStorage()._insertNil = newValue}
    }
    /// Returns true if `insertNil` has been explicitly set.
    var hasInsertNil: Bool {return _storage._insertNil != nil}
    /// Clears the value of `insertNil`. Subsequent reads from it will return its default value.
    mutating func clearInsertNil() {_uniqueStorage()._insertNil = nil}

    var insertAttribute: TSWP_UndoTransaction.InsertAttributeTransaction {
      get {return _storage._insertAttribute ?? TSWP_UndoTransaction.InsertAttributeTransaction()}
      set {_uniqueStorage()._insertAttribute = newValue}
    }
    /// Returns true if `insertAttribute` has been explicitly set.
    var hasInsertAttribute: Bool {return _storage._insertAttribute != nil}
    /// Clears the value of `insertAttribute`. Subsequent reads from it will return its default value.
    mutating func clearInsertAttribute() {_uniqueStorage()._insertAttribute = nil}

    var charDelta: TSWP_UndoTransaction.CharDeltaTransaction {
      get {return _storage._charDelta ?? TSWP_UndoTransaction.CharDeltaTransaction()}
      set {_uniqueStorage()._charDelta = newValue}
    }
    /// Returns true if `charDelta` has been explicitly set.
    var hasCharDelta: Bool {return _storage._charDelta != nil}
    /// Clears the value of `charDelta`. Subsequent reads from it will return its default value.
    mutating func clearCharDelta() {_uniqueStorage()._charDelta = nil}

    var paragraphData: TSWP_UndoTransaction.ParagraphDataTransaction {
      get {return _storage._paragraphData ?? TSWP_UndoTransaction.ParagraphDataTransaction()}
      set {_uniqueStorage()._paragraphData = newValue}
    }
    /// Returns true if `paragraphData` has been explicitly set.
    var hasParagraphData: Bool {return _storage._paragraphData != nil}
    /// Clears the value of `paragraphData`. Subsequent reads from it will return its default value.
    mutating func clearParagraphData() {_uniqueStorage()._paragraphData = nil}

    var objectDolc: TSWP_UndoTransaction.ObjectDOLCTransaction {
      get {return _storage._objectDolc ?? TSWP_UndoTransaction.ObjectDOLCTransaction()}
      set {_uniqueStorage()._objectDolc = newValue}
    }
    /// Returns true if `objectDolc` has been explicitly set.
    var hasObjectDolc: Bool {return _storage._objectDolc != nil}
    /// Clears the value of `objectDolc`. Subsequent reads from it will return its default value.
    mutating func clearObjectDolc() {_uniqueStorage()._objectDolc = nil}

    var ctDate: TSWP_UndoTransaction.CTDateTransaction {
      get {return _storage._ctDate ?? TSWP_UndoTransaction.CTDateTransaction()}
      set {_uniqueStorage()._ctDate = newValue}
    }
    /// Returns true if `ctDate` has been explicitly set.
    var hasCtDate: Bool {return _storage._ctDate != nil}
    /// Clears the value of `ctDate`. Subsequent reads from it will return its default value.
    mutating func clearCtDate() {_uniqueStorage()._ctDate = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct StorageAction: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var kind: TSWP_UndoTransaction.ActionKind {
      get {return _storage._kind ?? .actionUndefined}
      set {_uniqueStorage()._kind = newValue}
    }
    /// Returns true if `kind` has been explicitly set.
    var hasKind: Bool {return _storage._kind != nil}
    /// Clears the value of `kind`. Subsequent reads from it will return its default value.
    mutating func clearKind() {_uniqueStorage()._kind = nil}

    var flags: UInt32 {
      get {return _storage._flags ?? 0}
      set {_uniqueStorage()._flags = newValue}
    }
    /// Returns true if `flags` has been explicitly set.
    var hasFlags: Bool {return _storage._flags != nil}
    /// Clears the value of `flags`. Subsequent reads from it will return its default value.
    mutating func clearFlags() {_uniqueStorage()._flags = nil}

    var table: UInt32 {
      get {return _storage._table ?? 0}
      set {_uniqueStorage()._table = newValue}
    }
    /// Returns true if `table` has been explicitly set.
    var hasTable: Bool {return _storage._table != nil}
    /// Clears the value of `table`. Subsequent reads from it will return its default value.
    mutating func clearTable() {_uniqueStorage()._table = nil}

    var range: TSP_Range {
      get {return _storage._range ?? TSP_Range()}
      set {_uniqueStorage()._range = newValue}
    }
    /// Returns true if `range` has been explicitly set.
    var hasRange: Bool {return _storage._range != nil}
    /// Clears the value of `range`. Subsequent reads from it will return its default value.
    mutating func clearRange() {_uniqueStorage()._range = nil}

    var string: String {
      get {return _storage._string ?? String()}
      set {_uniqueStorage()._string = newValue}
    }
    /// Returns true if `string` has been explicitly set.
    var hasString: Bool {return _storage._string != nil}
    /// Clears the value of `string`. Subsequent reads from it will return its default value.
    mutating func clearString() {_uniqueStorage()._string = nil}

    var object: TSP_Reference {
      get {return _storage._object ?? TSP_Reference()}
      set {_uniqueStorage()._object = newValue}
    }
    /// Returns true if `object` has been explicitly set.
    var hasObject: Bool {return _storage._object != nil}
    /// Clears the value of `object`. Subsequent reads from it will return its default value.
    mutating func clearObject() {_uniqueStorage()._object = nil}

    var date: TSP_Date {
      get {return _storage._date ?? TSP_Date()}
      set {_uniqueStorage()._date = newValue}
    }
    /// Returns true if `date` has been explicitly set.
    var hasDate: Bool {return _storage._date != nil}
    /// Clears the value of `date`. Subsequent reads from it will return its default value.
    mutating func clearDate() {_uniqueStorage()._date = nil}

    var paragraphLevel: UInt32 {
      get {return _storage._paragraphLevel ?? 0}
      set {_uniqueStorage()._paragraphLevel = newValue}
    }
    /// Returns true if `paragraphLevel` has been explicitly set.
    var hasParagraphLevel: Bool {return _storage._paragraphLevel != nil}
    /// Clears the value of `paragraphLevel`. Subsequent reads from it will return its default value.
    mutating func clearParagraphLevel() {_uniqueStorage()._paragraphLevel = nil}

    var paragraphFlags: UInt32 {
      get {return _storage._paragraphFlags ?? 0}
      set {_uniqueStorage()._paragraphFlags = newValue}
    }
    /// Returns true if `paragraphFlags` has been explicitly set.
    var hasParagraphFlags: Bool {return _storage._paragraphFlags != nil}
    /// Clears the value of `paragraphFlags`. Subsequent reads from it will return its default value.
    mutating func clearParagraphFlags() {_uniqueStorage()._paragraphFlags = nil}

    var paragraphValue: UInt32 {
      get {return _storage._paragraphValue ?? 0}
      set {_uniqueStorage()._paragraphValue = newValue}
    }
    /// Returns true if `paragraphValue` has been explicitly set.
    var hasParagraphValue: Bool {return _storage._paragraphValue != nil}
    /// Clears the value of `paragraphValue`. Subsequent reads from it will return its default value.
    mutating func clearParagraphValue() {_uniqueStorage()._paragraphValue = nil}

    var placementIndex: Int32 {
      get {return _storage._placementIndex ?? 0}
      set {_uniqueStorage()._placementIndex = newValue}
    }
    /// Returns true if `placementIndex` has been explicitly set.
    var hasPlacementIndex: Bool {return _storage._placementIndex != nil}
    /// Clears the value of `placementIndex`. Subsequent reads from it will return its default value.
    mutating func clearPlacementIndex() {_uniqueStorage()._placementIndex = nil}

    var placementUuidPath: String {
      get {return _storage._placementUuidPath ?? String()}
      set {_uniqueStorage()._placementUuidPath = newValue}
    }
    /// Returns true if `placementUuidPath` has been explicitly set.
    var hasPlacementUuidPath: Bool {return _storage._placementUuidPath != nil}
    /// Clears the value of `placementUuidPath`. Subsequent reads from it will return its default value.
    mutating func clearPlacementUuidPath() {_uniqueStorage()._placementUuidPath = nil}

    var undoObject: TSP_Reference {
      get {return _storage._undoObject ?? TSP_Reference()}
      set {_uniqueStorage()._undoObject = newValue}
    }
    /// Returns true if `undoObject` has been explicitly set.
    var hasUndoObject: Bool {return _storage._undoObject != nil}
    /// Clears the value of `undoObject`. Subsequent reads from it will return its default value.
    mutating func clearUndoObject() {_uniqueStorage()._undoObject = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct StorageActionGroup: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var kind: TSWP_UndoTransaction.ActionGroupKind {
      get {return _kind ?? .actionGroupUndefined}
      set {_kind = newValue}
    }
    /// Returns true if `kind` has been explicitly set.
    var hasKind: Bool {return self._kind != nil}
    /// Clears the value of `kind`. Subsequent reads from it will return its default value.
    mutating func clearKind() {self._kind = nil}

    var forwardActions: [TSWP_UndoTransaction.StorageAction] = []

    var inverseForwardActions: [TSWP_UndoTransaction.StorageAction] = []

    var inverseDetailActions: [TSWP_UndoTransaction.StorageAction] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _kind: TSWP_UndoTransaction.ActionGroupKind? = nil
  }

  init() {}

  fileprivate var _flags: UInt32? = nil
  fileprivate var _version: UInt32? = nil
}

struct TSWP_UndoTransactionWrapperArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var undoTransaction: TSWP_UndoTransaction {
    get {return _undoTransaction ?? TSWP_UndoTransaction()}
    set {_undoTransaction = newValue}
  }
  /// Returns true if `undoTransaction` has been explicitly set.
  var hasUndoTransaction: Bool {return self._undoTransaction != nil}
  /// Clears the value of `undoTransaction`. Subsequent reads from it will return its default value.
  mutating func clearUndoTransaction() {self._undoTransaction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _undoTransaction: TSWP_UndoTransaction? = nil
}

struct TSWP_ShapeInfoArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_ShapeArchive {
    get {return _super ?? TSD_ShapeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var deprecatedStorage: TSP_Reference {
    get {return _deprecatedStorage ?? TSP_Reference()}
    set {_deprecatedStorage = newValue}
  }
  /// Returns true if `deprecatedStorage` has been explicitly set.
  var hasDeprecatedStorage: Bool {return self._deprecatedStorage != nil}
  /// Clears the value of `deprecatedStorage`. Subsequent reads from it will return its default value.
  mutating func clearDeprecatedStorage() {self._deprecatedStorage = nil}

  var textFlow: TSP_Reference {
    get {return _textFlow ?? TSP_Reference()}
    set {_textFlow = newValue}
  }
  /// Returns true if `textFlow` has been explicitly set.
  var hasTextFlow: Bool {return self._textFlow != nil}
  /// Clears the value of `textFlow`. Subsequent reads from it will return its default value.
  mutating func clearTextFlow() {self._textFlow = nil}

  var ownedStorage: TSP_Reference {
    get {return _ownedStorage ?? TSP_Reference()}
    set {_ownedStorage = newValue}
  }
  /// Returns true if `ownedStorage` has been explicitly set.
  var hasOwnedStorage: Bool {return self._ownedStorage != nil}
  /// Clears the value of `ownedStorage`. Subsequent reads from it will return its default value.
  mutating func clearOwnedStorage() {self._ownedStorage = nil}

  var isTextBox: Bool {
    get {return _isTextBox ?? false}
    set {_isTextBox = newValue}
  }
  /// Returns true if `isTextBox` has been explicitly set.
  var hasIsTextBox: Bool {return self._isTextBox != nil}
  /// Clears the value of `isTextBox`. Subsequent reads from it will return its default value.
  mutating func clearIsTextBox() {self._isTextBox = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_ShapeArchive? = nil
  fileprivate var _deprecatedStorage: TSP_Reference? = nil
  fileprivate var _textFlow: TSP_Reference? = nil
  fileprivate var _ownedStorage: TSP_Reference? = nil
  fileprivate var _isTextBox: Bool? = nil
}

struct TSWP_CommentInfoArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_ShapeInfoArchive {
    get {return _super ?? TSWP_ShapeInfoArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var commentStorage: TSP_Reference {
    get {return _commentStorage ?? TSP_Reference()}
    set {_commentStorage = newValue}
  }
  /// Returns true if `commentStorage` has been explicitly set.
  var hasCommentStorage: Bool {return self._commentStorage != nil}
  /// Clears the value of `commentStorage`. Subsequent reads from it will return its default value.
  mutating func clearCommentStorage() {self._commentStorage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_ShapeInfoArchive? = nil
  fileprivate var _commentStorage: TSP_Reference? = nil
}

struct TSWP_TOCInfoArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_ShapeInfoArchive {
    get {return _storage._super ?? TSWP_ShapeInfoArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var tocSettings: TSP_Reference {
    get {return _storage._tocSettings ?? TSP_Reference()}
    set {_uniqueStorage()._tocSettings = newValue}
  }
  /// Returns true if `tocSettings` has been explicitly set.
  var hasTocSettings: Bool {return _storage._tocSettings != nil}
  /// Clears the value of `tocSettings`. Subsequent reads from it will return its default value.
  mutating func clearTocSettings() {_uniqueStorage()._tocSettings = nil}

  var tocEntryData: [TSP_Reference] {
    get {return _storage._tocEntryData}
    set {_uniqueStorage()._tocEntryData = newValue}
  }

  var pageNumberRanges: [TSP_Range] {
    get {return _storage._pageNumberRanges}
    set {_uniqueStorage()._pageNumberRanges = newValue}
  }

  var syncTocSettingsWithTocNavigator: Bool {
    get {return _storage._syncTocSettingsWithTocNavigator ?? false}
    set {_uniqueStorage()._syncTocSettingsWithTocNavigator = newValue}
  }
  /// Returns true if `syncTocSettingsWithTocNavigator` has been explicitly set.
  var hasSyncTocSettingsWithTocNavigator: Bool {return _storage._syncTocSettingsWithTocNavigator != nil}
  /// Clears the value of `syncTocSettingsWithTocNavigator`. Subsequent reads from it will return its default value.
  mutating func clearSyncTocSettingsWithTocNavigator() {_uniqueStorage()._syncTocSettingsWithTocNavigator = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_TOCLayoutHintArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var charRange: TSP_Range {
    get {return _charRange ?? TSP_Range()}
    set {_charRange = newValue}
  }
  /// Returns true if `charRange` has been explicitly set.
  var hasCharRange: Bool {return self._charRange != nil}
  /// Clears the value of `charRange`. Subsequent reads from it will return its default value.
  mutating func clearCharRange() {self._charRange = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _charRange: TSP_Range? = nil
}

struct TSWP_EquationInfoArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSWP_TextualAttachmentArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stringEquivalent: String {
    get {return _stringEquivalent ?? String()}
    set {_stringEquivalent = newValue}
  }
  /// Returns true if `stringEquivalent` has been explicitly set.
  var hasStringEquivalent: Bool {return self._stringEquivalent != nil}
  /// Clears the value of `stringEquivalent`. Subsequent reads from it will return its default value.
  mutating func clearStringEquivalent() {self._stringEquivalent = nil}

  var kind: TSWP_TextualAttachmentArchive.Kind {
    get {return _kind ?? .kKindPageNumber}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {self._kind = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Kind: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kKindPageNumber = 0
    case kKindPageCount = 1
    case kKindFootnoteMark = 2

    init() {
      self = .kKindPageNumber
    }

  }

  init() {}

  fileprivate var _stringEquivalent: String? = nil
  fileprivate var _kind: TSWP_TextualAttachmentArchive.Kind? = nil
}

struct TSWP_TSWPTOCPageNumberAttachmentArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_TextualAttachmentArchive {
    get {return _super ?? TSWP_TextualAttachmentArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var pageNumber: String {
    get {return _pageNumber ?? String()}
    set {_pageNumber = newValue}
  }
  /// Returns true if `pageNumber` has been explicitly set.
  var hasPageNumber: Bool {return self._pageNumber != nil}
  /// Clears the value of `pageNumber`. Subsequent reads from it will return its default value.
  mutating func clearPageNumber() {self._pageNumber = nil}

  var bookmarkName: String {
    get {return _bookmarkName ?? String()}
    set {_bookmarkName = newValue}
  }
  /// Returns true if `bookmarkName` has been explicitly set.
  var hasBookmarkName: Bool {return self._bookmarkName != nil}
  /// Clears the value of `bookmarkName`. Subsequent reads from it will return its default value.
  mutating func clearBookmarkName() {self._bookmarkName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_TextualAttachmentArchive? = nil
  fileprivate var _pageNumber: String? = nil
  fileprivate var _bookmarkName: String? = nil
}

struct TSWP_UIGraphicalAttachment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSWP_DrawableAttachmentArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var drawable: TSP_Reference {
    get {return _drawable ?? TSP_Reference()}
    set {_drawable = newValue}
  }
  /// Returns true if `drawable` has been explicitly set.
  var hasDrawable: Bool {return self._drawable != nil}
  /// Clears the value of `drawable`. Subsequent reads from it will return its default value.
  mutating func clearDrawable() {self._drawable = nil}

  var hOffsetType: UInt32 {
    get {return _hOffsetType ?? 0}
    set {_hOffsetType = newValue}
  }
  /// Returns true if `hOffsetType` has been explicitly set.
  var hasHOffsetType: Bool {return self._hOffsetType != nil}
  /// Clears the value of `hOffsetType`. Subsequent reads from it will return its default value.
  mutating func clearHOffsetType() {self._hOffsetType = nil}

  var hOffset: Float {
    get {return _hOffset ?? 0}
    set {_hOffset = newValue}
  }
  /// Returns true if `hOffset` has been explicitly set.
  var hasHOffset: Bool {return self._hOffset != nil}
  /// Clears the value of `hOffset`. Subsequent reads from it will return its default value.
  mutating func clearHOffset() {self._hOffset = nil}

  var vOffsetType: UInt32 {
    get {return _vOffsetType ?? 0}
    set {_vOffsetType = newValue}
  }
  /// Returns true if `vOffsetType` has been explicitly set.
  var hasVOffsetType: Bool {return self._vOffsetType != nil}
  /// Clears the value of `vOffsetType`. Subsequent reads from it will return its default value.
  mutating func clearVOffsetType() {self._vOffsetType = nil}

  var vOffset: Float {
    get {return _vOffset ?? 0}
    set {_vOffset = newValue}
  }
  /// Returns true if `vOffset` has been explicitly set.
  var hasVOffset: Bool {return self._vOffset != nil}
  /// Clears the value of `vOffset`. Subsequent reads from it will return its default value.
  mutating func clearVOffset() {self._vOffset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _drawable: TSP_Reference? = nil
  fileprivate var _hOffsetType: UInt32? = nil
  fileprivate var _hOffset: Float? = nil
  fileprivate var _vOffsetType: UInt32? = nil
  fileprivate var _vOffset: Float? = nil
}

struct TSWP_TOCAttachmentArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_DrawableAttachmentArchive {
    get {return _super ?? TSWP_DrawableAttachmentArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_DrawableAttachmentArchive? = nil
}

struct TSWP_FootnoteReferenceAttachmentArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_TextualAttachmentArchive {
    get {return _super ?? TSWP_TextualAttachmentArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var containedStorage: TSP_Reference {
    get {return _containedStorage ?? TSP_Reference()}
    set {_containedStorage = newValue}
  }
  /// Returns true if `containedStorage` has been explicitly set.
  var hasContainedStorage: Bool {return self._containedStorage != nil}
  /// Clears the value of `containedStorage`. Subsequent reads from it will return its default value.
  mutating func clearContainedStorage() {self._containedStorage = nil}

  var customMarkString: String {
    get {return _customMarkString ?? String()}
    set {_customMarkString = newValue}
  }
  /// Returns true if `customMarkString` has been explicitly set.
  var hasCustomMarkString: Bool {return self._customMarkString != nil}
  /// Clears the value of `customMarkString`. Subsequent reads from it will return its default value.
  mutating func clearCustomMarkString() {self._customMarkString = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_TextualAttachmentArchive? = nil
  fileprivate var _containedStorage: TSP_Reference? = nil
  fileprivate var _customMarkString: String? = nil
}

struct TSWP_NumberAttachmentArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_TextualAttachmentArchive {
    get {return _super ?? TSWP_TextualAttachmentArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var numberFormat: UInt32 {
    get {return _numberFormat ?? 0}
    set {_numberFormat = newValue}
  }
  /// Returns true if `numberFormat` has been explicitly set.
  var hasNumberFormat: Bool {return self._numberFormat != nil}
  /// Clears the value of `numberFormat`. Subsequent reads from it will return its default value.
  mutating func clearNumberFormat() {self._numberFormat = nil}

  var stringValue: String {
    get {return _stringValue ?? String()}
    set {_stringValue = newValue}
  }
  /// Returns true if `stringValue` has been explicitly set.
  var hasStringValue: Bool {return self._stringValue != nil}
  /// Clears the value of `stringValue`. Subsequent reads from it will return its default value.
  mutating func clearStringValue() {self._stringValue = nil}

  var numberFormatName: String {
    get {return _numberFormatName ?? String()}
    set {_numberFormatName = newValue}
  }
  /// Returns true if `numberFormatName` has been explicitly set.
  var hasNumberFormatName: Bool {return self._numberFormatName != nil}
  /// Clears the value of `numberFormatName`. Subsequent reads from it will return its default value.
  mutating func clearNumberFormatName() {self._numberFormatName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_TextualAttachmentArchive? = nil
  fileprivate var _numberFormat: UInt32? = nil
  fileprivate var _stringValue: String? = nil
  fileprivate var _numberFormatName: String? = nil
}

struct TSWP_SmartFieldArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var textAttributeUuidString: String {
    get {return _textAttributeUuidString ?? String()}
    set {_textAttributeUuidString = newValue}
  }
  /// Returns true if `textAttributeUuidString` has been explicitly set.
  var hasTextAttributeUuidString: Bool {return self._textAttributeUuidString != nil}
  /// Clears the value of `textAttributeUuidString`. Subsequent reads from it will return its default value.
  mutating func clearTextAttributeUuidString() {self._textAttributeUuidString = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _textAttributeUuidString: String? = nil
}

struct TSWP_HyperlinkFieldArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_SmartFieldArchive {
    get {return _super ?? TSWP_SmartFieldArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var urlRef: String {
    get {return _urlRef ?? String()}
    set {_urlRef = newValue}
  }
  /// Returns true if `urlRef` has been explicitly set.
  var hasURLRef: Bool {return self._urlRef != nil}
  /// Clears the value of `urlRef`. Subsequent reads from it will return its default value.
  mutating func clearURLRef() {self._urlRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_SmartFieldArchive? = nil
  fileprivate var _urlRef: String? = nil
}

struct TSWP_PlaceholderSmartFieldArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_SmartFieldArchive {
    get {return _super ?? TSWP_SmartFieldArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var localizable: Bool {
    get {return _localizable ?? false}
    set {_localizable = newValue}
  }
  /// Returns true if `localizable` has been explicitly set.
  var hasLocalizable: Bool {return self._localizable != nil}
  /// Clears the value of `localizable`. Subsequent reads from it will return its default value.
  mutating func clearLocalizable() {self._localizable = nil}

  var scriptTag: String {
    get {return _scriptTag ?? String()}
    set {_scriptTag = newValue}
  }
  /// Returns true if `scriptTag` has been explicitly set.
  var hasScriptTag: Bool {return self._scriptTag != nil}
  /// Clears the value of `scriptTag`. Subsequent reads from it will return its default value.
  mutating func clearScriptTag() {self._scriptTag = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_SmartFieldArchive? = nil
  fileprivate var _localizable: Bool? = nil
  fileprivate var _scriptTag: String? = nil
}

struct TSWP_UnsupportedHyperlinkFieldArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_PlaceholderSmartFieldArchive {
    get {return _super ?? TSWP_PlaceholderSmartFieldArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var urlRef: String {
    get {return _urlRef ?? String()}
    set {_urlRef = newValue}
  }
  /// Returns true if `urlRef` has been explicitly set.
  var hasURLRef: Bool {return self._urlRef != nil}
  /// Clears the value of `urlRef`. Subsequent reads from it will return its default value.
  mutating func clearURLRef() {self._urlRef = nil}

  var urlOriginalRef: String {
    get {return _urlOriginalRef ?? String()}
    set {_urlOriginalRef = newValue}
  }
  /// Returns true if `urlOriginalRef` has been explicitly set.
  var hasURLOriginalRef: Bool {return self._urlOriginalRef != nil}
  /// Clears the value of `urlOriginalRef`. Subsequent reads from it will return its default value.
  mutating func clearURLOriginalRef() {self._urlOriginalRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_PlaceholderSmartFieldArchive? = nil
  fileprivate var _urlRef: String? = nil
  fileprivate var _urlOriginalRef: String? = nil
}

struct TSWP_BibliographySmartFieldArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_SmartFieldArchive {
    get {return _super ?? TSWP_SmartFieldArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var citationRecords: [TSP_Reference] = []

  var localizable: Bool {
    get {return _localizable ?? false}
    set {_localizable = newValue}
  }
  /// Returns true if `localizable` has been explicitly set.
  var hasLocalizable: Bool {return self._localizable != nil}
  /// Clears the value of `localizable`. Subsequent reads from it will return its default value.
  mutating func clearLocalizable() {self._localizable = nil}

  var oldSuper: TSWP_PlaceholderSmartFieldArchive {
    get {return _oldSuper ?? TSWP_PlaceholderSmartFieldArchive()}
    set {_oldSuper = newValue}
  }
  /// Returns true if `oldSuper` has been explicitly set.
  var hasOldSuper: Bool {return self._oldSuper != nil}
  /// Clears the value of `oldSuper`. Subsequent reads from it will return its default value.
  mutating func clearOldSuper() {self._oldSuper = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_SmartFieldArchive? = nil
  fileprivate var _localizable: Bool? = nil
  fileprivate var _oldSuper: TSWP_PlaceholderSmartFieldArchive? = nil
}

struct TSWP_CitationRecordArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var endnoteXml: String {
    get {return _endnoteXml ?? String()}
    set {_endnoteXml = newValue}
  }
  /// Returns true if `endnoteXml` has been explicitly set.
  var hasEndnoteXml: Bool {return self._endnoteXml != nil}
  /// Clears the value of `endnoteXml`. Subsequent reads from it will return its default value.
  mutating func clearEndnoteXml() {self._endnoteXml = nil}

  var hideAuthorNames: Bool {
    get {return _hideAuthorNames ?? false}
    set {_hideAuthorNames = newValue}
  }
  /// Returns true if `hideAuthorNames` has been explicitly set.
  var hasHideAuthorNames: Bool {return self._hideAuthorNames != nil}
  /// Clears the value of `hideAuthorNames`. Subsequent reads from it will return its default value.
  mutating func clearHideAuthorNames() {self._hideAuthorNames = nil}

  var hideYear: Bool {
    get {return _hideYear ?? false}
    set {_hideYear = newValue}
  }
  /// Returns true if `hideYear` has been explicitly set.
  var hasHideYear: Bool {return self._hideYear != nil}
  /// Clears the value of `hideYear`. Subsequent reads from it will return its default value.
  mutating func clearHideYear() {self._hideYear = nil}

  var pageRange: String {
    get {return _pageRange ?? String()}
    set {_pageRange = newValue}
  }
  /// Returns true if `pageRange` has been explicitly set.
  var hasPageRange: Bool {return self._pageRange != nil}
  /// Clears the value of `pageRange`. Subsequent reads from it will return its default value.
  mutating func clearPageRange() {self._pageRange = nil}

  var prefix: String {
    get {return _prefix ?? String()}
    set {_prefix = newValue}
  }
  /// Returns true if `prefix` has been explicitly set.
  var hasPrefix: Bool {return self._prefix != nil}
  /// Clears the value of `prefix`. Subsequent reads from it will return its default value.
  mutating func clearPrefix() {self._prefix = nil}

  var suffix: String {
    get {return _suffix ?? String()}
    set {_suffix = newValue}
  }
  /// Returns true if `suffix` has been explicitly set.
  var hasSuffix: Bool {return self._suffix != nil}
  /// Clears the value of `suffix`. Subsequent reads from it will return its default value.
  mutating func clearSuffix() {self._suffix = nil}

  var authorsString: String {
    get {return _authorsString ?? String()}
    set {_authorsString = newValue}
  }
  /// Returns true if `authorsString` has been explicitly set.
  var hasAuthorsString: Bool {return self._authorsString != nil}
  /// Clears the value of `authorsString`. Subsequent reads from it will return its default value.
  mutating func clearAuthorsString() {self._authorsString = nil}

  var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {self._title = nil}

  var year: String {
    get {return _year ?? String()}
    set {_year = newValue}
  }
  /// Returns true if `year` has been explicitly set.
  var hasYear: Bool {return self._year != nil}
  /// Clears the value of `year`. Subsequent reads from it will return its default value.
  mutating func clearYear() {self._year = nil}

  var type: String {
    get {return _type ?? String()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _endnoteXml: String? = nil
  fileprivate var _hideAuthorNames: Bool? = nil
  fileprivate var _hideYear: Bool? = nil
  fileprivate var _pageRange: String? = nil
  fileprivate var _prefix: String? = nil
  fileprivate var _suffix: String? = nil
  fileprivate var _authorsString: String? = nil
  fileprivate var _title: String? = nil
  fileprivate var _year: String? = nil
  fileprivate var _type: String? = nil
}

struct TSWP_CitationSmartFieldArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_SmartFieldArchive {
    get {return _super ?? TSWP_SmartFieldArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var citationRecords: [TSP_Reference] = []

  var localizable: Bool {
    get {return _localizable ?? false}
    set {_localizable = newValue}
  }
  /// Returns true if `localizable` has been explicitly set.
  var hasLocalizable: Bool {return self._localizable != nil}
  /// Clears the value of `localizable`. Subsequent reads from it will return its default value.
  mutating func clearLocalizable() {self._localizable = nil}

  var oldSuper: TSWP_PlaceholderSmartFieldArchive {
    get {return _oldSuper ?? TSWP_PlaceholderSmartFieldArchive()}
    set {_oldSuper = newValue}
  }
  /// Returns true if `oldSuper` has been explicitly set.
  var hasOldSuper: Bool {return self._oldSuper != nil}
  /// Clears the value of `oldSuper`. Subsequent reads from it will return its default value.
  mutating func clearOldSuper() {self._oldSuper = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_SmartFieldArchive? = nil
  fileprivate var _localizable: Bool? = nil
  fileprivate var _oldSuper: TSWP_PlaceholderSmartFieldArchive? = nil
}

struct TSWP_DateTimeSmartFieldArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_SmartFieldArchive {
    get {return _super ?? TSWP_SmartFieldArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var format: String {
    get {return _format ?? String()}
    set {_format = newValue}
  }
  /// Returns true if `format` has been explicitly set.
  var hasFormat: Bool {return self._format != nil}
  /// Clears the value of `format`. Subsequent reads from it will return its default value.
  mutating func clearFormat() {self._format = nil}

  var localeIdentifier: String {
    get {return _localeIdentifier ?? String()}
    set {_localeIdentifier = newValue}
  }
  /// Returns true if `localeIdentifier` has been explicitly set.
  var hasLocaleIdentifier: Bool {return self._localeIdentifier != nil}
  /// Clears the value of `localeIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearLocaleIdentifier() {self._localeIdentifier = nil}

  var dateStyle: TSWP_DateTimeSmartFieldArchive.DateTimeFormatterStyle {
    get {return _dateStyle ?? .kDateTimeFormatterStyleNone}
    set {_dateStyle = newValue}
  }
  /// Returns true if `dateStyle` has been explicitly set.
  var hasDateStyle: Bool {return self._dateStyle != nil}
  /// Clears the value of `dateStyle`. Subsequent reads from it will return its default value.
  mutating func clearDateStyle() {self._dateStyle = nil}

  var timeStyle: TSWP_DateTimeSmartFieldArchive.DateTimeFormatterStyle {
    get {return _timeStyle ?? .kDateTimeFormatterStyleNone}
    set {_timeStyle = newValue}
  }
  /// Returns true if `timeStyle` has been explicitly set.
  var hasTimeStyle: Bool {return self._timeStyle != nil}
  /// Clears the value of `timeStyle`. Subsequent reads from it will return its default value.
  mutating func clearTimeStyle() {self._timeStyle = nil}

  var updatePlan: TSWP_DateTimeSmartFieldArchive.DateTimeUpdatePlan {
    get {return _updatePlan ?? .kDateTimeUpdatePlanNever}
    set {_updatePlan = newValue}
  }
  /// Returns true if `updatePlan` has been explicitly set.
  var hasUpdatePlan: Bool {return self._updatePlan != nil}
  /// Clears the value of `updatePlan`. Subsequent reads from it will return its default value.
  mutating func clearUpdatePlan() {self._updatePlan = nil}

  var needsUpdate: Bool {
    get {return _needsUpdate ?? false}
    set {_needsUpdate = newValue}
  }
  /// Returns true if `needsUpdate` has been explicitly set.
  var hasNeedsUpdate: Bool {return self._needsUpdate != nil}
  /// Clears the value of `needsUpdate`. Subsequent reads from it will return its default value.
  mutating func clearNeedsUpdate() {self._needsUpdate = nil}

  var date: TSP_Date {
    get {return _date ?? TSP_Date()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {self._date = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum DateTimeUpdatePlan: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kDateTimeUpdatePlanNever = 0
    case kDateTimeUpdatePlanAuto = 1
    case kDateTimeUpdatePlanOnce = 2

    init() {
      self = .kDateTimeUpdatePlanNever
    }

  }

  enum DateTimeFormatterStyle: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kDateTimeFormatterStyleNone = 0
    case kDateTimeFormatterStyleShort = 1
    case kDateTimeFormatterStyleMedium = 2
    case kDateTimeFormatterStyleLong = 3
    case kDateTimeFormatterStyleFull = 4

    init() {
      self = .kDateTimeFormatterStyleNone
    }

  }

  init() {}

  fileprivate var _super: TSWP_SmartFieldArchive? = nil
  fileprivate var _format: String? = nil
  fileprivate var _localeIdentifier: String? = nil
  fileprivate var _dateStyle: TSWP_DateTimeSmartFieldArchive.DateTimeFormatterStyle? = nil
  fileprivate var _timeStyle: TSWP_DateTimeSmartFieldArchive.DateTimeFormatterStyle? = nil
  fileprivate var _updatePlan: TSWP_DateTimeSmartFieldArchive.DateTimeUpdatePlan? = nil
  fileprivate var _needsUpdate: Bool? = nil
  fileprivate var _date: TSP_Date? = nil
}

struct TSWP_BookmarkFieldArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_SmartFieldArchive {
    get {return _super ?? TSWP_SmartFieldArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var ranged: UInt32 {
    get {return _ranged ?? 0}
    set {_ranged = newValue}
  }
  /// Returns true if `ranged` has been explicitly set.
  var hasRanged: Bool {return self._ranged != nil}
  /// Clears the value of `ranged`. Subsequent reads from it will return its default value.
  mutating func clearRanged() {self._ranged = nil}

  var hidden: UInt32 {
    get {return _hidden ?? 0}
    set {_hidden = newValue}
  }
  /// Returns true if `hidden` has been explicitly set.
  var hasHidden: Bool {return self._hidden != nil}
  /// Clears the value of `hidden`. Subsequent reads from it will return its default value.
  mutating func clearHidden() {self._hidden = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_SmartFieldArchive? = nil
  fileprivate var _name: String? = nil
  fileprivate var _ranged: UInt32? = nil
  fileprivate var _hidden: UInt32? = nil
}

struct TSWP_FilenameSmartFieldArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_PlaceholderSmartFieldArchive {
    get {return _super ?? TSWP_PlaceholderSmartFieldArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var displayFlags: UInt32 {
    get {return _displayFlags ?? 0}
    set {_displayFlags = newValue}
  }
  /// Returns true if `displayFlags` has been explicitly set.
  var hasDisplayFlags: Bool {return self._displayFlags != nil}
  /// Clears the value of `displayFlags`. Subsequent reads from it will return its default value.
  mutating func clearDisplayFlags() {self._displayFlags = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_PlaceholderSmartFieldArchive? = nil
  fileprivate var _displayFlags: UInt32? = nil
}

struct TSWP_MergeFieldTypeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var contactsProperty: String {
    get {return _contactsProperty ?? String()}
    set {_contactsProperty = newValue}
  }
  /// Returns true if `contactsProperty` has been explicitly set.
  var hasContactsProperty: Bool {return self._contactsProperty != nil}
  /// Clears the value of `contactsProperty`. Subsequent reads from it will return its default value.
  mutating func clearContactsProperty() {self._contactsProperty = nil}

  var contactsKey: String {
    get {return _contactsKey ?? String()}
    set {_contactsKey = newValue}
  }
  /// Returns true if `contactsKey` has been explicitly set.
  var hasContactsKey: Bool {return self._contactsKey != nil}
  /// Clears the value of `contactsKey`. Subsequent reads from it will return its default value.
  mutating func clearContactsKey() {self._contactsKey = nil}

  var contactsLabel: String {
    get {return _contactsLabel ?? String()}
    set {_contactsLabel = newValue}
  }
  /// Returns true if `contactsLabel` has been explicitly set.
  var hasContactsLabel: Bool {return self._contactsLabel != nil}
  /// Clears the value of `contactsLabel`. Subsequent reads from it will return its default value.
  mutating func clearContactsLabel() {self._contactsLabel = nil}

  var tableKey: String {
    get {return _tableKey ?? String()}
    set {_tableKey = newValue}
  }
  /// Returns true if `tableKey` has been explicitly set.
  var hasTableKey: Bool {return self._tableKey != nil}
  /// Clears the value of `tableKey`. Subsequent reads from it will return its default value.
  mutating func clearTableKey() {self._tableKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _contactsProperty: String? = nil
  fileprivate var _contactsKey: String? = nil
  fileprivate var _contactsLabel: String? = nil
  fileprivate var _tableKey: String? = nil
}

struct TSWP_MergeSmartFieldArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_PlaceholderSmartFieldArchive {
    get {return _super ?? TSWP_PlaceholderSmartFieldArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var contactsProperty: String {
    get {return _contactsProperty ?? String()}
    set {_contactsProperty = newValue}
  }
  /// Returns true if `contactsProperty` has been explicitly set.
  var hasContactsProperty: Bool {return self._contactsProperty != nil}
  /// Clears the value of `contactsProperty`. Subsequent reads from it will return its default value.
  mutating func clearContactsProperty() {self._contactsProperty = nil}

  var contactsKey: String {
    get {return _contactsKey ?? String()}
    set {_contactsKey = newValue}
  }
  /// Returns true if `contactsKey` has been explicitly set.
  var hasContactsKey: Bool {return self._contactsKey != nil}
  /// Clears the value of `contactsKey`. Subsequent reads from it will return its default value.
  mutating func clearContactsKey() {self._contactsKey = nil}

  var contactsLabel: String {
    get {return _contactsLabel ?? String()}
    set {_contactsLabel = newValue}
  }
  /// Returns true if `contactsLabel` has been explicitly set.
  var hasContactsLabel: Bool {return self._contactsLabel != nil}
  /// Clears the value of `contactsLabel`. Subsequent reads from it will return its default value.
  mutating func clearContactsLabel() {self._contactsLabel = nil}

  var category: TSWP_MergeSmartFieldArchive.MergeCategory {
    get {return _category ?? .kMergeCategoryTo}
    set {_category = newValue}
  }
  /// Returns true if `category` has been explicitly set.
  var hasCategory: Bool {return self._category != nil}
  /// Clears the value of `category`. Subsequent reads from it will return its default value.
  mutating func clearCategory() {self._category = nil}

  var requiresFollowingWhitespace: Bool {
    get {return _requiresFollowingWhitespace ?? false}
    set {_requiresFollowingWhitespace = newValue}
  }
  /// Returns true if `requiresFollowingWhitespace` has been explicitly set.
  var hasRequiresFollowingWhitespace: Bool {return self._requiresFollowingWhitespace != nil}
  /// Clears the value of `requiresFollowingWhitespace`. Subsequent reads from it will return its default value.
  mutating func clearRequiresFollowingWhitespace() {self._requiresFollowingWhitespace = nil}

  var whitespace: String {
    get {return _whitespace ?? String()}
    set {_whitespace = newValue}
  }
  /// Returns true if `whitespace` has been explicitly set.
  var hasWhitespace: Bool {return self._whitespace != nil}
  /// Clears the value of `whitespace`. Subsequent reads from it will return its default value.
  mutating func clearWhitespace() {self._whitespace = nil}

  var guid: String {
    get {return _guid ?? String()}
    set {_guid = newValue}
  }
  /// Returns true if `guid` has been explicitly set.
  var hasGuid: Bool {return self._guid != nil}
  /// Clears the value of `guid`. Subsequent reads from it will return its default value.
  mutating func clearGuid() {self._guid = nil}

  var tableKey: String {
    get {return _tableKey ?? String()}
    set {_tableKey = newValue}
  }
  /// Returns true if `tableKey` has been explicitly set.
  var hasTableKey: Bool {return self._tableKey != nil}
  /// Clears the value of `tableKey`. Subsequent reads from it will return its default value.
  mutating func clearTableKey() {self._tableKey = nil}

  var fieldType: TSWP_MergeFieldTypeArchive {
    get {return _fieldType ?? TSWP_MergeFieldTypeArchive()}
    set {_fieldType = newValue}
  }
  /// Returns true if `fieldType` has been explicitly set.
  var hasFieldType: Bool {return self._fieldType != nil}
  /// Clears the value of `fieldType`. Subsequent reads from it will return its default value.
  mutating func clearFieldType() {self._fieldType = nil}

  var hasCustomText_p: Bool {
    get {return _hasCustomText_p ?? false}
    set {_hasCustomText_p = newValue}
  }
  /// Returns true if `hasCustomText_p` has been explicitly set.
  var hasHasCustomText_p: Bool {return self._hasCustomText_p != nil}
  /// Clears the value of `hasCustomText_p`. Subsequent reads from it will return its default value.
  mutating func clearHasCustomText_p() {self._hasCustomText_p = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum MergeCategory: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kMergeCategoryTo = 0
    case kMergeCategoryFrom = 1

    init() {
      self = .kMergeCategoryTo
    }

  }

  init() {}

  fileprivate var _super: TSWP_PlaceholderSmartFieldArchive? = nil
  fileprivate var _contactsProperty: String? = nil
  fileprivate var _contactsKey: String? = nil
  fileprivate var _contactsLabel: String? = nil
  fileprivate var _category: TSWP_MergeSmartFieldArchive.MergeCategory? = nil
  fileprivate var _requiresFollowingWhitespace: Bool? = nil
  fileprivate var _whitespace: String? = nil
  fileprivate var _guid: String? = nil
  fileprivate var _tableKey: String? = nil
  fileprivate var _fieldType: TSWP_MergeFieldTypeArchive? = nil
  fileprivate var _hasCustomText_p: Bool? = nil
}

struct TSWP_TOCSmartFieldArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_PlaceholderSmartFieldArchive {
    get {return _super ?? TSWP_PlaceholderSmartFieldArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var tocEntries: [TSWP_TOCSmartFieldArchive.TOCEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct TOCEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var bookmarkName: String {
      get {return _bookmarkName ?? String()}
      set {_bookmarkName = newValue}
    }
    /// Returns true if `bookmarkName` has been explicitly set.
    var hasBookmarkName: Bool {return self._bookmarkName != nil}
    /// Clears the value of `bookmarkName`. Subsequent reads from it will return its default value.
    mutating func clearBookmarkName() {self._bookmarkName = nil}

    var targetStyle: TSP_Reference {
      get {return _targetStyle ?? TSP_Reference()}
      set {_targetStyle = newValue}
    }
    /// Returns true if `targetStyle` has been explicitly set.
    var hasTargetStyle: Bool {return self._targetStyle != nil}
    /// Clears the value of `targetStyle`. Subsequent reads from it will return its default value.
    mutating func clearTargetStyle() {self._targetStyle = nil}

    var range: TSP_Range {
      get {return _range ?? TSP_Range()}
      set {_range = newValue}
    }
    /// Returns true if `range` has been explicitly set.
    var hasRange: Bool {return self._range != nil}
    /// Clears the value of `range`. Subsequent reads from it will return its default value.
    mutating func clearRange() {self._range = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _bookmarkName: String? = nil
    fileprivate var _targetStyle: TSP_Reference? = nil
    fileprivate var _range: TSP_Range? = nil
  }

  init() {}

  fileprivate var _super: TSWP_PlaceholderSmartFieldArchive? = nil
}

struct TSWP_RubyFieldArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_SmartFieldArchive {
    get {return _super ?? TSWP_SmartFieldArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var rubyText: String {
    get {return _rubyText ?? String()}
    set {_rubyText = newValue}
  }
  /// Returns true if `rubyText` has been explicitly set.
  var hasRubyText: Bool {return self._rubyText != nil}
  /// Clears the value of `rubyText`. Subsequent reads from it will return its default value.
  mutating func clearRubyText() {self._rubyText = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_SmartFieldArchive? = nil
  fileprivate var _rubyText: String? = nil
}

struct TSWP_TateChuYokoFieldArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_SmartFieldArchive {
    get {return _super ?? TSWP_SmartFieldArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_SmartFieldArchive? = nil
}

struct TSWP_ChangeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: TSWP_ChangeArchive.ChangeKind {
    get {return _kind ?? .kChangeKindInsertion}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {self._kind = nil}

  var session: TSP_Reference {
    get {return _session ?? TSP_Reference()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  var date: TSP_Date {
    get {return _date ?? TSP_Date()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {self._date = nil}

  var textAttributeUuidString: String {
    get {return _textAttributeUuidString ?? String()}
    set {_textAttributeUuidString = newValue}
  }
  /// Returns true if `textAttributeUuidString` has been explicitly set.
  var hasTextAttributeUuidString: Bool {return self._textAttributeUuidString != nil}
  /// Clears the value of `textAttributeUuidString`. Subsequent reads from it will return its default value.
  mutating func clearTextAttributeUuidString() {self._textAttributeUuidString = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ChangeKind: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kChangeKindInsertion = 1
    case kChangeKindDeletion = 2

    init() {
      self = .kChangeKindInsertion
    }

  }

  init() {}

  fileprivate var _kind: TSWP_ChangeArchive.ChangeKind? = nil
  fileprivate var _session: TSP_Reference? = nil
  fileprivate var _date: TSP_Date? = nil
  fileprivate var _textAttributeUuidString: String? = nil
}

struct TSWP_ChangeSessionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionUid: UInt32 {
    get {return _sessionUid ?? 0}
    set {_sessionUid = newValue}
  }
  /// Returns true if `sessionUid` has been explicitly set.
  var hasSessionUid: Bool {return self._sessionUid != nil}
  /// Clears the value of `sessionUid`. Subsequent reads from it will return its default value.
  mutating func clearSessionUid() {self._sessionUid = nil}

  var author: TSP_Reference {
    get {return _author ?? TSP_Reference()}
    set {_author = newValue}
  }
  /// Returns true if `author` has been explicitly set.
  var hasAuthor: Bool {return self._author != nil}
  /// Clears the value of `author`. Subsequent reads from it will return its default value.
  mutating func clearAuthor() {self._author = nil}

  var date: TSP_Date {
    get {return _date ?? TSP_Date()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {self._date = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sessionUid: UInt32? = nil
  fileprivate var _author: TSP_Reference? = nil
  fileprivate var _date: TSP_Date? = nil
}

struct TSWP_SectionPlaceholderArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var parentStorage: TSP_Reference {
    get {return _parentStorage ?? TSP_Reference()}
    set {_parentStorage = newValue}
  }
  /// Returns true if `parentStorage` has been explicitly set.
  var hasParentStorage: Bool {return self._parentStorage != nil}
  /// Clears the value of `parentStorage`. Subsequent reads from it will return its default value.
  mutating func clearParentStorage() {self._parentStorage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _parentStorage: TSP_Reference? = nil
}

struct TSWP_HyperlinkSelectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSWP_DateTimeSelectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSWP_FlowInfoArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var textStorage: TSP_Reference {
    get {return _textStorage ?? TSP_Reference()}
    set {_textStorage = newValue}
  }
  /// Returns true if `textStorage` has been explicitly set.
  var hasTextStorage: Bool {return self._textStorage != nil}
  /// Clears the value of `textStorage`. Subsequent reads from it will return its default value.
  mutating func clearTextStorage() {self._textStorage = nil}

  var textboxes: [TSP_Reference] = []

  var userInterfaceIdentifier: UInt32 {
    get {return _userInterfaceIdentifier ?? 0}
    set {_userInterfaceIdentifier = newValue}
  }
  /// Returns true if `userInterfaceIdentifier` has been explicitly set.
  var hasUserInterfaceIdentifier: Bool {return self._userInterfaceIdentifier != nil}
  /// Clears the value of `userInterfaceIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearUserInterfaceIdentifier() {self._userInterfaceIdentifier = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _textStorage: TSP_Reference? = nil
  fileprivate var _userInterfaceIdentifier: UInt32? = nil
}

struct TSWP_FlowInfoContainerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var flowInfos: [TSP_Reference] = []

  var nextUserInterfaceIdentifier: UInt32 {
    get {return _nextUserInterfaceIdentifier ?? 0}
    set {_nextUserInterfaceIdentifier = newValue}
  }
  /// Returns true if `nextUserInterfaceIdentifier` has been explicitly set.
  var hasNextUserInterfaceIdentifier: Bool {return self._nextUserInterfaceIdentifier != nil}
  /// Clears the value of `nextUserInterfaceIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearNextUserInterfaceIdentifier() {self._nextUserInterfaceIdentifier = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nextUserInterfaceIdentifier: UInt32? = nil
}

struct TSWP_DropCapArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: TSWP_DropCapArchive.DropCapType {
    get {return _type ?? .tswpdropCapTypeText}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var numberOfLines: UInt32 {
    get {return _numberOfLines ?? 3}
    set {_numberOfLines = newValue}
  }
  /// Returns true if `numberOfLines` has been explicitly set.
  var hasNumberOfLines: Bool {return self._numberOfLines != nil}
  /// Clears the value of `numberOfLines`. Subsequent reads from it will return its default value.
  mutating func clearNumberOfLines() {self._numberOfLines = nil}

  var numberOfRaisedLines: UInt32 {
    get {return _numberOfRaisedLines ?? 0}
    set {_numberOfRaisedLines = newValue}
  }
  /// Returns true if `numberOfRaisedLines` has been explicitly set.
  var hasNumberOfRaisedLines: Bool {return self._numberOfRaisedLines != nil}
  /// Clears the value of `numberOfRaisedLines`. Subsequent reads from it will return its default value.
  mutating func clearNumberOfRaisedLines() {self._numberOfRaisedLines = nil}

  var deprecatedOutdent: Float {
    get {return _deprecatedOutdent ?? 0}
    set {_deprecatedOutdent = newValue}
  }
  /// Returns true if `deprecatedOutdent` has been explicitly set.
  var hasDeprecatedOutdent: Bool {return self._deprecatedOutdent != nil}
  /// Clears the value of `deprecatedOutdent`. Subsequent reads from it will return its default value.
  mutating func clearDeprecatedOutdent() {self._deprecatedOutdent = nil}

  var outdent: Double {
    get {return _outdent ?? 0}
    set {_outdent = newValue}
  }
  /// Returns true if `outdent` has been explicitly set.
  var hasOutdent: Bool {return self._outdent != nil}
  /// Clears the value of `outdent`. Subsequent reads from it will return its default value.
  mutating func clearOutdent() {self._outdent = nil}

  var deprecatedPadding: Float {
    get {return _deprecatedPadding ?? 0}
    set {_deprecatedPadding = newValue}
  }
  /// Returns true if `deprecatedPadding` has been explicitly set.
  var hasDeprecatedPadding: Bool {return self._deprecatedPadding != nil}
  /// Clears the value of `deprecatedPadding`. Subsequent reads from it will return its default value.
  mutating func clearDeprecatedPadding() {self._deprecatedPadding = nil}

  var padding: Double {
    get {return _padding ?? 0}
    set {_padding = newValue}
  }
  /// Returns true if `padding` has been explicitly set.
  var hasPadding: Bool {return self._padding != nil}
  /// Clears the value of `padding`. Subsequent reads from it will return its default value.
  mutating func clearPadding() {self._padding = nil}

  var wrapType: TSWP_DropCapArchive.DropCapWrapType {
    get {return _wrapType ?? .tswpdropCapWrapTypeRectangular}
    set {_wrapType = newValue}
  }
  /// Returns true if `wrapType` has been explicitly set.
  var hasWrapType: Bool {return self._wrapType != nil}
  /// Clears the value of `wrapType`. Subsequent reads from it will return its default value.
  mutating func clearWrapType() {self._wrapType = nil}

  var shapeEnabled: Bool {
    get {return _shapeEnabled ?? false}
    set {_shapeEnabled = newValue}
  }
  /// Returns true if `shapeEnabled` has been explicitly set.
  var hasShapeEnabled: Bool {return self._shapeEnabled != nil}
  /// Clears the value of `shapeEnabled`. Subsequent reads from it will return its default value.
  mutating func clearShapeEnabled() {self._shapeEnabled = nil}

  var deprecatedCornerRadius: Float {
    get {return _deprecatedCornerRadius ?? 0}
    set {_deprecatedCornerRadius = newValue}
  }
  /// Returns true if `deprecatedCornerRadius` has been explicitly set.
  var hasDeprecatedCornerRadius: Bool {return self._deprecatedCornerRadius != nil}
  /// Clears the value of `deprecatedCornerRadius`. Subsequent reads from it will return its default value.
  mutating func clearDeprecatedCornerRadius() {self._deprecatedCornerRadius = nil}

  var cornerRadius: Double {
    get {return _cornerRadius ?? 0}
    set {_cornerRadius = newValue}
  }
  /// Returns true if `cornerRadius` has been explicitly set.
  var hasCornerRadius: Bool {return self._cornerRadius != nil}
  /// Clears the value of `cornerRadius`. Subsequent reads from it will return its default value.
  mutating func clearCornerRadius() {self._cornerRadius = nil}

  var deprecatedCharacterScale: Float {
    get {return _deprecatedCharacterScale ?? 0}
    set {_deprecatedCharacterScale = newValue}
  }
  /// Returns true if `deprecatedCharacterScale` has been explicitly set.
  var hasDeprecatedCharacterScale: Bool {return self._deprecatedCharacterScale != nil}
  /// Clears the value of `deprecatedCharacterScale`. Subsequent reads from it will return its default value.
  mutating func clearDeprecatedCharacterScale() {self._deprecatedCharacterScale = nil}

  var characterScale: Double {
    get {return _characterScale ?? 1}
    set {_characterScale = newValue}
  }
  /// Returns true if `characterScale` has been explicitly set.
  var hasCharacterScale: Bool {return self._characterScale != nil}
  /// Clears the value of `characterScale`. Subsequent reads from it will return its default value.
  mutating func clearCharacterScale() {self._characterScale = nil}

  var numberOfCharacters: UInt32 {
    get {return _numberOfCharacters ?? 1}
    set {_numberOfCharacters = newValue}
  }
  /// Returns true if `numberOfCharacters` has been explicitly set.
  var hasNumberOfCharacters: Bool {return self._numberOfCharacters != nil}
  /// Clears the value of `numberOfCharacters`. Subsequent reads from it will return its default value.
  mutating func clearNumberOfCharacters() {self._numberOfCharacters = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum DropCapType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case tswpdropCapTypeText = 0
    case tswpdropCapTypeShape = 1
    case tswpdropCapTypeImage = 2

    init() {
      self = .tswpdropCapTypeText
    }

  }

  enum DropCapWrapType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case tswpdropCapWrapTypeRectangular = 0
    case tswpdropCapWrapTypeContour = 1
    case tswpdropCapWrapTypeNone = 2

    init() {
      self = .tswpdropCapWrapTypeRectangular
    }

  }

  init() {}

  fileprivate var _type: TSWP_DropCapArchive.DropCapType? = nil
  fileprivate var _numberOfLines: UInt32? = nil
  fileprivate var _numberOfRaisedLines: UInt32? = nil
  fileprivate var _deprecatedOutdent: Float? = nil
  fileprivate var _outdent: Double? = nil
  fileprivate var _deprecatedPadding: Float? = nil
  fileprivate var _padding: Double? = nil
  fileprivate var _wrapType: TSWP_DropCapArchive.DropCapWrapType? = nil
  fileprivate var _shapeEnabled: Bool? = nil
  fileprivate var _deprecatedCornerRadius: Float? = nil
  fileprivate var _cornerRadius: Double? = nil
  fileprivate var _deprecatedCharacterScale: Float? = nil
  fileprivate var _characterScale: Double? = nil
  fileprivate var _numberOfCharacters: UInt32? = nil
}

struct TSWP_DropCapStylePropertiesArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dropCap: TSWP_DropCapArchive {
    get {return _storage._dropCap ?? TSWP_DropCapArchive()}
    set {_uniqueStorage()._dropCap = newValue}
  }
  /// Returns true if `dropCap` has been explicitly set.
  var hasDropCap: Bool {return _storage._dropCap != nil}
  /// Clears the value of `dropCap`. Subsequent reads from it will return its default value.
  mutating func clearDropCap() {_uniqueStorage()._dropCap = nil}

  var dropCapShapeStroke: TSD_StrokeArchive {
    get {return _storage._dropCapShapeStroke ?? TSD_StrokeArchive()}
    set {_uniqueStorage()._dropCapShapeStroke = newValue}
  }
  /// Returns true if `dropCapShapeStroke` has been explicitly set.
  var hasDropCapShapeStroke: Bool {return _storage._dropCapShapeStroke != nil}
  /// Clears the value of `dropCapShapeStroke`. Subsequent reads from it will return its default value.
  mutating func clearDropCapShapeStroke() {_uniqueStorage()._dropCapShapeStroke = nil}

  var dropCapShapeFillNull: Bool {
    get {return _storage._dropCapShapeFillNull ?? false}
    set {_uniqueStorage()._dropCapShapeFillNull = newValue}
  }
  /// Returns true if `dropCapShapeFillNull` has been explicitly set.
  var hasDropCapShapeFillNull: Bool {return _storage._dropCapShapeFillNull != nil}
  /// Clears the value of `dropCapShapeFillNull`. Subsequent reads from it will return its default value.
  mutating func clearDropCapShapeFillNull() {_uniqueStorage()._dropCapShapeFillNull = nil}

  var dropCapShapeFill: TSD_FillArchive {
    get {return _storage._dropCapShapeFill ?? TSD_FillArchive()}
    set {_uniqueStorage()._dropCapShapeFill = newValue}
  }
  /// Returns true if `dropCapShapeFill` has been explicitly set.
  var hasDropCapShapeFill: Bool {return _storage._dropCapShapeFill != nil}
  /// Clears the value of `dropCapShapeFill`. Subsequent reads from it will return its default value.
  mutating func clearDropCapShapeFill() {_uniqueStorage()._dropCapShapeFill = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSWP_DropCapStyleArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_StyleArchive {
    get {return _super ?? TSS_StyleArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var overrideCount: UInt32 {
    get {return _overrideCount ?? 0}
    set {_overrideCount = newValue}
  }
  /// Returns true if `overrideCount` has been explicitly set.
  var hasOverrideCount: Bool {return self._overrideCount != nil}
  /// Clears the value of `overrideCount`. Subsequent reads from it will return its default value.
  mutating func clearOverrideCount() {self._overrideCount = nil}

  var charProperties: TSWP_CharacterStylePropertiesArchive {
    get {return _charProperties ?? TSWP_CharacterStylePropertiesArchive()}
    set {_charProperties = newValue}
  }
  /// Returns true if `charProperties` has been explicitly set.
  var hasCharProperties: Bool {return self._charProperties != nil}
  /// Clears the value of `charProperties`. Subsequent reads from it will return its default value.
  mutating func clearCharProperties() {self._charProperties = nil}

  var dropCapProperties: TSWP_DropCapStylePropertiesArchive {
    get {return _dropCapProperties ?? TSWP_DropCapStylePropertiesArchive()}
    set {_dropCapProperties = newValue}
  }
  /// Returns true if `dropCapProperties` has been explicitly set.
  var hasDropCapProperties: Bool {return self._dropCapProperties != nil}
  /// Clears the value of `dropCapProperties`. Subsequent reads from it will return its default value.
  mutating func clearDropCapProperties() {self._dropCapProperties = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSS_StyleArchive? = nil
  fileprivate var _overrideCount: UInt32? = nil
  fileprivate var _charProperties: TSWP_CharacterStylePropertiesArchive? = nil
  fileprivate var _dropCapProperties: TSWP_DropCapStylePropertiesArchive? = nil
}

struct TSWP_CollaboratorTextCursorSubselectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var textSelection: TSWP_SelectionArchive {
    get {return _textSelection ?? TSWP_SelectionArchive()}
    set {_textSelection = newValue}
  }
  /// Returns true if `textSelection` has been explicitly set.
  var hasTextSelection: Bool {return self._textSelection != nil}
  /// Clears the value of `textSelection`. Subsequent reads from it will return its default value.
  mutating func clearTextSelection() {self._textSelection = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _textSelection: TSWP_SelectionArchive? = nil
}

// MARK: - Extension support defined in TSWPArchives.proto.

// MARK: - Extension Properties

// Swift Extensions on the extended Messages to add easy access to the declared
// extension fields. The names are based on the extension field name from the proto
// declaration. To avoid naming collisions, the names are prefixed with the name of
// the scope where the extend directive occurs.

extension TSCK_CollaboratorCursorArchive {

  var TSWP_CollaboratorTextCursorSubselectionArchive_textCursorSubselection: TSWP_CollaboratorTextCursorSubselectionArchive {
    get {return getExtensionValue(ext: TSWP_CollaboratorTextCursorSubselectionArchive.Extensions.text_cursor_subselection) ?? TSWP_CollaboratorTextCursorSubselectionArchive()}
    set {setExtensionValue(ext: TSWP_CollaboratorTextCursorSubselectionArchive.Extensions.text_cursor_subselection, value: newValue)}
  }
  /// Returns true if extension `TSWP_CollaboratorTextCursorSubselectionArchive.Extensions.text_cursor_subselection`
  /// has been explicitly set.
  var hasTSWP_CollaboratorTextCursorSubselectionArchive_textCursorSubselection: Bool {
    return hasExtensionValue(ext: TSWP_CollaboratorTextCursorSubselectionArchive.Extensions.text_cursor_subselection)
  }
  /// Clears the value of extension `TSWP_CollaboratorTextCursorSubselectionArchive.Extensions.text_cursor_subselection`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTSWP_CollaboratorTextCursorSubselectionArchive_textCursorSubselection() {
    clearExtensionValue(ext: TSWP_CollaboratorTextCursorSubselectionArchive.Extensions.text_cursor_subselection)
  }
}

extension TSD_ImageArchive {

  var TSWP_EquationInfoArchive_equationSourceOld: String {
    get {return getExtensionValue(ext: TSWP_EquationInfoArchive.Extensions.equation_source_old) ?? String()}
    set {setExtensionValue(ext: TSWP_EquationInfoArchive.Extensions.equation_source_old, value: newValue)}
  }
  /// Returns true if extension `TSWP_EquationInfoArchive.Extensions.equation_source_old`
  /// has been explicitly set.
  var hasTSWP_EquationInfoArchive_equationSourceOld: Bool {
    return hasExtensionValue(ext: TSWP_EquationInfoArchive.Extensions.equation_source_old)
  }
  /// Clears the value of extension `TSWP_EquationInfoArchive.Extensions.equation_source_old`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTSWP_EquationInfoArchive_equationSourceOld() {
    clearExtensionValue(ext: TSWP_EquationInfoArchive.Extensions.equation_source_old)
  }

  var TSWP_EquationInfoArchive_equationTextProperties: TSWP_CharacterStylePropertiesArchive {
    get {return getExtensionValue(ext: TSWP_EquationInfoArchive.Extensions.equation_text_properties) ?? TSWP_CharacterStylePropertiesArchive()}
    set {setExtensionValue(ext: TSWP_EquationInfoArchive.Extensions.equation_text_properties, value: newValue)}
  }
  /// Returns true if extension `TSWP_EquationInfoArchive.Extensions.equation_text_properties`
  /// has been explicitly set.
  var hasTSWP_EquationInfoArchive_equationTextProperties: Bool {
    return hasExtensionValue(ext: TSWP_EquationInfoArchive.Extensions.equation_text_properties)
  }
  /// Clears the value of extension `TSWP_EquationInfoArchive.Extensions.equation_text_properties`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTSWP_EquationInfoArchive_equationTextProperties() {
    clearExtensionValue(ext: TSWP_EquationInfoArchive.Extensions.equation_text_properties)
  }

  var TSWP_EquationInfoArchive_equationDepth: Float {
    get {return getExtensionValue(ext: TSWP_EquationInfoArchive.Extensions.equation_depth) ?? 0}
    set {setExtensionValue(ext: TSWP_EquationInfoArchive.Extensions.equation_depth, value: newValue)}
  }
  /// Returns true if extension `TSWP_EquationInfoArchive.Extensions.equation_depth`
  /// has been explicitly set.
  var hasTSWP_EquationInfoArchive_equationDepth: Bool {
    return hasExtensionValue(ext: TSWP_EquationInfoArchive.Extensions.equation_depth)
  }
  /// Clears the value of extension `TSWP_EquationInfoArchive.Extensions.equation_depth`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTSWP_EquationInfoArchive_equationDepth() {
    clearExtensionValue(ext: TSWP_EquationInfoArchive.Extensions.equation_depth)
  }

  var TSWP_EquationInfoArchive_equationSourceText: String {
    get {return getExtensionValue(ext: TSWP_EquationInfoArchive.Extensions.equation_source_text) ?? String()}
    set {setExtensionValue(ext: TSWP_EquationInfoArchive.Extensions.equation_source_text, value: newValue)}
  }
  /// Returns true if extension `TSWP_EquationInfoArchive.Extensions.equation_source_text`
  /// has been explicitly set.
  var hasTSWP_EquationInfoArchive_equationSourceText: Bool {
    return hasExtensionValue(ext: TSWP_EquationInfoArchive.Extensions.equation_source_text)
  }
  /// Clears the value of extension `TSWP_EquationInfoArchive.Extensions.equation_source_text`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTSWP_EquationInfoArchive_equationSourceText() {
    clearExtensionValue(ext: TSWP_EquationInfoArchive.Extensions.equation_source_text)
  }
}

extension TSS_CommandPropertyEntryArchive {

  var TSWP_padding: TSWP_PaddingArchive {
    get {return getExtensionValue(ext: TSWP_Extensions_padding) ?? TSWP_PaddingArchive()}
    set {setExtensionValue(ext: TSWP_Extensions_padding, value: newValue)}
  }
  /// Returns true if extension `TSWP_Extensions_padding`
  /// has been explicitly set.
  var hasTSWP_padding: Bool {
    return hasExtensionValue(ext: TSWP_Extensions_padding)
  }
  /// Clears the value of extension `TSWP_Extensions_padding`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTSWP_padding() {
    clearExtensionValue(ext: TSWP_Extensions_padding)
  }
}

extension TSS_ThemeArchive {

  var TSWP_ThemePresetsArchive_extension: TSWP_ThemePresetsArchive {
    get {return getExtensionValue(ext: TSWP_ThemePresetsArchive.Extensions.extension) ?? TSWP_ThemePresetsArchive()}
    set {setExtensionValue(ext: TSWP_ThemePresetsArchive.Extensions.extension, value: newValue)}
  }
  /// Returns true if extension `TSWP_ThemePresetsArchive.Extensions.extension`
  /// has been explicitly set.
  var hasTSWP_ThemePresetsArchive_extension: Bool {
    return hasExtensionValue(ext: TSWP_ThemePresetsArchive.Extensions.extension)
  }
  /// Clears the value of extension `TSWP_ThemePresetsArchive.Extensions.extension`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTSWP_ThemePresetsArchive_extension() {
    clearExtensionValue(ext: TSWP_ThemePresetsArchive.Extensions.extension)
  }

}

// MARK: - File's ExtensionMap: TSWP_Tswparchives_Extensions

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
let TSWP_Tswparchives_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  TSWP_Extensions_padding,
  TSWP_ThemePresetsArchive.Extensions.extension,
  TSWP_EquationInfoArchive.Extensions.equation_source_old,
  TSWP_EquationInfoArchive.Extensions.equation_text_properties,
  TSWP_EquationInfoArchive.Extensions.equation_depth,
  TSWP_EquationInfoArchive.Extensions.equation_source_text,
  TSWP_CollaboratorTextCursorSubselectionArchive.Extensions.text_cursor_subselection
]

// Extension Objects - The only reason these might be needed is when manually
// constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
// accessors for the extension fields on the messages directly.

let TSWP_Extensions_padding = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TSWP_PaddingArchive>, TSS_CommandPropertyEntryArchive>(
  _protobuf_fieldNumber: 100,
  fieldName: "TSWP.padding"
)

extension TSWP_ThemePresetsArchive {
  enum Extensions {
    static let `extension` = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TSWP_ThemePresetsArchive>, TSS_ThemeArchive>(
      _protobuf_fieldNumber: 110,
      fieldName: "TSWP.ThemePresetsArchive.extension"
    )
  }
}

extension TSWP_EquationInfoArchive {
  enum Extensions {
    static let equation_source_old = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufString>, TSD_ImageArchive>(
      _protobuf_fieldNumber: 100,
      fieldName: "TSWP.EquationInfoArchive.equation_source_old"
    )

    static let equation_text_properties = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TSWP_CharacterStylePropertiesArchive>, TSD_ImageArchive>(
      _protobuf_fieldNumber: 101,
      fieldName: "TSWP.EquationInfoArchive.equation_text_properties"
    )

    static let equation_depth = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufFloat>, TSD_ImageArchive>(
      _protobuf_fieldNumber: 102,
      fieldName: "TSWP.EquationInfoArchive.equation_depth"
    )

    static let equation_source_text = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufString>, TSD_ImageArchive>(
      _protobuf_fieldNumber: 103,
      fieldName: "TSWP.EquationInfoArchive.equation_source_text"
    )
  }
}

extension TSWP_CollaboratorTextCursorSubselectionArchive {
  enum Extensions {
    static let text_cursor_subselection = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TSWP_CollaboratorTextCursorSubselectionArchive>, TSCK_CollaboratorCursorArchive>(
      _protobuf_fieldNumber: 100,
      fieldName: "TSWP.CollaboratorTextCursorSubselectionArchive.text_cursor_subselection"
    )
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TSWP"

extension TSWP_SelectionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SelectionType_Normal_DEPRECATED\0\u{1}SelectionType_ListLabel\0\u{1}SelectionType_ListTopic\0\u{1}SelectionType_Replace\0\u{1}SelectionType_CopyPasteStyle\0\u{1}SelectionType_Replace2\0\u{1}SelectionType_SmartField\0\u{1}SelectionType_Visual\0\u{1}SelectionType_Logical\0")
}

extension TSWP_StyleInsertionBehavior: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0StyleInsertionBehavior_NoGrow\0\u{1}StyleInsertionBehavior_GrowLeft\0\u{1}StyleInsertionBehavior_GrowRight\0")
}

extension TSWP_CaretAffinity: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CaretAffinity_Start\0\u{1}CaretAffinity_End\0")
}

extension TSWP_WritingDirectionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{7f}\u{7f}\u{7f}\u{7f}\u{7f}\u{3}kWritingDirectionNatural\0\u{1}kWritingDirectionLeftToRight\0\u{1}kWritingDirectionRightToLeft\0")
}

extension TSWP_SelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}deprecated_type\0\u{3}visual_definition_range\0\u{1}styleInsertionBehavior\0\u{1}caretAffinity\0\u{3}smart_field_range\0\u{3}leading_edge\0\u{3}leading_char_index\0\u{1}type\0\u{1}ranges\0")

  public var isInitialized: Bool {
    if self._deprecatedType == nil {return false}
    if self._visualDefinitionRange == nil {return false}
    if self._styleInsertionBehavior == nil {return false}
    if self._caretAffinity == nil {return false}
    if self._smartFieldRange == nil {return false}
    if let v = self._visualDefinitionRange, !v.isInitialized {return false}
    if let v = self._smartFieldRange, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.ranges) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._deprecatedType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._visualDefinitionRange) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._styleInsertionBehavior) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._caretAffinity) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._smartFieldRange) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._leadingEdge) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._leadingCharIndex) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.ranges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deprecatedType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._visualDefinitionRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._styleInsertionBehavior {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._caretAffinity {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._smartFieldRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._leadingEdge {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._leadingCharIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 8)
    } }()
    if !self.ranges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranges, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_SelectionArchive, rhs: TSWP_SelectionArchive) -> Bool {
    if lhs._deprecatedType != rhs._deprecatedType {return false}
    if lhs._visualDefinitionRange != rhs._visualDefinitionRange {return false}
    if lhs._styleInsertionBehavior != rhs._styleInsertionBehavior {return false}
    if lhs._caretAffinity != rhs._caretAffinity {return false}
    if lhs._smartFieldRange != rhs._smartFieldRange {return false}
    if lhs._leadingEdge != rhs._leadingEdge {return false}
    if lhs._leadingCharIndex != rhs._leadingCharIndex {return false}
    if lhs._type != rhs._type {return false}
    if lhs.ranges != rhs.ranges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ObjectAttributeTable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ObjectAttributeTable"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}entries\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.entries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ObjectAttributeTable, rhs: TSWP_ObjectAttributeTable) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ObjectAttributeTable.ObjectAttribute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_ObjectAttributeTable.protoMessageName + ".ObjectAttribute"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}character_index\0\u{1}object\0")

  public var isInitialized: Bool {
    if self._characterIndex == nil {return false}
    if let v = self._object, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._characterIndex) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._object) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._characterIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._object {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ObjectAttributeTable.ObjectAttribute, rhs: TSWP_ObjectAttributeTable.ObjectAttribute) -> Bool {
    if lhs._characterIndex != rhs._characterIndex {return false}
    if lhs._object != rhs._object {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_StringAttributeTable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StringAttributeTable"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}entries\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.entries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_StringAttributeTable, rhs: TSWP_StringAttributeTable) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_StringAttributeTable.StringAttribute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_StringAttributeTable.protoMessageName + ".StringAttribute"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}character_index\0\u{1}object\0")

  public var isInitialized: Bool {
    if self._characterIndex == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._characterIndex) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._object) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._characterIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._object {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_StringAttributeTable.StringAttribute, rhs: TSWP_StringAttributeTable.StringAttribute) -> Bool {
    if lhs._characterIndex != rhs._characterIndex {return false}
    if lhs._object != rhs._object {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ParaDataAttributeTable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParaDataAttributeTable"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}entries\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.entries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ParaDataAttributeTable, rhs: TSWP_ParaDataAttributeTable) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ParaDataAttributeTable.ParaDataAttribute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_ParaDataAttributeTable.protoMessageName + ".ParaDataAttribute"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}character_index\0\u{1}first\0\u{1}second\0")

  public var isInitialized: Bool {
    if self._characterIndex == nil {return false}
    if self._first == nil {return false}
    if self._second == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._characterIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._first) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._second) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._characterIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._first {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._second {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ParaDataAttributeTable.ParaDataAttribute, rhs: TSWP_ParaDataAttributeTable.ParaDataAttribute) -> Bool {
    if lhs._characterIndex != rhs._characterIndex {return false}
    if lhs._first != rhs._first {return false}
    if lhs._second != rhs._second {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_OverlappingFieldAttributeTable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OverlappingFieldAttributeTable"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}entries\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.entries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_OverlappingFieldAttributeTable, rhs: TSWP_OverlappingFieldAttributeTable) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_OverlappingFieldAttributeTable.OverlappingFieldAttribute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_OverlappingFieldAttributeTable.protoMessageName + ".OverlappingFieldAttribute"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}range\0\u{1}field\0")

  public var isInitialized: Bool {
    if self._range == nil {return false}
    if self._field == nil {return false}
    if let v = self._range, !v.isInitialized {return false}
    if let v = self._field, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._range) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._field) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._range {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._field {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_OverlappingFieldAttributeTable.OverlappingFieldAttribute, rhs: TSWP_OverlappingFieldAttributeTable.OverlappingFieldAttribute) -> Bool {
    if lhs._range != rhs._range {return false}
    if lhs._field != rhs._field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_StorageArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StorageArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}kind\0\u{3}style_sheet\0\u{1}text\0\u{3}has_itext\0\u{3}table_para_style\0\u{3}table_para_data\0\u{3}table_list_style\0\u{3}table_char_style\0\u{3}table_attachment\0\u{3}in_document\0\u{3}table_smartfield\0\u{3}table_layout_style\0\u{4}\u{2}table_para_starts\0\u{3}table_bookmark\0\u{3}table_footnote\0\u{3}table_section\0\u{3}table_rubyfield\0\u{3}table_language\0\u{3}table_dictation\0\u{3}table_insertion\0\u{3}table_deletion\0\u{3}table_highlight\0\u{3}table_para_bidi\0\u{3}table_overlapping_highlight\0\u{3}table_pencil_annotation\0\u{3}table_tatechuyoko\0\u{3}table_drop_cap_style\0")

  fileprivate class _StorageClass {
    var _kind: TSWP_StorageArchive.KindType? = nil
    var _styleSheet: TSP_Reference? = nil
    var _text: [String] = []
    var _hasItext_p: Bool? = nil
    var _inDocument: Bool? = nil
    var _tableParaStyle: TSWP_ObjectAttributeTable? = nil
    var _tableParaData: TSWP_ParaDataAttributeTable? = nil
    var _tableListStyle: TSWP_ObjectAttributeTable? = nil
    var _tableCharStyle: TSWP_ObjectAttributeTable? = nil
    var _tableAttachment: TSWP_ObjectAttributeTable? = nil
    var _tableSmartfield: TSWP_ObjectAttributeTable? = nil
    var _tableLayoutStyle: TSWP_ObjectAttributeTable? = nil
    var _tableParaStarts: TSWP_ParaDataAttributeTable? = nil
    var _tableBookmark: TSWP_ObjectAttributeTable? = nil
    var _tableFootnote: TSWP_ObjectAttributeTable? = nil
    var _tableSection: TSWP_ObjectAttributeTable? = nil
    var _tableRubyfield: TSWP_ObjectAttributeTable? = nil
    var _tableLanguage: TSWP_StringAttributeTable? = nil
    var _tableDictation: TSWP_StringAttributeTable? = nil
    var _tableInsertion: TSWP_ObjectAttributeTable? = nil
    var _tableDeletion: TSWP_ObjectAttributeTable? = nil
    var _tableHighlight: TSWP_ObjectAttributeTable? = nil
    var _tableParaBidi: TSWP_ParaDataAttributeTable? = nil
    var _tableOverlappingHighlight: TSWP_OverlappingFieldAttributeTable? = nil
    var _tablePencilAnnotation: TSWP_OverlappingFieldAttributeTable? = nil
    var _tableTatechuyoko: TSWP_ObjectAttributeTable? = nil
    var _tableDropCapStyle: TSWP_ObjectAttributeTable? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kind = source._kind
      _styleSheet = source._styleSheet
      _text = source._text
      _hasItext_p = source._hasItext_p
      _inDocument = source._inDocument
      _tableParaStyle = source._tableParaStyle
      _tableParaData = source._tableParaData
      _tableListStyle = source._tableListStyle
      _tableCharStyle = source._tableCharStyle
      _tableAttachment = source._tableAttachment
      _tableSmartfield = source._tableSmartfield
      _tableLayoutStyle = source._tableLayoutStyle
      _tableParaStarts = source._tableParaStarts
      _tableBookmark = source._tableBookmark
      _tableFootnote = source._tableFootnote
      _tableSection = source._tableSection
      _tableRubyfield = source._tableRubyfield
      _tableLanguage = source._tableLanguage
      _tableDictation = source._tableDictation
      _tableInsertion = source._tableInsertion
      _tableDeletion = source._tableDeletion
      _tableHighlight = source._tableHighlight
      _tableParaBidi = source._tableParaBidi
      _tableOverlappingHighlight = source._tableOverlappingHighlight
      _tablePencilAnnotation = source._tablePencilAnnotation
      _tableTatechuyoko = source._tableTatechuyoko
      _tableDropCapStyle = source._tableDropCapStyle
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._styleSheet, !v.isInitialized {return false}
      if let v = _storage._tableParaStyle, !v.isInitialized {return false}
      if let v = _storage._tableParaData, !v.isInitialized {return false}
      if let v = _storage._tableListStyle, !v.isInitialized {return false}
      if let v = _storage._tableCharStyle, !v.isInitialized {return false}
      if let v = _storage._tableAttachment, !v.isInitialized {return false}
      if let v = _storage._tableSmartfield, !v.isInitialized {return false}
      if let v = _storage._tableLayoutStyle, !v.isInitialized {return false}
      if let v = _storage._tableParaStarts, !v.isInitialized {return false}
      if let v = _storage._tableBookmark, !v.isInitialized {return false}
      if let v = _storage._tableFootnote, !v.isInitialized {return false}
      if let v = _storage._tableSection, !v.isInitialized {return false}
      if let v = _storage._tableRubyfield, !v.isInitialized {return false}
      if let v = _storage._tableLanguage, !v.isInitialized {return false}
      if let v = _storage._tableDictation, !v.isInitialized {return false}
      if let v = _storage._tableInsertion, !v.isInitialized {return false}
      if let v = _storage._tableDeletion, !v.isInitialized {return false}
      if let v = _storage._tableHighlight, !v.isInitialized {return false}
      if let v = _storage._tableParaBidi, !v.isInitialized {return false}
      if let v = _storage._tableOverlappingHighlight, !v.isInitialized {return false}
      if let v = _storage._tablePencilAnnotation, !v.isInitialized {return false}
      if let v = _storage._tableTatechuyoko, !v.isInitialized {return false}
      if let v = _storage._tableDropCapStyle, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._kind) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._styleSheet) }()
        case 3: try { try decoder.decodeRepeatedStringField(value: &_storage._text) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._hasItext_p) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._tableParaStyle) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._tableParaData) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._tableListStyle) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._tableCharStyle) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._tableAttachment) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._inDocument) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._tableSmartfield) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._tableLayoutStyle) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._tableParaStarts) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._tableBookmark) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._tableFootnote) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._tableSection) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._tableRubyfield) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._tableLanguage) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._tableDictation) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._tableInsertion) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._tableDeletion) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._tableHighlight) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._tableParaBidi) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._tableOverlappingHighlight) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._tablePencilAnnotation) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._tableTatechuyoko) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._tableDropCapStyle) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._kind {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._styleSheet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._text.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._text, fieldNumber: 3)
      }
      try { if let v = _storage._hasItext_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._tableParaStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._tableParaData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._tableListStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._tableCharStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._tableAttachment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._inDocument {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._tableSmartfield {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._tableLayoutStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._tableParaStarts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._tableBookmark {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._tableFootnote {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._tableSection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._tableRubyfield {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._tableLanguage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._tableDictation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._tableInsertion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._tableDeletion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._tableHighlight {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._tableParaBidi {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._tableOverlappingHighlight {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._tablePencilAnnotation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._tableTatechuyoko {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      } }()
      try { if let v = _storage._tableDropCapStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_StorageArchive, rhs: TSWP_StorageArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._styleSheet != rhs_storage._styleSheet {return false}
        if _storage._text != rhs_storage._text {return false}
        if _storage._hasItext_p != rhs_storage._hasItext_p {return false}
        if _storage._inDocument != rhs_storage._inDocument {return false}
        if _storage._tableParaStyle != rhs_storage._tableParaStyle {return false}
        if _storage._tableParaData != rhs_storage._tableParaData {return false}
        if _storage._tableListStyle != rhs_storage._tableListStyle {return false}
        if _storage._tableCharStyle != rhs_storage._tableCharStyle {return false}
        if _storage._tableAttachment != rhs_storage._tableAttachment {return false}
        if _storage._tableSmartfield != rhs_storage._tableSmartfield {return false}
        if _storage._tableLayoutStyle != rhs_storage._tableLayoutStyle {return false}
        if _storage._tableParaStarts != rhs_storage._tableParaStarts {return false}
        if _storage._tableBookmark != rhs_storage._tableBookmark {return false}
        if _storage._tableFootnote != rhs_storage._tableFootnote {return false}
        if _storage._tableSection != rhs_storage._tableSection {return false}
        if _storage._tableRubyfield != rhs_storage._tableRubyfield {return false}
        if _storage._tableLanguage != rhs_storage._tableLanguage {return false}
        if _storage._tableDictation != rhs_storage._tableDictation {return false}
        if _storage._tableInsertion != rhs_storage._tableInsertion {return false}
        if _storage._tableDeletion != rhs_storage._tableDeletion {return false}
        if _storage._tableHighlight != rhs_storage._tableHighlight {return false}
        if _storage._tableParaBidi != rhs_storage._tableParaBidi {return false}
        if _storage._tableOverlappingHighlight != rhs_storage._tableOverlappingHighlight {return false}
        if _storage._tablePencilAnnotation != rhs_storage._tablePencilAnnotation {return false}
        if _storage._tableTatechuyoko != rhs_storage._tableTatechuyoko {return false}
        if _storage._tableDropCapStyle != rhs_storage._tableDropCapStyle {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_StorageArchive.KindType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0BODY\0\u{1}HEADER\0\u{1}FOOTNOTE\0\u{1}TEXTBOX\0\u{1}NOTE\0\u{1}CELL\0\u{1}UNCLASSIFIED\0\u{1}TABLEOFCONTENTS\0\u{1}UNDEFINED\0")
}

extension TSWP_HighlightArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HighlightArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}commentStorage\0\u{3}text_attribute_uuid_string\0")

  public var isInitialized: Bool {
    if let v = self._commentStorage, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commentStorage) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._textAttributeUuidString) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commentStorage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._textAttributeUuidString {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_HighlightArchive, rhs: TSWP_HighlightArchive) -> Bool {
    if lhs._commentStorage != rhs._commentStorage {return false}
    if lhs._textAttributeUuidString != rhs._textAttributeUuidString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_PencilAnnotationArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PencilAnnotationArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}pencil_annotation_storage\0\u{3}text_attribute_uuid_string\0")

  public var isInitialized: Bool {
    if let v = self._pencilAnnotationStorage, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pencilAnnotationStorage) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._textAttributeUuidString) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pencilAnnotationStorage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._textAttributeUuidString {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_PencilAnnotationArchive, rhs: TSWP_PencilAnnotationArchive) -> Bool {
    if lhs._pencilAnnotationStorage != rhs._pencilAnnotationStorage {return false}
    if lhs._textAttributeUuidString != rhs._textAttributeUuidString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_FontFeatureArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FontFeatureArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}feature_type\0\u{3}feature_selector\0")

  public var isInitialized: Bool {
    if self._featureType == nil {return false}
    if self._featureSelector == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._featureType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._featureSelector) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._featureType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._featureSelector {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_FontFeatureArchive, rhs: TSWP_FontFeatureArchive) -> Bool {
    if lhs._featureType != rhs._featureType {return false}
    if lhs._featureSelector != rhs._featureSelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_CharacterStylePropertiesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CharacterStylePropertiesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}bold\0\u{1}italic\0\u{3}font_size\0\u{3}font_name_null\0\u{3}font_name\0\u{3}font_color_null\0\u{3}font_color\0\u{3}language_null\0\u{1}language\0\u{1}superscript\0\u{1}underline\0\u{1}strikethru\0\u{1}capitalization\0\u{3}baseline_shift\0\u{1}kerning\0\u{1}ligatures\0\u{3}outline_color_null\0\u{3}outline_color\0\u{1}outline\0\u{3}shadow_null\0\u{1}shadow\0\u{3}strikethru_color_null\0\u{3}strikethru_color\0\u{3}strikethru_width\0\u{3}background_color_null\0\u{3}background_color\0\u{1}tracking\0\u{3}underline_color_null\0\u{3}underline_color\0\u{3}underline_width\0\u{3}word_strikethru\0\u{3}word_underline\0\u{3}font_features_null\0\u{3}font_features\0\u{3}writing_direction\0\u{3}emphasis_marks_null\0\u{3}emphasis_marks\0\u{3}compatibility_font_name_null\0\u{3}compatibility_font_name\0\u{3}is_named_point_size\0\u{3}capitalization_uses_linguistics\0\u{3}tate_chu_yoko\0\u{3}tsd_stroke_null\0\u{3}tsd_stroke\0\u{3}tsd_fill_null\0\u{3}tsd_fill\0\u{3}tsd_fill_should_fill_text_container\0")

  fileprivate class _StorageClass {
    var _bold: Bool? = nil
    var _italic: Bool? = nil
    var _fontSize: Float? = nil
    var _fontNameNull: Bool? = nil
    var _fontName: String? = nil
    var _fontColorNull: Bool? = nil
    var _fontColor: TSP_Color? = nil
    var _languageNull: Bool? = nil
    var _language: String? = nil
    var _superscript: TSWP_CharacterStylePropertiesArchive.SuperscriptType? = nil
    var _underline: TSWP_CharacterStylePropertiesArchive.UnderlineType? = nil
    var _strikethru: TSWP_CharacterStylePropertiesArchive.StrikethruType? = nil
    var _capitalization: TSWP_CharacterStylePropertiesArchive.CapitalizationType? = nil
    var _baselineShift: Float? = nil
    var _kerning: Float? = nil
    var _ligatures: TSWP_CharacterStylePropertiesArchive.LigaturesType? = nil
    var _outlineColorNull: Bool? = nil
    var _outlineColor: TSP_Color? = nil
    var _outline: Float? = nil
    var _shadowNull: Bool? = nil
    var _shadow: TSD_ShadowArchive? = nil
    var _strikethruColorNull: Bool? = nil
    var _strikethruColor: TSP_Color? = nil
    var _strikethruWidth: Float? = nil
    var _backgroundColorNull: Bool? = nil
    var _backgroundColor: TSP_Color? = nil
    var _tracking: Float? = nil
    var _underlineColorNull: Bool? = nil
    var _underlineColor: TSP_Color? = nil
    var _underlineWidth: Float? = nil
    var _wordStrikethru: Bool? = nil
    var _wordUnderline: Bool? = nil
    var _fontFeaturesNull: Bool? = nil
    var _fontFeatures: [TSWP_FontFeatureArchive] = []
    var _writingDirection: TSWP_WritingDirectionType? = nil
    var _emphasisMarksNull: Bool? = nil
    var _emphasisMarks: String? = nil
    var _compatibilityFontNameNull: Bool? = nil
    var _compatibilityFontName: String? = nil
    var _isNamedPointSize: Bool? = nil
    var _capitalizationUsesLinguistics: Bool? = nil
    var _tateChuYoko: Bool? = nil
    var _tsdStrokeNull: Bool? = nil
    var _tsdStroke: TSD_StrokeArchive? = nil
    var _tsdFillNull: Bool? = nil
    var _tsdFill: TSD_FillArchive? = nil
    var _tsdFillShouldFillTextContainer: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _bold = source._bold
      _italic = source._italic
      _fontSize = source._fontSize
      _fontNameNull = source._fontNameNull
      _fontName = source._fontName
      _fontColorNull = source._fontColorNull
      _fontColor = source._fontColor
      _languageNull = source._languageNull
      _language = source._language
      _superscript = source._superscript
      _underline = source._underline
      _strikethru = source._strikethru
      _capitalization = source._capitalization
      _baselineShift = source._baselineShift
      _kerning = source._kerning
      _ligatures = source._ligatures
      _outlineColorNull = source._outlineColorNull
      _outlineColor = source._outlineColor
      _outline = source._outline
      _shadowNull = source._shadowNull
      _shadow = source._shadow
      _strikethruColorNull = source._strikethruColorNull
      _strikethruColor = source._strikethruColor
      _strikethruWidth = source._strikethruWidth
      _backgroundColorNull = source._backgroundColorNull
      _backgroundColor = source._backgroundColor
      _tracking = source._tracking
      _underlineColorNull = source._underlineColorNull
      _underlineColor = source._underlineColor
      _underlineWidth = source._underlineWidth
      _wordStrikethru = source._wordStrikethru
      _wordUnderline = source._wordUnderline
      _fontFeaturesNull = source._fontFeaturesNull
      _fontFeatures = source._fontFeatures
      _writingDirection = source._writingDirection
      _emphasisMarksNull = source._emphasisMarksNull
      _emphasisMarks = source._emphasisMarks
      _compatibilityFontNameNull = source._compatibilityFontNameNull
      _compatibilityFontName = source._compatibilityFontName
      _isNamedPointSize = source._isNamedPointSize
      _capitalizationUsesLinguistics = source._capitalizationUsesLinguistics
      _tateChuYoko = source._tateChuYoko
      _tsdStrokeNull = source._tsdStrokeNull
      _tsdStroke = source._tsdStroke
      _tsdFillNull = source._tsdFillNull
      _tsdFill = source._tsdFill
      _tsdFillShouldFillTextContainer = source._tsdFillShouldFillTextContainer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._fontColor, !v.isInitialized {return false}
      if let v = _storage._outlineColor, !v.isInitialized {return false}
      if let v = _storage._shadow, !v.isInitialized {return false}
      if let v = _storage._strikethruColor, !v.isInitialized {return false}
      if let v = _storage._backgroundColor, !v.isInitialized {return false}
      if let v = _storage._underlineColor, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._fontFeatures) {return false}
      if let v = _storage._tsdStroke, !v.isInitialized {return false}
      if let v = _storage._tsdFill, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._bold) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._italic) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._fontSize) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._fontNameNull) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._fontName) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._fontColorNull) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._fontColor) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._languageNull) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._language) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._superscript) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._underline) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._strikethru) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._capitalization) }()
        case 14: try { try decoder.decodeSingularFloatField(value: &_storage._baselineShift) }()
        case 15: try { try decoder.decodeSingularFloatField(value: &_storage._kerning) }()
        case 16: try { try decoder.decodeSingularEnumField(value: &_storage._ligatures) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._outlineColorNull) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._outlineColor) }()
        case 19: try { try decoder.decodeSingularFloatField(value: &_storage._outline) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._shadowNull) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._shadow) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._strikethruColorNull) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._strikethruColor) }()
        case 24: try { try decoder.decodeSingularFloatField(value: &_storage._strikethruWidth) }()
        case 25: try { try decoder.decodeSingularBoolField(value: &_storage._backgroundColorNull) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._backgroundColor) }()
        case 27: try { try decoder.decodeSingularFloatField(value: &_storage._tracking) }()
        case 28: try { try decoder.decodeSingularBoolField(value: &_storage._underlineColorNull) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._underlineColor) }()
        case 30: try { try decoder.decodeSingularFloatField(value: &_storage._underlineWidth) }()
        case 31: try { try decoder.decodeSingularBoolField(value: &_storage._wordStrikethru) }()
        case 32: try { try decoder.decodeSingularBoolField(value: &_storage._wordUnderline) }()
        case 33: try { try decoder.decodeSingularBoolField(value: &_storage._fontFeaturesNull) }()
        case 34: try { try decoder.decodeRepeatedMessageField(value: &_storage._fontFeatures) }()
        case 35: try { try decoder.decodeSingularEnumField(value: &_storage._writingDirection) }()
        case 36: try { try decoder.decodeSingularBoolField(value: &_storage._emphasisMarksNull) }()
        case 37: try { try decoder.decodeSingularStringField(value: &_storage._emphasisMarks) }()
        case 38: try { try decoder.decodeSingularBoolField(value: &_storage._compatibilityFontNameNull) }()
        case 39: try { try decoder.decodeSingularStringField(value: &_storage._compatibilityFontName) }()
        case 40: try { try decoder.decodeSingularBoolField(value: &_storage._isNamedPointSize) }()
        case 41: try { try decoder.decodeSingularBoolField(value: &_storage._capitalizationUsesLinguistics) }()
        case 42: try { try decoder.decodeSingularBoolField(value: &_storage._tateChuYoko) }()
        case 43: try { try decoder.decodeSingularBoolField(value: &_storage._tsdStrokeNull) }()
        case 44: try { try decoder.decodeSingularMessageField(value: &_storage._tsdStroke) }()
        case 45: try { try decoder.decodeSingularBoolField(value: &_storage._tsdFillNull) }()
        case 46: try { try decoder.decodeSingularMessageField(value: &_storage._tsdFill) }()
        case 47: try { try decoder.decodeSingularBoolField(value: &_storage._tsdFillShouldFillTextContainer) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._bold {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._italic {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._fontSize {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._fontNameNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._fontName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._fontColorNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._fontColor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._languageNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._language {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._superscript {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._underline {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._strikethru {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._capitalization {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._baselineShift {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._kerning {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._ligatures {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._outlineColorNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._outlineColor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._outline {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._shadowNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._shadow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._strikethruColorNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._strikethruColor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._strikethruWidth {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._backgroundColorNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._backgroundColor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._tracking {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 27)
      } }()
      try { if let v = _storage._underlineColorNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._underlineColor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._underlineWidth {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._wordStrikethru {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._wordUnderline {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._fontFeaturesNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 33)
      } }()
      if !_storage._fontFeatures.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._fontFeatures, fieldNumber: 34)
      }
      try { if let v = _storage._writingDirection {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 35)
      } }()
      try { if let v = _storage._emphasisMarksNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 36)
      } }()
      try { if let v = _storage._emphasisMarks {
        try visitor.visitSingularStringField(value: v, fieldNumber: 37)
      } }()
      try { if let v = _storage._compatibilityFontNameNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 38)
      } }()
      try { if let v = _storage._compatibilityFontName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 39)
      } }()
      try { if let v = _storage._isNamedPointSize {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 40)
      } }()
      try { if let v = _storage._capitalizationUsesLinguistics {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 41)
      } }()
      try { if let v = _storage._tateChuYoko {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 42)
      } }()
      try { if let v = _storage._tsdStrokeNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 43)
      } }()
      try { if let v = _storage._tsdStroke {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      } }()
      try { if let v = _storage._tsdFillNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 45)
      } }()
      try { if let v = _storage._tsdFill {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      } }()
      try { if let v = _storage._tsdFillShouldFillTextContainer {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 47)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_CharacterStylePropertiesArchive, rhs: TSWP_CharacterStylePropertiesArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._bold != rhs_storage._bold {return false}
        if _storage._italic != rhs_storage._italic {return false}
        if _storage._fontSize != rhs_storage._fontSize {return false}
        if _storage._fontNameNull != rhs_storage._fontNameNull {return false}
        if _storage._fontName != rhs_storage._fontName {return false}
        if _storage._fontColorNull != rhs_storage._fontColorNull {return false}
        if _storage._fontColor != rhs_storage._fontColor {return false}
        if _storage._languageNull != rhs_storage._languageNull {return false}
        if _storage._language != rhs_storage._language {return false}
        if _storage._superscript != rhs_storage._superscript {return false}
        if _storage._underline != rhs_storage._underline {return false}
        if _storage._strikethru != rhs_storage._strikethru {return false}
        if _storage._capitalization != rhs_storage._capitalization {return false}
        if _storage._baselineShift != rhs_storage._baselineShift {return false}
        if _storage._kerning != rhs_storage._kerning {return false}
        if _storage._ligatures != rhs_storage._ligatures {return false}
        if _storage._outlineColorNull != rhs_storage._outlineColorNull {return false}
        if _storage._outlineColor != rhs_storage._outlineColor {return false}
        if _storage._outline != rhs_storage._outline {return false}
        if _storage._shadowNull != rhs_storage._shadowNull {return false}
        if _storage._shadow != rhs_storage._shadow {return false}
        if _storage._strikethruColorNull != rhs_storage._strikethruColorNull {return false}
        if _storage._strikethruColor != rhs_storage._strikethruColor {return false}
        if _storage._strikethruWidth != rhs_storage._strikethruWidth {return false}
        if _storage._backgroundColorNull != rhs_storage._backgroundColorNull {return false}
        if _storage._backgroundColor != rhs_storage._backgroundColor {return false}
        if _storage._tracking != rhs_storage._tracking {return false}
        if _storage._underlineColorNull != rhs_storage._underlineColorNull {return false}
        if _storage._underlineColor != rhs_storage._underlineColor {return false}
        if _storage._underlineWidth != rhs_storage._underlineWidth {return false}
        if _storage._wordStrikethru != rhs_storage._wordStrikethru {return false}
        if _storage._wordUnderline != rhs_storage._wordUnderline {return false}
        if _storage._fontFeaturesNull != rhs_storage._fontFeaturesNull {return false}
        if _storage._fontFeatures != rhs_storage._fontFeatures {return false}
        if _storage._writingDirection != rhs_storage._writingDirection {return false}
        if _storage._emphasisMarksNull != rhs_storage._emphasisMarksNull {return false}
        if _storage._emphasisMarks != rhs_storage._emphasisMarks {return false}
        if _storage._compatibilityFontNameNull != rhs_storage._compatibilityFontNameNull {return false}
        if _storage._compatibilityFontName != rhs_storage._compatibilityFontName {return false}
        if _storage._isNamedPointSize != rhs_storage._isNamedPointSize {return false}
        if _storage._capitalizationUsesLinguistics != rhs_storage._capitalizationUsesLinguistics {return false}
        if _storage._tateChuYoko != rhs_storage._tateChuYoko {return false}
        if _storage._tsdStrokeNull != rhs_storage._tsdStrokeNull {return false}
        if _storage._tsdStroke != rhs_storage._tsdStroke {return false}
        if _storage._tsdFillNull != rhs_storage._tsdFillNull {return false}
        if _storage._tsdFill != rhs_storage._tsdFill {return false}
        if _storage._tsdFillShouldFillTextContainer != rhs_storage._tsdFillShouldFillTextContainer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_CharacterStylePropertiesArchive.CapitalizationType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kNoCaps\0\u{1}kAllCaps\0\u{1}kSmallCaps\0\u{1}kTitled\0")
}

extension TSWP_CharacterStylePropertiesArchive.UnderlineType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kNoUnderline\0\u{1}kSingleUnderline\0\u{1}kDoubleUnderline\0\u{1}kWavyUnderline\0")
}

extension TSWP_CharacterStylePropertiesArchive.LigaturesType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kRequiredLigatures\0\u{1}kStandardLigatures\0\u{1}kAllLigatures\0")
}

extension TSWP_CharacterStylePropertiesArchive.StrikethruType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kNoStrikethru\0\u{1}kSingleStrikethru\0\u{1}kDoubleStrikethru\0\u{1}kTripleStrikethru\0")
}

extension TSWP_CharacterStylePropertiesArchive.SuperscriptType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kNoScript\0\u{1}kSuperscript\0\u{1}kSubscript\0")
}

extension TSWP_CharacterStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CharacterStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{9}override_count\0\u{3}char_properties\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._charProperties, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._overrideCount) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._charProperties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._overrideCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._charProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_CharacterStyleArchive, rhs: TSWP_CharacterStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._overrideCount != rhs._overrideCount {return false}
    if lhs._charProperties != rhs._charProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_TabArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TabArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}position\0\u{1}alignment\0\u{1}leader\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._position) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._alignment) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._leader) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._position {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._alignment {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._leader {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_TabArchive, rhs: TSWP_TabArchive) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs._alignment != rhs._alignment {return false}
    if lhs._leader != rhs._leader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_TabArchive.TabAlignmentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kTabAlignmentLeft\0\u{1}kTabAlignmentCenter\0\u{1}kTabAlignmentRight\0\u{1}kTabAlignmentDecimal\0")
}

extension TSWP_TabsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TabsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}tabs\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tabs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tabs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tabs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_TabsArchive, rhs: TSWP_TabsArchive) -> Bool {
    if lhs.tabs != rhs.tabs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_LineSpacingArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LineSpacingArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}mode\0\u{1}amount\0\u{1}baselineRule\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._mode) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._amount) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._baselineRule) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._amount {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._baselineRule {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_LineSpacingArchive, rhs: TSWP_LineSpacingArchive) -> Bool {
    if lhs._mode != rhs._mode {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs._baselineRule != rhs._baselineRule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_LineSpacingArchive.LineSpacingModeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kRelativeLineSpacing\0\u{1}kMinimumLineSpacing\0\u{1}kExactLineSpacing\0\u{1}kMaximumLineSpacing\0\u{1}kSpaceBetweenLineSpacing\0")
}

extension TSWP_ParagraphStylePropertiesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParagraphStylePropertiesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}alignment\0\u{3}decimal_tab_null\0\u{3}decimal_tab\0\u{3}default_tab_stops\0\u{3}fill_null\0\u{1}fill\0\u{3}first_line_indent\0\u{1}hyphenate\0\u{3}keep_lines_together\0\u{3}keep_with_next\0\u{3}left_indent\0\u{3}line_spacing_null\0\u{3}line_spacing\0\u{3}page_break_before\0\u{3}deprecated_borders\0\u{3}historical_rule_offset_null\0\u{3}historical_rule_offset\0\u{3}rule_width\0\u{3}right_indent\0\u{3}space_after\0\u{3}space_before\0\u{4}\u{3}tabs_null\0\u{1}tabs\0\u{3}widow_control\0\u{3}outline_level\0\u{3}outline_style\0\u{3}following_style_id_null\0\u{3}following_style_id\0\u{3}stroke_null\0\u{1}stroke\0\u{3}show_in_toc\0\u{3}toc_style_id_null\0\u{3}toc_style_id\0\u{4}\u{3}writing_direction\0\u{3}list_style_null\0\u{3}list_style\0\u{3}following_style_null\0\u{3}following_style\0\u{3}show_in_bookmarks_list\0\u{3}show_in_toc_navigator\0\u{3}border_positions\0\u{3}rounded_corners\0")

  fileprivate class _StorageClass {
    var _alignment: TSWP_ParagraphStylePropertiesArchive.TextAlignmentType? = nil
    var _decimalTabNull: Bool? = nil
    var _decimalTab: String? = nil
    var _defaultTabStops: Float? = nil
    var _fillNull: Bool? = nil
    var _fill: TSP_Color? = nil
    var _firstLineIndent: Float? = nil
    var _hyphenate: Bool? = nil
    var _keepLinesTogether: Bool? = nil
    var _keepWithNext: Bool? = nil
    var _leftIndent: Float? = nil
    var _lineSpacingNull: Bool? = nil
    var _lineSpacing: TSWP_LineSpacingArchive? = nil
    var _pageBreakBefore: Bool? = nil
    var _deprecatedBorders: TSWP_ParagraphStylePropertiesArchive.DeprecatedParagraphBorderType? = nil
    var _historicalRuleOffsetNull: Bool? = nil
    var _historicalRuleOffset: TSP_Point? = nil
    var _ruleWidth: Float? = nil
    var _rightIndent: Float? = nil
    var _spaceAfter: Float? = nil
    var _spaceBefore: Float? = nil
    var _tabsNull: Bool? = nil
    var _tabs: TSWP_TabsArchive? = nil
    var _widowControl: Bool? = nil
    var _outlineLevel: UInt32? = nil
    var _outlineStyle: TSWP_ParagraphStylePropertiesArchive.OutlineStyleType? = nil
    var _followingStyleIDNull: Bool? = nil
    var _followingStyleID: String? = nil
    var _strokeNull: Bool? = nil
    var _stroke: TSD_StrokeArchive? = nil
    var _showInToc: Bool? = nil
    var _tocStyleIDNull: Bool? = nil
    var _tocStyleID: String? = nil
    var _writingDirection: TSWP_WritingDirectionType? = nil
    var _listStyleNull: Bool? = nil
    var _listStyle: TSP_Reference? = nil
    var _followingStyleNull: Bool? = nil
    var _followingStyle: TSP_Reference? = nil
    var _showInBookmarksList: Bool? = nil
    var _showInTocNavigator: Bool? = nil
    var _borderPositions: Int32? = nil
    var _roundedCorners: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _alignment = source._alignment
      _decimalTabNull = source._decimalTabNull
      _decimalTab = source._decimalTab
      _defaultTabStops = source._defaultTabStops
      _fillNull = source._fillNull
      _fill = source._fill
      _firstLineIndent = source._firstLineIndent
      _hyphenate = source._hyphenate
      _keepLinesTogether = source._keepLinesTogether
      _keepWithNext = source._keepWithNext
      _leftIndent = source._leftIndent
      _lineSpacingNull = source._lineSpacingNull
      _lineSpacing = source._lineSpacing
      _pageBreakBefore = source._pageBreakBefore
      _deprecatedBorders = source._deprecatedBorders
      _historicalRuleOffsetNull = source._historicalRuleOffsetNull
      _historicalRuleOffset = source._historicalRuleOffset
      _ruleWidth = source._ruleWidth
      _rightIndent = source._rightIndent
      _spaceAfter = source._spaceAfter
      _spaceBefore = source._spaceBefore
      _tabsNull = source._tabsNull
      _tabs = source._tabs
      _widowControl = source._widowControl
      _outlineLevel = source._outlineLevel
      _outlineStyle = source._outlineStyle
      _followingStyleIDNull = source._followingStyleIDNull
      _followingStyleID = source._followingStyleID
      _strokeNull = source._strokeNull
      _stroke = source._stroke
      _showInToc = source._showInToc
      _tocStyleIDNull = source._tocStyleIDNull
      _tocStyleID = source._tocStyleID
      _writingDirection = source._writingDirection
      _listStyleNull = source._listStyleNull
      _listStyle = source._listStyle
      _followingStyleNull = source._followingStyleNull
      _followingStyle = source._followingStyle
      _showInBookmarksList = source._showInBookmarksList
      _showInTocNavigator = source._showInTocNavigator
      _borderPositions = source._borderPositions
      _roundedCorners = source._roundedCorners
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._fill, !v.isInitialized {return false}
      if let v = _storage._historicalRuleOffset, !v.isInitialized {return false}
      if let v = _storage._stroke, !v.isInitialized {return false}
      if let v = _storage._listStyle, !v.isInitialized {return false}
      if let v = _storage._followingStyle, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._alignment) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._decimalTabNull) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._decimalTab) }()
        case 4: try { try decoder.decodeSingularFloatField(value: &_storage._defaultTabStops) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._fillNull) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._fill) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._firstLineIndent) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._hyphenate) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._keepLinesTogether) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._keepWithNext) }()
        case 11: try { try decoder.decodeSingularFloatField(value: &_storage._leftIndent) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._lineSpacingNull) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._lineSpacing) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._pageBreakBefore) }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._deprecatedBorders) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._historicalRuleOffsetNull) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._historicalRuleOffset) }()
        case 18: try { try decoder.decodeSingularFloatField(value: &_storage._ruleWidth) }()
        case 19: try { try decoder.decodeSingularFloatField(value: &_storage._rightIndent) }()
        case 20: try { try decoder.decodeSingularFloatField(value: &_storage._spaceAfter) }()
        case 21: try { try decoder.decodeSingularFloatField(value: &_storage._spaceBefore) }()
        case 24: try { try decoder.decodeSingularBoolField(value: &_storage._tabsNull) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._tabs) }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._widowControl) }()
        case 27: try { try decoder.decodeSingularUInt32Field(value: &_storage._outlineLevel) }()
        case 28: try { try decoder.decodeSingularEnumField(value: &_storage._outlineStyle) }()
        case 29: try { try decoder.decodeSingularBoolField(value: &_storage._followingStyleIDNull) }()
        case 30: try { try decoder.decodeSingularStringField(value: &_storage._followingStyleID) }()
        case 31: try { try decoder.decodeSingularBoolField(value: &_storage._strokeNull) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._stroke) }()
        case 33: try { try decoder.decodeSingularBoolField(value: &_storage._showInToc) }()
        case 34: try { try decoder.decodeSingularBoolField(value: &_storage._tocStyleIDNull) }()
        case 35: try { try decoder.decodeSingularStringField(value: &_storage._tocStyleID) }()
        case 38: try { try decoder.decodeSingularEnumField(value: &_storage._writingDirection) }()
        case 39: try { try decoder.decodeSingularBoolField(value: &_storage._listStyleNull) }()
        case 40: try { try decoder.decodeSingularMessageField(value: &_storage._listStyle) }()
        case 41: try { try decoder.decodeSingularBoolField(value: &_storage._followingStyleNull) }()
        case 42: try { try decoder.decodeSingularMessageField(value: &_storage._followingStyle) }()
        case 43: try { try decoder.decodeSingularBoolField(value: &_storage._showInBookmarksList) }()
        case 44: try { try decoder.decodeSingularBoolField(value: &_storage._showInTocNavigator) }()
        case 45: try { try decoder.decodeSingularInt32Field(value: &_storage._borderPositions) }()
        case 46: try { try decoder.decodeSingularBoolField(value: &_storage._roundedCorners) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._alignment {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._decimalTabNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._decimalTab {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._defaultTabStops {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._fillNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._fill {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._firstLineIndent {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._hyphenate {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._keepLinesTogether {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._keepWithNext {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._leftIndent {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._lineSpacingNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._lineSpacing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._pageBreakBefore {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._deprecatedBorders {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._historicalRuleOffsetNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._historicalRuleOffset {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._ruleWidth {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._rightIndent {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._spaceAfter {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._spaceBefore {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._tabsNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._tabs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._widowControl {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._outlineLevel {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 27)
      } }()
      try { if let v = _storage._outlineStyle {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._followingStyleIDNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._followingStyleID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._strokeNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._stroke {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._showInToc {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 33)
      } }()
      try { if let v = _storage._tocStyleIDNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 34)
      } }()
      try { if let v = _storage._tocStyleID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 35)
      } }()
      try { if let v = _storage._writingDirection {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 38)
      } }()
      try { if let v = _storage._listStyleNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 39)
      } }()
      try { if let v = _storage._listStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      } }()
      try { if let v = _storage._followingStyleNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 41)
      } }()
      try { if let v = _storage._followingStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      } }()
      try { if let v = _storage._showInBookmarksList {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 43)
      } }()
      try { if let v = _storage._showInTocNavigator {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 44)
      } }()
      try { if let v = _storage._borderPositions {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 45)
      } }()
      try { if let v = _storage._roundedCorners {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 46)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ParagraphStylePropertiesArchive, rhs: TSWP_ParagraphStylePropertiesArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._alignment != rhs_storage._alignment {return false}
        if _storage._decimalTabNull != rhs_storage._decimalTabNull {return false}
        if _storage._decimalTab != rhs_storage._decimalTab {return false}
        if _storage._defaultTabStops != rhs_storage._defaultTabStops {return false}
        if _storage._fillNull != rhs_storage._fillNull {return false}
        if _storage._fill != rhs_storage._fill {return false}
        if _storage._firstLineIndent != rhs_storage._firstLineIndent {return false}
        if _storage._hyphenate != rhs_storage._hyphenate {return false}
        if _storage._keepLinesTogether != rhs_storage._keepLinesTogether {return false}
        if _storage._keepWithNext != rhs_storage._keepWithNext {return false}
        if _storage._leftIndent != rhs_storage._leftIndent {return false}
        if _storage._lineSpacingNull != rhs_storage._lineSpacingNull {return false}
        if _storage._lineSpacing != rhs_storage._lineSpacing {return false}
        if _storage._pageBreakBefore != rhs_storage._pageBreakBefore {return false}
        if _storage._deprecatedBorders != rhs_storage._deprecatedBorders {return false}
        if _storage._historicalRuleOffsetNull != rhs_storage._historicalRuleOffsetNull {return false}
        if _storage._historicalRuleOffset != rhs_storage._historicalRuleOffset {return false}
        if _storage._ruleWidth != rhs_storage._ruleWidth {return false}
        if _storage._rightIndent != rhs_storage._rightIndent {return false}
        if _storage._spaceAfter != rhs_storage._spaceAfter {return false}
        if _storage._spaceBefore != rhs_storage._spaceBefore {return false}
        if _storage._tabsNull != rhs_storage._tabsNull {return false}
        if _storage._tabs != rhs_storage._tabs {return false}
        if _storage._widowControl != rhs_storage._widowControl {return false}
        if _storage._outlineLevel != rhs_storage._outlineLevel {return false}
        if _storage._outlineStyle != rhs_storage._outlineStyle {return false}
        if _storage._followingStyleIDNull != rhs_storage._followingStyleIDNull {return false}
        if _storage._followingStyleID != rhs_storage._followingStyleID {return false}
        if _storage._strokeNull != rhs_storage._strokeNull {return false}
        if _storage._stroke != rhs_storage._stroke {return false}
        if _storage._showInToc != rhs_storage._showInToc {return false}
        if _storage._tocStyleIDNull != rhs_storage._tocStyleIDNull {return false}
        if _storage._tocStyleID != rhs_storage._tocStyleID {return false}
        if _storage._writingDirection != rhs_storage._writingDirection {return false}
        if _storage._listStyleNull != rhs_storage._listStyleNull {return false}
        if _storage._listStyle != rhs_storage._listStyle {return false}
        if _storage._followingStyleNull != rhs_storage._followingStyleNull {return false}
        if _storage._followingStyle != rhs_storage._followingStyle {return false}
        if _storage._showInBookmarksList != rhs_storage._showInBookmarksList {return false}
        if _storage._showInTocNavigator != rhs_storage._showInTocNavigator {return false}
        if _storage._borderPositions != rhs_storage._borderPositions {return false}
        if _storage._roundedCorners != rhs_storage._roundedCorners {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ParagraphStylePropertiesArchive.TextAlignmentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TATvalue0\0\u{1}TATvalue1\0\u{1}TATvalue2\0\u{1}TATvalue3\0\u{1}TATvalue4\0")
}

extension TSWP_ParagraphStylePropertiesArchive.DeprecatedParagraphBorderType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PBTvalue0\0\u{1}PBTvalue1\0\u{1}PBTvalue2\0\u{1}PBTvalue3\0\u{1}PBTvalue4\0\u{2}\u{4}PBTvalue5\0\u{1}PBTvalue6\0\u{1}PBTvalue7\0\u{1}PBTvalue8\0\u{2}\u{5}PBTvalue9\0\u{1}PBTvalue10\0\u{1}PBTvalue11\0\u{1}PBTvalue12\0\u{2}\u{5}PBTvalue13\0\u{1}PBTvalue14\0\u{1}PBTvalue15\0")
}

extension TSWP_ParagraphStylePropertiesArchive.OutlineStyleType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OSTvalue0\0\u{1}OSTvalue1\0\u{1}OSTvalue2\0")
}

extension TSWP_ParagraphStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParagraphStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{9}override_count\0\u{3}char_properties\0\u{3}para_properties\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._charProperties, !v.isInitialized {return false}
    if let v = self._paraProperties, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._overrideCount) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._charProperties) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._paraProperties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._overrideCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._charProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._paraProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ParagraphStyleArchive, rhs: TSWP_ParagraphStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._overrideCount != rhs._overrideCount {return false}
    if lhs._charProperties != rhs._charProperties {return false}
    if lhs._paraProperties != rhs._paraProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ListStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{9}override_count\0\u{3}label_types\0\u{3}text_indents\0\u{1}indents\0\u{1}geometries\0\u{3}number_types\0\u{1}strings\0\u{1}images\0\u{3}shadow_null\0\u{1}shadow\0\u{3}font_color_null\0\u{3}font_color\0\u{3}font_name_null\0\u{3}font_name\0\u{3}writing_direction\0\u{3}tiered_numbers\0")

  fileprivate class _StorageClass {
    var _super: TSS_StyleArchive? = nil
    var _overrideCount: UInt32? = nil
    var _labelTypes: [TSWP_ListStyleArchive.LabelType] = []
    var _textIndents: [Float] = []
    var _indents: [Float] = []
    var _geometries: [TSWP_ListStyleArchive.LabelGeometry] = []
    var _numberTypes: [TSWP_ListStyleArchive.NumberType] = []
    var _strings: [String] = []
    var _images: [TSWP_ListStyleArchive.LabelImage] = []
    var _shadowNull: Bool? = nil
    var _shadow: TSD_ShadowArchive? = nil
    var _fontColorNull: Bool? = nil
    var _fontColor: TSP_Color? = nil
    var _fontNameNull: Bool? = nil
    var _fontName: String? = nil
    var _writingDirection: TSWP_WritingDirectionType? = nil
    var _tieredNumbers: [Bool] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _overrideCount = source._overrideCount
      _labelTypes = source._labelTypes
      _textIndents = source._textIndents
      _indents = source._indents
      _geometries = source._geometries
      _numberTypes = source._numberTypes
      _strings = source._strings
      _images = source._images
      _shadowNull = source._shadowNull
      _shadow = source._shadow
      _fontColorNull = source._fontColorNull
      _fontColor = source._fontColor
      _fontNameNull = source._fontNameNull
      _fontName = source._fontName
      _writingDirection = source._writingDirection
      _tieredNumbers = source._tieredNumbers
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._images) {return false}
      if let v = _storage._shadow, !v.isInitialized {return false}
      if let v = _storage._fontColor, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._overrideCount) }()
        case 11: try { try decoder.decodeRepeatedEnumField(value: &_storage._labelTypes) }()
        case 12: try { try decoder.decodeRepeatedFloatField(value: &_storage._textIndents) }()
        case 13: try { try decoder.decodeRepeatedFloatField(value: &_storage._indents) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._geometries) }()
        case 15: try { try decoder.decodeRepeatedEnumField(value: &_storage._numberTypes) }()
        case 16: try { try decoder.decodeRepeatedStringField(value: &_storage._strings) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._images) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._shadowNull) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._shadow) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._fontColorNull) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._fontColor) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._fontNameNull) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._fontName) }()
        case 24: try { try decoder.decodeSingularEnumField(value: &_storage._writingDirection) }()
        case 25: try { try decoder.decodeRepeatedBoolField(value: &_storage._tieredNumbers) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._overrideCount {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
      } }()
      if !_storage._labelTypes.isEmpty {
        try visitor.visitRepeatedEnumField(value: _storage._labelTypes, fieldNumber: 11)
      }
      if !_storage._textIndents.isEmpty {
        try visitor.visitRepeatedFloatField(value: _storage._textIndents, fieldNumber: 12)
      }
      if !_storage._indents.isEmpty {
        try visitor.visitRepeatedFloatField(value: _storage._indents, fieldNumber: 13)
      }
      if !_storage._geometries.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._geometries, fieldNumber: 14)
      }
      if !_storage._numberTypes.isEmpty {
        try visitor.visitRepeatedEnumField(value: _storage._numberTypes, fieldNumber: 15)
      }
      if !_storage._strings.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._strings, fieldNumber: 16)
      }
      if !_storage._images.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._images, fieldNumber: 17)
      }
      try { if let v = _storage._shadowNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._shadow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._fontColorNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._fontColor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._fontNameNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._fontName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._writingDirection {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 24)
      } }()
      if !_storage._tieredNumbers.isEmpty {
        try visitor.visitRepeatedBoolField(value: _storage._tieredNumbers, fieldNumber: 25)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ListStyleArchive, rhs: TSWP_ListStyleArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._overrideCount != rhs_storage._overrideCount {return false}
        if _storage._labelTypes != rhs_storage._labelTypes {return false}
        if _storage._textIndents != rhs_storage._textIndents {return false}
        if _storage._indents != rhs_storage._indents {return false}
        if _storage._geometries != rhs_storage._geometries {return false}
        if _storage._numberTypes != rhs_storage._numberTypes {return false}
        if _storage._strings != rhs_storage._strings {return false}
        if _storage._images != rhs_storage._images {return false}
        if _storage._shadowNull != rhs_storage._shadowNull {return false}
        if _storage._shadow != rhs_storage._shadow {return false}
        if _storage._fontColorNull != rhs_storage._fontColorNull {return false}
        if _storage._fontColor != rhs_storage._fontColor {return false}
        if _storage._fontNameNull != rhs_storage._fontNameNull {return false}
        if _storage._fontName != rhs_storage._fontName {return false}
        if _storage._writingDirection != rhs_storage._writingDirection {return false}
        if _storage._tieredNumbers != rhs_storage._tieredNumbers {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ListStyleArchive.LabelType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kNone\0\u{1}kImage\0\u{1}kString\0\u{1}kNumber\0")
}

extension TSWP_ListStyleArchive.NumberType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kNumericDecimal\0\u{1}kNumericDoubleParen\0\u{1}kNumericRightParen\0\u{1}kRomanUpperDecimal\0\u{1}kRomanUpperDoubleParen\0\u{1}kRomanUpperRightParen\0\u{1}kRomanLowerDecimal\0\u{1}kRomanLowerDoubleParen\0\u{1}kRomanLowerRightParen\0\u{1}kAlphaUpperDecimal\0\u{1}kAlphaUpperDoubleParen\0\u{1}kAlphaUpperRightParen\0\u{1}kAlphaLowerDecimal\0\u{1}kAlphaLowerDoubleParen\0\u{1}kAlphaLowerRightParen\0\u{1}kIdeographicJapaneseDecimalKind\0\u{1}kIdeographicJapaneseDoubleParenKind\0\u{1}kIdeographicJapaneseRightParenKind\0\u{1}kHiraganaDecimalKind\0\u{1}kHiraganaDoubleParenKind\0\u{1}kHiraganaRightParenKind\0\u{1}kKatakanaDecimalKind\0\u{1}kKatakanaDoubleParenKind\0\u{1}kKatakanaRightParenKind\0\u{1}kHiraganaIrohaDecimalKind\0\u{1}kHiraganaIrohaDoubleParenKind\0\u{1}kHiraganaIrohaRightParenKind\0\u{1}kKatakanaIrohaDecimalKind\0\u{1}kKatakanaIrohaDoubleParenKind\0\u{1}kKatakanaIrohaRightParenKind\0\u{1}kIdeographicSimplifiedChineseDecimalKind\0\u{1}kIdeographicSimplifiedChineseDoubleParenKind\0\u{1}kIdeographicSimplifiedChineseRightParenKind\0\u{1}kIdeographicTraditionalChineseDecimalKind\0\u{1}kIdeographicTraditionalChineseDoubleParenKind\0\u{1}kIdeographicTraditionalChineseRightParenKind\0\u{1}kIdeographicFormalJapaneseDecimalKind\0\u{1}kIdeographicFormalJapaneseDoubleParenKind\0\u{1}kIdeographicFormalJapaneseRightParenKind\0\u{1}kIdeographicFormalSimplifiedChineseDecimalKind\0\u{1}kIdeographicFormalSimplifiedChineseDoubleParenKind\0\u{1}kIdeographicFormalSimplifiedChineseRightParenKind\0\u{1}kIdeographicFormalTraditionalChineseDecimalKind\0\u{1}kIdeographicFormalTraditionalChineseDoubleParenKind\0\u{1}kIdeographicFormalTraditionalChineseRightParenKind\0\u{1}kKoreanAlphabetDecimalKind\0\u{1}kKoreanAlphabetDoubleParenKind\0\u{1}kKoreanAlphabetRightParenKind\0\u{1}kCircledNumberKind\0\u{1}kArabianNumericDecimalKind\0\u{1}kArabianNumericDoubleParenKind\0\u{1}kArabianNumericRightParenKind\0\u{1}kArabianAlphaDecimalKind\0\u{1}kArabianAlphaDoubleParenKind\0\u{1}kArabianAlphaRightParenKind\0\u{1}kArabianAbjadDecimalKind\0\u{1}kArabianAbjadDoubleParenKind\0\u{1}kArabianAbjadRightParenKind\0\u{1}kHebrewAlphaDecimalKind\0\u{1}kHebrewAlphaDoubleParenKind\0\u{1}kHebrewAlphaRightParenKind\0\u{1}kHebrewBiblicalStandardKind\0\u{1}kHebrewBiblicalDecimalKind\0\u{1}kHebrewBiblicalDoubleParenKind\0\u{1}kHebrewBiblicalRightParenKind\0")
}

extension TSWP_ListStyleArchive.LabelGeometry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_ListStyleArchive.protoMessageName + ".LabelGeometry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}scale\0\u{3}baseline_offset\0\u{3}scale_with_text\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._scale) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._baselineOffset) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._scaleWithText) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._scale {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._baselineOffset {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._scaleWithText {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ListStyleArchive.LabelGeometry, rhs: TSWP_ListStyleArchive.LabelGeometry) -> Bool {
    if lhs._scale != rhs._scale {return false}
    if lhs._baselineOffset != rhs._baselineOffset {return false}
    if lhs._scaleWithText != rhs._scaleWithText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ListStyleArchive.LabelImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_ListStyleArchive.protoMessageName + ".LabelImage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}database_image\0\u{3}image_null\0\u{1}image\0")

  public var isInitialized: Bool {
    if let v = self._image, !v.isInitialized {return false}
    if let v = self._databaseImage, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._databaseImage) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._imageNull) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._databaseImage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._imageNull {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ListStyleArchive.LabelImage, rhs: TSWP_ListStyleArchive.LabelImage) -> Bool {
    if lhs._image != rhs._image {return false}
    if lhs._imageNull != rhs._imageNull {return false}
    if lhs._databaseImage != rhs._databaseImage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_TextStylePresetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TextStylePresetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}preset_identifier\0\u{3}paragraph_style\0\u{3}list_style\0")

  public var isInitialized: Bool {
    if let v = self._paragraphStyle, !v.isInitialized {return false}
    if let v = self._listStyle, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._presetIdentifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._paragraphStyle) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._listStyle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._presetIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._paragraphStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._listStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_TextStylePresetArchive, rhs: TSWP_TextStylePresetArchive) -> Bool {
    if lhs._presetIdentifier != rhs._presetIdentifier {return false}
    if lhs._paragraphStyle != rhs._paragraphStyle {return false}
    if lhs._listStyle != rhs._listStyle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ColumnsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ColumnsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}equal_columns\0\u{3}non_equal_columns\0")

  public var isInitialized: Bool {
    if let v = self._nonEqualColumns, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._equalColumns) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._nonEqualColumns) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._equalColumns {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nonEqualColumns {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ColumnsArchive, rhs: TSWP_ColumnsArchive) -> Bool {
    if lhs._equalColumns != rhs._equalColumns {return false}
    if lhs._nonEqualColumns != rhs._nonEqualColumns {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ColumnsArchive.EqualColumnsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_ColumnsArchive.protoMessageName + ".EqualColumnsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}count\0\u{1}gap\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._count) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._gap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._count {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._gap {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ColumnsArchive.EqualColumnsArchive, rhs: TSWP_ColumnsArchive.EqualColumnsArchive) -> Bool {
    if lhs._count != rhs._count {return false}
    if lhs._gap != rhs._gap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ColumnsArchive.NonEqualColumnsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_ColumnsArchive.protoMessageName + ".NonEqualColumnsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}first\0\u{1}following\0")

  public var isInitialized: Bool {
    if self._first == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.following) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._first) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.following) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._first {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    if !self.following.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.following, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ColumnsArchive.NonEqualColumnsArchive, rhs: TSWP_ColumnsArchive.NonEqualColumnsArchive) -> Bool {
    if lhs._first != rhs._first {return false}
    if lhs.following != rhs.following {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ColumnsArchive.NonEqualColumnsArchive.GapWidthArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_ColumnsArchive.NonEqualColumnsArchive.protoMessageName + ".GapWidthArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}gap\0\u{1}width\0")

  public var isInitialized: Bool {
    if self._gap == nil {return false}
    if self._width == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._gap) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._width) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._gap {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._width {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ColumnsArchive.NonEqualColumnsArchive.GapWidthArchive, rhs: TSWP_ColumnsArchive.NonEqualColumnsArchive.GapWidthArchive) -> Bool {
    if lhs._gap != rhs._gap {return false}
    if lhs._width != rhs._width {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_PaddingArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaddingArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}left\0\u{1}top\0\u{1}right\0\u{1}bottom\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._left) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._top) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._right) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._bottom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._left {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._top {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._right {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._bottom {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_PaddingArchive, rhs: TSWP_PaddingArchive) -> Bool {
    if lhs._left != rhs._left {return false}
    if lhs._top != rhs._top {return false}
    if lhs._right != rhs._right {return false}
    if lhs._bottom != rhs._bottom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ColumnStylePropertiesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ColumnStylePropertiesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}continuous\0\u{3}shrink_to_fit\0\u{3}vertical_text\0\u{3}min_horizontal_inset\0\u{3}vertical_alignment\0\u{3}columns_null\0\u{1}columns\0\u{3}margins_null\0\u{1}margins\0\u{3}padding_null\0\u{1}padding\0\u{3}writing_direction\0")

  fileprivate class _StorageClass {
    var _continuous: Bool? = nil
    var _shrinkToFit: Bool? = nil
    var _verticalText: Bool? = nil
    var _minHorizontalInset: Float? = nil
    var _verticalAlignment: TSWP_ColumnStylePropertiesArchive.VerticalAlignmentType? = nil
    var _columnsNull: Bool? = nil
    var _columns: TSWP_ColumnsArchive? = nil
    var _marginsNull: Bool? = nil
    var _margins: TSWP_PaddingArchive? = nil
    var _paddingNull: Bool? = nil
    var _padding: TSWP_PaddingArchive? = nil
    var _writingDirection: TSWP_WritingDirectionType? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _continuous = source._continuous
      _shrinkToFit = source._shrinkToFit
      _verticalText = source._verticalText
      _minHorizontalInset = source._minHorizontalInset
      _verticalAlignment = source._verticalAlignment
      _columnsNull = source._columnsNull
      _columns = source._columns
      _marginsNull = source._marginsNull
      _margins = source._margins
      _paddingNull = source._paddingNull
      _padding = source._padding
      _writingDirection = source._writingDirection
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._columns, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._continuous) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._shrinkToFit) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._verticalText) }()
        case 4: try { try decoder.decodeSingularFloatField(value: &_storage._minHorizontalInset) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._verticalAlignment) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._columnsNull) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._columns) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._marginsNull) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._margins) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._paddingNull) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._padding) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._writingDirection) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._continuous {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._shrinkToFit {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._verticalText {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._minHorizontalInset {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._verticalAlignment {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._columnsNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._columns {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._marginsNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._margins {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._paddingNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._padding {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._writingDirection {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ColumnStylePropertiesArchive, rhs: TSWP_ColumnStylePropertiesArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._continuous != rhs_storage._continuous {return false}
        if _storage._shrinkToFit != rhs_storage._shrinkToFit {return false}
        if _storage._verticalText != rhs_storage._verticalText {return false}
        if _storage._minHorizontalInset != rhs_storage._minHorizontalInset {return false}
        if _storage._verticalAlignment != rhs_storage._verticalAlignment {return false}
        if _storage._columnsNull != rhs_storage._columnsNull {return false}
        if _storage._columns != rhs_storage._columns {return false}
        if _storage._marginsNull != rhs_storage._marginsNull {return false}
        if _storage._margins != rhs_storage._margins {return false}
        if _storage._paddingNull != rhs_storage._paddingNull {return false}
        if _storage._padding != rhs_storage._padding {return false}
        if _storage._writingDirection != rhs_storage._writingDirection {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ColumnStylePropertiesArchive.VerticalAlignmentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kFrameAlignTop\0\u{1}kFrameAlignMiddle\0\u{1}kFrameAlignBottom\0\u{1}kFrameAlignJustify\0")
}

extension TSWP_ColumnStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ColumnStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{9}override_count\0\u{3}column_properties\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._columnProperties, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._overrideCount) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._columnProperties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._overrideCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._columnProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ColumnStyleArchive, rhs: TSWP_ColumnStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._overrideCount != rhs._overrideCount {return false}
    if lhs._columnProperties != rhs._columnProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ShapeStylePropertiesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShapeStylePropertiesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}shrink_to_fit\0\u{3}vertical_alignment\0\u{3}columns_null\0\u{1}columns\0\u{3}padding_null\0\u{1}padding\0\u{3}default_text_preset_index\0\u{3}vertical_text\0\u{3}paragraph_style_null\0\u{3}paragraph_style\0\u{3}vertical_text_40\0")

  fileprivate class _StorageClass {
    var _shrinkToFit: Bool? = nil
    var _verticalAlignment: TSWP_ShapeStylePropertiesArchive.VerticalAlignmentType? = nil
    var _columnsNull: Bool? = nil
    var _columns: TSWP_ColumnsArchive? = nil
    var _paddingNull: Bool? = nil
    var _padding: TSWP_PaddingArchive? = nil
    var _defaultTextPresetIndex: UInt32? = nil
    var _verticalText: Bool? = nil
    var _paragraphStyleNull: Bool? = nil
    var _paragraphStyle: TSP_Reference? = nil
    var _verticalText40: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _shrinkToFit = source._shrinkToFit
      _verticalAlignment = source._verticalAlignment
      _columnsNull = source._columnsNull
      _columns = source._columns
      _paddingNull = source._paddingNull
      _padding = source._padding
      _defaultTextPresetIndex = source._defaultTextPresetIndex
      _verticalText = source._verticalText
      _paragraphStyleNull = source._paragraphStyleNull
      _paragraphStyle = source._paragraphStyle
      _verticalText40 = source._verticalText40
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._columns, !v.isInitialized {return false}
      if let v = _storage._paragraphStyle, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._shrinkToFit) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._verticalAlignment) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._columnsNull) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._columns) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._paddingNull) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._padding) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._defaultTextPresetIndex) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._verticalText) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._paragraphStyleNull) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._paragraphStyle) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._verticalText40) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._shrinkToFit {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._verticalAlignment {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._columnsNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._columns {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._paddingNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._padding {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._defaultTextPresetIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._verticalText {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._paragraphStyleNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._paragraphStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._verticalText40 {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ShapeStylePropertiesArchive, rhs: TSWP_ShapeStylePropertiesArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._shrinkToFit != rhs_storage._shrinkToFit {return false}
        if _storage._verticalAlignment != rhs_storage._verticalAlignment {return false}
        if _storage._columnsNull != rhs_storage._columnsNull {return false}
        if _storage._columns != rhs_storage._columns {return false}
        if _storage._paddingNull != rhs_storage._paddingNull {return false}
        if _storage._padding != rhs_storage._padding {return false}
        if _storage._defaultTextPresetIndex != rhs_storage._defaultTextPresetIndex {return false}
        if _storage._verticalText != rhs_storage._verticalText {return false}
        if _storage._paragraphStyleNull != rhs_storage._paragraphStyleNull {return false}
        if _storage._paragraphStyle != rhs_storage._paragraphStyle {return false}
        if _storage._verticalText40 != rhs_storage._verticalText40 {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ShapeStylePropertiesArchive.VerticalAlignmentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kFrameAlignTop\0\u{1}kFrameAlignMiddle\0\u{1}kFrameAlignBottom\0\u{1}kFrameAlignJustify\0")
}

extension TSWP_ShapeStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShapeStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{9}override_count\0\u{3}shape_properties\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._shapeProperties, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._overrideCount) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._shapeProperties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._overrideCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._shapeProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ShapeStyleArchive, rhs: TSWP_ShapeStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._overrideCount != rhs._overrideCount {return false}
    if lhs._shapeProperties != rhs._shapeProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ThemePresetsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThemePresetsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}list_style_presets\0\u{3}text_style_presets\0\u{3}imported_text_style_presets\0\u{3}toc_entry_style_presets\0\u{3}toc_settings_presets\0\u{3}character_style_presets\0\u{3}paragraph_style_presets\0\u{3}dropcap_style_presets\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.listStylePresets) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.textStylePresets) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.importedTextStylePresets) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.tocEntryStylePresets) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.tocSettingsPresets) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.characterStylePresets) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.paragraphStylePresets) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.dropcapStylePresets) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.listStylePresets) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.textStylePresets) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.importedTextStylePresets) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.tocEntryStylePresets) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.tocSettingsPresets) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.characterStylePresets) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.paragraphStylePresets) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.dropcapStylePresets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.listStylePresets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.listStylePresets, fieldNumber: 1)
    }
    if !self.textStylePresets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.textStylePresets, fieldNumber: 2)
    }
    if !self.importedTextStylePresets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.importedTextStylePresets, fieldNumber: 3)
    }
    if !self.tocEntryStylePresets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tocEntryStylePresets, fieldNumber: 4)
    }
    if !self.tocSettingsPresets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tocSettingsPresets, fieldNumber: 5)
    }
    if !self.characterStylePresets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.characterStylePresets, fieldNumber: 6)
    }
    if !self.paragraphStylePresets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.paragraphStylePresets, fieldNumber: 7)
    }
    if !self.dropcapStylePresets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dropcapStylePresets, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ThemePresetsArchive, rhs: TSWP_ThemePresetsArchive) -> Bool {
    if lhs.listStylePresets != rhs.listStylePresets {return false}
    if lhs.textStylePresets != rhs.textStylePresets {return false}
    if lhs.importedTextStylePresets != rhs.importedTextStylePresets {return false}
    if lhs.tocEntryStylePresets != rhs.tocEntryStylePresets {return false}
    if lhs.tocSettingsPresets != rhs.tocSettingsPresets {return false}
    if lhs.characterStylePresets != rhs.characterStylePresets {return false}
    if lhs.paragraphStylePresets != rhs.paragraphStylePresets {return false}
    if lhs.dropcapStylePresets != rhs.dropcapStylePresets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_TextPresetDisplayItemArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TextPresetDisplayItemArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}preset\0\u{3}display_name\0")

  public var isInitialized: Bool {
    if self._preset == nil {return false}
    if self._displayName == nil {return false}
    if let v = self._preset, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._preset) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._displayName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._preset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._displayName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_TextPresetDisplayItemArchive, rhs: TSWP_TextPresetDisplayItemArchive) -> Bool {
    if lhs._preset != rhs._preset {return false}
    if lhs._displayName != rhs._displayName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_TOCEntryStylePropertiesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TOCEntryStylePropertiesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_number_style_null\0\u{3}page_number_style\0\u{3}show_page_number\0")

  public var isInitialized: Bool {
    if let v = self._pageNumberStyle, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._pageNumberStyleNull) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pageNumberStyle) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._showPageNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pageNumberStyleNull {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pageNumberStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._showPageNumber {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_TOCEntryStylePropertiesArchive, rhs: TSWP_TOCEntryStylePropertiesArchive) -> Bool {
    if lhs._pageNumberStyleNull != rhs._pageNumberStyleNull {return false}
    if lhs._pageNumberStyle != rhs._pageNumberStyle {return false}
    if lhs._showPageNumber != rhs._showPageNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_TOCEntryStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TOCEntryStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}toc_properties\0")

  fileprivate class _StorageClass {
    var _super: TSWP_ParagraphStyleArchive? = nil
    var _tocProperties: TSWP_TOCEntryStylePropertiesArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _tocProperties = source._tocProperties
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._tocProperties, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._tocProperties) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._tocProperties {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_TOCEntryStyleArchive, rhs: TSWP_TOCEntryStyleArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._tocProperties != rhs_storage._tocProperties {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_TOCSettingsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TOCSettingsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}toc_name\0\u{3}toc_scope\0\u{1}entries\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.entries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._tocName) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._tocScope) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tocName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tocScope {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_TOCSettingsArchive, rhs: TSWP_TOCSettingsArchive) -> Bool {
    if lhs._tocName != rhs._tocName {return false}
    if lhs._tocScope != rhs._tocScope {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_TOCSettingsArchive.TOCEntryData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_TOCSettingsArchive.protoMessageName + ".TOCEntryData"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}paragraph_style\0\u{3}toc_entry_style\0\u{3}show_in_toc\0")

  public var isInitialized: Bool {
    if let v = self._paragraphStyle, !v.isInitialized {return false}
    if let v = self._tocEntryStyle, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paragraphStyle) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tocEntryStyle) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._showInToc) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._paragraphStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tocEntryStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._showInToc {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_TOCSettingsArchive.TOCEntryData, rhs: TSWP_TOCSettingsArchive.TOCEntryData) -> Bool {
    if lhs._paragraphStyle != rhs._paragraphStyle {return false}
    if lhs._tocEntryStyle != rhs._tocEntryStyle {return false}
    if lhs._showInToc != rhs._showInToc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_TOCEntryInstanceArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TOCEntryInstanceArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}paragraph_index\0\u{3}page_number\0\u{3}number_format\0\u{1}heading\0\u{3}indexed_style\0\u{3}indexed_list_style\0\u{3}indexed_list_start\0\u{3}indexed_paragraph_level\0\u{3}number_format_name\0")

  public var isInitialized: Bool {
    if self._paragraphIndex == nil {return false}
    if self._pageNumber == nil {return false}
    if self._numberFormat == nil {return false}
    if self._heading == nil {return false}
    if self._indexedStyle == nil {return false}
    if let v = self._indexedStyle, !v.isInitialized {return false}
    if let v = self._indexedListStyle, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._paragraphIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._pageNumber) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._numberFormat) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._heading) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._indexedStyle) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._indexedListStyle) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._indexedListStart) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._indexedParagraphLevel) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._numberFormatName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._paragraphIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pageNumber {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._numberFormat {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._heading {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._indexedStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._indexedListStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._indexedListStart {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._indexedParagraphLevel {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._numberFormatName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_TOCEntryInstanceArchive, rhs: TSWP_TOCEntryInstanceArchive) -> Bool {
    if lhs._paragraphIndex != rhs._paragraphIndex {return false}
    if lhs._pageNumber != rhs._pageNumber {return false}
    if lhs._numberFormat != rhs._numberFormat {return false}
    if lhs._heading != rhs._heading {return false}
    if lhs._indexedStyle != rhs._indexedStyle {return false}
    if lhs._indexedListStyle != rhs._indexedListStyle {return false}
    if lhs._indexedListStart != rhs._indexedListStart {return false}
    if lhs._indexedParagraphLevel != rhs._indexedParagraphLevel {return false}
    if lhs._numberFormatName != rhs._numberFormatName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_UndoTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UndoTransaction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}entries\0\u{3}group_entries\0\u{1}flags\0\u{1}version\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.entries) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.groupEntries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.groupEntries) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._flags) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    if !self.groupEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupEntries, fieldNumber: 2)
    }
    try { if let v = self._flags {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._version {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_UndoTransaction, rhs: TSWP_UndoTransaction) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.groupEntries != rhs.groupEntries {return false}
    if lhs._flags != rhs._flags {return false}
    if lhs._version != rhs._version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_UndoTransaction.UndoKind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}REPLACE_TEXT\0\u{1}INSERT_ATTRIBUTE\0\u{1}DELETE_ATTRIBUTE\0\u{1}ADJUST_CHAR_INDEXES\0\u{1}COMPR_ADJUST_CHAR_INDEXES\0\u{1}REPLACE_CHAR_INDEX\0\u{1}REPLACE_OBJECT\0\u{1}REPLACE_PARAGRAPH_DATA\0\u{1}OBJECT_DOLC\0\u{1}CT_DATE\0")
}

extension TSWP_UndoTransaction.ActionKind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ACTION_UNDEFINED\0\u{1}ACTION_TEXT\0\u{1}ACTION_ATTRIBUTE\0")
}

extension TSWP_UndoTransaction.ActionGroupKind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ACTION_GROUP_UNDEFINED\0\u{1}ACTION_GROUP_TEXT\0\u{1}ACTION_GROUP_ATTRIBUTE\0")
}

extension TSWP_UndoTransaction.GenericTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_UndoTransaction.protoMessageName + ".GenericTransaction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value1\0\u{1}value2\0\u{1}value3\0")

  public var isInitialized: Bool {
    if self._value1 == nil {return false}
    if self._value2 == nil {return false}
    if self._value3 == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._value1) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._value2) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._value3) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value1 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value2 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._value3 {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_UndoTransaction.GenericTransaction, rhs: TSWP_UndoTransaction.GenericTransaction) -> Bool {
    if lhs._value1 != rhs._value1 {return false}
    if lhs._value2 != rhs._value2 {return false}
    if lhs._value3 != rhs._value3 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_UndoTransaction.TextTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_UndoTransaction.protoMessageName + ".TextTransaction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}insert_location\0\u{3}insert_length\0\u{3}string_to_delete\0")

  public var isInitialized: Bool {
    if self._insertLocation == nil {return false}
    if self._insertLength == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._insertLocation) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._insertLength) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._stringToDelete) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._insertLocation {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._insertLength {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._stringToDelete {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_UndoTransaction.TextTransaction, rhs: TSWP_UndoTransaction.TextTransaction) -> Bool {
    if lhs._insertLocation != rhs._insertLocation {return false}
    if lhs._insertLength != rhs._insertLength {return false}
    if lhs._stringToDelete != rhs._stringToDelete {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_UndoTransaction.CharIndexTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_UndoTransaction.protoMessageName + ".CharIndexTransaction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}char_index\0\u{1}count\0\u{1}object\0")

  public var isInitialized: Bool {
    if self._charIndex == nil {return false}
    if self._count == nil {return false}
    if let v = self._object, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._charIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._count) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._object) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._charIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._count {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._object {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_UndoTransaction.CharIndexTransaction, rhs: TSWP_UndoTransaction.CharIndexTransaction) -> Bool {
    if lhs._charIndex != rhs._charIndex {return false}
    if lhs._count != rhs._count {return false}
    if lhs._object != rhs._object {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_UndoTransaction.ReplaceCharIndexTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_UndoTransaction.protoMessageName + ".ReplaceCharIndexTransaction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}attribute_index\0\u{3}char_index\0")

  public var isInitialized: Bool {
    if self._attributeIndex == nil {return false}
    if self._charIndex == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._attributeIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._charIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._attributeIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._charIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_UndoTransaction.ReplaceCharIndexTransaction, rhs: TSWP_UndoTransaction.ReplaceCharIndexTransaction) -> Bool {
    if lhs._attributeIndex != rhs._attributeIndex {return false}
    if lhs._charIndex != rhs._charIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_UndoTransaction.AttributeIndexTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_UndoTransaction.protoMessageName + ".AttributeIndexTransaction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}attribute_index\0\u{3}char_index\0\u{1}object\0\u{1}string\0")

  public var isInitialized: Bool {
    if self._attributeIndex == nil {return false}
    if self._charIndex == nil {return false}
    if let v = self._object, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._attributeIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._charIndex) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._object) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._string) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._attributeIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._charIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._object {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._string {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_UndoTransaction.AttributeIndexTransaction, rhs: TSWP_UndoTransaction.AttributeIndexTransaction) -> Bool {
    if lhs._attributeIndex != rhs._attributeIndex {return false}
    if lhs._charIndex != rhs._charIndex {return false}
    if lhs._object != rhs._object {return false}
    if lhs._string != rhs._string {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_UndoTransaction.InsertAttributeTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_UndoTransaction.protoMessageName + ".InsertAttributeTransaction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}attribute_index\0\u{3}attribute_count\0\u{1}object\0\u{1}string\0")

  public var isInitialized: Bool {
    if self._attributeIndex == nil {return false}
    if self._attributeCount == nil {return false}
    if let v = self._object, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._attributeIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._attributeCount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._object) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._string) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._attributeIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._attributeCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._object {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._string {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_UndoTransaction.InsertAttributeTransaction, rhs: TSWP_UndoTransaction.InsertAttributeTransaction) -> Bool {
    if lhs._attributeIndex != rhs._attributeIndex {return false}
    if lhs._attributeCount != rhs._attributeCount {return false}
    if lhs._object != rhs._object {return false}
    if lhs._string != rhs._string {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_UndoTransaction.InsertNilTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_UndoTransaction.protoMessageName + ".InsertNilTransaction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}attribute_index\0\u{3}attribute_count\0")

  public var isInitialized: Bool {
    if self._attributeIndex == nil {return false}
    if self._attributeCount == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._attributeIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._attributeCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._attributeIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._attributeCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_UndoTransaction.InsertNilTransaction, rhs: TSWP_UndoTransaction.InsertNilTransaction) -> Bool {
    if lhs._attributeIndex != rhs._attributeIndex {return false}
    if lhs._attributeCount != rhs._attributeCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_UndoTransaction.CharDeltaTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_UndoTransaction.protoMessageName + ".CharDeltaTransaction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}char_index\0\u{3}attribute_index\0\u{3}char_delta\0")

  public var isInitialized: Bool {
    if self._charIndex == nil {return false}
    if self._attributeIndex == nil {return false}
    if self._charDelta == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._charIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._attributeIndex) }()
      case 3: try { try decoder.decodeSingularSInt32Field(value: &self._charDelta) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._charIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._attributeIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._charDelta {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_UndoTransaction.CharDeltaTransaction, rhs: TSWP_UndoTransaction.CharDeltaTransaction) -> Bool {
    if lhs._charIndex != rhs._charIndex {return false}
    if lhs._attributeIndex != rhs._attributeIndex {return false}
    if lhs._charDelta != rhs._charDelta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_UndoTransaction.ParagraphDataTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_UndoTransaction.protoMessageName + ".ParagraphDataTransaction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}attribute_index\0\u{1}first\0\u{1}second\0\u{3}char_index\0")

  public var isInitialized: Bool {
    if self._attributeIndex == nil {return false}
    if self._first == nil {return false}
    if self._second == nil {return false}
    if self._charIndex == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._attributeIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._first) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._second) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._charIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._attributeIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._first {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._second {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._charIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_UndoTransaction.ParagraphDataTransaction, rhs: TSWP_UndoTransaction.ParagraphDataTransaction) -> Bool {
    if lhs._attributeIndex != rhs._attributeIndex {return false}
    if lhs._first != rhs._first {return false}
    if lhs._second != rhs._second {return false}
    if lhs._charIndex != rhs._charIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_UndoTransaction.ObjectDOLCTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_UndoTransaction.protoMessageName + ".ObjectDOLCTransaction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}flags\0\u{1}object\0")

  public var isInitialized: Bool {
    if self._flags == nil {return false}
    if let v = self._object, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._flags) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._object) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._flags {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._object {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_UndoTransaction.ObjectDOLCTransaction, rhs: TSWP_UndoTransaction.ObjectDOLCTransaction) -> Bool {
    if lhs._flags != rhs._flags {return false}
    if lhs._object != rhs._object {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_UndoTransaction.CTDateTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_UndoTransaction.protoMessageName + ".CTDateTransaction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}attribute_index\0\u{1}date\0")

  public var isInitialized: Bool {
    if self._attributeIndex == nil {return false}
    if let v = self._date, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._attributeIndex) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._attributeIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_UndoTransaction.CTDateTransaction, rhs: TSWP_UndoTransaction.CTDateTransaction) -> Bool {
    if lhs._attributeIndex != rhs._attributeIndex {return false}
    if lhs._date != rhs._date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_UndoTransaction.UnionTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_UndoTransaction.protoMessageName + ".UnionTransaction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}kind\0\u{1}table\0\u{2}\u{3}generic\0\u{1}text\0\u{3}char_index\0\u{3}replace_char_index\0\u{3}attribute_index\0\u{3}insert_nil\0\u{3}insert_attribute\0\u{3}char_delta\0\u{3}paragraph_data\0\u{3}object_dolc\0\u{3}ct_date\0")

  fileprivate class _StorageClass {
    var _kind: TSWP_UndoTransaction.UndoKind? = nil
    var _table: UInt32? = nil
    var _generic: TSWP_UndoTransaction.GenericTransaction? = nil
    var _text: TSWP_UndoTransaction.TextTransaction? = nil
    var _charIndex: TSWP_UndoTransaction.CharIndexTransaction? = nil
    var _replaceCharIndex: TSWP_UndoTransaction.ReplaceCharIndexTransaction? = nil
    var _attributeIndex: TSWP_UndoTransaction.AttributeIndexTransaction? = nil
    var _insertNil: TSWP_UndoTransaction.InsertNilTransaction? = nil
    var _insertAttribute: TSWP_UndoTransaction.InsertAttributeTransaction? = nil
    var _charDelta: TSWP_UndoTransaction.CharDeltaTransaction? = nil
    var _paragraphData: TSWP_UndoTransaction.ParagraphDataTransaction? = nil
    var _objectDolc: TSWP_UndoTransaction.ObjectDOLCTransaction? = nil
    var _ctDate: TSWP_UndoTransaction.CTDateTransaction? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kind = source._kind
      _table = source._table
      _generic = source._generic
      _text = source._text
      _charIndex = source._charIndex
      _replaceCharIndex = source._replaceCharIndex
      _attributeIndex = source._attributeIndex
      _insertNil = source._insertNil
      _insertAttribute = source._insertAttribute
      _charDelta = source._charDelta
      _paragraphData = source._paragraphData
      _objectDolc = source._objectDolc
      _ctDate = source._ctDate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._kind == nil {return false}
      if let v = _storage._generic, !v.isInitialized {return false}
      if let v = _storage._text, !v.isInitialized {return false}
      if let v = _storage._charIndex, !v.isInitialized {return false}
      if let v = _storage._replaceCharIndex, !v.isInitialized {return false}
      if let v = _storage._attributeIndex, !v.isInitialized {return false}
      if let v = _storage._insertNil, !v.isInitialized {return false}
      if let v = _storage._insertAttribute, !v.isInitialized {return false}
      if let v = _storage._charDelta, !v.isInitialized {return false}
      if let v = _storage._paragraphData, !v.isInitialized {return false}
      if let v = _storage._objectDolc, !v.isInitialized {return false}
      if let v = _storage._ctDate, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._kind) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._table) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._generic) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._text) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._charIndex) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._replaceCharIndex) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._attributeIndex) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._insertNil) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._insertAttribute) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._charDelta) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._paragraphData) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._objectDolc) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._ctDate) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._kind {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._table {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._generic {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._text {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._charIndex {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._replaceCharIndex {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._attributeIndex {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._insertNil {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._insertAttribute {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._charDelta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._paragraphData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._objectDolc {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._ctDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_UndoTransaction.UnionTransaction, rhs: TSWP_UndoTransaction.UnionTransaction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._table != rhs_storage._table {return false}
        if _storage._generic != rhs_storage._generic {return false}
        if _storage._text != rhs_storage._text {return false}
        if _storage._charIndex != rhs_storage._charIndex {return false}
        if _storage._replaceCharIndex != rhs_storage._replaceCharIndex {return false}
        if _storage._attributeIndex != rhs_storage._attributeIndex {return false}
        if _storage._insertNil != rhs_storage._insertNil {return false}
        if _storage._insertAttribute != rhs_storage._insertAttribute {return false}
        if _storage._charDelta != rhs_storage._charDelta {return false}
        if _storage._paragraphData != rhs_storage._paragraphData {return false}
        if _storage._objectDolc != rhs_storage._objectDolc {return false}
        if _storage._ctDate != rhs_storage._ctDate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_UndoTransaction.StorageAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_UndoTransaction.protoMessageName + ".StorageAction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}kind\0\u{1}flags\0\u{1}table\0\u{1}range\0\u{1}string\0\u{1}object\0\u{1}date\0\u{3}paragraph_level\0\u{3}paragraph_flags\0\u{3}paragraph_value\0\u{3}placement_index\0\u{3}placement_uuid_path\0\u{3}undo_object\0")

  fileprivate class _StorageClass {
    var _kind: TSWP_UndoTransaction.ActionKind? = nil
    var _flags: UInt32? = nil
    var _table: UInt32? = nil
    var _range: TSP_Range? = nil
    var _string: String? = nil
    var _object: TSP_Reference? = nil
    var _date: TSP_Date? = nil
    var _paragraphLevel: UInt32? = nil
    var _paragraphFlags: UInt32? = nil
    var _paragraphValue: UInt32? = nil
    var _placementIndex: Int32? = nil
    var _placementUuidPath: String? = nil
    var _undoObject: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kind = source._kind
      _flags = source._flags
      _table = source._table
      _range = source._range
      _string = source._string
      _object = source._object
      _date = source._date
      _paragraphLevel = source._paragraphLevel
      _paragraphFlags = source._paragraphFlags
      _paragraphValue = source._paragraphValue
      _placementIndex = source._placementIndex
      _placementUuidPath = source._placementUuidPath
      _undoObject = source._undoObject
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._kind == nil {return false}
      if let v = _storage._range, !v.isInitialized {return false}
      if let v = _storage._object, !v.isInitialized {return false}
      if let v = _storage._date, !v.isInitialized {return false}
      if let v = _storage._undoObject, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._kind) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._flags) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._table) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._range) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._string) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._object) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._date) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._paragraphLevel) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._paragraphFlags) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._paragraphValue) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._placementIndex) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._placementUuidPath) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._undoObject) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._kind {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._flags {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._table {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._range {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._string {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._object {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._paragraphLevel {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._paragraphFlags {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._paragraphValue {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._placementIndex {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._placementUuidPath {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._undoObject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_UndoTransaction.StorageAction, rhs: TSWP_UndoTransaction.StorageAction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._table != rhs_storage._table {return false}
        if _storage._range != rhs_storage._range {return false}
        if _storage._string != rhs_storage._string {return false}
        if _storage._object != rhs_storage._object {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._paragraphLevel != rhs_storage._paragraphLevel {return false}
        if _storage._paragraphFlags != rhs_storage._paragraphFlags {return false}
        if _storage._paragraphValue != rhs_storage._paragraphValue {return false}
        if _storage._placementIndex != rhs_storage._placementIndex {return false}
        if _storage._placementUuidPath != rhs_storage._placementUuidPath {return false}
        if _storage._undoObject != rhs_storage._undoObject {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_UndoTransaction.StorageActionGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_UndoTransaction.protoMessageName + ".StorageActionGroup"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}kind\0\u{4}\u{2}forward_actions\0\u{3}inverse_forward_actions\0\u{4}\u{2}inverse_detail_actions\0")

  public var isInitialized: Bool {
    if self._kind == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.forwardActions) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.inverseForwardActions) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.inverseDetailActions) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._kind) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.forwardActions) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.inverseForwardActions) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.inverseDetailActions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._kind {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.forwardActions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.forwardActions, fieldNumber: 3)
    }
    if !self.inverseForwardActions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inverseForwardActions, fieldNumber: 4)
    }
    if !self.inverseDetailActions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inverseDetailActions, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_UndoTransaction.StorageActionGroup, rhs: TSWP_UndoTransaction.StorageActionGroup) -> Bool {
    if lhs._kind != rhs._kind {return false}
    if lhs.forwardActions != rhs.forwardActions {return false}
    if lhs.inverseForwardActions != rhs.inverseForwardActions {return false}
    if lhs.inverseDetailActions != rhs.inverseDetailActions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_UndoTransactionWrapperArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UndoTransactionWrapperArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}undo_transaction\0")

  public var isInitialized: Bool {
    if self._undoTransaction == nil {return false}
    if let v = self._undoTransaction, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._undoTransaction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._undoTransaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_UndoTransactionWrapperArchive, rhs: TSWP_UndoTransactionWrapperArchive) -> Bool {
    if lhs._undoTransaction != rhs._undoTransaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ShapeInfoArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShapeInfoArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}deprecated_storage\0\u{3}text_flow\0\u{3}owned_storage\0\u{4}\u{2}is_text_box\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._deprecatedStorage, !v.isInitialized {return false}
    if let v = self._textFlow, !v.isInitialized {return false}
    if let v = self._ownedStorage, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deprecatedStorage) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._textFlow) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ownedStorage) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._isTextBox) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._deprecatedStorage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._textFlow {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._ownedStorage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._isTextBox {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ShapeInfoArchive, rhs: TSWP_ShapeInfoArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._deprecatedStorage != rhs._deprecatedStorage {return false}
    if lhs._textFlow != rhs._textFlow {return false}
    if lhs._ownedStorage != rhs._ownedStorage {return false}
    if lhs._isTextBox != rhs._isTextBox {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_CommentInfoArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommentInfoArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}comment_storage\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._commentStorage, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._commentStorage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._commentStorage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_CommentInfoArchive, rhs: TSWP_CommentInfoArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._commentStorage != rhs._commentStorage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_TOCInfoArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TOCInfoArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}toc_settings\0\u{3}toc_entry_data\0\u{3}page_number_ranges\0\u{3}sync_toc_settings_with_toc_navigator\0")

  fileprivate class _StorageClass {
    var _super: TSWP_ShapeInfoArchive? = nil
    var _tocSettings: TSP_Reference? = nil
    var _tocEntryData: [TSP_Reference] = []
    var _pageNumberRanges: [TSP_Range] = []
    var _syncTocSettingsWithTocNavigator: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _tocSettings = source._tocSettings
      _tocEntryData = source._tocEntryData
      _pageNumberRanges = source._pageNumberRanges
      _syncTocSettingsWithTocNavigator = source._syncTocSettingsWithTocNavigator
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._tocSettings, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._tocEntryData) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._pageNumberRanges) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._tocSettings) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._tocEntryData) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._pageNumberRanges) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._syncTocSettingsWithTocNavigator) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._tocSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._tocEntryData.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tocEntryData, fieldNumber: 3)
      }
      if !_storage._pageNumberRanges.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pageNumberRanges, fieldNumber: 4)
      }
      try { if let v = _storage._syncTocSettingsWithTocNavigator {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_TOCInfoArchive, rhs: TSWP_TOCInfoArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._tocSettings != rhs_storage._tocSettings {return false}
        if _storage._tocEntryData != rhs_storage._tocEntryData {return false}
        if _storage._pageNumberRanges != rhs_storage._pageNumberRanges {return false}
        if _storage._syncTocSettingsWithTocNavigator != rhs_storage._syncTocSettingsWithTocNavigator {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_TOCLayoutHintArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TOCLayoutHintArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}charRange\0")

  public var isInitialized: Bool {
    if self._charRange == nil {return false}
    if let v = self._charRange, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._charRange) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._charRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_TOCLayoutHintArchive, rhs: TSWP_TOCLayoutHintArchive) -> Bool {
    if lhs._charRange != rhs._charRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_EquationInfoArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EquationInfoArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_EquationInfoArchive, rhs: TSWP_EquationInfoArchive) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_TextualAttachmentArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TextualAttachmentArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}string_equivalent\0\u{1}kind\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._stringEquivalent) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._kind) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stringEquivalent {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._kind {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_TextualAttachmentArchive, rhs: TSWP_TextualAttachmentArchive) -> Bool {
    if lhs._stringEquivalent != rhs._stringEquivalent {return false}
    if lhs._kind != rhs._kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_TextualAttachmentArchive.Kind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kKindPageNumber\0\u{1}kKindPageCount\0\u{1}kKindFootnoteMark\0")
}

extension TSWP_TSWPTOCPageNumberAttachmentArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TSWPTOCPageNumberAttachmentArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}page_number\0\u{3}bookmark_name\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._pageNumber) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._bookmarkName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pageNumber {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._bookmarkName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_TSWPTOCPageNumberAttachmentArchive, rhs: TSWP_TSWPTOCPageNumberAttachmentArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._pageNumber != rhs._pageNumber {return false}
    if lhs._bookmarkName != rhs._bookmarkName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_UIGraphicalAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIGraphicalAttachment"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_UIGraphicalAttachment, rhs: TSWP_UIGraphicalAttachment) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_DrawableAttachmentArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawableAttachmentArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}drawable\0\u{3}h_offset_type\0\u{3}h_offset\0\u{3}v_offset_type\0\u{3}v_offset\0")

  public var isInitialized: Bool {
    if let v = self._drawable, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._drawable) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._hOffsetType) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._hOffset) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._vOffsetType) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._vOffset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._drawable {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._hOffsetType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hOffset {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._vOffsetType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._vOffset {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_DrawableAttachmentArchive, rhs: TSWP_DrawableAttachmentArchive) -> Bool {
    if lhs._drawable != rhs._drawable {return false}
    if lhs._hOffsetType != rhs._hOffsetType {return false}
    if lhs._hOffset != rhs._hOffset {return false}
    if lhs._vOffsetType != rhs._vOffsetType {return false}
    if lhs._vOffset != rhs._vOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_TOCAttachmentArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TOCAttachmentArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_TOCAttachmentArchive, rhs: TSWP_TOCAttachmentArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_FootnoteReferenceAttachmentArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FootnoteReferenceAttachmentArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}contained_storage\0\u{3}custom_mark_string\0")

  public var isInitialized: Bool {
    if let v = self._containedStorage, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._containedStorage) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._customMarkString) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._containedStorage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._customMarkString {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_FootnoteReferenceAttachmentArchive, rhs: TSWP_FootnoteReferenceAttachmentArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._containedStorage != rhs._containedStorage {return false}
    if lhs._customMarkString != rhs._customMarkString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_NumberAttachmentArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NumberAttachmentArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}number_format\0\u{3}string_value\0\u{3}number_format_name\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._numberFormat) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._stringValue) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._numberFormatName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._numberFormat {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._stringValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._numberFormatName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_NumberAttachmentArchive, rhs: TSWP_NumberAttachmentArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._numberFormat != rhs._numberFormat {return false}
    if lhs._stringValue != rhs._stringValue {return false}
    if lhs._numberFormatName != rhs._numberFormatName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_SmartFieldArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SmartFieldArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}text_attribute_uuid_string\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._textAttributeUuidString) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._textAttributeUuidString {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_SmartFieldArchive, rhs: TSWP_SmartFieldArchive) -> Bool {
    if lhs._textAttributeUuidString != rhs._textAttributeUuidString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_HyperlinkFieldArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HyperlinkFieldArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}url_ref\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._urlRef) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._urlRef {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_HyperlinkFieldArchive, rhs: TSWP_HyperlinkFieldArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._urlRef != rhs._urlRef {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_PlaceholderSmartFieldArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlaceholderSmartFieldArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}localizable\0\u{3}script_tag\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._localizable) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._scriptTag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._localizable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._scriptTag {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_PlaceholderSmartFieldArchive, rhs: TSWP_PlaceholderSmartFieldArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._localizable != rhs._localizable {return false}
    if lhs._scriptTag != rhs._scriptTag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_UnsupportedHyperlinkFieldArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnsupportedHyperlinkFieldArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}url_ref\0\u{3}url_original_ref\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._urlRef) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._urlOriginalRef) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._urlRef {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._urlOriginalRef {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_UnsupportedHyperlinkFieldArchive, rhs: TSWP_UnsupportedHyperlinkFieldArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._urlRef != rhs._urlRef {return false}
    if lhs._urlOriginalRef != rhs._urlOriginalRef {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_BibliographySmartFieldArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BibliographySmartFieldArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}old_super\0\u{3}citation_records\0\u{1}super\0\u{1}localizable\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.citationRecords) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._oldSuper) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.citationRecords) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._localizable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._oldSuper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.citationRecords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.citationRecords, fieldNumber: 2)
    }
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._localizable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_BibliographySmartFieldArchive, rhs: TSWP_BibliographySmartFieldArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.citationRecords != rhs.citationRecords {return false}
    if lhs._localizable != rhs._localizable {return false}
    if lhs._oldSuper != rhs._oldSuper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_CitationRecordArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CitationRecordArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}endnote_xml\0\u{3}hide_author_names\0\u{3}hide_year\0\u{3}page_range\0\u{1}prefix\0\u{1}suffix\0\u{3}authors_string\0\u{1}title\0\u{1}year\0\u{1}type\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._endnoteXml) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._hideAuthorNames) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._hideYear) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._pageRange) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._prefix) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._suffix) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._authorsString) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._year) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._endnoteXml {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._hideAuthorNames {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hideYear {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pageRange {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._prefix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._suffix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._authorsString {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._year {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_CitationRecordArchive, rhs: TSWP_CitationRecordArchive) -> Bool {
    if lhs._endnoteXml != rhs._endnoteXml {return false}
    if lhs._hideAuthorNames != rhs._hideAuthorNames {return false}
    if lhs._hideYear != rhs._hideYear {return false}
    if lhs._pageRange != rhs._pageRange {return false}
    if lhs._prefix != rhs._prefix {return false}
    if lhs._suffix != rhs._suffix {return false}
    if lhs._authorsString != rhs._authorsString {return false}
    if lhs._title != rhs._title {return false}
    if lhs._year != rhs._year {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_CitationSmartFieldArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CitationSmartFieldArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}old_super\0\u{3}citation_records\0\u{1}super\0\u{1}localizable\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.citationRecords) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._oldSuper) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.citationRecords) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._localizable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._oldSuper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.citationRecords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.citationRecords, fieldNumber: 2)
    }
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._localizable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_CitationSmartFieldArchive, rhs: TSWP_CitationSmartFieldArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.citationRecords != rhs.citationRecords {return false}
    if lhs._localizable != rhs._localizable {return false}
    if lhs._oldSuper != rhs._oldSuper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_DateTimeSmartFieldArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DateTimeSmartFieldArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}format\0\u{3}locale_identifier\0\u{3}date_style\0\u{3}time_style\0\u{3}update_plan\0\u{3}needs_update\0\u{1}date\0")

  public var isInitialized: Bool {
    if let v = self._date, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._format) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._localeIdentifier) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._dateStyle) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._timeStyle) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._updatePlan) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._needsUpdate) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._format {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._localeIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._dateStyle {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._timeStyle {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._updatePlan {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._needsUpdate {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_DateTimeSmartFieldArchive, rhs: TSWP_DateTimeSmartFieldArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._format != rhs._format {return false}
    if lhs._localeIdentifier != rhs._localeIdentifier {return false}
    if lhs._dateStyle != rhs._dateStyle {return false}
    if lhs._timeStyle != rhs._timeStyle {return false}
    if lhs._updatePlan != rhs._updatePlan {return false}
    if lhs._needsUpdate != rhs._needsUpdate {return false}
    if lhs._date != rhs._date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_DateTimeSmartFieldArchive.DateTimeUpdatePlan: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kDateTimeUpdatePlanNever\0\u{1}kDateTimeUpdatePlanAuto\0\u{1}kDateTimeUpdatePlanOnce\0")
}

extension TSWP_DateTimeSmartFieldArchive.DateTimeFormatterStyle: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kDateTimeFormatterStyleNone\0\u{1}kDateTimeFormatterStyleShort\0\u{1}kDateTimeFormatterStyleMedium\0\u{1}kDateTimeFormatterStyleLong\0\u{1}kDateTimeFormatterStyleFull\0")
}

extension TSWP_BookmarkFieldArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BookmarkFieldArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}name\0\u{1}ranged\0\u{1}hidden\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._ranged) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._hidden) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._ranged {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._hidden {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_BookmarkFieldArchive, rhs: TSWP_BookmarkFieldArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._name != rhs._name {return false}
    if lhs._ranged != rhs._ranged {return false}
    if lhs._hidden != rhs._hidden {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_FilenameSmartFieldArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FilenameSmartFieldArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}display_flags\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._displayFlags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._displayFlags {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_FilenameSmartFieldArchive, rhs: TSWP_FilenameSmartFieldArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._displayFlags != rhs._displayFlags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_MergeFieldTypeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MergeFieldTypeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{2}contacts_property\0\u{3}contacts_key\0\u{3}contacts_label\0\u{3}table_key\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._contactsProperty) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._contactsKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._contactsLabel) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._tableKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contactsProperty {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._contactsKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._contactsLabel {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._tableKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_MergeFieldTypeArchive, rhs: TSWP_MergeFieldTypeArchive) -> Bool {
    if lhs._contactsProperty != rhs._contactsProperty {return false}
    if lhs._contactsKey != rhs._contactsKey {return false}
    if lhs._contactsLabel != rhs._contactsLabel {return false}
    if lhs._tableKey != rhs._tableKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_MergeSmartFieldArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MergeSmartFieldArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}contacts_property\0\u{3}contacts_key\0\u{3}contacts_label\0\u{1}category\0\u{3}requires_following_whitespace\0\u{1}whitespace\0\u{1}guid\0\u{3}table_key\0\u{3}field_type\0\u{3}has_custom_text\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._contactsProperty) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._contactsKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._contactsLabel) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._category) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._requiresFollowingWhitespace) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._whitespace) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._guid) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._tableKey) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._fieldType) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self._hasCustomText_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._contactsProperty {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._contactsKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._contactsLabel {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._category {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._requiresFollowingWhitespace {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._whitespace {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._guid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._tableKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._fieldType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._hasCustomText_p {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_MergeSmartFieldArchive, rhs: TSWP_MergeSmartFieldArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._contactsProperty != rhs._contactsProperty {return false}
    if lhs._contactsKey != rhs._contactsKey {return false}
    if lhs._contactsLabel != rhs._contactsLabel {return false}
    if lhs._category != rhs._category {return false}
    if lhs._requiresFollowingWhitespace != rhs._requiresFollowingWhitespace {return false}
    if lhs._whitespace != rhs._whitespace {return false}
    if lhs._guid != rhs._guid {return false}
    if lhs._tableKey != rhs._tableKey {return false}
    if lhs._fieldType != rhs._fieldType {return false}
    if lhs._hasCustomText_p != rhs._hasCustomText_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_MergeSmartFieldArchive.MergeCategory: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kMergeCategoryTo\0\u{1}kMergeCategoryFrom\0")
}

extension TSWP_TOCSmartFieldArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TOCSmartFieldArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}toc_entries\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.tocEntries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tocEntries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.tocEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tocEntries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_TOCSmartFieldArchive, rhs: TSWP_TOCSmartFieldArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.tocEntries != rhs.tocEntries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_TOCSmartFieldArchive.TOCEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSWP_TOCSmartFieldArchive.protoMessageName + ".TOCEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}bookmark_name\0\u{3}target_style\0\u{1}range\0")

  public var isInitialized: Bool {
    if let v = self._targetStyle, !v.isInitialized {return false}
    if let v = self._range, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._bookmarkName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._targetStyle) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._range) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bookmarkName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._targetStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._range {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_TOCSmartFieldArchive.TOCEntry, rhs: TSWP_TOCSmartFieldArchive.TOCEntry) -> Bool {
    if lhs._bookmarkName != rhs._bookmarkName {return false}
    if lhs._targetStyle != rhs._targetStyle {return false}
    if lhs._range != rhs._range {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_RubyFieldArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RubyFieldArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}ruby_text\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._rubyText) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rubyText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_RubyFieldArchive, rhs: TSWP_RubyFieldArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._rubyText != rhs._rubyText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_TateChuYokoFieldArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TateChuYokoFieldArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_TateChuYokoFieldArchive, rhs: TSWP_TateChuYokoFieldArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ChangeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}kind\0\u{1}session\0\u{1}date\0\u{3}text_attribute_uuid_string\0")

  public var isInitialized: Bool {
    if let v = self._session, !v.isInitialized {return false}
    if let v = self._date, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._kind) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._session) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._textAttributeUuidString) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._kind {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._session {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._textAttributeUuidString {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ChangeArchive, rhs: TSWP_ChangeArchive) -> Bool {
    if lhs._kind != rhs._kind {return false}
    if lhs._session != rhs._session {return false}
    if lhs._date != rhs._date {return false}
    if lhs._textAttributeUuidString != rhs._textAttributeUuidString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_ChangeArchive.ChangeKind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}kChangeKindInsertion\0\u{1}kChangeKindDeletion\0")
}

extension TSWP_ChangeSessionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeSessionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}session_uid\0\u{1}author\0\u{1}date\0")

  public var isInitialized: Bool {
    if let v = self._author, !v.isInitialized {return false}
    if let v = self._date, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._sessionUid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._author) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sessionUid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._author {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_ChangeSessionArchive, rhs: TSWP_ChangeSessionArchive) -> Bool {
    if lhs._sessionUid != rhs._sessionUid {return false}
    if lhs._author != rhs._author {return false}
    if lhs._date != rhs._date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_SectionPlaceholderArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SectionPlaceholderArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}parent_storage\0")

  public var isInitialized: Bool {
    if let v = self._parentStorage, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parentStorage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._parentStorage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_SectionPlaceholderArchive, rhs: TSWP_SectionPlaceholderArchive) -> Bool {
    if lhs._parentStorage != rhs._parentStorage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_HyperlinkSelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HyperlinkSelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_HyperlinkSelectionArchive, rhs: TSWP_HyperlinkSelectionArchive) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_DateTimeSelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DateTimeSelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_DateTimeSelectionArchive, rhs: TSWP_DateTimeSelectionArchive) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_FlowInfoArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FlowInfoArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}text_storage\0\u{1}textboxes\0\u{3}user_interface_identifier\0")

  public var isInitialized: Bool {
    if let v = self._textStorage, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.textboxes) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._textStorage) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.textboxes) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._userInterfaceIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._textStorage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.textboxes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.textboxes, fieldNumber: 2)
    }
    try { if let v = self._userInterfaceIdentifier {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_FlowInfoArchive, rhs: TSWP_FlowInfoArchive) -> Bool {
    if lhs._textStorage != rhs._textStorage {return false}
    if lhs.textboxes != rhs.textboxes {return false}
    if lhs._userInterfaceIdentifier != rhs._userInterfaceIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_FlowInfoContainerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FlowInfoContainerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}flow_infos\0\u{3}next_user_interface_identifier\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.flowInfos) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.flowInfos) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._nextUserInterfaceIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.flowInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.flowInfos, fieldNumber: 1)
    }
    try { if let v = self._nextUserInterfaceIdentifier {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_FlowInfoContainerArchive, rhs: TSWP_FlowInfoContainerArchive) -> Bool {
    if lhs.flowInfos != rhs.flowInfos {return false}
    if lhs._nextUserInterfaceIdentifier != rhs._nextUserInterfaceIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_DropCapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DropCapArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{3}number_of_lines\0\u{3}number_of_raised_lines\0\u{3}deprecated_outdent\0\u{3}deprecated_padding\0\u{3}wrap_type\0\u{3}shape_enabled\0\u{3}deprecated_corner_radius\0\u{3}deprecated_character_scale\0\u{3}number_of_characters\0\u{1}outdent\0\u{1}padding\0\u{3}corner_radius\0\u{3}character_scale\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._numberOfLines) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._numberOfRaisedLines) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._deprecatedOutdent) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._deprecatedPadding) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._wrapType) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._shapeEnabled) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self._deprecatedCornerRadius) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self._deprecatedCharacterScale) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._numberOfCharacters) }()
      case 11: try { try decoder.decodeSingularDoubleField(value: &self._outdent) }()
      case 12: try { try decoder.decodeSingularDoubleField(value: &self._padding) }()
      case 13: try { try decoder.decodeSingularDoubleField(value: &self._cornerRadius) }()
      case 14: try { try decoder.decodeSingularDoubleField(value: &self._characterScale) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._numberOfLines {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._numberOfRaisedLines {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._deprecatedOutdent {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._deprecatedPadding {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._wrapType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._shapeEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._deprecatedCornerRadius {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._deprecatedCharacterScale {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._numberOfCharacters {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._outdent {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._padding {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._cornerRadius {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._characterScale {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 14)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_DropCapArchive, rhs: TSWP_DropCapArchive) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._numberOfLines != rhs._numberOfLines {return false}
    if lhs._numberOfRaisedLines != rhs._numberOfRaisedLines {return false}
    if lhs._deprecatedOutdent != rhs._deprecatedOutdent {return false}
    if lhs._outdent != rhs._outdent {return false}
    if lhs._deprecatedPadding != rhs._deprecatedPadding {return false}
    if lhs._padding != rhs._padding {return false}
    if lhs._wrapType != rhs._wrapType {return false}
    if lhs._shapeEnabled != rhs._shapeEnabled {return false}
    if lhs._deprecatedCornerRadius != rhs._deprecatedCornerRadius {return false}
    if lhs._cornerRadius != rhs._cornerRadius {return false}
    if lhs._deprecatedCharacterScale != rhs._deprecatedCharacterScale {return false}
    if lhs._characterScale != rhs._characterScale {return false}
    if lhs._numberOfCharacters != rhs._numberOfCharacters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_DropCapArchive.DropCapType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TSWPDropCapTypeText\0\u{1}TSWPDropCapTypeShape\0\u{1}TSWPDropCapTypeImage\0")
}

extension TSWP_DropCapArchive.DropCapWrapType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TSWPDropCapWrapTypeRectangular\0\u{1}TSWPDropCapWrapTypeContour\0\u{1}TSWPDropCapWrapTypeNone\0")
}

extension TSWP_DropCapStylePropertiesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DropCapStylePropertiesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}drop_cap\0\u{4}\u{2}drop_cap_shape_stroke\0\u{3}drop_cap_shape_fill_null\0\u{3}drop_cap_shape_fill\0")

  fileprivate class _StorageClass {
    var _dropCap: TSWP_DropCapArchive? = nil
    var _dropCapShapeStroke: TSD_StrokeArchive? = nil
    var _dropCapShapeFillNull: Bool? = nil
    var _dropCapShapeFill: TSD_FillArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _dropCap = source._dropCap
      _dropCapShapeStroke = source._dropCapShapeStroke
      _dropCapShapeFillNull = source._dropCapShapeFillNull
      _dropCapShapeFill = source._dropCapShapeFill
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._dropCapShapeStroke, !v.isInitialized {return false}
      if let v = _storage._dropCapShapeFill, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._dropCap) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._dropCapShapeStroke) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._dropCapShapeFillNull) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._dropCapShapeFill) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._dropCap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._dropCapShapeStroke {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._dropCapShapeFillNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._dropCapShapeFill {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_DropCapStylePropertiesArchive, rhs: TSWP_DropCapStylePropertiesArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._dropCap != rhs_storage._dropCap {return false}
        if _storage._dropCapShapeStroke != rhs_storage._dropCapShapeStroke {return false}
        if _storage._dropCapShapeFillNull != rhs_storage._dropCapShapeFillNull {return false}
        if _storage._dropCapShapeFill != rhs_storage._dropCapShapeFill {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_DropCapStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DropCapStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{9}override_count\0\u{3}char_properties\0\u{3}drop_cap_properties\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._charProperties, !v.isInitialized {return false}
    if let v = self._dropCapProperties, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._overrideCount) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._charProperties) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._dropCapProperties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._overrideCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._charProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._dropCapProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_DropCapStyleArchive, rhs: TSWP_DropCapStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._overrideCount != rhs._overrideCount {return false}
    if lhs._charProperties != rhs._charProperties {return false}
    if lhs._dropCapProperties != rhs._dropCapProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSWP_CollaboratorTextCursorSubselectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CollaboratorTextCursorSubselectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}text_selection\0")

  public var isInitialized: Bool {
    if let v = self._textSelection, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._textSelection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._textSelection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSWP_CollaboratorTextCursorSubselectionArchive, rhs: TSWP_CollaboratorTextCursorSubselectionArchive) -> Bool {
    if lhs._textSelection != rhs._textSelection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
