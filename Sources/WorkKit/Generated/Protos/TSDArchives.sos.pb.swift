// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TSDArchives.sos.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct TSDSOS_SpecSetFillArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fill: TSD_FillArchive {
    get {return _fill ?? TSD_FillArchive()}
    set {_fill = newValue}
  }
  /// Returns true if `fill` has been explicitly set.
  var hasFill: Bool {return self._fill != nil}
  /// Clears the value of `fill`. Subsequent reads from it will return its default value.
  mutating func clearFill() {self._fill = nil}

  var unset: Bool {
    get {return _unset ?? false}
    set {_unset = newValue}
  }
  /// Returns true if `unset` has been explicitly set.
  var hasUnset: Bool {return self._unset != nil}
  /// Clears the value of `unset`. Subsequent reads from it will return its default value.
  mutating func clearUnset() {self._unset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fill: TSD_FillArchive? = nil
  fileprivate var _unset: Bool? = nil
}

struct TSDSOS_SpecSetLineEndArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lineEnd: TSD_LineEndArchive {
    get {return _lineEnd ?? TSD_LineEndArchive()}
    set {_lineEnd = newValue}
  }
  /// Returns true if `lineEnd` has been explicitly set.
  var hasLineEnd: Bool {return self._lineEnd != nil}
  /// Clears the value of `lineEnd`. Subsequent reads from it will return its default value.
  mutating func clearLineEnd() {self._lineEnd = nil}

  var unset: Bool {
    get {return _unset ?? false}
    set {_unset = newValue}
  }
  /// Returns true if `unset` has been explicitly set.
  var hasUnset: Bool {return self._unset != nil}
  /// Clears the value of `unset`. Subsequent reads from it will return its default value.
  mutating func clearUnset() {self._unset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lineEnd: TSD_LineEndArchive? = nil
  fileprivate var _unset: Bool? = nil
}

struct TSDSOS_SpecSetReflectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reflection: TSD_ReflectionArchive {
    get {return _reflection ?? TSD_ReflectionArchive()}
    set {_reflection = newValue}
  }
  /// Returns true if `reflection` has been explicitly set.
  var hasReflection: Bool {return self._reflection != nil}
  /// Clears the value of `reflection`. Subsequent reads from it will return its default value.
  mutating func clearReflection() {self._reflection = nil}

  var unset: Bool {
    get {return _unset ?? false}
    set {_unset = newValue}
  }
  /// Returns true if `unset` has been explicitly set.
  var hasUnset: Bool {return self._unset != nil}
  /// Clears the value of `unset`. Subsequent reads from it will return its default value.
  mutating func clearUnset() {self._unset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _reflection: TSD_ReflectionArchive? = nil
  fileprivate var _unset: Bool? = nil
}

struct TSDSOS_SpecSetShadowArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var shadow: TSD_ShadowArchive {
    get {return _shadow ?? TSD_ShadowArchive()}
    set {_shadow = newValue}
  }
  /// Returns true if `shadow` has been explicitly set.
  var hasShadow: Bool {return self._shadow != nil}
  /// Clears the value of `shadow`. Subsequent reads from it will return its default value.
  mutating func clearShadow() {self._shadow = nil}

  var unset: Bool {
    get {return _unset ?? false}
    set {_unset = newValue}
  }
  /// Returns true if `unset` has been explicitly set.
  var hasUnset: Bool {return self._unset != nil}
  /// Clears the value of `unset`. Subsequent reads from it will return its default value.
  mutating func clearUnset() {self._unset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _shadow: TSD_ShadowArchive? = nil
  fileprivate var _unset: Bool? = nil
}

struct TSDSOS_SpecSetStrokeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stroke: TSD_StrokeArchive {
    get {return _stroke ?? TSD_StrokeArchive()}
    set {_stroke = newValue}
  }
  /// Returns true if `stroke` has been explicitly set.
  var hasStroke: Bool {return self._stroke != nil}
  /// Clears the value of `stroke`. Subsequent reads from it will return its default value.
  mutating func clearStroke() {self._stroke = nil}

  var unset: Bool {
    get {return _unset ?? false}
    set {_unset = newValue}
  }
  /// Returns true if `unset` has been explicitly set.
  var hasUnset: Bool {return self._unset != nil}
  /// Clears the value of `unset`. Subsequent reads from it will return its default value.
  mutating func clearUnset() {self._unset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _stroke: TSD_StrokeArchive? = nil
  fileprivate var _unset: Bool? = nil
}

struct TSDSOS_SpecFillArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var specColorFillSetColor: TSD_SpecColorFillSetColorArchive {
    get {return _specColorFillSetColor ?? TSD_SpecColorFillSetColorArchive()}
    set {_specColorFillSetColor = newValue}
  }
  /// Returns true if `specColorFillSetColor` has been explicitly set.
  var hasSpecColorFillSetColor: Bool {return self._specColorFillSetColor != nil}
  /// Clears the value of `specColorFillSetColor`. Subsequent reads from it will return its default value.
  mutating func clearSpecColorFillSetColor() {self._specColorFillSetColor = nil}

  var specGradientFillSetAngle: TSD_SpecGradientFillSetAngleArchive {
    get {return _specGradientFillSetAngle ?? TSD_SpecGradientFillSetAngleArchive()}
    set {_specGradientFillSetAngle = newValue}
  }
  /// Returns true if `specGradientFillSetAngle` has been explicitly set.
  var hasSpecGradientFillSetAngle: Bool {return self._specGradientFillSetAngle != nil}
  /// Clears the value of `specGradientFillSetAngle`. Subsequent reads from it will return its default value.
  mutating func clearSpecGradientFillSetAngle() {self._specGradientFillSetAngle = nil}

  var specImageFillSetTechnique: TSD_SpecImageFillSetTechniqueArchive {
    get {return _specImageFillSetTechnique ?? TSD_SpecImageFillSetTechniqueArchive()}
    set {_specImageFillSetTechnique = newValue}
  }
  /// Returns true if `specImageFillSetTechnique` has been explicitly set.
  var hasSpecImageFillSetTechnique: Bool {return self._specImageFillSetTechnique != nil}
  /// Clears the value of `specImageFillSetTechnique`. Subsequent reads from it will return its default value.
  mutating func clearSpecImageFillSetTechnique() {self._specImageFillSetTechnique = nil}

  var specSetFill: TSDSOS_SpecSetFillArchive {
    get {return _specSetFill ?? TSDSOS_SpecSetFillArchive()}
    set {_specSetFill = newValue}
  }
  /// Returns true if `specSetFill` has been explicitly set.
  var hasSpecSetFill: Bool {return self._specSetFill != nil}
  /// Clears the value of `specSetFill`. Subsequent reads from it will return its default value.
  mutating func clearSpecSetFill() {self._specSetFill = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _specColorFillSetColor: TSD_SpecColorFillSetColorArchive? = nil
  fileprivate var _specGradientFillSetAngle: TSD_SpecGradientFillSetAngleArchive? = nil
  fileprivate var _specImageFillSetTechnique: TSD_SpecImageFillSetTechniqueArchive? = nil
  fileprivate var _specSetFill: TSDSOS_SpecSetFillArchive? = nil
}

struct TSDSOS_SpecLineEndArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var specSetLineEnd: TSDSOS_SpecSetLineEndArchive {
    get {return _specSetLineEnd ?? TSDSOS_SpecSetLineEndArchive()}
    set {_specSetLineEnd = newValue}
  }
  /// Returns true if `specSetLineEnd` has been explicitly set.
  var hasSpecSetLineEnd: Bool {return self._specSetLineEnd != nil}
  /// Clears the value of `specSetLineEnd`. Subsequent reads from it will return its default value.
  mutating func clearSpecSetLineEnd() {self._specSetLineEnd = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _specSetLineEnd: TSDSOS_SpecSetLineEndArchive? = nil
}

struct TSDSOS_SpecReflectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var specReflectionSetOpacity: TSD_SpecReflectionSetOpacityArchive {
    get {return _specReflectionSetOpacity ?? TSD_SpecReflectionSetOpacityArchive()}
    set {_specReflectionSetOpacity = newValue}
  }
  /// Returns true if `specReflectionSetOpacity` has been explicitly set.
  var hasSpecReflectionSetOpacity: Bool {return self._specReflectionSetOpacity != nil}
  /// Clears the value of `specReflectionSetOpacity`. Subsequent reads from it will return its default value.
  mutating func clearSpecReflectionSetOpacity() {self._specReflectionSetOpacity = nil}

  var specSetReflection: TSDSOS_SpecSetReflectionArchive {
    get {return _specSetReflection ?? TSDSOS_SpecSetReflectionArchive()}
    set {_specSetReflection = newValue}
  }
  /// Returns true if `specSetReflection` has been explicitly set.
  var hasSpecSetReflection: Bool {return self._specSetReflection != nil}
  /// Clears the value of `specSetReflection`. Subsequent reads from it will return its default value.
  mutating func clearSpecSetReflection() {self._specSetReflection = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _specReflectionSetOpacity: TSD_SpecReflectionSetOpacityArchive? = nil
  fileprivate var _specSetReflection: TSDSOS_SpecSetReflectionArchive? = nil
}

struct TSDSOS_SpecShadowArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var specSetShadow: TSDSOS_SpecSetShadowArchive {
    get {return _storage._specSetShadow ?? TSDSOS_SpecSetShadowArchive()}
    set {_uniqueStorage()._specSetShadow = newValue}
  }
  /// Returns true if `specSetShadow` has been explicitly set.
  var hasSpecSetShadow: Bool {return _storage._specSetShadow != nil}
  /// Clears the value of `specSetShadow`. Subsequent reads from it will return its default value.
  mutating func clearSpecSetShadow() {_uniqueStorage()._specSetShadow = nil}

  var specShadowSetAngle: TSD_SpecShadowSetAngleArchive {
    get {return _storage._specShadowSetAngle ?? TSD_SpecShadowSetAngleArchive()}
    set {_uniqueStorage()._specShadowSetAngle = newValue}
  }
  /// Returns true if `specShadowSetAngle` has been explicitly set.
  var hasSpecShadowSetAngle: Bool {return _storage._specShadowSetAngle != nil}
  /// Clears the value of `specShadowSetAngle`. Subsequent reads from it will return its default value.
  mutating func clearSpecShadowSetAngle() {_uniqueStorage()._specShadowSetAngle = nil}

  var specShadowSetColor: TSD_SpecShadowSetColorArchive {
    get {return _storage._specShadowSetColor ?? TSD_SpecShadowSetColorArchive()}
    set {_uniqueStorage()._specShadowSetColor = newValue}
  }
  /// Returns true if `specShadowSetColor` has been explicitly set.
  var hasSpecShadowSetColor: Bool {return _storage._specShadowSetColor != nil}
  /// Clears the value of `specShadowSetColor`. Subsequent reads from it will return its default value.
  mutating func clearSpecShadowSetColor() {_uniqueStorage()._specShadowSetColor = nil}

  var specShadowSetOffset: TSD_SpecShadowSetOffsetArchive {
    get {return _storage._specShadowSetOffset ?? TSD_SpecShadowSetOffsetArchive()}
    set {_uniqueStorage()._specShadowSetOffset = newValue}
  }
  /// Returns true if `specShadowSetOffset` has been explicitly set.
  var hasSpecShadowSetOffset: Bool {return _storage._specShadowSetOffset != nil}
  /// Clears the value of `specShadowSetOffset`. Subsequent reads from it will return its default value.
  mutating func clearSpecShadowSetOffset() {_uniqueStorage()._specShadowSetOffset = nil}

  var specShadowSetOpacity: TSD_SpecShadowSetOpacityArchive {
    get {return _storage._specShadowSetOpacity ?? TSD_SpecShadowSetOpacityArchive()}
    set {_uniqueStorage()._specShadowSetOpacity = newValue}
  }
  /// Returns true if `specShadowSetOpacity` has been explicitly set.
  var hasSpecShadowSetOpacity: Bool {return _storage._specShadowSetOpacity != nil}
  /// Clears the value of `specShadowSetOpacity`. Subsequent reads from it will return its default value.
  mutating func clearSpecShadowSetOpacity() {_uniqueStorage()._specShadowSetOpacity = nil}

  var specShadowSetRadius: TSD_SpecShadowSetRadiusArchive {
    get {return _storage._specShadowSetRadius ?? TSD_SpecShadowSetRadiusArchive()}
    set {_uniqueStorage()._specShadowSetRadius = newValue}
  }
  /// Returns true if `specShadowSetRadius` has been explicitly set.
  var hasSpecShadowSetRadius: Bool {return _storage._specShadowSetRadius != nil}
  /// Clears the value of `specShadowSetRadius`. Subsequent reads from it will return its default value.
  mutating func clearSpecShadowSetRadius() {_uniqueStorage()._specShadowSetRadius = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSDSOS_SpecStrokeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var specFrameSetAssetScale: TSD_SpecFrameSetAssetScaleArchive {
    get {return _specFrameSetAssetScale ?? TSD_SpecFrameSetAssetScaleArchive()}
    set {_specFrameSetAssetScale = newValue}
  }
  /// Returns true if `specFrameSetAssetScale` has been explicitly set.
  var hasSpecFrameSetAssetScale: Bool {return self._specFrameSetAssetScale != nil}
  /// Clears the value of `specFrameSetAssetScale`. Subsequent reads from it will return its default value.
  mutating func clearSpecFrameSetAssetScale() {self._specFrameSetAssetScale = nil}

  var specSetStroke: TSDSOS_SpecSetStrokeArchive {
    get {return _specSetStroke ?? TSDSOS_SpecSetStrokeArchive()}
    set {_specSetStroke = newValue}
  }
  /// Returns true if `specSetStroke` has been explicitly set.
  var hasSpecSetStroke: Bool {return self._specSetStroke != nil}
  /// Clears the value of `specSetStroke`. Subsequent reads from it will return its default value.
  mutating func clearSpecSetStroke() {self._specSetStroke = nil}

  var specStrokeSetColor: TSD_SpecStrokeSetColorArchive {
    get {return _specStrokeSetColor ?? TSD_SpecStrokeSetColorArchive()}
    set {_specStrokeSetColor = newValue}
  }
  /// Returns true if `specStrokeSetColor` has been explicitly set.
  var hasSpecStrokeSetColor: Bool {return self._specStrokeSetColor != nil}
  /// Clears the value of `specStrokeSetColor`. Subsequent reads from it will return its default value.
  mutating func clearSpecStrokeSetColor() {self._specStrokeSetColor = nil}

  var specStrokeSetPattern: TSD_SpecStrokeSetPatternArchive {
    get {return _specStrokeSetPattern ?? TSD_SpecStrokeSetPatternArchive()}
    set {_specStrokeSetPattern = newValue}
  }
  /// Returns true if `specStrokeSetPattern` has been explicitly set.
  var hasSpecStrokeSetPattern: Bool {return self._specStrokeSetPattern != nil}
  /// Clears the value of `specStrokeSetPattern`. Subsequent reads from it will return its default value.
  mutating func clearSpecStrokeSetPattern() {self._specStrokeSetPattern = nil}

  var specStrokeSetWidth: TSD_SpecStrokeSetWidthArchive {
    get {return _specStrokeSetWidth ?? TSD_SpecStrokeSetWidthArchive()}
    set {_specStrokeSetWidth = newValue}
  }
  /// Returns true if `specStrokeSetWidth` has been explicitly set.
  var hasSpecStrokeSetWidth: Bool {return self._specStrokeSetWidth != nil}
  /// Clears the value of `specStrokeSetWidth`. Subsequent reads from it will return its default value.
  mutating func clearSpecStrokeSetWidth() {self._specStrokeSetWidth = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _specFrameSetAssetScale: TSD_SpecFrameSetAssetScaleArchive? = nil
  fileprivate var _specSetStroke: TSDSOS_SpecSetStrokeArchive? = nil
  fileprivate var _specStrokeSetColor: TSD_SpecStrokeSetColorArchive? = nil
  fileprivate var _specStrokeSetPattern: TSD_SpecStrokeSetPatternArchive? = nil
  fileprivate var _specStrokeSetWidth: TSD_SpecStrokeSetWidthArchive? = nil
}

struct TSDSOS_BaseShapeStylePropertyChangeSetArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fill: TSDSOS_SpecFillArchive {
    get {return _storage._fill ?? TSDSOS_SpecFillArchive()}
    set {_uniqueStorage()._fill = newValue}
  }
  /// Returns true if `fill` has been explicitly set.
  var hasFill: Bool {return _storage._fill != nil}
  /// Clears the value of `fill`. Subsequent reads from it will return its default value.
  mutating func clearFill() {_uniqueStorage()._fill = nil}

  var fillUndefined: Bool {
    get {return _storage._fillUndefined ?? false}
    set {_uniqueStorage()._fillUndefined = newValue}
  }
  /// Returns true if `fillUndefined` has been explicitly set.
  var hasFillUndefined: Bool {return _storage._fillUndefined != nil}
  /// Clears the value of `fillUndefined`. Subsequent reads from it will return its default value.
  mutating func clearFillUndefined() {_uniqueStorage()._fillUndefined = nil}

  var stroke: TSDSOS_SpecStrokeArchive {
    get {return _storage._stroke ?? TSDSOS_SpecStrokeArchive()}
    set {_uniqueStorage()._stroke = newValue}
  }
  /// Returns true if `stroke` has been explicitly set.
  var hasStroke: Bool {return _storage._stroke != nil}
  /// Clears the value of `stroke`. Subsequent reads from it will return its default value.
  mutating func clearStroke() {_uniqueStorage()._stroke = nil}

  var strokeUndefined: Bool {
    get {return _storage._strokeUndefined ?? false}
    set {_uniqueStorage()._strokeUndefined = newValue}
  }
  /// Returns true if `strokeUndefined` has been explicitly set.
  var hasStrokeUndefined: Bool {return _storage._strokeUndefined != nil}
  /// Clears the value of `strokeUndefined`. Subsequent reads from it will return its default value.
  mutating func clearStrokeUndefined() {_uniqueStorage()._strokeUndefined = nil}

  var opacity: TSSSOS_SpecDoubleArchive {
    get {return _storage._opacity ?? TSSSOS_SpecDoubleArchive()}
    set {_uniqueStorage()._opacity = newValue}
  }
  /// Returns true if `opacity` has been explicitly set.
  var hasOpacity: Bool {return _storage._opacity != nil}
  /// Clears the value of `opacity`. Subsequent reads from it will return its default value.
  mutating func clearOpacity() {_uniqueStorage()._opacity = nil}

  var opacityUndefined: Bool {
    get {return _storage._opacityUndefined ?? false}
    set {_uniqueStorage()._opacityUndefined = newValue}
  }
  /// Returns true if `opacityUndefined` has been explicitly set.
  var hasOpacityUndefined: Bool {return _storage._opacityUndefined != nil}
  /// Clears the value of `opacityUndefined`. Subsequent reads from it will return its default value.
  mutating func clearOpacityUndefined() {_uniqueStorage()._opacityUndefined = nil}

  var shadow: TSDSOS_SpecShadowArchive {
    get {return _storage._shadow ?? TSDSOS_SpecShadowArchive()}
    set {_uniqueStorage()._shadow = newValue}
  }
  /// Returns true if `shadow` has been explicitly set.
  var hasShadow: Bool {return _storage._shadow != nil}
  /// Clears the value of `shadow`. Subsequent reads from it will return its default value.
  mutating func clearShadow() {_uniqueStorage()._shadow = nil}

  var shadowUndefined: Bool {
    get {return _storage._shadowUndefined ?? false}
    set {_uniqueStorage()._shadowUndefined = newValue}
  }
  /// Returns true if `shadowUndefined` has been explicitly set.
  var hasShadowUndefined: Bool {return _storage._shadowUndefined != nil}
  /// Clears the value of `shadowUndefined`. Subsequent reads from it will return its default value.
  mutating func clearShadowUndefined() {_uniqueStorage()._shadowUndefined = nil}

  var reflection: TSDSOS_SpecReflectionArchive {
    get {return _storage._reflection ?? TSDSOS_SpecReflectionArchive()}
    set {_uniqueStorage()._reflection = newValue}
  }
  /// Returns true if `reflection` has been explicitly set.
  var hasReflection: Bool {return _storage._reflection != nil}
  /// Clears the value of `reflection`. Subsequent reads from it will return its default value.
  mutating func clearReflection() {_uniqueStorage()._reflection = nil}

  var reflectionUndefined: Bool {
    get {return _storage._reflectionUndefined ?? false}
    set {_uniqueStorage()._reflectionUndefined = newValue}
  }
  /// Returns true if `reflectionUndefined` has been explicitly set.
  var hasReflectionUndefined: Bool {return _storage._reflectionUndefined != nil}
  /// Clears the value of `reflectionUndefined`. Subsequent reads from it will return its default value.
  mutating func clearReflectionUndefined() {_uniqueStorage()._reflectionUndefined = nil}

  var headLineEnd: TSDSOS_SpecLineEndArchive {
    get {return _storage._headLineEnd ?? TSDSOS_SpecLineEndArchive()}
    set {_uniqueStorage()._headLineEnd = newValue}
  }
  /// Returns true if `headLineEnd` has been explicitly set.
  var hasHeadLineEnd: Bool {return _storage._headLineEnd != nil}
  /// Clears the value of `headLineEnd`. Subsequent reads from it will return its default value.
  mutating func clearHeadLineEnd() {_uniqueStorage()._headLineEnd = nil}

  var headLineEndUndefined: Bool {
    get {return _storage._headLineEndUndefined ?? false}
    set {_uniqueStorage()._headLineEndUndefined = newValue}
  }
  /// Returns true if `headLineEndUndefined` has been explicitly set.
  var hasHeadLineEndUndefined: Bool {return _storage._headLineEndUndefined != nil}
  /// Clears the value of `headLineEndUndefined`. Subsequent reads from it will return its default value.
  mutating func clearHeadLineEndUndefined() {_uniqueStorage()._headLineEndUndefined = nil}

  var tailLineEnd: TSDSOS_SpecLineEndArchive {
    get {return _storage._tailLineEnd ?? TSDSOS_SpecLineEndArchive()}
    set {_uniqueStorage()._tailLineEnd = newValue}
  }
  /// Returns true if `tailLineEnd` has been explicitly set.
  var hasTailLineEnd: Bool {return _storage._tailLineEnd != nil}
  /// Clears the value of `tailLineEnd`. Subsequent reads from it will return its default value.
  mutating func clearTailLineEnd() {_uniqueStorage()._tailLineEnd = nil}

  var tailLineEndUndefined: Bool {
    get {return _storage._tailLineEndUndefined ?? false}
    set {_uniqueStorage()._tailLineEndUndefined = newValue}
  }
  /// Returns true if `tailLineEndUndefined` has been explicitly set.
  var hasTailLineEndUndefined: Bool {return _storage._tailLineEndUndefined != nil}
  /// Clears the value of `tailLineEndUndefined`. Subsequent reads from it will return its default value.
  mutating func clearTailLineEndUndefined() {_uniqueStorage()._tailLineEndUndefined = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSDSOS_MediaStylePropertyChangeSetArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stroke: TSDSOS_SpecStrokeArchive {
    get {return _storage._stroke ?? TSDSOS_SpecStrokeArchive()}
    set {_uniqueStorage()._stroke = newValue}
  }
  /// Returns true if `stroke` has been explicitly set.
  var hasStroke: Bool {return _storage._stroke != nil}
  /// Clears the value of `stroke`. Subsequent reads from it will return its default value.
  mutating func clearStroke() {_uniqueStorage()._stroke = nil}

  var strokeUndefined: Bool {
    get {return _storage._strokeUndefined ?? false}
    set {_uniqueStorage()._strokeUndefined = newValue}
  }
  /// Returns true if `strokeUndefined` has been explicitly set.
  var hasStrokeUndefined: Bool {return _storage._strokeUndefined != nil}
  /// Clears the value of `strokeUndefined`. Subsequent reads from it will return its default value.
  mutating func clearStrokeUndefined() {_uniqueStorage()._strokeUndefined = nil}

  var opacity: TSSSOS_SpecDoubleArchive {
    get {return _storage._opacity ?? TSSSOS_SpecDoubleArchive()}
    set {_uniqueStorage()._opacity = newValue}
  }
  /// Returns true if `opacity` has been explicitly set.
  var hasOpacity: Bool {return _storage._opacity != nil}
  /// Clears the value of `opacity`. Subsequent reads from it will return its default value.
  mutating func clearOpacity() {_uniqueStorage()._opacity = nil}

  var opacityUndefined: Bool {
    get {return _storage._opacityUndefined ?? false}
    set {_uniqueStorage()._opacityUndefined = newValue}
  }
  /// Returns true if `opacityUndefined` has been explicitly set.
  var hasOpacityUndefined: Bool {return _storage._opacityUndefined != nil}
  /// Clears the value of `opacityUndefined`. Subsequent reads from it will return its default value.
  mutating func clearOpacityUndefined() {_uniqueStorage()._opacityUndefined = nil}

  var shadow: TSDSOS_SpecShadowArchive {
    get {return _storage._shadow ?? TSDSOS_SpecShadowArchive()}
    set {_uniqueStorage()._shadow = newValue}
  }
  /// Returns true if `shadow` has been explicitly set.
  var hasShadow: Bool {return _storage._shadow != nil}
  /// Clears the value of `shadow`. Subsequent reads from it will return its default value.
  mutating func clearShadow() {_uniqueStorage()._shadow = nil}

  var shadowUndefined: Bool {
    get {return _storage._shadowUndefined ?? false}
    set {_uniqueStorage()._shadowUndefined = newValue}
  }
  /// Returns true if `shadowUndefined` has been explicitly set.
  var hasShadowUndefined: Bool {return _storage._shadowUndefined != nil}
  /// Clears the value of `shadowUndefined`. Subsequent reads from it will return its default value.
  mutating func clearShadowUndefined() {_uniqueStorage()._shadowUndefined = nil}

  var reflection: TSDSOS_SpecReflectionArchive {
    get {return _storage._reflection ?? TSDSOS_SpecReflectionArchive()}
    set {_uniqueStorage()._reflection = newValue}
  }
  /// Returns true if `reflection` has been explicitly set.
  var hasReflection: Bool {return _storage._reflection != nil}
  /// Clears the value of `reflection`. Subsequent reads from it will return its default value.
  mutating func clearReflection() {_uniqueStorage()._reflection = nil}

  var reflectionUndefined: Bool {
    get {return _storage._reflectionUndefined ?? false}
    set {_uniqueStorage()._reflectionUndefined = newValue}
  }
  /// Returns true if `reflectionUndefined` has been explicitly set.
  var hasReflectionUndefined: Bool {return _storage._reflectionUndefined != nil}
  /// Clears the value of `reflectionUndefined`. Subsequent reads from it will return its default value.
  mutating func clearReflectionUndefined() {_uniqueStorage()._reflectionUndefined = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TSDSOS"

extension TSDSOS_SpecSetFillArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecSetFillArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}fill\0\u{1}unset\0")

  public var isInitialized: Bool {
    if self._unset == nil {return false}
    if let v = self._fill, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fill) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._unset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fill {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._unset {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSDSOS_SpecSetFillArchive, rhs: TSDSOS_SpecSetFillArchive) -> Bool {
    if lhs._fill != rhs._fill {return false}
    if lhs._unset != rhs._unset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSDSOS_SpecSetLineEndArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecSetLineEndArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}line_end\0\u{1}unset\0")

  public var isInitialized: Bool {
    if self._unset == nil {return false}
    if let v = self._lineEnd, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lineEnd) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._unset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lineEnd {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._unset {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSDSOS_SpecSetLineEndArchive, rhs: TSDSOS_SpecSetLineEndArchive) -> Bool {
    if lhs._lineEnd != rhs._lineEnd {return false}
    if lhs._unset != rhs._unset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSDSOS_SpecSetReflectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecSetReflectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}reflection\0\u{1}unset\0")

  public var isInitialized: Bool {
    if self._unset == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._reflection) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._unset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._reflection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._unset {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSDSOS_SpecSetReflectionArchive, rhs: TSDSOS_SpecSetReflectionArchive) -> Bool {
    if lhs._reflection != rhs._reflection {return false}
    if lhs._unset != rhs._unset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSDSOS_SpecSetShadowArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecSetShadowArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}shadow\0\u{1}unset\0")

  public var isInitialized: Bool {
    if self._unset == nil {return false}
    if let v = self._shadow, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._shadow) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._unset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._shadow {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._unset {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSDSOS_SpecSetShadowArchive, rhs: TSDSOS_SpecSetShadowArchive) -> Bool {
    if lhs._shadow != rhs._shadow {return false}
    if lhs._unset != rhs._unset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSDSOS_SpecSetStrokeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecSetStrokeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}stroke\0\u{1}unset\0")

  public var isInitialized: Bool {
    if self._unset == nil {return false}
    if let v = self._stroke, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._stroke) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._unset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stroke {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._unset {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSDSOS_SpecSetStrokeArchive, rhs: TSDSOS_SpecSetStrokeArchive) -> Bool {
    if lhs._stroke != rhs._stroke {return false}
    if lhs._unset != rhs._unset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSDSOS_SpecFillArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecFillArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}spec_color_fill_set_color\0\u{3}spec_gradient_fill_set_angle\0\u{3}spec_image_fill_set_technique\0\u{3}spec_set_fill\0")

  public var isInitialized: Bool {
    if let v = self._specColorFillSetColor, !v.isInitialized {return false}
    if let v = self._specGradientFillSetAngle, !v.isInitialized {return false}
    if let v = self._specImageFillSetTechnique, !v.isInitialized {return false}
    if let v = self._specSetFill, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._specColorFillSetColor) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._specGradientFillSetAngle) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._specImageFillSetTechnique) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._specSetFill) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._specColorFillSetColor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._specGradientFillSetAngle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._specImageFillSetTechnique {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._specSetFill {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSDSOS_SpecFillArchive, rhs: TSDSOS_SpecFillArchive) -> Bool {
    if lhs._specColorFillSetColor != rhs._specColorFillSetColor {return false}
    if lhs._specGradientFillSetAngle != rhs._specGradientFillSetAngle {return false}
    if lhs._specImageFillSetTechnique != rhs._specImageFillSetTechnique {return false}
    if lhs._specSetFill != rhs._specSetFill {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSDSOS_SpecLineEndArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecLineEndArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}spec_set_line_end\0")

  public var isInitialized: Bool {
    if let v = self._specSetLineEnd, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._specSetLineEnd) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._specSetLineEnd {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSDSOS_SpecLineEndArchive, rhs: TSDSOS_SpecLineEndArchive) -> Bool {
    if lhs._specSetLineEnd != rhs._specSetLineEnd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSDSOS_SpecReflectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecReflectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}spec_reflection_set_opacity\0\u{3}spec_set_reflection\0")

  public var isInitialized: Bool {
    if let v = self._specReflectionSetOpacity, !v.isInitialized {return false}
    if let v = self._specSetReflection, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._specReflectionSetOpacity) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._specSetReflection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._specReflectionSetOpacity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._specSetReflection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSDSOS_SpecReflectionArchive, rhs: TSDSOS_SpecReflectionArchive) -> Bool {
    if lhs._specReflectionSetOpacity != rhs._specReflectionSetOpacity {return false}
    if lhs._specSetReflection != rhs._specSetReflection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSDSOS_SpecShadowArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecShadowArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}spec_set_shadow\0\u{3}spec_shadow_set_angle\0\u{3}spec_shadow_set_color\0\u{3}spec_shadow_set_offset\0\u{3}spec_shadow_set_opacity\0\u{3}spec_shadow_set_radius\0")

  fileprivate class _StorageClass {
    var _specSetShadow: TSDSOS_SpecSetShadowArchive? = nil
    var _specShadowSetAngle: TSD_SpecShadowSetAngleArchive? = nil
    var _specShadowSetColor: TSD_SpecShadowSetColorArchive? = nil
    var _specShadowSetOffset: TSD_SpecShadowSetOffsetArchive? = nil
    var _specShadowSetOpacity: TSD_SpecShadowSetOpacityArchive? = nil
    var _specShadowSetRadius: TSD_SpecShadowSetRadiusArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _specSetShadow = source._specSetShadow
      _specShadowSetAngle = source._specShadowSetAngle
      _specShadowSetColor = source._specShadowSetColor
      _specShadowSetOffset = source._specShadowSetOffset
      _specShadowSetOpacity = source._specShadowSetOpacity
      _specShadowSetRadius = source._specShadowSetRadius
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._specSetShadow, !v.isInitialized {return false}
      if let v = _storage._specShadowSetAngle, !v.isInitialized {return false}
      if let v = _storage._specShadowSetColor, !v.isInitialized {return false}
      if let v = _storage._specShadowSetOffset, !v.isInitialized {return false}
      if let v = _storage._specShadowSetOpacity, !v.isInitialized {return false}
      if let v = _storage._specShadowSetRadius, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._specSetShadow) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._specShadowSetAngle) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._specShadowSetColor) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._specShadowSetOffset) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._specShadowSetOpacity) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._specShadowSetRadius) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._specSetShadow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._specShadowSetAngle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._specShadowSetColor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._specShadowSetOffset {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._specShadowSetOpacity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._specShadowSetRadius {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSDSOS_SpecShadowArchive, rhs: TSDSOS_SpecShadowArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._specSetShadow != rhs_storage._specSetShadow {return false}
        if _storage._specShadowSetAngle != rhs_storage._specShadowSetAngle {return false}
        if _storage._specShadowSetColor != rhs_storage._specShadowSetColor {return false}
        if _storage._specShadowSetOffset != rhs_storage._specShadowSetOffset {return false}
        if _storage._specShadowSetOpacity != rhs_storage._specShadowSetOpacity {return false}
        if _storage._specShadowSetRadius != rhs_storage._specShadowSetRadius {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSDSOS_SpecStrokeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecStrokeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}spec_frame_set_asset_scale\0\u{3}spec_set_stroke\0\u{3}spec_stroke_set_color\0\u{3}spec_stroke_set_pattern\0\u{3}spec_stroke_set_width\0")

  public var isInitialized: Bool {
    if let v = self._specFrameSetAssetScale, !v.isInitialized {return false}
    if let v = self._specSetStroke, !v.isInitialized {return false}
    if let v = self._specStrokeSetColor, !v.isInitialized {return false}
    if let v = self._specStrokeSetPattern, !v.isInitialized {return false}
    if let v = self._specStrokeSetWidth, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._specFrameSetAssetScale) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._specSetStroke) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._specStrokeSetColor) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._specStrokeSetPattern) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._specStrokeSetWidth) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._specFrameSetAssetScale {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._specSetStroke {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._specStrokeSetColor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._specStrokeSetPattern {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._specStrokeSetWidth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSDSOS_SpecStrokeArchive, rhs: TSDSOS_SpecStrokeArchive) -> Bool {
    if lhs._specFrameSetAssetScale != rhs._specFrameSetAssetScale {return false}
    if lhs._specSetStroke != rhs._specSetStroke {return false}
    if lhs._specStrokeSetColor != rhs._specStrokeSetColor {return false}
    if lhs._specStrokeSetPattern != rhs._specStrokeSetPattern {return false}
    if lhs._specStrokeSetWidth != rhs._specStrokeSetWidth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSDSOS_BaseShapeStylePropertyChangeSetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BaseShapeStylePropertyChangeSetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}fill\0\u{3}fill_undefined\0\u{1}stroke\0\u{3}stroke_undefined\0\u{1}opacity\0\u{3}opacity_undefined\0\u{1}shadow\0\u{3}shadow_undefined\0\u{1}reflection\0\u{3}reflection_undefined\0\u{3}head_line_end\0\u{3}head_line_end_undefined\0\u{3}tail_line_end\0\u{3}tail_line_end_undefined\0")

  fileprivate class _StorageClass {
    var _fill: TSDSOS_SpecFillArchive? = nil
    var _fillUndefined: Bool? = nil
    var _stroke: TSDSOS_SpecStrokeArchive? = nil
    var _strokeUndefined: Bool? = nil
    var _opacity: TSSSOS_SpecDoubleArchive? = nil
    var _opacityUndefined: Bool? = nil
    var _shadow: TSDSOS_SpecShadowArchive? = nil
    var _shadowUndefined: Bool? = nil
    var _reflection: TSDSOS_SpecReflectionArchive? = nil
    var _reflectionUndefined: Bool? = nil
    var _headLineEnd: TSDSOS_SpecLineEndArchive? = nil
    var _headLineEndUndefined: Bool? = nil
    var _tailLineEnd: TSDSOS_SpecLineEndArchive? = nil
    var _tailLineEndUndefined: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _fill = source._fill
      _fillUndefined = source._fillUndefined
      _stroke = source._stroke
      _strokeUndefined = source._strokeUndefined
      _opacity = source._opacity
      _opacityUndefined = source._opacityUndefined
      _shadow = source._shadow
      _shadowUndefined = source._shadowUndefined
      _reflection = source._reflection
      _reflectionUndefined = source._reflectionUndefined
      _headLineEnd = source._headLineEnd
      _headLineEndUndefined = source._headLineEndUndefined
      _tailLineEnd = source._tailLineEnd
      _tailLineEndUndefined = source._tailLineEndUndefined
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._fill, !v.isInitialized {return false}
      if let v = _storage._stroke, !v.isInitialized {return false}
      if let v = _storage._opacity, !v.isInitialized {return false}
      if let v = _storage._shadow, !v.isInitialized {return false}
      if let v = _storage._reflection, !v.isInitialized {return false}
      if let v = _storage._headLineEnd, !v.isInitialized {return false}
      if let v = _storage._tailLineEnd, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._fill) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._fillUndefined) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._stroke) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._strokeUndefined) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._opacity) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._opacityUndefined) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._shadow) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._shadowUndefined) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._reflection) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._reflectionUndefined) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._headLineEnd) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._headLineEndUndefined) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._tailLineEnd) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._tailLineEndUndefined) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._fill {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._fillUndefined {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._stroke {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._strokeUndefined {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._opacity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._opacityUndefined {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._shadow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._shadowUndefined {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._reflection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._reflectionUndefined {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._headLineEnd {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._headLineEndUndefined {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._tailLineEnd {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._tailLineEndUndefined {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSDSOS_BaseShapeStylePropertyChangeSetArchive, rhs: TSDSOS_BaseShapeStylePropertyChangeSetArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._fill != rhs_storage._fill {return false}
        if _storage._fillUndefined != rhs_storage._fillUndefined {return false}
        if _storage._stroke != rhs_storage._stroke {return false}
        if _storage._strokeUndefined != rhs_storage._strokeUndefined {return false}
        if _storage._opacity != rhs_storage._opacity {return false}
        if _storage._opacityUndefined != rhs_storage._opacityUndefined {return false}
        if _storage._shadow != rhs_storage._shadow {return false}
        if _storage._shadowUndefined != rhs_storage._shadowUndefined {return false}
        if _storage._reflection != rhs_storage._reflection {return false}
        if _storage._reflectionUndefined != rhs_storage._reflectionUndefined {return false}
        if _storage._headLineEnd != rhs_storage._headLineEnd {return false}
        if _storage._headLineEndUndefined != rhs_storage._headLineEndUndefined {return false}
        if _storage._tailLineEnd != rhs_storage._tailLineEnd {return false}
        if _storage._tailLineEndUndefined != rhs_storage._tailLineEndUndefined {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSDSOS_MediaStylePropertyChangeSetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaStylePropertyChangeSetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}stroke\0\u{3}stroke_undefined\0\u{1}opacity\0\u{3}opacity_undefined\0\u{1}shadow\0\u{3}shadow_undefined\0\u{1}reflection\0\u{3}reflection_undefined\0")

  fileprivate class _StorageClass {
    var _stroke: TSDSOS_SpecStrokeArchive? = nil
    var _strokeUndefined: Bool? = nil
    var _opacity: TSSSOS_SpecDoubleArchive? = nil
    var _opacityUndefined: Bool? = nil
    var _shadow: TSDSOS_SpecShadowArchive? = nil
    var _shadowUndefined: Bool? = nil
    var _reflection: TSDSOS_SpecReflectionArchive? = nil
    var _reflectionUndefined: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _stroke = source._stroke
      _strokeUndefined = source._strokeUndefined
      _opacity = source._opacity
      _opacityUndefined = source._opacityUndefined
      _shadow = source._shadow
      _shadowUndefined = source._shadowUndefined
      _reflection = source._reflection
      _reflectionUndefined = source._reflectionUndefined
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._stroke, !v.isInitialized {return false}
      if let v = _storage._opacity, !v.isInitialized {return false}
      if let v = _storage._shadow, !v.isInitialized {return false}
      if let v = _storage._reflection, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._stroke) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._strokeUndefined) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._opacity) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._opacityUndefined) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._shadow) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._shadowUndefined) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._reflection) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._reflectionUndefined) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._stroke {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._strokeUndefined {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._opacity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._opacityUndefined {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._shadow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._shadowUndefined {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._reflection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._reflectionUndefined {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSDSOS_MediaStylePropertyChangeSetArchive, rhs: TSDSOS_MediaStylePropertyChangeSetArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._stroke != rhs_storage._stroke {return false}
        if _storage._strokeUndefined != rhs_storage._strokeUndefined {return false}
        if _storage._opacity != rhs_storage._opacity {return false}
        if _storage._opacityUndefined != rhs_storage._opacityUndefined {return false}
        if _storage._shadow != rhs_storage._shadow {return false}
        if _storage._shadowUndefined != rhs_storage._shadowUndefined {return false}
        if _storage._reflection != rhs_storage._reflection {return false}
        if _storage._reflectionUndefined != rhs_storage._reflectionUndefined {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
