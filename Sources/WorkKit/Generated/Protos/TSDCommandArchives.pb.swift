// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TSDCommandArchives.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum TSD_CommentCommandVariant: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case baseComment = 0
  case addReply = 1
  case editReply = 2
  case deleteReply = 3

  init() {
    self = .baseComment
  }

}

enum TSD_CaptionOrTitleKind: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case caption = 1
  case title = 2

  init() {
    self = .caption
  }

}

struct TSD_UndoObjectArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stylesheet: TSP_Reference {
    get {return _stylesheet ?? TSP_Reference()}
    set {_stylesheet = newValue}
  }
  /// Returns true if `stylesheet` has been explicitly set.
  var hasStylesheet: Bool {return self._stylesheet != nil}
  /// Clears the value of `stylesheet`. Subsequent reads from it will return its default value.
  mutating func clearStylesheet() {self._stylesheet = nil}

  var objects: [TSP_Reference] = []

  var keys: [String] = []

  var counts: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _stylesheet: TSP_Reference? = nil
}

struct TSD_GroupDrawablesCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var drawables: [TSP_Reference] = []

  var group: TSP_Reference {
    get {return _group ?? TSP_Reference()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  mutating func clearGroup() {self._group = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _group: TSP_Reference? = nil
}

struct TSD_UngroupGroupCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var drawables: [TSP_Reference] = []

  var group: TSP_Reference {
    get {return _group ?? TSP_Reference()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  mutating func clearGroup() {self._group = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _group: TSP_Reference? = nil
}

struct TSD_ContainerRemoveChildrenCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var containerIDPath: TSP_UUIDPath {
    get {return _containerIDPath ?? TSP_UUIDPath()}
    set {_containerIDPath = newValue}
  }
  /// Returns true if `containerIDPath` has been explicitly set.
  var hasContainerIDPath: Bool {return self._containerIDPath != nil}
  /// Clears the value of `containerIDPath`. Subsequent reads from it will return its default value.
  mutating func clearContainerIDPath() {self._containerIDPath = nil}

  var argsList: [TSCK_RemoveIdOperationArgs] = []

  var children: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _containerIDPath: TSP_UUIDPath? = nil
}

struct TSD_ContainerRemoveDrawablesCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_ContainerRemoveChildrenCommandArchive {
    get {return _super ?? TSD_ContainerRemoveChildrenCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_ContainerRemoveChildrenCommandArchive? = nil
}

struct TSD_ContainerInsertChildrenCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var containerIDPath: TSP_UUIDPath {
    get {return _storage._containerIDPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._containerIDPath = newValue}
  }
  /// Returns true if `containerIDPath` has been explicitly set.
  var hasContainerIDPath: Bool {return _storage._containerIDPath != nil}
  /// Clears the value of `containerIDPath`. Subsequent reads from it will return its default value.
  mutating func clearContainerIDPath() {_uniqueStorage()._containerIDPath = nil}

  var children: [TSP_Reference] {
    get {return _storage._children}
    set {_uniqueStorage()._children = newValue}
  }

  var argsList: [TSCK_AddIdOperationArgs] {
    get {return _storage._argsList}
    set {_uniqueStorage()._argsList = newValue}
  }

  var customFormatKeys: [TSP_UUID] {
    get {return _storage._customFormatKeys}
    set {_uniqueStorage()._customFormatKeys = newValue}
  }

  var undoObject: TSP_Reference {
    get {return _storage._undoObject ?? TSP_Reference()}
    set {_uniqueStorage()._undoObject = newValue}
  }
  /// Returns true if `undoObject` has been explicitly set.
  var hasUndoObject: Bool {return _storage._undoObject != nil}
  /// Clears the value of `undoObject`. Subsequent reads from it will return its default value.
  mutating func clearUndoObject() {_uniqueStorage()._undoObject = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_ContainerInsertDrawablesCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_ContainerInsertChildrenCommandArchive {
    get {return _super ?? TSD_ContainerInsertChildrenCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var drawables: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_ContainerInsertChildrenCommandArchive? = nil
}

struct TSD_ContainerReorderChildrenCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var containerIDPath: TSP_UUIDPath {
    get {return _containerIDPath ?? TSP_UUIDPath()}
    set {_containerIDPath = newValue}
  }
  /// Returns true if `containerIDPath` has been explicitly set.
  var hasContainerIDPath: Bool {return self._containerIDPath != nil}
  /// Clears the value of `containerIDPath`. Subsequent reads from it will return its default value.
  mutating func clearContainerIDPath() {self._containerIDPath = nil}

  var argsList: [TSCK_RearrangeIdOperationArgs] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _containerIDPath: TSP_UUIDPath? = nil
}

struct TSD_GroupUngroupInformativeCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var removedInfos: [TSP_Reference] = []

  var insertedInfos: [TSP_Reference] = []

  var commandType: TSD_GroupUngroupInformativeCommandArchive.CommandType {
    get {return _commandType ?? .group}
    set {_commandType = newValue}
  }
  /// Returns true if `commandType` has been explicitly set.
  var hasCommandType: Bool {return self._commandType != nil}
  /// Clears the value of `commandType`. Subsequent reads from it will return its default value.
  mutating func clearCommandType() {self._commandType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum CommandType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case group = 0
    case ungroup = 1

    init() {
      self = .group
    }

  }

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _commandType: TSD_GroupUngroupInformativeCommandArchive.CommandType? = nil
}

struct TSD_InfoCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var infoIDPath: TSP_UUIDPath {
    get {return _infoIDPath ?? TSP_UUIDPath()}
    set {_infoIDPath = newValue}
  }
  /// Returns true if `infoIDPath` has been explicitly set.
  var hasInfoIDPath: Bool {return self._infoIDPath != nil}
  /// Clears the value of `infoIDPath`. Subsequent reads from it will return its default value.
  mutating func clearInfoIDPath() {self._infoIDPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _infoIDPath: TSP_UUIDPath? = nil
}

struct TSD_ConnectionLineConnectCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _storage._super ?? TSD_InfoCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var connectedFromID: TSP_UUID {
    get {return _storage._connectedFromID ?? TSP_UUID()}
    set {_uniqueStorage()._connectedFromID = newValue}
  }
  /// Returns true if `connectedFromID` has been explicitly set.
  var hasConnectedFromID: Bool {return _storage._connectedFromID != nil}
  /// Clears the value of `connectedFromID`. Subsequent reads from it will return its default value.
  mutating func clearConnectedFromID() {_uniqueStorage()._connectedFromID = nil}

  var connectedToID: TSP_UUID {
    get {return _storage._connectedToID ?? TSP_UUID()}
    set {_uniqueStorage()._connectedToID = newValue}
  }
  /// Returns true if `connectedToID` has been explicitly set.
  var hasConnectedToID: Bool {return _storage._connectedToID != nil}
  /// Clears the value of `connectedToID`. Subsequent reads from it will return its default value.
  mutating func clearConnectedToID() {_uniqueStorage()._connectedToID = nil}

  var oldConnectedToID: TSP_UUID {
    get {return _storage._oldConnectedToID ?? TSP_UUID()}
    set {_uniqueStorage()._oldConnectedToID = newValue}
  }
  /// Returns true if `oldConnectedToID` has been explicitly set.
  var hasOldConnectedToID: Bool {return _storage._oldConnectedToID != nil}
  /// Clears the value of `oldConnectedToID`. Subsequent reads from it will return its default value.
  mutating func clearOldConnectedToID() {_uniqueStorage()._oldConnectedToID = nil}

  var oldConnectedFromID: TSP_UUID {
    get {return _storage._oldConnectedFromID ?? TSP_UUID()}
    set {_uniqueStorage()._oldConnectedFromID = newValue}
  }
  /// Returns true if `oldConnectedFromID` has been explicitly set.
  var hasOldConnectedFromID: Bool {return _storage._oldConnectedFromID != nil}
  /// Clears the value of `oldConnectedFromID`. Subsequent reads from it will return its default value.
  mutating func clearOldConnectedFromID() {_uniqueStorage()._oldConnectedFromID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_InfoGeometryCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _storage._super ?? TSD_InfoCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var newGeometry: TSD_GeometryArchive {
    get {return _storage._newGeometry ?? TSD_GeometryArchive()}
    set {_uniqueStorage()._newGeometry = newValue}
  }
  /// Returns true if `newGeometry` has been explicitly set.
  var hasNewGeometry: Bool {return _storage._newGeometry != nil}
  /// Clears the value of `newGeometry`. Subsequent reads from it will return its default value.
  mutating func clearNewGeometry() {_uniqueStorage()._newGeometry = nil}

  var oldGeometry: TSD_GeometryArchive {
    get {return _storage._oldGeometry ?? TSD_GeometryArchive()}
    set {_uniqueStorage()._oldGeometry = newValue}
  }
  /// Returns true if `oldGeometry` has been explicitly set.
  var hasOldGeometry: Bool {return _storage._oldGeometry != nil}
  /// Clears the value of `oldGeometry`. Subsequent reads from it will return its default value.
  mutating func clearOldGeometry() {_uniqueStorage()._oldGeometry = nil}

  var matchObjectPlaceholderGeometry: Bool {
    get {return _storage._matchObjectPlaceholderGeometry ?? false}
    set {_uniqueStorage()._matchObjectPlaceholderGeometry = newValue}
  }
  /// Returns true if `matchObjectPlaceholderGeometry` has been explicitly set.
  var hasMatchObjectPlaceholderGeometry: Bool {return _storage._matchObjectPlaceholderGeometry != nil}
  /// Clears the value of `matchObjectPlaceholderGeometry`. Subsequent reads from it will return its default value.
  mutating func clearMatchObjectPlaceholderGeometry() {_uniqueStorage()._matchObjectPlaceholderGeometry = nil}

  var oldMatchObjectPlaceholderGeometry: Bool {
    get {return _storage._oldMatchObjectPlaceholderGeometry ?? false}
    set {_uniqueStorage()._oldMatchObjectPlaceholderGeometry = newValue}
  }
  /// Returns true if `oldMatchObjectPlaceholderGeometry` has been explicitly set.
  var hasOldMatchObjectPlaceholderGeometry: Bool {return _storage._oldMatchObjectPlaceholderGeometry != nil}
  /// Clears the value of `oldMatchObjectPlaceholderGeometry`. Subsequent reads from it will return its default value.
  mutating func clearOldMatchObjectPlaceholderGeometry() {_uniqueStorage()._oldMatchObjectPlaceholderGeometry = nil}

  var shouldTriggerRtuAnimation: Bool {
    get {return _storage._shouldTriggerRtuAnimation ?? false}
    set {_uniqueStorage()._shouldTriggerRtuAnimation = newValue}
  }
  /// Returns true if `shouldTriggerRtuAnimation` has been explicitly set.
  var hasShouldTriggerRtuAnimation: Bool {return _storage._shouldTriggerRtuAnimation != nil}
  /// Clears the value of `shouldTriggerRtuAnimation`. Subsequent reads from it will return its default value.
  mutating func clearShouldTriggerRtuAnimation() {_uniqueStorage()._shouldTriggerRtuAnimation = nil}

  var initiatedOnWeb: Bool {
    get {return _storage._initiatedOnWeb ?? false}
    set {_uniqueStorage()._initiatedOnWeb = newValue}
  }
  /// Returns true if `initiatedOnWeb` has been explicitly set.
  var hasInitiatedOnWeb: Bool {return _storage._initiatedOnWeb != nil}
  /// Clears the value of `initiatedOnWeb`. Subsequent reads from it will return its default value.
  mutating func clearInitiatedOnWeb() {_uniqueStorage()._initiatedOnWeb = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_DrawablePathSourceCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _super ?? TSD_InfoCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var oldPathSource: TSD_PathSourceArchive {
    get {return _oldPathSource ?? TSD_PathSourceArchive()}
    set {_oldPathSource = newValue}
  }
  /// Returns true if `oldPathSource` has been explicitly set.
  var hasOldPathSource: Bool {return self._oldPathSource != nil}
  /// Clears the value of `oldPathSource`. Subsequent reads from it will return its default value.
  mutating func clearOldPathSource() {self._oldPathSource = nil}

  var newPathSource: TSD_PathSourceArchive {
    get {return _newPathSource ?? TSD_PathSourceArchive()}
    set {_newPathSource = newValue}
  }
  /// Returns true if `newPathSource` has been explicitly set.
  var hasNewPathSource: Bool {return self._newPathSource != nil}
  /// Clears the value of `newPathSource`. Subsequent reads from it will return its default value.
  mutating func clearNewPathSource() {self._newPathSource = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_InfoCommandArchive? = nil
  fileprivate var _oldPathSource: TSD_PathSourceArchive? = nil
  fileprivate var _newPathSource: TSD_PathSourceArchive? = nil
}

struct TSD_InstantAlphaCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _super ?? TSD_InfoCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var oldpath: TSP_Path {
    get {return _oldpath ?? TSP_Path()}
    set {_oldpath = newValue}
  }
  /// Returns true if `oldpath` has been explicitly set.
  var hasOldpath: Bool {return self._oldpath != nil}
  /// Clears the value of `oldpath`. Subsequent reads from it will return its default value.
  mutating func clearOldpath() {self._oldpath = nil}

  var newpath: TSP_Path {
    get {return _newpath ?? TSP_Path()}
    set {_newpath = newValue}
  }
  /// Returns true if `newpath` has been explicitly set.
  var hasNewpath: Bool {return self._newpath != nil}
  /// Clears the value of `newpath`. Subsequent reads from it will return its default value.
  mutating func clearNewpath() {self._newpath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_InfoCommandArchive? = nil
  fileprivate var _oldpath: TSP_Path? = nil
  fileprivate var _newpath: TSP_Path? = nil
}

struct TSD_DrawableApplyThemeCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_ApplyThemeChildCommandArchive {
    get {return _storage._super ?? TSS_ApplyThemeChildCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var info: TSP_Reference {
    get {return _storage._info ?? TSP_Reference()}
    set {_uniqueStorage()._info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return _storage._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {_uniqueStorage()._info = nil}

  var style: TSP_Reference {
    get {return _storage._style ?? TSP_Reference()}
    set {_uniqueStorage()._style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  var hasStyle: Bool {return _storage._style != nil}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  mutating func clearStyle() {_uniqueStorage()._style = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_AbstractStyleCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _super ?? TSD_InfoCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_InfoCommandArchive? = nil
}

struct TSD_StyledInfoSetStyleCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_AbstractStyleCommandArchive {
    get {return _storage._super ?? TSD_AbstractStyleCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var newStyle: TSP_Reference {
    get {return _storage._newStyle ?? TSP_Reference()}
    set {_uniqueStorage()._newStyle = newValue}
  }
  /// Returns true if `newStyle` has been explicitly set.
  var hasNewStyle: Bool {return _storage._newStyle != nil}
  /// Clears the value of `newStyle`. Subsequent reads from it will return its default value.
  mutating func clearNewStyle() {_uniqueStorage()._newStyle = nil}

  var rollbackStyle: TSP_Reference {
    get {return _storage._rollbackStyle ?? TSP_Reference()}
    set {_uniqueStorage()._rollbackStyle = newValue}
  }
  /// Returns true if `rollbackStyle` has been explicitly set.
  var hasRollbackStyle: Bool {return _storage._rollbackStyle != nil}
  /// Clears the value of `rollbackStyle`. Subsequent reads from it will return its default value.
  mutating func clearRollbackStyle() {_uniqueStorage()._rollbackStyle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_BaseApplyPresetCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_AbstractStyleCommandArchive {
    get {return _storage._super ?? TSD_AbstractStyleCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var presetStyle: TSP_Reference {
    get {return _storage._presetStyle ?? TSP_Reference()}
    set {_uniqueStorage()._presetStyle = newValue}
  }
  /// Returns true if `presetStyle` has been explicitly set.
  var hasPresetStyle: Bool {return _storage._presetStyle != nil}
  /// Clears the value of `presetStyle`. Subsequent reads from it will return its default value.
  mutating func clearPresetStyle() {_uniqueStorage()._presetStyle = nil}

  var rollbackStyle: TSP_Reference {
    get {return _storage._rollbackStyle ?? TSP_Reference()}
    set {_uniqueStorage()._rollbackStyle = newValue}
  }
  /// Returns true if `rollbackStyle` has been explicitly set.
  var hasRollbackStyle: Bool {return _storage._rollbackStyle != nil}
  /// Clears the value of `rollbackStyle`. Subsequent reads from it will return its default value.
  mutating func clearRollbackStyle() {_uniqueStorage()._rollbackStyle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_ShapeApplyPresetCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_BaseApplyPresetCommandArchive {
    get {return _super ?? TSD_BaseApplyPresetCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_BaseApplyPresetCommandArchive? = nil
}

struct TSD_MediaApplyPresetCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_BaseApplyPresetCommandArchive {
    get {return _super ?? TSD_BaseApplyPresetCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_BaseApplyPresetCommandArchive? = nil
}

struct TSD_ShapeStyleSetValueCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_BaseStyleSetValueCommandArchive {
    get {return _storage._super ?? TSD_BaseStyleSetValueCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var change: TSDSOS_BaseShapeStylePropertyChangeSetArchive {
    get {return _storage._change ?? TSDSOS_BaseShapeStylePropertyChangeSetArchive()}
    set {_uniqueStorage()._change = newValue}
  }
  /// Returns true if `change` has been explicitly set.
  var hasChange: Bool {return _storage._change != nil}
  /// Clears the value of `change`. Subsequent reads from it will return its default value.
  mutating func clearChange() {_uniqueStorage()._change = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_BaseStyleSetValueCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_AbstractStyleCommandArchive {
    get {return _super ?? TSD_AbstractStyleCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var oldStyle: TSP_Reference {
    get {return _oldStyle ?? TSP_Reference()}
    set {_oldStyle = newValue}
  }
  /// Returns true if `oldStyle` has been explicitly set.
  var hasOldStyle: Bool {return self._oldStyle != nil}
  /// Clears the value of `oldStyle`. Subsequent reads from it will return its default value.
  mutating func clearOldStyle() {self._oldStyle = nil}

  var isBorderChange: Bool {
    get {return _isBorderChange ?? false}
    set {_isBorderChange = newValue}
  }
  /// Returns true if `isBorderChange` has been explicitly set.
  var hasIsBorderChange: Bool {return self._isBorderChange != nil}
  /// Clears the value of `isBorderChange`. Subsequent reads from it will return its default value.
  mutating func clearIsBorderChange() {self._isBorderChange = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_AbstractStyleCommandArchive? = nil
  fileprivate var _oldStyle: TSP_Reference? = nil
  fileprivate var _isBorderChange: Bool? = nil
}

struct TSD_MovieSetValueCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _storage._super ?? TSD_InfoCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var property: Int32 {
    get {return _storage._property ?? 0}
    set {_uniqueStorage()._property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return _storage._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {_uniqueStorage()._property = nil}

  var value: TSD_MovieSetValueCommandArchive.PropertyValue {
    get {return _storage._value ?? TSD_MovieSetValueCommandArchive.PropertyValue()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {_uniqueStorage()._value = nil}

  var oldValue: TSD_MovieSetValueCommandArchive.PropertyValue {
    get {return _storage._oldValue ?? TSD_MovieSetValueCommandArchive.PropertyValue()}
    set {_uniqueStorage()._oldValue = newValue}
  }
  /// Returns true if `oldValue` has been explicitly set.
  var hasOldValue: Bool {return _storage._oldValue != nil}
  /// Clears the value of `oldValue`. Subsequent reads from it will return its default value.
  mutating func clearOldValue() {_uniqueStorage()._oldValue = nil}

  var importedauxiliarymedia: TSP_DataReference {
    get {return _storage._importedauxiliarymedia ?? TSP_DataReference()}
    set {_uniqueStorage()._importedauxiliarymedia = newValue}
  }
  /// Returns true if `importedauxiliarymedia` has been explicitly set.
  var hasImportedauxiliarymedia: Bool {return _storage._importedauxiliarymedia != nil}
  /// Clears the value of `importedauxiliarymedia`. Subsequent reads from it will return its default value.
  mutating func clearImportedauxiliarymedia() {_uniqueStorage()._importedauxiliarymedia = nil}

  var oldimportedauxiliarymedia: TSP_DataReference {
    get {return _storage._oldimportedauxiliarymedia ?? TSP_DataReference()}
    set {_uniqueStorage()._oldimportedauxiliarymedia = newValue}
  }
  /// Returns true if `oldimportedauxiliarymedia` has been explicitly set.
  var hasOldimportedauxiliarymedia: Bool {return _storage._oldimportedauxiliarymedia != nil}
  /// Clears the value of `oldimportedauxiliarymedia`. Subsequent reads from it will return its default value.
  mutating func clearOldimportedauxiliarymedia() {_uniqueStorage()._oldimportedauxiliarymedia = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum LoopOption: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case none = 0
    case `repeat` = 1
    case backAndForth = 2

    init() {
      self = .none
    }

  }

  struct PropertyValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var starttime: Double {
      get {return _starttime ?? 0}
      set {_starttime = newValue}
    }
    /// Returns true if `starttime` has been explicitly set.
    var hasStarttime: Bool {return self._starttime != nil}
    /// Clears the value of `starttime`. Subsequent reads from it will return its default value.
    mutating func clearStarttime() {self._starttime = nil}

    var endtime: Double {
      get {return _endtime ?? 0}
      set {_endtime = newValue}
    }
    /// Returns true if `endtime` has been explicitly set.
    var hasEndtime: Bool {return self._endtime != nil}
    /// Clears the value of `endtime`. Subsequent reads from it will return its default value.
    mutating func clearEndtime() {self._endtime = nil}

    var postertime: Double {
      get {return _postertime ?? 0}
      set {_postertime = newValue}
    }
    /// Returns true if `postertime` has been explicitly set.
    var hasPostertime: Bool {return self._postertime != nil}
    /// Clears the value of `postertime`. Subsequent reads from it will return its default value.
    mutating func clearPostertime() {self._postertime = nil}

    var posterimagedata: TSP_DataReference {
      get {return _posterimagedata ?? TSP_DataReference()}
      set {_posterimagedata = newValue}
    }
    /// Returns true if `posterimagedata` has been explicitly set.
    var hasPosterimagedata: Bool {return self._posterimagedata != nil}
    /// Clears the value of `posterimagedata`. Subsequent reads from it will return its default value.
    mutating func clearPosterimagedata() {self._posterimagedata = nil}

    var autoplay: Bool {
      get {return _autoplay ?? false}
      set {_autoplay = newValue}
    }
    /// Returns true if `autoplay` has been explicitly set.
    var hasAutoplay: Bool {return self._autoplay != nil}
    /// Clears the value of `autoplay`. Subsequent reads from it will return its default value.
    mutating func clearAutoplay() {self._autoplay = nil}

    var loopOption: TSD_MovieSetValueCommandArchive.LoopOption {
      get {return _loopOption ?? .none}
      set {_loopOption = newValue}
    }
    /// Returns true if `loopOption` has been explicitly set.
    var hasLoopOption: Bool {return self._loopOption != nil}
    /// Clears the value of `loopOption`. Subsequent reads from it will return its default value.
    mutating func clearLoopOption() {self._loopOption = nil}

    var volume: Float {
      get {return _volume ?? 0}
      set {_volume = newValue}
    }
    /// Returns true if `volume` has been explicitly set.
    var hasVolume: Bool {return self._volume != nil}
    /// Clears the value of `volume`. Subsequent reads from it will return its default value.
    mutating func clearVolume() {self._volume = nil}

    var media: TSP_DataReference {
      get {return _media ?? TSP_DataReference()}
      set {_media = newValue}
    }
    /// Returns true if `media` has been explicitly set.
    var hasMedia: Bool {return self._media != nil}
    /// Clears the value of `media`. Subsequent reads from it will return its default value.
    mutating func clearMedia() {self._media = nil}

    var playsAcrossSlides: Bool {
      get {return _playsAcrossSlides ?? false}
      set {_playsAcrossSlides = newValue}
    }
    /// Returns true if `playsAcrossSlides` has been explicitly set.
    var hasPlaysAcrossSlides: Bool {return self._playsAcrossSlides != nil}
    /// Clears the value of `playsAcrossSlides`. Subsequent reads from it will return its default value.
    mutating func clearPlaysAcrossSlides() {self._playsAcrossSlides = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _starttime: Double? = nil
    fileprivate var _endtime: Double? = nil
    fileprivate var _postertime: Double? = nil
    fileprivate var _posterimagedata: TSP_DataReference? = nil
    fileprivate var _autoplay: Bool? = nil
    fileprivate var _loopOption: TSD_MovieSetValueCommandArchive.LoopOption? = nil
    fileprivate var _volume: Float? = nil
    fileprivate var _media: TSP_DataReference? = nil
    fileprivate var _playsAcrossSlides: Bool? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_MediaStyleSetValueCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_BaseStyleSetValueCommandArchive {
    get {return _storage._super ?? TSD_BaseStyleSetValueCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var change: TSDSOS_MediaStylePropertyChangeSetArchive {
    get {return _storage._change ?? TSDSOS_MediaStylePropertyChangeSetArchive()}
    set {_uniqueStorage()._change = newValue}
  }
  /// Returns true if `change` has been explicitly set.
  var hasChange: Bool {return _storage._change != nil}
  /// Clears the value of `change`. Subsequent reads from it will return its default value.
  mutating func clearChange() {_uniqueStorage()._change = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_ImageMediaCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _storage._super ?? TSD_InfoCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var newImageData: TSP_DataReference {
    get {return _storage._newImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._newImageData = newValue}
  }
  /// Returns true if `newImageData` has been explicitly set.
  var hasNewImageData: Bool {return _storage._newImageData != nil}
  /// Clears the value of `newImageData`. Subsequent reads from it will return its default value.
  mutating func clearNewImageData() {_uniqueStorage()._newImageData = nil}

  var oldImageData: TSP_DataReference {
    get {return _storage._oldImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._oldImageData = newValue}
  }
  /// Returns true if `oldImageData` has been explicitly set.
  var hasOldImageData: Bool {return _storage._oldImageData != nil}
  /// Clears the value of `oldImageData`. Subsequent reads from it will return its default value.
  mutating func clearOldImageData() {_uniqueStorage()._oldImageData = nil}

  var oldOriginalImageData: TSP_DataReference {
    get {return _storage._oldOriginalImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._oldOriginalImageData = newValue}
  }
  /// Returns true if `oldOriginalImageData` has been explicitly set.
  var hasOldOriginalImageData: Bool {return _storage._oldOriginalImageData != nil}
  /// Clears the value of `oldOriginalImageData`. Subsequent reads from it will return its default value.
  mutating func clearOldOriginalImageData() {_uniqueStorage()._oldOriginalImageData = nil}

  var oldNaturalSize: TSP_Size {
    get {return _storage._oldNaturalSize ?? TSP_Size()}
    set {_uniqueStorage()._oldNaturalSize = newValue}
  }
  /// Returns true if `oldNaturalSize` has been explicitly set.
  var hasOldNaturalSize: Bool {return _storage._oldNaturalSize != nil}
  /// Clears the value of `oldNaturalSize`. Subsequent reads from it will return its default value.
  mutating func clearOldNaturalSize() {_uniqueStorage()._oldNaturalSize = nil}

  var newOriginalImageData: TSP_DataReference {
    get {return _storage._newOriginalImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._newOriginalImageData = newValue}
  }
  /// Returns true if `newOriginalImageData` has been explicitly set.
  var hasNewOriginalImageData: Bool {return _storage._newOriginalImageData != nil}
  /// Clears the value of `newOriginalImageData`. Subsequent reads from it will return its default value.
  mutating func clearNewOriginalImageData() {_uniqueStorage()._newOriginalImageData = nil}

  var oldImageAdjustments: TSD_ImageAdjustmentsArchive {
    get {return _storage._oldImageAdjustments ?? TSD_ImageAdjustmentsArchive()}
    set {_uniqueStorage()._oldImageAdjustments = newValue}
  }
  /// Returns true if `oldImageAdjustments` has been explicitly set.
  var hasOldImageAdjustments: Bool {return _storage._oldImageAdjustments != nil}
  /// Clears the value of `oldImageAdjustments`. Subsequent reads from it will return its default value.
  mutating func clearOldImageAdjustments() {_uniqueStorage()._oldImageAdjustments = nil}

  var oldAdjustedImageData: TSP_DataReference {
    get {return _storage._oldAdjustedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._oldAdjustedImageData = newValue}
  }
  /// Returns true if `oldAdjustedImageData` has been explicitly set.
  var hasOldAdjustedImageData: Bool {return _storage._oldAdjustedImageData != nil}
  /// Clears the value of `oldAdjustedImageData`. Subsequent reads from it will return its default value.
  mutating func clearOldAdjustedImageData() {_uniqueStorage()._oldAdjustedImageData = nil}

  var oldEnhancedImageData: TSP_DataReference {
    get {return _storage._oldEnhancedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._oldEnhancedImageData = newValue}
  }
  /// Returns true if `oldEnhancedImageData` has been explicitly set.
  var hasOldEnhancedImageData: Bool {return _storage._oldEnhancedImageData != nil}
  /// Clears the value of `oldEnhancedImageData`. Subsequent reads from it will return its default value.
  mutating func clearOldEnhancedImageData() {_uniqueStorage()._oldEnhancedImageData = nil}

  var imageAdjustments: TSD_ImageAdjustmentsArchive {
    get {return _storage._imageAdjustments ?? TSD_ImageAdjustmentsArchive()}
    set {_uniqueStorage()._imageAdjustments = newValue}
  }
  /// Returns true if `imageAdjustments` has been explicitly set.
  var hasImageAdjustments: Bool {return _storage._imageAdjustments != nil}
  /// Clears the value of `imageAdjustments`. Subsequent reads from it will return its default value.
  mutating func clearImageAdjustments() {_uniqueStorage()._imageAdjustments = nil}

  var adjustedImageData: TSP_DataReference {
    get {return _storage._adjustedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._adjustedImageData = newValue}
  }
  /// Returns true if `adjustedImageData` has been explicitly set.
  var hasAdjustedImageData: Bool {return _storage._adjustedImageData != nil}
  /// Clears the value of `adjustedImageData`. Subsequent reads from it will return its default value.
  mutating func clearAdjustedImageData() {_uniqueStorage()._adjustedImageData = nil}

  var enhancedImageData: TSP_DataReference {
    get {return _storage._enhancedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._enhancedImageData = newValue}
  }
  /// Returns true if `enhancedImageData` has been explicitly set.
  var hasEnhancedImageData: Bool {return _storage._enhancedImageData != nil}
  /// Clears the value of `enhancedImageData`. Subsequent reads from it will return its default value.
  mutating func clearEnhancedImageData() {_uniqueStorage()._enhancedImageData = nil}

  var newThumbnailImageData: TSP_DataReference {
    get {return _storage._newThumbnailImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._newThumbnailImageData = newValue}
  }
  /// Returns true if `newThumbnailImageData` has been explicitly set.
  var hasNewThumbnailImageData: Bool {return _storage._newThumbnailImageData != nil}
  /// Clears the value of `newThumbnailImageData`. Subsequent reads from it will return its default value.
  mutating func clearNewThumbnailImageData() {_uniqueStorage()._newThumbnailImageData = nil}

  var oldThumbnailImageData: TSP_DataReference {
    get {return _storage._oldThumbnailImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._oldThumbnailImageData = newValue}
  }
  /// Returns true if `oldThumbnailImageData` has been explicitly set.
  var hasOldThumbnailImageData: Bool {return _storage._oldThumbnailImageData != nil}
  /// Clears the value of `oldThumbnailImageData`. Subsequent reads from it will return its default value.
  mutating func clearOldThumbnailImageData() {_uniqueStorage()._oldThumbnailImageData = nil}

  var thumbnailAdjustedImageData: TSP_DataReference {
    get {return _storage._thumbnailAdjustedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._thumbnailAdjustedImageData = newValue}
  }
  /// Returns true if `thumbnailAdjustedImageData` has been explicitly set.
  var hasThumbnailAdjustedImageData: Bool {return _storage._thumbnailAdjustedImageData != nil}
  /// Clears the value of `thumbnailAdjustedImageData`. Subsequent reads from it will return its default value.
  mutating func clearThumbnailAdjustedImageData() {_uniqueStorage()._thumbnailAdjustedImageData = nil}

  var oldThumbnailAdjustedImageData: TSP_DataReference {
    get {return _storage._oldThumbnailAdjustedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._oldThumbnailAdjustedImageData = newValue}
  }
  /// Returns true if `oldThumbnailAdjustedImageData` has been explicitly set.
  var hasOldThumbnailAdjustedImageData: Bool {return _storage._oldThumbnailAdjustedImageData != nil}
  /// Clears the value of `oldThumbnailAdjustedImageData`. Subsequent reads from it will return its default value.
  mutating func clearOldThumbnailAdjustedImageData() {_uniqueStorage()._oldThumbnailAdjustedImageData = nil}

  var databaseNewImageData: TSP_Reference {
    get {return _storage._databaseNewImageData ?? TSP_Reference()}
    set {_uniqueStorage()._databaseNewImageData = newValue}
  }
  /// Returns true if `databaseNewImageData` has been explicitly set.
  var hasDatabaseNewImageData: Bool {return _storage._databaseNewImageData != nil}
  /// Clears the value of `databaseNewImageData`. Subsequent reads from it will return its default value.
  mutating func clearDatabaseNewImageData() {_uniqueStorage()._databaseNewImageData = nil}

  var databaseOldImageData: TSP_Reference {
    get {return _storage._databaseOldImageData ?? TSP_Reference()}
    set {_uniqueStorage()._databaseOldImageData = newValue}
  }
  /// Returns true if `databaseOldImageData` has been explicitly set.
  var hasDatabaseOldImageData: Bool {return _storage._databaseOldImageData != nil}
  /// Clears the value of `databaseOldImageData`. Subsequent reads from it will return its default value.
  mutating func clearDatabaseOldImageData() {_uniqueStorage()._databaseOldImageData = nil}

  var databaseOldOriginalImageData: TSP_Reference {
    get {return _storage._databaseOldOriginalImageData ?? TSP_Reference()}
    set {_uniqueStorage()._databaseOldOriginalImageData = newValue}
  }
  /// Returns true if `databaseOldOriginalImageData` has been explicitly set.
  var hasDatabaseOldOriginalImageData: Bool {return _storage._databaseOldOriginalImageData != nil}
  /// Clears the value of `databaseOldOriginalImageData`. Subsequent reads from it will return its default value.
  mutating func clearDatabaseOldOriginalImageData() {_uniqueStorage()._databaseOldOriginalImageData = nil}

  var databaseNewOriginalImageData: TSP_Reference {
    get {return _storage._databaseNewOriginalImageData ?? TSP_Reference()}
    set {_uniqueStorage()._databaseNewOriginalImageData = newValue}
  }
  /// Returns true if `databaseNewOriginalImageData` has been explicitly set.
  var hasDatabaseNewOriginalImageData: Bool {return _storage._databaseNewOriginalImageData != nil}
  /// Clears the value of `databaseNewOriginalImageData`. Subsequent reads from it will return its default value.
  mutating func clearDatabaseNewOriginalImageData() {_uniqueStorage()._databaseNewOriginalImageData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_MediaOriginalSizeCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _storage._super ?? TSD_InfoCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var newOriginalSize: TSP_Size {
    get {return _storage._newOriginalSize ?? TSP_Size()}
    set {_uniqueStorage()._newOriginalSize = newValue}
  }
  /// Returns true if `newOriginalSize` has been explicitly set.
  var hasNewOriginalSize: Bool {return _storage._newOriginalSize != nil}
  /// Clears the value of `newOriginalSize`. Subsequent reads from it will return its default value.
  mutating func clearNewOriginalSize() {_uniqueStorage()._newOriginalSize = nil}

  var oldOriginalSize: TSP_Size {
    get {return _storage._oldOriginalSize ?? TSP_Size()}
    set {_uniqueStorage()._oldOriginalSize = newValue}
  }
  /// Returns true if `oldOriginalSize` has been explicitly set.
  var hasOldOriginalSize: Bool {return _storage._oldOriginalSize != nil}
  /// Clears the value of `oldOriginalSize`. Subsequent reads from it will return its default value.
  mutating func clearOldOriginalSize() {_uniqueStorage()._oldOriginalSize = nil}

  var propertyName: String {
    get {return _storage._propertyName ?? String()}
    set {_uniqueStorage()._propertyName = newValue}
  }
  /// Returns true if `propertyName` has been explicitly set.
  var hasPropertyName: Bool {return _storage._propertyName != nil}
  /// Clears the value of `propertyName`. Subsequent reads from it will return its default value.
  mutating func clearPropertyName() {_uniqueStorage()._propertyName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_MediaInfoGeometryCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoGeometryCommandArchive {
    get {return _super ?? TSD_InfoGeometryCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var newOriginalSize: TSP_Size {
    get {return _newOriginalSize ?? TSP_Size()}
    set {_newOriginalSize = newValue}
  }
  /// Returns true if `newOriginalSize` has been explicitly set.
  var hasNewOriginalSize: Bool {return self._newOriginalSize != nil}
  /// Clears the value of `newOriginalSize`. Subsequent reads from it will return its default value.
  mutating func clearNewOriginalSize() {self._newOriginalSize = nil}

  var oldOriginalSize: TSP_Size {
    get {return _oldOriginalSize ?? TSP_Size()}
    set {_oldOriginalSize = newValue}
  }
  /// Returns true if `oldOriginalSize` has been explicitly set.
  var hasOldOriginalSize: Bool {return self._oldOriginalSize != nil}
  /// Clears the value of `oldOriginalSize`. Subsequent reads from it will return its default value.
  mutating func clearOldOriginalSize() {self._oldOriginalSize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_InfoGeometryCommandArchive? = nil
  fileprivate var _newOriginalSize: TSP_Size? = nil
  fileprivate var _oldOriginalSize: TSP_Size? = nil
}

struct TSD_ImageNaturalSizeCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _super ?? TSD_InfoCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var newNaturalSize: TSP_Size {
    get {return _newNaturalSize ?? TSP_Size()}
    set {_newNaturalSize = newValue}
  }
  /// Returns true if `newNaturalSize` has been explicitly set.
  var hasNewNaturalSize: Bool {return self._newNaturalSize != nil}
  /// Clears the value of `newNaturalSize`. Subsequent reads from it will return its default value.
  mutating func clearNewNaturalSize() {self._newNaturalSize = nil}

  var oldNaturalSize: TSP_Size {
    get {return _oldNaturalSize ?? TSP_Size()}
    set {_oldNaturalSize = newValue}
  }
  /// Returns true if `oldNaturalSize` has been explicitly set.
  var hasOldNaturalSize: Bool {return self._oldNaturalSize != nil}
  /// Clears the value of `oldNaturalSize`. Subsequent reads from it will return its default value.
  mutating func clearOldNaturalSize() {self._oldNaturalSize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_InfoCommandArchive? = nil
  fileprivate var _newNaturalSize: TSP_Size? = nil
  fileprivate var _oldNaturalSize: TSP_Size? = nil
}

struct TSD_ImageMaskCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _storage._super ?? TSD_InfoCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var newMaskInfo: TSP_Reference {
    get {return _storage._newMaskInfo ?? TSP_Reference()}
    set {_uniqueStorage()._newMaskInfo = newValue}
  }
  /// Returns true if `newMaskInfo` has been explicitly set.
  var hasNewMaskInfo: Bool {return _storage._newMaskInfo != nil}
  /// Clears the value of `newMaskInfo`. Subsequent reads from it will return its default value.
  mutating func clearNewMaskInfo() {_uniqueStorage()._newMaskInfo = nil}

  var oldMaskInfo: TSP_Reference {
    get {return _storage._oldMaskInfo ?? TSP_Reference()}
    set {_uniqueStorage()._oldMaskInfo = newValue}
  }
  /// Returns true if `oldMaskInfo` has been explicitly set.
  var hasOldMaskInfo: Bool {return _storage._oldMaskInfo != nil}
  /// Clears the value of `oldMaskInfo`. Subsequent reads from it will return its default value.
  mutating func clearOldMaskInfo() {_uniqueStorage()._oldMaskInfo = nil}

  var backgroundRemoved: Bool {
    get {return _storage._backgroundRemoved ?? false}
    set {_uniqueStorage()._backgroundRemoved = newValue}
  }
  /// Returns true if `backgroundRemoved` has been explicitly set.
  var hasBackgroundRemoved: Bool {return _storage._backgroundRemoved != nil}
  /// Clears the value of `backgroundRemoved`. Subsequent reads from it will return its default value.
  mutating func clearBackgroundRemoved() {_uniqueStorage()._backgroundRemoved = nil}

  var oldBackgroundRemoved: Bool {
    get {return _storage._oldBackgroundRemoved ?? false}
    set {_uniqueStorage()._oldBackgroundRemoved = newValue}
  }
  /// Returns true if `oldBackgroundRemoved` has been explicitly set.
  var hasOldBackgroundRemoved: Bool {return _storage._oldBackgroundRemoved != nil}
  /// Clears the value of `oldBackgroundRemoved`. Subsequent reads from it will return its default value.
  mutating func clearOldBackgroundRemoved() {_uniqueStorage()._oldBackgroundRemoved = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_ImageAdjustmentsCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _storage._super ?? TSD_InfoCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var oldImageAdjustments: TSD_ImageAdjustmentsArchive {
    get {return _storage._oldImageAdjustments ?? TSD_ImageAdjustmentsArchive()}
    set {_uniqueStorage()._oldImageAdjustments = newValue}
  }
  /// Returns true if `oldImageAdjustments` has been explicitly set.
  var hasOldImageAdjustments: Bool {return _storage._oldImageAdjustments != nil}
  /// Clears the value of `oldImageAdjustments`. Subsequent reads from it will return its default value.
  mutating func clearOldImageAdjustments() {_uniqueStorage()._oldImageAdjustments = nil}

  var newImageAdjustments: TSD_ImageAdjustmentsArchive {
    get {return _storage._newImageAdjustments ?? TSD_ImageAdjustmentsArchive()}
    set {_uniqueStorage()._newImageAdjustments = newValue}
  }
  /// Returns true if `newImageAdjustments` has been explicitly set.
  var hasNewImageAdjustments: Bool {return _storage._newImageAdjustments != nil}
  /// Clears the value of `newImageAdjustments`. Subsequent reads from it will return its default value.
  mutating func clearNewImageAdjustments() {_uniqueStorage()._newImageAdjustments = nil}

  var adjustedImageData: TSP_DataReference {
    get {return _storage._adjustedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._adjustedImageData = newValue}
  }
  /// Returns true if `adjustedImageData` has been explicitly set.
  var hasAdjustedImageData: Bool {return _storage._adjustedImageData != nil}
  /// Clears the value of `adjustedImageData`. Subsequent reads from it will return its default value.
  mutating func clearAdjustedImageData() {_uniqueStorage()._adjustedImageData = nil}

  var replacedAdjustedImageData: TSP_DataReference {
    get {return _storage._replacedAdjustedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._replacedAdjustedImageData = newValue}
  }
  /// Returns true if `replacedAdjustedImageData` has been explicitly set.
  var hasReplacedAdjustedImageData: Bool {return _storage._replacedAdjustedImageData != nil}
  /// Clears the value of `replacedAdjustedImageData`. Subsequent reads from it will return its default value.
  mutating func clearReplacedAdjustedImageData() {_uniqueStorage()._replacedAdjustedImageData = nil}

  var enhancedImageData: TSP_DataReference {
    get {return _storage._enhancedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._enhancedImageData = newValue}
  }
  /// Returns true if `enhancedImageData` has been explicitly set.
  var hasEnhancedImageData: Bool {return _storage._enhancedImageData != nil}
  /// Clears the value of `enhancedImageData`. Subsequent reads from it will return its default value.
  mutating func clearEnhancedImageData() {_uniqueStorage()._enhancedImageData = nil}

  var replacedEnhancedImageData: TSP_DataReference {
    get {return _storage._replacedEnhancedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._replacedEnhancedImageData = newValue}
  }
  /// Returns true if `replacedEnhancedImageData` has been explicitly set.
  var hasReplacedEnhancedImageData: Bool {return _storage._replacedEnhancedImageData != nil}
  /// Clears the value of `replacedEnhancedImageData`. Subsequent reads from it will return its default value.
  mutating func clearReplacedEnhancedImageData() {_uniqueStorage()._replacedEnhancedImageData = nil}

  var thumbnailAdjustedImageData: TSP_DataReference {
    get {return _storage._thumbnailAdjustedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._thumbnailAdjustedImageData = newValue}
  }
  /// Returns true if `thumbnailAdjustedImageData` has been explicitly set.
  var hasThumbnailAdjustedImageData: Bool {return _storage._thumbnailAdjustedImageData != nil}
  /// Clears the value of `thumbnailAdjustedImageData`. Subsequent reads from it will return its default value.
  mutating func clearThumbnailAdjustedImageData() {_uniqueStorage()._thumbnailAdjustedImageData = nil}

  var replacedThumbnailAdjustedImageData: TSP_DataReference {
    get {return _storage._replacedThumbnailAdjustedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._replacedThumbnailAdjustedImageData = newValue}
  }
  /// Returns true if `replacedThumbnailAdjustedImageData` has been explicitly set.
  var hasReplacedThumbnailAdjustedImageData: Bool {return _storage._replacedThumbnailAdjustedImageData != nil}
  /// Clears the value of `replacedThumbnailAdjustedImageData`. Subsequent reads from it will return its default value.
  mutating func clearReplacedThumbnailAdjustedImageData() {_uniqueStorage()._replacedThumbnailAdjustedImageData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_MediaFlagsCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _storage._super ?? TSD_InfoCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var wasMediaReplaced: Bool {
    get {return _storage._wasMediaReplaced ?? false}
    set {_uniqueStorage()._wasMediaReplaced = newValue}
  }
  /// Returns true if `wasMediaReplaced` has been explicitly set.
  var hasWasMediaReplaced: Bool {return _storage._wasMediaReplaced != nil}
  /// Clears the value of `wasMediaReplaced`. Subsequent reads from it will return its default value.
  mutating func clearWasMediaReplaced() {_uniqueStorage()._wasMediaReplaced = nil}

  var isPlaceholder: Bool {
    get {return _storage._isPlaceholder ?? false}
    set {_uniqueStorage()._isPlaceholder = newValue}
  }
  /// Returns true if `isPlaceholder` has been explicitly set.
  var hasIsPlaceholder: Bool {return _storage._isPlaceholder != nil}
  /// Clears the value of `isPlaceholder`. Subsequent reads from it will return its default value.
  mutating func clearIsPlaceholder() {_uniqueStorage()._isPlaceholder = nil}

  var oldWasMediaReplaced: Bool {
    get {return _storage._oldWasMediaReplaced ?? false}
    set {_uniqueStorage()._oldWasMediaReplaced = newValue}
  }
  /// Returns true if `oldWasMediaReplaced` has been explicitly set.
  var hasOldWasMediaReplaced: Bool {return _storage._oldWasMediaReplaced != nil}
  /// Clears the value of `oldWasMediaReplaced`. Subsequent reads from it will return its default value.
  mutating func clearOldWasMediaReplaced() {_uniqueStorage()._oldWasMediaReplaced = nil}

  var oldIsPlaceholder: Bool {
    get {return _storage._oldIsPlaceholder ?? false}
    set {_uniqueStorage()._oldIsPlaceholder = newValue}
  }
  /// Returns true if `oldIsPlaceholder` has been explicitly set.
  var hasOldIsPlaceholder: Bool {return _storage._oldIsPlaceholder != nil}
  /// Clears the value of `oldIsPlaceholder`. Subsequent reads from it will return its default value.
  mutating func clearOldIsPlaceholder() {_uniqueStorage()._oldIsPlaceholder = nil}

  var propertyName: String {
    get {return _storage._propertyName ?? String()}
    set {_uniqueStorage()._propertyName = newValue}
  }
  /// Returns true if `propertyName` has been explicitly set.
  var hasPropertyName: Bool {return _storage._propertyName != nil}
  /// Clears the value of `propertyName`. Subsequent reads from it will return its default value.
  mutating func clearPropertyName() {_uniqueStorage()._propertyName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_DrawablesCommandGroupArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandGroupArchive {
    get {return _storage._super ?? TSK_CommandGroupArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var obsoleteSelection: TSD_CanvasSelectionArchive {
    get {return _storage._obsoleteSelection ?? TSD_CanvasSelectionArchive()}
    set {_uniqueStorage()._obsoleteSelection = newValue}
  }
  /// Returns true if `obsoleteSelection` has been explicitly set.
  var hasObsoleteSelection: Bool {return _storage._obsoleteSelection != nil}
  /// Clears the value of `obsoleteSelection`. Subsequent reads from it will return its default value.
  mutating func clearObsoleteSelection() {_uniqueStorage()._obsoleteSelection = nil}

  var modelforselection: TSP_Reference {
    get {return _storage._modelforselection ?? TSP_Reference()}
    set {_uniqueStorage()._modelforselection = newValue}
  }
  /// Returns true if `modelforselection` has been explicitly set.
  var hasModelforselection: Bool {return _storage._modelforselection != nil}
  /// Clears the value of `modelforselection`. Subsequent reads from it will return its default value.
  mutating func clearModelforselection() {_uniqueStorage()._modelforselection = nil}

  var type: TSD_DrawablesCommandGroupArchive.DrawablesCommandGroupType {
    get {return _storage._type ?? .constructive}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  var forDrag: Bool {
    get {return _storage._forDrag ?? false}
    set {_uniqueStorage()._forDrag = newValue}
  }
  /// Returns true if `forDrag` has been explicitly set.
  var hasForDrag: Bool {return _storage._forDrag != nil}
  /// Clears the value of `forDrag`. Subsequent reads from it will return its default value.
  mutating func clearForDrag() {_uniqueStorage()._forDrag = nil}

  var archivedselection: TSP_Reference {
    get {return _storage._archivedselection ?? TSP_Reference()}
    set {_uniqueStorage()._archivedselection = newValue}
  }
  /// Returns true if `archivedselection` has been explicitly set.
  var hasArchivedselection: Bool {return _storage._archivedselection != nil}
  /// Clears the value of `archivedselection`. Subsequent reads from it will return its default value.
  mutating func clearArchivedselection() {_uniqueStorage()._archivedselection = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum DrawablesCommandGroupType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case constructive = 1
    case destructive = 2
    case inPlace = 3

    init() {
      self = .constructive
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_ExteriorTextWrapCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _storage._super ?? TSD_InfoCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var oldExteriorTextWrap: TSD_ExteriorTextWrapArchive {
    get {return _storage._oldExteriorTextWrap ?? TSD_ExteriorTextWrapArchive()}
    set {_uniqueStorage()._oldExteriorTextWrap = newValue}
  }
  /// Returns true if `oldExteriorTextWrap` has been explicitly set.
  var hasOldExteriorTextWrap: Bool {return _storage._oldExteriorTextWrap != nil}
  /// Clears the value of `oldExteriorTextWrap`. Subsequent reads from it will return its default value.
  mutating func clearOldExteriorTextWrap() {_uniqueStorage()._oldExteriorTextWrap = nil}

  var type: UInt32 {
    get {return _storage._type ?? 0}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  var direction: UInt32 {
    get {return _storage._direction ?? 0}
    set {_uniqueStorage()._direction = newValue}
  }
  /// Returns true if `direction` has been explicitly set.
  var hasDirection: Bool {return _storage._direction != nil}
  /// Clears the value of `direction`. Subsequent reads from it will return its default value.
  mutating func clearDirection() {_uniqueStorage()._direction = nil}

  var fitType: UInt32 {
    get {return _storage._fitType ?? 0}
    set {_uniqueStorage()._fitType = newValue}
  }
  /// Returns true if `fitType` has been explicitly set.
  var hasFitType: Bool {return _storage._fitType != nil}
  /// Clears the value of `fitType`. Subsequent reads from it will return its default value.
  mutating func clearFitType() {_uniqueStorage()._fitType = nil}

  var margin: Float {
    get {return _storage._margin ?? 0}
    set {_uniqueStorage()._margin = newValue}
  }
  /// Returns true if `margin` has been explicitly set.
  var hasMargin: Bool {return _storage._margin != nil}
  /// Clears the value of `margin`. Subsequent reads from it will return its default value.
  mutating func clearMargin() {_uniqueStorage()._margin = nil}

  var alphaThreshold: Float {
    get {return _storage._alphaThreshold ?? 0}
    set {_uniqueStorage()._alphaThreshold = newValue}
  }
  /// Returns true if `alphaThreshold` has been explicitly set.
  var hasAlphaThreshold: Bool {return _storage._alphaThreshold != nil}
  /// Clears the value of `alphaThreshold`. Subsequent reads from it will return its default value.
  mutating func clearAlphaThreshold() {_uniqueStorage()._alphaThreshold = nil}

  var isHtmlWrap: Bool {
    get {return _storage._isHtmlWrap ?? false}
    set {_uniqueStorage()._isHtmlWrap = newValue}
  }
  /// Returns true if `isHtmlWrap` has been explicitly set.
  var hasIsHtmlWrap: Bool {return _storage._isHtmlWrap != nil}
  /// Clears the value of `isHtmlWrap`. Subsequent reads from it will return its default value.
  mutating func clearIsHtmlWrap() {_uniqueStorage()._isHtmlWrap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_DrawableHyperlinkCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _super ?? TSD_InfoCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var oldhyperlinkURL: String {
    get {return _oldhyperlinkURL ?? String()}
    set {_oldhyperlinkURL = newValue}
  }
  /// Returns true if `oldhyperlinkURL` has been explicitly set.
  var hasOldhyperlinkURL: Bool {return self._oldhyperlinkURL != nil}
  /// Clears the value of `oldhyperlinkURL`. Subsequent reads from it will return its default value.
  mutating func clearOldhyperlinkURL() {self._oldhyperlinkURL = nil}

  var newhyperlinkURL: String {
    get {return _newhyperlinkURL ?? String()}
    set {_newhyperlinkURL = newValue}
  }
  /// Returns true if `newhyperlinkURL` has been explicitly set.
  var hasNewhyperlinkURL: Bool {return self._newhyperlinkURL != nil}
  /// Clears the value of `newhyperlinkURL`. Subsequent reads from it will return its default value.
  mutating func clearNewhyperlinkURL() {self._newhyperlinkURL = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_InfoCommandArchive? = nil
  fileprivate var _oldhyperlinkURL: String? = nil
  fileprivate var _newhyperlinkURL: String? = nil
}

struct TSD_CommentInvalidatingCommandSelectionBehaviorArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandSelectionBehaviorArchive {
    get {return _super ?? TSK_CommandSelectionBehaviorArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var annotationDisplayingCommand: TSP_Reference {
    get {return _annotationDisplayingCommand ?? TSP_Reference()}
    set {_annotationDisplayingCommand = newValue}
  }
  /// Returns true if `annotationDisplayingCommand` has been explicitly set.
  var hasAnnotationDisplayingCommand: Bool {return self._annotationDisplayingCommand != nil}
  /// Clears the value of `annotationDisplayingCommand`. Subsequent reads from it will return its default value.
  mutating func clearAnnotationDisplayingCommand() {self._annotationDisplayingCommand = nil}

  var beginEditingOnUndo: Bool {
    get {return _beginEditingOnUndo ?? false}
    set {_beginEditingOnUndo = newValue}
  }
  /// Returns true if `beginEditingOnUndo` has been explicitly set.
  var hasBeginEditingOnUndo: Bool {return self._beginEditingOnUndo != nil}
  /// Clears the value of `beginEditingOnUndo`. Subsequent reads from it will return its default value.
  mutating func clearBeginEditingOnUndo() {self._beginEditingOnUndo = nil}

  var beginEditingOnRedo: Bool {
    get {return _beginEditingOnRedo ?? false}
    set {_beginEditingOnRedo = newValue}
  }
  /// Returns true if `beginEditingOnRedo` has been explicitly set.
  var hasBeginEditingOnRedo: Bool {return self._beginEditingOnRedo != nil}
  /// Clears the value of `beginEditingOnRedo`. Subsequent reads from it will return its default value.
  mutating func clearBeginEditingOnRedo() {self._beginEditingOnRedo = nil}

  var shouldInvalidateOnUndo: Bool {
    get {return _shouldInvalidateOnUndo ?? false}
    set {_shouldInvalidateOnUndo = newValue}
  }
  /// Returns true if `shouldInvalidateOnUndo` has been explicitly set.
  var hasShouldInvalidateOnUndo: Bool {return self._shouldInvalidateOnUndo != nil}
  /// Clears the value of `shouldInvalidateOnUndo`. Subsequent reads from it will return its default value.
  mutating func clearShouldInvalidateOnUndo() {self._shouldInvalidateOnUndo = nil}

  var shouldInvalidateOnRedo: Bool {
    get {return _shouldInvalidateOnRedo ?? false}
    set {_shouldInvalidateOnRedo = newValue}
  }
  /// Returns true if `shouldInvalidateOnRedo` has been explicitly set.
  var hasShouldInvalidateOnRedo: Bool {return self._shouldInvalidateOnRedo != nil}
  /// Clears the value of `shouldInvalidateOnRedo`. Subsequent reads from it will return its default value.
  mutating func clearShouldInvalidateOnRedo() {self._shouldInvalidateOnRedo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandSelectionBehaviorArchive? = nil
  fileprivate var _annotationDisplayingCommand: TSP_Reference? = nil
  fileprivate var _beginEditingOnUndo: Bool? = nil
  fileprivate var _beginEditingOnRedo: Bool? = nil
  fileprivate var _shouldInvalidateOnUndo: Bool? = nil
  fileprivate var _shouldInvalidateOnRedo: Bool? = nil
}

struct TSD_ImageReplaceCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _storage._super ?? TSD_InfoCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var newImageData: TSP_DataReference {
    get {return _storage._newImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._newImageData = newValue}
  }
  /// Returns true if `newImageData` has been explicitly set.
  var hasNewImageData: Bool {return _storage._newImageData != nil}
  /// Clears the value of `newImageData`. Subsequent reads from it will return its default value.
  mutating func clearNewImageData() {_uniqueStorage()._newImageData = nil}

  var newOriginalImageData: TSP_DataReference {
    get {return _storage._newOriginalImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._newOriginalImageData = newValue}
  }
  /// Returns true if `newOriginalImageData` has been explicitly set.
  var hasNewOriginalImageData: Bool {return _storage._newOriginalImageData != nil}
  /// Clears the value of `newOriginalImageData`. Subsequent reads from it will return its default value.
  mutating func clearNewOriginalImageData() {_uniqueStorage()._newOriginalImageData = nil}

  var oldImageData: TSP_DataReference {
    get {return _storage._oldImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._oldImageData = newValue}
  }
  /// Returns true if `oldImageData` has been explicitly set.
  var hasOldImageData: Bool {return _storage._oldImageData != nil}
  /// Clears the value of `oldImageData`. Subsequent reads from it will return its default value.
  mutating func clearOldImageData() {_uniqueStorage()._oldImageData = nil}

  var oldOriginalImageData: TSP_DataReference {
    get {return _storage._oldOriginalImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._oldOriginalImageData = newValue}
  }
  /// Returns true if `oldOriginalImageData` has been explicitly set.
  var hasOldOriginalImageData: Bool {return _storage._oldOriginalImageData != nil}
  /// Clears the value of `oldOriginalImageData`. Subsequent reads from it will return its default value.
  mutating func clearOldOriginalImageData() {_uniqueStorage()._oldOriginalImageData = nil}

  var instantAlphaPath: TSP_Path {
    get {return _storage._instantAlphaPath ?? TSP_Path()}
    set {_uniqueStorage()._instantAlphaPath = newValue}
  }
  /// Returns true if `instantAlphaPath` has been explicitly set.
  var hasInstantAlphaPath: Bool {return _storage._instantAlphaPath != nil}
  /// Clears the value of `instantAlphaPath`. Subsequent reads from it will return its default value.
  mutating func clearInstantAlphaPath() {_uniqueStorage()._instantAlphaPath = nil}

  var oldInstantAlphaPath: TSP_Path {
    get {return _storage._oldInstantAlphaPath ?? TSP_Path()}
    set {_uniqueStorage()._oldInstantAlphaPath = newValue}
  }
  /// Returns true if `oldInstantAlphaPath` has been explicitly set.
  var hasOldInstantAlphaPath: Bool {return _storage._oldInstantAlphaPath != nil}
  /// Clears the value of `oldInstantAlphaPath`. Subsequent reads from it will return its default value.
  mutating func clearOldInstantAlphaPath() {_uniqueStorage()._oldInstantAlphaPath = nil}

  var naturalSizeForIapath: TSP_Size {
    get {return _storage._naturalSizeForIapath ?? TSP_Size()}
    set {_uniqueStorage()._naturalSizeForIapath = newValue}
  }
  /// Returns true if `naturalSizeForIapath` has been explicitly set.
  var hasNaturalSizeForIapath: Bool {return _storage._naturalSizeForIapath != nil}
  /// Clears the value of `naturalSizeForIapath`. Subsequent reads from it will return its default value.
  mutating func clearNaturalSizeForIapath() {_uniqueStorage()._naturalSizeForIapath = nil}

  var oldNaturalSizeForIapath: TSP_Size {
    get {return _storage._oldNaturalSizeForIapath ?? TSP_Size()}
    set {_uniqueStorage()._oldNaturalSizeForIapath = newValue}
  }
  /// Returns true if `oldNaturalSizeForIapath` has been explicitly set.
  var hasOldNaturalSizeForIapath: Bool {return _storage._oldNaturalSizeForIapath != nil}
  /// Clears the value of `oldNaturalSizeForIapath`. Subsequent reads from it will return its default value.
  mutating func clearOldNaturalSizeForIapath() {_uniqueStorage()._oldNaturalSizeForIapath = nil}

  var targetImageGeometry: TSD_GeometryArchive {
    get {return _storage._targetImageGeometry ?? TSD_GeometryArchive()}
    set {_uniqueStorage()._targetImageGeometry = newValue}
  }
  /// Returns true if `targetImageGeometry` has been explicitly set.
  var hasTargetImageGeometry: Bool {return _storage._targetImageGeometry != nil}
  /// Clears the value of `targetImageGeometry`. Subsequent reads from it will return its default value.
  mutating func clearTargetImageGeometry() {_uniqueStorage()._targetImageGeometry = nil}

  var oldTargetImageGeometry: TSD_GeometryArchive {
    get {return _storage._oldTargetImageGeometry ?? TSD_GeometryArchive()}
    set {_uniqueStorage()._oldTargetImageGeometry = newValue}
  }
  /// Returns true if `oldTargetImageGeometry` has been explicitly set.
  var hasOldTargetImageGeometry: Bool {return _storage._oldTargetImageGeometry != nil}
  /// Clears the value of `oldTargetImageGeometry`. Subsequent reads from it will return its default value.
  mutating func clearOldTargetImageGeometry() {_uniqueStorage()._oldTargetImageGeometry = nil}

  var targetMaskGeometry: TSD_GeometryArchive {
    get {return _storage._targetMaskGeometry ?? TSD_GeometryArchive()}
    set {_uniqueStorage()._targetMaskGeometry = newValue}
  }
  /// Returns true if `targetMaskGeometry` has been explicitly set.
  var hasTargetMaskGeometry: Bool {return _storage._targetMaskGeometry != nil}
  /// Clears the value of `targetMaskGeometry`. Subsequent reads from it will return its default value.
  mutating func clearTargetMaskGeometry() {_uniqueStorage()._targetMaskGeometry = nil}

  var oldTargetMaskGeometry: TSD_GeometryArchive {
    get {return _storage._oldTargetMaskGeometry ?? TSD_GeometryArchive()}
    set {_uniqueStorage()._oldTargetMaskGeometry = newValue}
  }
  /// Returns true if `oldTargetMaskGeometry` has been explicitly set.
  var hasOldTargetMaskGeometry: Bool {return _storage._oldTargetMaskGeometry != nil}
  /// Clears the value of `oldTargetMaskGeometry`. Subsequent reads from it will return its default value.
  mutating func clearOldTargetMaskGeometry() {_uniqueStorage()._oldTargetMaskGeometry = nil}

  var imageAdjustments: TSD_ImageAdjustmentsArchive {
    get {return _storage._imageAdjustments ?? TSD_ImageAdjustmentsArchive()}
    set {_uniqueStorage()._imageAdjustments = newValue}
  }
  /// Returns true if `imageAdjustments` has been explicitly set.
  var hasImageAdjustments: Bool {return _storage._imageAdjustments != nil}
  /// Clears the value of `imageAdjustments`. Subsequent reads from it will return its default value.
  mutating func clearImageAdjustments() {_uniqueStorage()._imageAdjustments = nil}

  var adjustedImageData: TSP_DataReference {
    get {return _storage._adjustedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._adjustedImageData = newValue}
  }
  /// Returns true if `adjustedImageData` has been explicitly set.
  var hasAdjustedImageData: Bool {return _storage._adjustedImageData != nil}
  /// Clears the value of `adjustedImageData`. Subsequent reads from it will return its default value.
  mutating func clearAdjustedImageData() {_uniqueStorage()._adjustedImageData = nil}

  var enhancedImageData: TSP_DataReference {
    get {return _storage._enhancedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._enhancedImageData = newValue}
  }
  /// Returns true if `enhancedImageData` has been explicitly set.
  var hasEnhancedImageData: Bool {return _storage._enhancedImageData != nil}
  /// Clears the value of `enhancedImageData`. Subsequent reads from it will return its default value.
  mutating func clearEnhancedImageData() {_uniqueStorage()._enhancedImageData = nil}

  var oldImageAdjustments: TSD_ImageAdjustmentsArchive {
    get {return _storage._oldImageAdjustments ?? TSD_ImageAdjustmentsArchive()}
    set {_uniqueStorage()._oldImageAdjustments = newValue}
  }
  /// Returns true if `oldImageAdjustments` has been explicitly set.
  var hasOldImageAdjustments: Bool {return _storage._oldImageAdjustments != nil}
  /// Clears the value of `oldImageAdjustments`. Subsequent reads from it will return its default value.
  mutating func clearOldImageAdjustments() {_uniqueStorage()._oldImageAdjustments = nil}

  var oldAdjustedImageData: TSP_DataReference {
    get {return _storage._oldAdjustedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._oldAdjustedImageData = newValue}
  }
  /// Returns true if `oldAdjustedImageData` has been explicitly set.
  var hasOldAdjustedImageData: Bool {return _storage._oldAdjustedImageData != nil}
  /// Clears the value of `oldAdjustedImageData`. Subsequent reads from it will return its default value.
  mutating func clearOldAdjustedImageData() {_uniqueStorage()._oldAdjustedImageData = nil}

  var oldEnhancedImageData: TSP_DataReference {
    get {return _storage._oldEnhancedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._oldEnhancedImageData = newValue}
  }
  /// Returns true if `oldEnhancedImageData` has been explicitly set.
  var hasOldEnhancedImageData: Bool {return _storage._oldEnhancedImageData != nil}
  /// Clears the value of `oldEnhancedImageData`. Subsequent reads from it will return its default value.
  mutating func clearOldEnhancedImageData() {_uniqueStorage()._oldEnhancedImageData = nil}

  var thumbnailImageData: TSP_DataReference {
    get {return _storage._thumbnailImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._thumbnailImageData = newValue}
  }
  /// Returns true if `thumbnailImageData` has been explicitly set.
  var hasThumbnailImageData: Bool {return _storage._thumbnailImageData != nil}
  /// Clears the value of `thumbnailImageData`. Subsequent reads from it will return its default value.
  mutating func clearThumbnailImageData() {_uniqueStorage()._thumbnailImageData = nil}

  var oldThumbnailImageData: TSP_DataReference {
    get {return _storage._oldThumbnailImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._oldThumbnailImageData = newValue}
  }
  /// Returns true if `oldThumbnailImageData` has been explicitly set.
  var hasOldThumbnailImageData: Bool {return _storage._oldThumbnailImageData != nil}
  /// Clears the value of `oldThumbnailImageData`. Subsequent reads from it will return its default value.
  mutating func clearOldThumbnailImageData() {_uniqueStorage()._oldThumbnailImageData = nil}

  var thumbnailAdjustedImageData: TSP_DataReference {
    get {return _storage._thumbnailAdjustedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._thumbnailAdjustedImageData = newValue}
  }
  /// Returns true if `thumbnailAdjustedImageData` has been explicitly set.
  var hasThumbnailAdjustedImageData: Bool {return _storage._thumbnailAdjustedImageData != nil}
  /// Clears the value of `thumbnailAdjustedImageData`. Subsequent reads from it will return its default value.
  mutating func clearThumbnailAdjustedImageData() {_uniqueStorage()._thumbnailAdjustedImageData = nil}

  var oldThumbnailAdjustedImageData: TSP_DataReference {
    get {return _storage._oldThumbnailAdjustedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._oldThumbnailAdjustedImageData = newValue}
  }
  /// Returns true if `oldThumbnailAdjustedImageData` has been explicitly set.
  var hasOldThumbnailAdjustedImageData: Bool {return _storage._oldThumbnailAdjustedImageData != nil}
  /// Clears the value of `oldThumbnailAdjustedImageData`. Subsequent reads from it will return its default value.
  mutating func clearOldThumbnailAdjustedImageData() {_uniqueStorage()._oldThumbnailAdjustedImageData = nil}

  var naturalSize: TSP_Size {
    get {return _storage._naturalSize ?? TSP_Size()}
    set {_uniqueStorage()._naturalSize = newValue}
  }
  /// Returns true if `naturalSize` has been explicitly set.
  var hasNaturalSize: Bool {return _storage._naturalSize != nil}
  /// Clears the value of `naturalSize`. Subsequent reads from it will return its default value.
  mutating func clearNaturalSize() {_uniqueStorage()._naturalSize = nil}

  var oldNaturalSize: TSP_Size {
    get {return _storage._oldNaturalSize ?? TSP_Size()}
    set {_uniqueStorage()._oldNaturalSize = newValue}
  }
  /// Returns true if `oldNaturalSize` has been explicitly set.
  var hasOldNaturalSize: Bool {return _storage._oldNaturalSize != nil}
  /// Clears the value of `oldNaturalSize`. Subsequent reads from it will return its default value.
  mutating func clearOldNaturalSize() {_uniqueStorage()._oldNaturalSize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_DrawableLockCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _super ?? TSD_InfoCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var locked: Bool {
    get {return _locked ?? false}
    set {_locked = newValue}
  }
  /// Returns true if `locked` has been explicitly set.
  var hasLocked: Bool {return self._locked != nil}
  /// Clears the value of `locked`. Subsequent reads from it will return its default value.
  mutating func clearLocked() {self._locked = nil}

  var wasLocked: Bool {
    get {return _wasLocked ?? false}
    set {_wasLocked = newValue}
  }
  /// Returns true if `wasLocked` has been explicitly set.
  var hasWasLocked: Bool {return self._wasLocked != nil}
  /// Clears the value of `wasLocked`. Subsequent reads from it will return its default value.
  mutating func clearWasLocked() {self._wasLocked = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_InfoCommandArchive? = nil
  fileprivate var _locked: Bool? = nil
  fileprivate var _wasLocked: Bool? = nil
}

struct TSD_DrawableInfoCommentCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _storage._super ?? TSD_InfoCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var oldComment: TSP_Reference {
    get {return _storage._oldComment ?? TSP_Reference()}
    set {_uniqueStorage()._oldComment = newValue}
  }
  /// Returns true if `oldComment` has been explicitly set.
  var hasOldComment: Bool {return _storage._oldComment != nil}
  /// Clears the value of `oldComment`. Subsequent reads from it will return its default value.
  mutating func clearOldComment() {_uniqueStorage()._oldComment = nil}

  var newComment: TSP_Reference {
    get {return _storage._newComment ?? TSP_Reference()}
    set {_uniqueStorage()._newComment = newValue}
  }
  /// Returns true if `newComment` has been explicitly set.
  var hasNewComment: Bool {return _storage._newComment != nil}
  /// Clears the value of `newComment`. Subsequent reads from it will return its default value.
  mutating func clearNewComment() {_uniqueStorage()._newComment = nil}

  var forwardVariant: TSD_CommentCommandVariant {
    get {return _storage._forwardVariant ?? .baseComment}
    set {_uniqueStorage()._forwardVariant = newValue}
  }
  /// Returns true if `forwardVariant` has been explicitly set.
  var hasForwardVariant: Bool {return _storage._forwardVariant != nil}
  /// Clears the value of `forwardVariant`. Subsequent reads from it will return its default value.
  mutating func clearForwardVariant() {_uniqueStorage()._forwardVariant = nil}

  var inverseVariant: TSD_CommentCommandVariant {
    get {return _storage._inverseVariant ?? .baseComment}
    set {_uniqueStorage()._inverseVariant = newValue}
  }
  /// Returns true if `inverseVariant` has been explicitly set.
  var hasInverseVariant: Bool {return _storage._inverseVariant != nil}
  /// Clears the value of `inverseVariant`. Subsequent reads from it will return its default value.
  mutating func clearInverseVariant() {_uniqueStorage()._inverseVariant = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_DrawablePencilAnnotationCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _storage._super ?? TSD_InfoCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var pencilAnnotationToAdd: TSP_Reference {
    get {return _storage._pencilAnnotationToAdd ?? TSP_Reference()}
    set {_uniqueStorage()._pencilAnnotationToAdd = newValue}
  }
  /// Returns true if `pencilAnnotationToAdd` has been explicitly set.
  var hasPencilAnnotationToAdd: Bool {return _storage._pencilAnnotationToAdd != nil}
  /// Clears the value of `pencilAnnotationToAdd`. Subsequent reads from it will return its default value.
  mutating func clearPencilAnnotationToAdd() {_uniqueStorage()._pencilAnnotationToAdd = nil}

  var pencilAnnotationToRemove: TSP_Reference {
    get {return _storage._pencilAnnotationToRemove ?? TSP_Reference()}
    set {_uniqueStorage()._pencilAnnotationToRemove = newValue}
  }
  /// Returns true if `pencilAnnotationToRemove` has been explicitly set.
  var hasPencilAnnotationToRemove: Bool {return _storage._pencilAnnotationToRemove != nil}
  /// Clears the value of `pencilAnnotationToRemove`. Subsequent reads from it will return its default value.
  mutating func clearPencilAnnotationToRemove() {_uniqueStorage()._pencilAnnotationToRemove = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_AbstractGuideCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var oldGuides: [TSD_UserDefinedGuideArchive] = []

  var newGuides: [TSD_UserDefinedGuideArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
}

struct TSD_GuideCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_AbstractGuideCommandArchive {
    get {return _super ?? TSD_AbstractGuideCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var storageIDPath: TSP_UUIDPath {
    get {return _storageIDPath ?? TSP_UUIDPath()}
    set {_storageIDPath = newValue}
  }
  /// Returns true if `storageIDPath` has been explicitly set.
  var hasStorageIDPath: Bool {return self._storageIDPath != nil}
  /// Clears the value of `storageIDPath`. Subsequent reads from it will return its default value.
  mutating func clearStorageIDPath() {self._storageIDPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_AbstractGuideCommandArchive? = nil
  fileprivate var _storageIDPath: TSP_UUIDPath? = nil
}

struct TSD_DrawableAspectRatioLockedCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _super ?? TSD_InfoCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var aspectRatioLocked: Bool {
    get {return _aspectRatioLocked ?? false}
    set {_aspectRatioLocked = newValue}
  }
  /// Returns true if `aspectRatioLocked` has been explicitly set.
  var hasAspectRatioLocked: Bool {return self._aspectRatioLocked != nil}
  /// Clears the value of `aspectRatioLocked`. Subsequent reads from it will return its default value.
  mutating func clearAspectRatioLocked() {self._aspectRatioLocked = nil}

  var wasAspectRatioLocked: Bool {
    get {return _wasAspectRatioLocked ?? false}
    set {_wasAspectRatioLocked = newValue}
  }
  /// Returns true if `wasAspectRatioLocked` has been explicitly set.
  var hasWasAspectRatioLocked: Bool {return self._wasAspectRatioLocked != nil}
  /// Clears the value of `wasAspectRatioLocked`. Subsequent reads from it will return its default value.
  mutating func clearWasAspectRatioLocked() {self._wasAspectRatioLocked = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_InfoCommandArchive? = nil
  fileprivate var _aspectRatioLocked: Bool? = nil
  fileprivate var _wasAspectRatioLocked: Bool? = nil
}

struct TSD_DrawableAccessibilityDescriptionCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _super ?? TSD_InfoCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var accessibilityDescription: String {
    get {return _accessibilityDescription ?? String()}
    set {_accessibilityDescription = newValue}
  }
  /// Returns true if `accessibilityDescription` has been explicitly set.
  var hasAccessibilityDescription: Bool {return self._accessibilityDescription != nil}
  /// Clears the value of `accessibilityDescription`. Subsequent reads from it will return its default value.
  mutating func clearAccessibilityDescription() {self._accessibilityDescription = nil}

  var oldAccessibilityDescription: String {
    get {return _oldAccessibilityDescription ?? String()}
    set {_oldAccessibilityDescription = newValue}
  }
  /// Returns true if `oldAccessibilityDescription` has been explicitly set.
  var hasOldAccessibilityDescription: Bool {return self._oldAccessibilityDescription != nil}
  /// Clears the value of `oldAccessibilityDescription`. Subsequent reads from it will return its default value.
  mutating func clearOldAccessibilityDescription() {self._oldAccessibilityDescription = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_InfoCommandArchive? = nil
  fileprivate var _accessibilityDescription: String? = nil
  fileprivate var _oldAccessibilityDescription: String? = nil
}

struct TSD_PasteStyleCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_AbstractStyleCommandArchive {
    get {return _storage._super ?? TSD_AbstractStyleCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var newStyle: TSP_Reference {
    get {return _storage._newStyle ?? TSP_Reference()}
    set {_uniqueStorage()._newStyle = newValue}
  }
  /// Returns true if `newStyle` has been explicitly set.
  var hasNewStyle: Bool {return _storage._newStyle != nil}
  /// Clears the value of `newStyle`. Subsequent reads from it will return its default value.
  mutating func clearNewStyle() {_uniqueStorage()._newStyle = nil}

  var rollbackStyle: TSP_Reference {
    get {return _storage._rollbackStyle ?? TSP_Reference()}
    set {_uniqueStorage()._rollbackStyle = newValue}
  }
  /// Returns true if `rollbackStyle` has been explicitly set.
  var hasRollbackStyle: Bool {return _storage._rollbackStyle != nil}
  /// Clears the value of `rollbackStyle`. Subsequent reads from it will return its default value.
  mutating func clearRollbackStyle() {_uniqueStorage()._rollbackStyle = nil}

  var tailEndOnLeft: Bool {
    get {return _storage._tailEndOnLeft ?? false}
    set {_uniqueStorage()._tailEndOnLeft = newValue}
  }
  /// Returns true if `tailEndOnLeft` has been explicitly set.
  var hasTailEndOnLeft: Bool {return _storage._tailEndOnLeft != nil}
  /// Clears the value of `tailEndOnLeft`. Subsequent reads from it will return its default value.
  mutating func clearTailEndOnLeft() {_uniqueStorage()._tailEndOnLeft = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_ImageInfoAbstractGeometryCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _storage._super ?? TSD_InfoCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var newImageGeometry: TSD_GeometryArchive {
    get {return _storage._newImageGeometry ?? TSD_GeometryArchive()}
    set {_uniqueStorage()._newImageGeometry = newValue}
  }
  /// Returns true if `newImageGeometry` has been explicitly set.
  var hasNewImageGeometry: Bool {return _storage._newImageGeometry != nil}
  /// Clears the value of `newImageGeometry`. Subsequent reads from it will return its default value.
  mutating func clearNewImageGeometry() {_uniqueStorage()._newImageGeometry = nil}

  var oldImageGeometry: TSD_GeometryArchive {
    get {return _storage._oldImageGeometry ?? TSD_GeometryArchive()}
    set {_uniqueStorage()._oldImageGeometry = newValue}
  }
  /// Returns true if `oldImageGeometry` has been explicitly set.
  var hasOldImageGeometry: Bool {return _storage._oldImageGeometry != nil}
  /// Clears the value of `oldImageGeometry`. Subsequent reads from it will return its default value.
  mutating func clearOldImageGeometry() {_uniqueStorage()._oldImageGeometry = nil}

  var newMaskGeometry: TSD_GeometryArchive {
    get {return _storage._newMaskGeometry ?? TSD_GeometryArchive()}
    set {_uniqueStorage()._newMaskGeometry = newValue}
  }
  /// Returns true if `newMaskGeometry` has been explicitly set.
  var hasNewMaskGeometry: Bool {return _storage._newMaskGeometry != nil}
  /// Clears the value of `newMaskGeometry`. Subsequent reads from it will return its default value.
  mutating func clearNewMaskGeometry() {_uniqueStorage()._newMaskGeometry = nil}

  var oldMaskGeometry: TSD_GeometryArchive {
    get {return _storage._oldMaskGeometry ?? TSD_GeometryArchive()}
    set {_uniqueStorage()._oldMaskGeometry = newValue}
  }
  /// Returns true if `oldMaskGeometry` has been explicitly set.
  var hasOldMaskGeometry: Bool {return _storage._oldMaskGeometry != nil}
  /// Clears the value of `oldMaskGeometry`. Subsequent reads from it will return its default value.
  mutating func clearOldMaskGeometry() {_uniqueStorage()._oldMaskGeometry = nil}

  var newMaskPathSource: TSD_PathSourceArchive {
    get {return _storage._newMaskPathSource ?? TSD_PathSourceArchive()}
    set {_uniqueStorage()._newMaskPathSource = newValue}
  }
  /// Returns true if `newMaskPathSource` has been explicitly set.
  var hasNewMaskPathSource: Bool {return _storage._newMaskPathSource != nil}
  /// Clears the value of `newMaskPathSource`. Subsequent reads from it will return its default value.
  mutating func clearNewMaskPathSource() {_uniqueStorage()._newMaskPathSource = nil}

  var oldMaskPathSource: TSD_PathSourceArchive {
    get {return _storage._oldMaskPathSource ?? TSD_PathSourceArchive()}
    set {_uniqueStorage()._oldMaskPathSource = newValue}
  }
  /// Returns true if `oldMaskPathSource` has been explicitly set.
  var hasOldMaskPathSource: Bool {return _storage._oldMaskPathSource != nil}
  /// Clears the value of `oldMaskPathSource`. Subsequent reads from it will return its default value.
  mutating func clearOldMaskPathSource() {_uniqueStorage()._oldMaskPathSource = nil}

  var newImageOriginalSize: TSP_Size {
    get {return _storage._newImageOriginalSize ?? TSP_Size()}
    set {_uniqueStorage()._newImageOriginalSize = newValue}
  }
  /// Returns true if `newImageOriginalSize` has been explicitly set.
  var hasNewImageOriginalSize: Bool {return _storage._newImageOriginalSize != nil}
  /// Clears the value of `newImageOriginalSize`. Subsequent reads from it will return its default value.
  mutating func clearNewImageOriginalSize() {_uniqueStorage()._newImageOriginalSize = nil}

  var oldImageOriginalSize: TSP_Size {
    get {return _storage._oldImageOriginalSize ?? TSP_Size()}
    set {_uniqueStorage()._oldImageOriginalSize = newValue}
  }
  /// Returns true if `oldImageOriginalSize` has been explicitly set.
  var hasOldImageOriginalSize: Bool {return _storage._oldImageOriginalSize != nil}
  /// Clears the value of `oldImageOriginalSize`. Subsequent reads from it will return its default value.
  mutating func clearOldImageOriginalSize() {_uniqueStorage()._oldImageOriginalSize = nil}

  var backgroundRemoved: Bool {
    get {return _storage._backgroundRemoved ?? false}
    set {_uniqueStorage()._backgroundRemoved = newValue}
  }
  /// Returns true if `backgroundRemoved` has been explicitly set.
  var hasBackgroundRemoved: Bool {return _storage._backgroundRemoved != nil}
  /// Clears the value of `backgroundRemoved`. Subsequent reads from it will return its default value.
  mutating func clearBackgroundRemoved() {_uniqueStorage()._backgroundRemoved = nil}

  var oldBackgroundRemoved: Bool {
    get {return _storage._oldBackgroundRemoved ?? false}
    set {_uniqueStorage()._oldBackgroundRemoved = newValue}
  }
  /// Returns true if `oldBackgroundRemoved` has been explicitly set.
  var hasOldBackgroundRemoved: Bool {return _storage._oldBackgroundRemoved != nil}
  /// Clears the value of `oldBackgroundRemoved`. Subsequent reads from it will return its default value.
  mutating func clearOldBackgroundRemoved() {_uniqueStorage()._oldBackgroundRemoved = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_ImageInfoGeometryCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_ImageInfoAbstractGeometryCommandArchive {
    get {return _super ?? TSD_ImageInfoAbstractGeometryCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_ImageInfoAbstractGeometryCommandArchive? = nil
}

struct TSD_ImageInfoMaskGeometryCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_ImageInfoAbstractGeometryCommandArchive {
    get {return _super ?? TSD_ImageInfoAbstractGeometryCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_ImageInfoAbstractGeometryCommandArchive? = nil
}

struct TSD_InfoCollectionSelectionTransformerHelperArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var infoUuidPathList: [TSP_UUIDPath] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSD_DrawableSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transformerHelper: TSD_InfoCollectionSelectionTransformerHelperArchive {
    get {return _transformerHelper ?? TSD_InfoCollectionSelectionTransformerHelperArchive()}
    set {_transformerHelper = newValue}
  }
  /// Returns true if `transformerHelper` has been explicitly set.
  var hasTransformerHelper: Bool {return self._transformerHelper != nil}
  /// Clears the value of `transformerHelper`. Subsequent reads from it will return its default value.
  mutating func clearTransformerHelper() {self._transformerHelper = nil}

  var untransformedDrawableSelection: TSP_Reference {
    get {return _untransformedDrawableSelection ?? TSP_Reference()}
    set {_untransformedDrawableSelection = newValue}
  }
  /// Returns true if `untransformedDrawableSelection` has been explicitly set.
  var hasUntransformedDrawableSelection: Bool {return self._untransformedDrawableSelection != nil}
  /// Clears the value of `untransformedDrawableSelection`. Subsequent reads from it will return its default value.
  mutating func clearUntransformedDrawableSelection() {self._untransformedDrawableSelection = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transformerHelper: TSD_InfoCollectionSelectionTransformerHelperArchive? = nil
  fileprivate var _untransformedDrawableSelection: TSP_Reference? = nil
}

struct TSD_InfoHyperlinkSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSD_CanvasSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transformerHelper: TSD_InfoCollectionSelectionTransformerHelperArchive {
    get {return _transformerHelper ?? TSD_InfoCollectionSelectionTransformerHelperArchive()}
    set {_transformerHelper = newValue}
  }
  /// Returns true if `transformerHelper` has been explicitly set.
  var hasTransformerHelper: Bool {return self._transformerHelper != nil}
  /// Clears the value of `transformerHelper`. Subsequent reads from it will return its default value.
  mutating func clearTransformerHelper() {self._transformerHelper = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transformerHelper: TSD_InfoCollectionSelectionTransformerHelperArchive? = nil
}

struct TSD_PathSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSD_ShapeSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_DrawableSelectionTransformerArchive {
    get {return _super ?? TSD_DrawableSelectionTransformerArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_DrawableSelectionTransformerArchive? = nil
}

struct TSD_GroupSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_DrawableSelectionTransformerArchive {
    get {return _super ?? TSD_DrawableSelectionTransformerArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_DrawableSelectionTransformerArchive? = nil
}

struct TSD_PencilAnnotationSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pencilAnnotationUuid: TSP_UUID {
    get {return _pencilAnnotationUuid ?? TSP_UUID()}
    set {_pencilAnnotationUuid = newValue}
  }
  /// Returns true if `pencilAnnotationUuid` has been explicitly set.
  var hasPencilAnnotationUuid: Bool {return self._pencilAnnotationUuid != nil}
  /// Clears the value of `pencilAnnotationUuid`. Subsequent reads from it will return its default value.
  mutating func clearPencilAnnotationUuid() {self._pencilAnnotationUuid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pencilAnnotationUuid: TSP_UUID? = nil
}

struct TSD_FreehandDrawingOpacityCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _super ?? TSD_InfoCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var opacity: Double {
    get {return _opacity ?? 0}
    set {_opacity = newValue}
  }
  /// Returns true if `opacity` has been explicitly set.
  var hasOpacity: Bool {return self._opacity != nil}
  /// Clears the value of `opacity`. Subsequent reads from it will return its default value.
  mutating func clearOpacity() {self._opacity = nil}

  var oldOpacity: Double {
    get {return _oldOpacity ?? 0}
    set {_oldOpacity = newValue}
  }
  /// Returns true if `oldOpacity` has been explicitly set.
  var hasOldOpacity: Bool {return self._oldOpacity != nil}
  /// Clears the value of `oldOpacity`. Subsequent reads from it will return its default value.
  mutating func clearOldOpacity() {self._oldOpacity = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_InfoCommandArchive? = nil
  fileprivate var _opacity: Double? = nil
  fileprivate var _oldOpacity: Double? = nil
}

struct TSD_FreehandDrawingAnimationCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _super ?? TSD_InfoCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var animation: TSD_FreehandDrawingAnimationArchive {
    get {return _animation ?? TSD_FreehandDrawingAnimationArchive()}
    set {_animation = newValue}
  }
  /// Returns true if `animation` has been explicitly set.
  var hasAnimation: Bool {return self._animation != nil}
  /// Clears the value of `animation`. Subsequent reads from it will return its default value.
  mutating func clearAnimation() {self._animation = nil}

  var oldAnimation: TSD_FreehandDrawingAnimationArchive {
    get {return _oldAnimation ?? TSD_FreehandDrawingAnimationArchive()}
    set {_oldAnimation = newValue}
  }
  /// Returns true if `oldAnimation` has been explicitly set.
  var hasOldAnimation: Bool {return self._oldAnimation != nil}
  /// Clears the value of `oldAnimation`. Subsequent reads from it will return its default value.
  mutating func clearOldAnimation() {self._oldAnimation = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_InfoCommandArchive? = nil
  fileprivate var _animation: TSD_FreehandDrawingAnimationArchive? = nil
  fileprivate var _oldAnimation: TSD_FreehandDrawingAnimationArchive? = nil
}

struct TSD_InsertCaptionOrTitleCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var drawableInfoIDPath: TSP_UUIDPath {
    get {return _storage._drawableInfoIDPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._drawableInfoIDPath = newValue}
  }
  /// Returns true if `drawableInfoIDPath` has been explicitly set.
  var hasDrawableInfoIDPath: Bool {return _storage._drawableInfoIDPath != nil}
  /// Clears the value of `drawableInfoIDPath`. Subsequent reads from it will return its default value.
  mutating func clearDrawableInfoIDPath() {_uniqueStorage()._drawableInfoIDPath = nil}

  var captionOrTitleInfo: TSP_Reference {
    get {return _storage._captionOrTitleInfo ?? TSP_Reference()}
    set {_uniqueStorage()._captionOrTitleInfo = newValue}
  }
  /// Returns true if `captionOrTitleInfo` has been explicitly set.
  var hasCaptionOrTitleInfo: Bool {return _storage._captionOrTitleInfo != nil}
  /// Clears the value of `captionOrTitleInfo`. Subsequent reads from it will return its default value.
  mutating func clearCaptionOrTitleInfo() {_uniqueStorage()._captionOrTitleInfo = nil}

  var addedCaptionOrTitleUuid: TSP_UUID {
    get {return _storage._addedCaptionOrTitleUuid ?? TSP_UUID()}
    set {_uniqueStorage()._addedCaptionOrTitleUuid = newValue}
  }
  /// Returns true if `addedCaptionOrTitleUuid` has been explicitly set.
  var hasAddedCaptionOrTitleUuid: Bool {return _storage._addedCaptionOrTitleUuid != nil}
  /// Clears the value of `addedCaptionOrTitleUuid`. Subsequent reads from it will return its default value.
  mutating func clearAddedCaptionOrTitleUuid() {_uniqueStorage()._addedCaptionOrTitleUuid = nil}

  var captionOrTitleKind: TSD_CaptionOrTitleKind {
    get {return _storage._captionOrTitleKind ?? .caption}
    set {_uniqueStorage()._captionOrTitleKind = newValue}
  }
  /// Returns true if `captionOrTitleKind` has been explicitly set.
  var hasCaptionOrTitleKind: Bool {return _storage._captionOrTitleKind != nil}
  /// Clears the value of `captionOrTitleKind`. Subsequent reads from it will return its default value.
  mutating func clearCaptionOrTitleKind() {_uniqueStorage()._captionOrTitleKind = nil}

  var undoObject: TSP_Reference {
    get {return _storage._undoObject ?? TSP_Reference()}
    set {_uniqueStorage()._undoObject = newValue}
  }
  /// Returns true if `undoObject` has been explicitly set.
  var hasUndoObject: Bool {return _storage._undoObject != nil}
  /// Clears the value of `undoObject`. Subsequent reads from it will return its default value.
  mutating func clearUndoObject() {_uniqueStorage()._undoObject = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_RemoveCaptionOrTitleCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var drawableInfoIDPath: TSP_UUIDPath {
    get {return _storage._drawableInfoIDPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._drawableInfoIDPath = newValue}
  }
  /// Returns true if `drawableInfoIDPath` has been explicitly set.
  var hasDrawableInfoIDPath: Bool {return _storage._drawableInfoIDPath != nil}
  /// Clears the value of `drawableInfoIDPath`. Subsequent reads from it will return its default value.
  mutating func clearDrawableInfoIDPath() {_uniqueStorage()._drawableInfoIDPath = nil}

  var removedCaptionOrTitleInfo: TSP_Reference {
    get {return _storage._removedCaptionOrTitleInfo ?? TSP_Reference()}
    set {_uniqueStorage()._removedCaptionOrTitleInfo = newValue}
  }
  /// Returns true if `removedCaptionOrTitleInfo` has been explicitly set.
  var hasRemovedCaptionOrTitleInfo: Bool {return _storage._removedCaptionOrTitleInfo != nil}
  /// Clears the value of `removedCaptionOrTitleInfo`. Subsequent reads from it will return its default value.
  mutating func clearRemovedCaptionOrTitleInfo() {_uniqueStorage()._removedCaptionOrTitleInfo = nil}

  var removedCaptionOrTitleUuid: TSP_UUID {
    get {return _storage._removedCaptionOrTitleUuid ?? TSP_UUID()}
    set {_uniqueStorage()._removedCaptionOrTitleUuid = newValue}
  }
  /// Returns true if `removedCaptionOrTitleUuid` has been explicitly set.
  var hasRemovedCaptionOrTitleUuid: Bool {return _storage._removedCaptionOrTitleUuid != nil}
  /// Clears the value of `removedCaptionOrTitleUuid`. Subsequent reads from it will return its default value.
  mutating func clearRemovedCaptionOrTitleUuid() {_uniqueStorage()._removedCaptionOrTitleUuid = nil}

  var captionOrTitleKind: TSD_CaptionOrTitleKind {
    get {return _storage._captionOrTitleKind ?? .caption}
    set {_uniqueStorage()._captionOrTitleKind = newValue}
  }
  /// Returns true if `captionOrTitleKind` has been explicitly set.
  var hasCaptionOrTitleKind: Bool {return _storage._captionOrTitleKind != nil}
  /// Clears the value of `captionOrTitleKind`. Subsequent reads from it will return its default value.
  mutating func clearCaptionOrTitleKind() {_uniqueStorage()._captionOrTitleKind = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_SetCaptionOrTitleVisibilityCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _super ?? TSD_InfoCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var captionOrTitleKind: TSD_CaptionOrTitleKind {
    get {return _captionOrTitleKind ?? .caption}
    set {_captionOrTitleKind = newValue}
  }
  /// Returns true if `captionOrTitleKind` has been explicitly set.
  var hasCaptionOrTitleKind: Bool {return self._captionOrTitleKind != nil}
  /// Clears the value of `captionOrTitleKind`. Subsequent reads from it will return its default value.
  mutating func clearCaptionOrTitleKind() {self._captionOrTitleKind = nil}

  var hidden: Bool {
    get {return _hidden ?? false}
    set {_hidden = newValue}
  }
  /// Returns true if `hidden` has been explicitly set.
  var hasHidden: Bool {return self._hidden != nil}
  /// Clears the value of `hidden`. Subsequent reads from it will return its default value.
  mutating func clearHidden() {self._hidden = nil}

  var wasHidden: Bool {
    get {return _wasHidden ?? false}
    set {_wasHidden = newValue}
  }
  /// Returns true if `wasHidden` has been explicitly set.
  var hasWasHidden: Bool {return self._wasHidden != nil}
  /// Clears the value of `wasHidden`. Subsequent reads from it will return its default value.
  mutating func clearWasHidden() {self._wasHidden = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_InfoCommandArchive? = nil
  fileprivate var _captionOrTitleKind: TSD_CaptionOrTitleKind? = nil
  fileprivate var _hidden: Bool? = nil
  fileprivate var _wasHidden: Bool? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TSD"

extension TSD_CommentCommandVariant: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0BaseComment\0\u{1}AddReply\0\u{1}EditReply\0\u{1}DeleteReply\0")
}

extension TSD_CaptionOrTitleKind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Caption\0\u{1}Title\0")
}

extension TSD_UndoObjectArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UndoObjectArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}objects\0\u{1}stylesheet\0\u{1}keys\0\u{1}counts\0")

  public var isInitialized: Bool {
    if let v = self._stylesheet, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.objects) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.objects) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._stylesheet) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.keys) }()
      case 4: try { try decoder.decodeRepeatedUInt32Field(value: &self.counts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.objects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objects, fieldNumber: 1)
    }
    try { if let v = self._stylesheet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 3)
    }
    if !self.counts.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.counts, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_UndoObjectArchive, rhs: TSD_UndoObjectArchive) -> Bool {
    if lhs._stylesheet != rhs._stylesheet {return false}
    if lhs.objects != rhs.objects {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.counts != rhs.counts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_GroupDrawablesCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupDrawablesCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}drawables\0\u{1}group\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.drawables) {return false}
    if let v = self._group, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.drawables) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.drawables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.drawables, fieldNumber: 2)
    }
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_GroupDrawablesCommandArchive, rhs: TSD_GroupDrawablesCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.drawables != rhs.drawables {return false}
    if lhs._group != rhs._group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_UngroupGroupCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UngroupGroupCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}drawables\0\u{1}group\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.drawables) {return false}
    if let v = self._group, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.drawables) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.drawables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.drawables, fieldNumber: 2)
    }
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_UngroupGroupCommandArchive, rhs: TSD_UngroupGroupCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.drawables != rhs.drawables {return false}
    if lhs._group != rhs._group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ContainerRemoveChildrenCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerRemoveChildrenCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}container_id_path\0\u{3}args_list\0\u{1}children\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._containerIDPath, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.argsList) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.children) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._containerIDPath) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.argsList) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.children) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._containerIDPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.argsList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.argsList, fieldNumber: 3)
    }
    if !self.children.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.children, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ContainerRemoveChildrenCommandArchive, rhs: TSD_ContainerRemoveChildrenCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._containerIDPath != rhs._containerIDPath {return false}
    if lhs.argsList != rhs.argsList {return false}
    if lhs.children != rhs.children {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ContainerRemoveDrawablesCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerRemoveDrawablesCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ContainerRemoveDrawablesCommandArchive, rhs: TSD_ContainerRemoveDrawablesCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ContainerInsertChildrenCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerInsertChildrenCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}container_id_path\0\u{1}children\0\u{3}args_list\0\u{3}custom_format_keys\0\u{3}undo_object\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _containerIDPath: TSP_UUIDPath? = nil
    var _children: [TSP_Reference] = []
    var _argsList: [TSCK_AddIdOperationArgs] = []
    var _customFormatKeys: [TSP_UUID] = []
    var _undoObject: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _containerIDPath = source._containerIDPath
      _children = source._children
      _argsList = source._argsList
      _customFormatKeys = source._customFormatKeys
      _undoObject = source._undoObject
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._containerIDPath, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._children) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._argsList) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._customFormatKeys) {return false}
      if let v = _storage._undoObject, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._containerIDPath) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._children) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._argsList) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._customFormatKeys) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._undoObject) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._containerIDPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._children.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._children, fieldNumber: 3)
      }
      if !_storage._argsList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._argsList, fieldNumber: 4)
      }
      if !_storage._customFormatKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._customFormatKeys, fieldNumber: 5)
      }
      try { if let v = _storage._undoObject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ContainerInsertChildrenCommandArchive, rhs: TSD_ContainerInsertChildrenCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._containerIDPath != rhs_storage._containerIDPath {return false}
        if _storage._children != rhs_storage._children {return false}
        if _storage._argsList != rhs_storage._argsList {return false}
        if _storage._customFormatKeys != rhs_storage._customFormatKeys {return false}
        if _storage._undoObject != rhs_storage._undoObject {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ContainerInsertDrawablesCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerInsertDrawablesCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}drawables\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.drawables) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.drawables) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.drawables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.drawables, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ContainerInsertDrawablesCommandArchive, rhs: TSD_ContainerInsertDrawablesCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.drawables != rhs.drawables {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ContainerReorderChildrenCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerReorderChildrenCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}container_id_path\0\u{3}args_list\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._containerIDPath, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.argsList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._containerIDPath) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.argsList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._containerIDPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.argsList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.argsList, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ContainerReorderChildrenCommandArchive, rhs: TSD_ContainerReorderChildrenCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._containerIDPath != rhs._containerIDPath {return false}
    if lhs.argsList != rhs.argsList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_GroupUngroupInformativeCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupUngroupInformativeCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}removed_infos\0\u{3}inserted_infos\0\u{3}command_type\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.removedInfos) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.insertedInfos) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.removedInfos) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.insertedInfos) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._commandType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.removedInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.removedInfos, fieldNumber: 2)
    }
    if !self.insertedInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.insertedInfos, fieldNumber: 3)
    }
    try { if let v = self._commandType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_GroupUngroupInformativeCommandArchive, rhs: TSD_GroupUngroupInformativeCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.removedInfos != rhs.removedInfos {return false}
    if lhs.insertedInfos != rhs.insertedInfos {return false}
    if lhs._commandType != rhs._commandType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_GroupUngroupInformativeCommandArchive.CommandType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Group\0\u{1}Ungroup\0")
}

extension TSD_InfoCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InfoCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}info_id_path\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._infoIDPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._infoIDPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._infoIDPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_InfoCommandArchive, rhs: TSD_InfoCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._infoIDPath != rhs._infoIDPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ConnectionLineConnectCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionLineConnectCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{3}connected_from_id\0\u{3}connected_to_id\0\u{3}old_connected_to_id\0\u{3}old_connected_from_id\0")

  fileprivate class _StorageClass {
    var _super: TSD_InfoCommandArchive? = nil
    var _connectedFromID: TSP_UUID? = nil
    var _connectedToID: TSP_UUID? = nil
    var _oldConnectedToID: TSP_UUID? = nil
    var _oldConnectedFromID: TSP_UUID? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _connectedFromID = source._connectedFromID
      _connectedToID = source._connectedToID
      _oldConnectedToID = source._oldConnectedToID
      _oldConnectedFromID = source._oldConnectedFromID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._connectedFromID, !v.isInitialized {return false}
      if let v = _storage._connectedToID, !v.isInitialized {return false}
      if let v = _storage._oldConnectedToID, !v.isInitialized {return false}
      if let v = _storage._oldConnectedFromID, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._connectedFromID) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._connectedToID) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._oldConnectedToID) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._oldConnectedFromID) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._connectedFromID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._connectedToID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._oldConnectedToID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._oldConnectedFromID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ConnectionLineConnectCommandArchive, rhs: TSD_ConnectionLineConnectCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._connectedFromID != rhs_storage._connectedFromID {return false}
        if _storage._connectedToID != rhs_storage._connectedToID {return false}
        if _storage._oldConnectedToID != rhs_storage._oldConnectedToID {return false}
        if _storage._oldConnectedFromID != rhs_storage._oldConnectedFromID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_InfoGeometryCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InfoGeometryCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}newGeometry\0\u{1}oldGeometry\0\u{1}matchObjectPlaceholderGeometry\0\u{1}oldMatchObjectPlaceholderGeometry\0\u{1}shouldTriggerRtuAnimation\0\u{1}initiatedOnWeb\0")

  fileprivate class _StorageClass {
    var _super: TSD_InfoCommandArchive? = nil
    var _newGeometry: TSD_GeometryArchive? = nil
    var _oldGeometry: TSD_GeometryArchive? = nil
    var _matchObjectPlaceholderGeometry: Bool? = nil
    var _oldMatchObjectPlaceholderGeometry: Bool? = nil
    var _shouldTriggerRtuAnimation: Bool? = nil
    var _initiatedOnWeb: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _newGeometry = source._newGeometry
      _oldGeometry = source._oldGeometry
      _matchObjectPlaceholderGeometry = source._matchObjectPlaceholderGeometry
      _oldMatchObjectPlaceholderGeometry = source._oldMatchObjectPlaceholderGeometry
      _shouldTriggerRtuAnimation = source._shouldTriggerRtuAnimation
      _initiatedOnWeb = source._initiatedOnWeb
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._newGeometry, !v.isInitialized {return false}
      if let v = _storage._oldGeometry, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._newGeometry) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._oldGeometry) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._matchObjectPlaceholderGeometry) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._oldMatchObjectPlaceholderGeometry) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._shouldTriggerRtuAnimation) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._initiatedOnWeb) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._newGeometry {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._oldGeometry {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._matchObjectPlaceholderGeometry {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._oldMatchObjectPlaceholderGeometry {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._shouldTriggerRtuAnimation {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._initiatedOnWeb {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_InfoGeometryCommandArchive, rhs: TSD_InfoGeometryCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._newGeometry != rhs_storage._newGeometry {return false}
        if _storage._oldGeometry != rhs_storage._oldGeometry {return false}
        if _storage._matchObjectPlaceholderGeometry != rhs_storage._matchObjectPlaceholderGeometry {return false}
        if _storage._oldMatchObjectPlaceholderGeometry != rhs_storage._oldMatchObjectPlaceholderGeometry {return false}
        if _storage._shouldTriggerRtuAnimation != rhs_storage._shouldTriggerRtuAnimation {return false}
        if _storage._initiatedOnWeb != rhs_storage._initiatedOnWeb {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_DrawablePathSourceCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawablePathSourceCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}old_path_source\0\u{3}new_path_source\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._oldPathSource, !v.isInitialized {return false}
    if let v = self._newPathSource, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._oldPathSource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newPathSource) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oldPathSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newPathSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_DrawablePathSourceCommandArchive, rhs: TSD_DrawablePathSourceCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._oldPathSource != rhs._oldPathSource {return false}
    if lhs._newPathSource != rhs._newPathSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_InstantAlphaCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstantAlphaCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}oldpath\0\u{1}newpath\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._oldpath, !v.isInitialized {return false}
    if let v = self._newpath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._oldpath) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newpath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oldpath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newpath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_InstantAlphaCommandArchive, rhs: TSD_InstantAlphaCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._oldpath != rhs._oldpath {return false}
    if lhs._newpath != rhs._newpath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_DrawableApplyThemeCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawableApplyThemeCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}info\0\u{1}style\0")

  fileprivate class _StorageClass {
    var _super: TSS_ApplyThemeChildCommandArchive? = nil
    var _info: TSP_Reference? = nil
    var _style: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _info = source._info
      _style = source._style
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._info, !v.isInitialized {return false}
      if let v = _storage._style, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._info) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._style) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_DrawableApplyThemeCommandArchive, rhs: TSD_DrawableApplyThemeCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._info != rhs_storage._info {return false}
        if _storage._style != rhs_storage._style {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_AbstractStyleCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AbstractStyleCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_AbstractStyleCommandArchive, rhs: TSD_AbstractStyleCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_StyledInfoSetStyleCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StyledInfoSetStyleCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}new_style\0\u{4}\u{2}rollback_style\0")

  fileprivate class _StorageClass {
    var _super: TSD_AbstractStyleCommandArchive? = nil
    var _newStyle: TSP_Reference? = nil
    var _rollbackStyle: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _newStyle = source._newStyle
      _rollbackStyle = source._rollbackStyle
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._newStyle, !v.isInitialized {return false}
      if let v = _storage._rollbackStyle, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._newStyle) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._rollbackStyle) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._newStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._rollbackStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_StyledInfoSetStyleCommandArchive, rhs: TSD_StyledInfoSetStyleCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._newStyle != rhs_storage._newStyle {return false}
        if _storage._rollbackStyle != rhs_storage._rollbackStyle {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_BaseApplyPresetCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BaseApplyPresetCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}preset_style\0\u{4}\u{2}rollback_style\0")

  fileprivate class _StorageClass {
    var _super: TSD_AbstractStyleCommandArchive? = nil
    var _presetStyle: TSP_Reference? = nil
    var _rollbackStyle: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _presetStyle = source._presetStyle
      _rollbackStyle = source._rollbackStyle
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._presetStyle, !v.isInitialized {return false}
      if let v = _storage._rollbackStyle, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._presetStyle) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._rollbackStyle) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._presetStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._rollbackStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_BaseApplyPresetCommandArchive, rhs: TSD_BaseApplyPresetCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._presetStyle != rhs_storage._presetStyle {return false}
        if _storage._rollbackStyle != rhs_storage._rollbackStyle {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ShapeApplyPresetCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShapeApplyPresetCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ShapeApplyPresetCommandArchive, rhs: TSD_ShapeApplyPresetCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_MediaApplyPresetCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaApplyPresetCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_MediaApplyPresetCommandArchive, rhs: TSD_MediaApplyPresetCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ShapeStyleSetValueCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShapeStyleSetValueCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{2}\u{3}change\0")

  fileprivate class _StorageClass {
    var _super: TSD_BaseStyleSetValueCommandArchive? = nil
    var _change: TSDSOS_BaseShapeStylePropertyChangeSetArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _change = source._change
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._change, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._change) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._change {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ShapeStyleSetValueCommandArchive, rhs: TSD_ShapeStyleSetValueCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._change != rhs_storage._change {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_BaseStyleSetValueCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BaseStyleSetValueCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{3}old_style\0\u{3}is_border_change\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._isBorderChange == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._oldStyle, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._oldStyle) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._isBorderChange) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oldStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._isBorderChange {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_BaseStyleSetValueCommandArchive, rhs: TSD_BaseStyleSetValueCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._oldStyle != rhs._oldStyle {return false}
    if lhs._isBorderChange != rhs._isBorderChange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_MovieSetValueCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MovieSetValueCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}property\0\u{1}value\0\u{1}oldValue\0\u{1}importedauxiliarymedia\0\u{1}oldimportedauxiliarymedia\0")

  fileprivate class _StorageClass {
    var _super: TSD_InfoCommandArchive? = nil
    var _property: Int32? = nil
    var _value: TSD_MovieSetValueCommandArchive.PropertyValue? = nil
    var _oldValue: TSD_MovieSetValueCommandArchive.PropertyValue? = nil
    var _importedauxiliarymedia: TSP_DataReference? = nil
    var _oldimportedauxiliarymedia: TSP_DataReference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _property = source._property
      _value = source._value
      _oldValue = source._oldValue
      _importedauxiliarymedia = source._importedauxiliarymedia
      _oldimportedauxiliarymedia = source._oldimportedauxiliarymedia
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._value, !v.isInitialized {return false}
      if let v = _storage._oldValue, !v.isInitialized {return false}
      if let v = _storage._importedauxiliarymedia, !v.isInitialized {return false}
      if let v = _storage._oldimportedauxiliarymedia, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._property) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._value) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._oldValue) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._importedauxiliarymedia) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._oldimportedauxiliarymedia) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._property {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._oldValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._importedauxiliarymedia {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._oldimportedauxiliarymedia {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_MovieSetValueCommandArchive, rhs: TSD_MovieSetValueCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._property != rhs_storage._property {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._oldValue != rhs_storage._oldValue {return false}
        if _storage._importedauxiliarymedia != rhs_storage._importedauxiliarymedia {return false}
        if _storage._oldimportedauxiliarymedia != rhs_storage._oldimportedauxiliarymedia {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_MovieSetValueCommandArchive.LoopOption: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0None\0\u{1}Repeat\0\u{1}BackAndForth\0")
}

extension TSD_MovieSetValueCommandArchive.PropertyValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSD_MovieSetValueCommandArchive.protoMessageName + ".PropertyValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}starttime\0\u{1}endtime\0\u{1}postertime\0\u{1}posterimagedata\0\u{1}autoplay\0\u{1}loopOption\0\u{1}volume\0\u{1}media\0\u{1}playsAcrossSlides\0")

  public var isInitialized: Bool {
    if let v = self._posterimagedata, !v.isInitialized {return false}
    if let v = self._media, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._starttime) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._endtime) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self._postertime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._posterimagedata) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._autoplay) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._loopOption) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self._volume) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._media) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self._playsAcrossSlides) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._starttime {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endtime {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._postertime {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._posterimagedata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._autoplay {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._loopOption {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._volume {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._media {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._playsAcrossSlides {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_MovieSetValueCommandArchive.PropertyValue, rhs: TSD_MovieSetValueCommandArchive.PropertyValue) -> Bool {
    if lhs._starttime != rhs._starttime {return false}
    if lhs._endtime != rhs._endtime {return false}
    if lhs._postertime != rhs._postertime {return false}
    if lhs._posterimagedata != rhs._posterimagedata {return false}
    if lhs._autoplay != rhs._autoplay {return false}
    if lhs._loopOption != rhs._loopOption {return false}
    if lhs._volume != rhs._volume {return false}
    if lhs._media != rhs._media {return false}
    if lhs._playsAcrossSlides != rhs._playsAcrossSlides {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_MediaStyleSetValueCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaStyleSetValueCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{2}\u{3}change\0")

  fileprivate class _StorageClass {
    var _super: TSD_BaseStyleSetValueCommandArchive? = nil
    var _change: TSDSOS_MediaStylePropertyChangeSetArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _change = source._change
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._change, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._change) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._change {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_MediaStyleSetValueCommandArchive, rhs: TSD_MediaStyleSetValueCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._change != rhs_storage._change {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ImageMediaCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageMediaCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{2}database_newImageData\0\u{3}database_oldImageData\0\u{3}database_oldOriginalImageData\0\u{1}oldNaturalSize\0\u{3}database_newOriginalImageData\0\u{1}newImageData\0\u{1}oldImageData\0\u{1}oldOriginalImageData\0\u{1}newOriginalImageData\0\u{1}oldImageAdjustments\0\u{1}oldAdjustedImageData\0\u{1}oldEnhancedImageData\0\u{1}imageAdjustments\0\u{1}adjustedImageData\0\u{1}enhancedImageData\0\u{1}newThumbnailImageData\0\u{1}oldThumbnailImageData\0\u{1}thumbnailAdjustedImageData\0\u{1}oldThumbnailAdjustedImageData\0")

  fileprivate class _StorageClass {
    var _super: TSD_InfoCommandArchive? = nil
    var _newImageData: TSP_DataReference? = nil
    var _oldImageData: TSP_DataReference? = nil
    var _oldOriginalImageData: TSP_DataReference? = nil
    var _oldNaturalSize: TSP_Size? = nil
    var _newOriginalImageData: TSP_DataReference? = nil
    var _oldImageAdjustments: TSD_ImageAdjustmentsArchive? = nil
    var _oldAdjustedImageData: TSP_DataReference? = nil
    var _oldEnhancedImageData: TSP_DataReference? = nil
    var _imageAdjustments: TSD_ImageAdjustmentsArchive? = nil
    var _adjustedImageData: TSP_DataReference? = nil
    var _enhancedImageData: TSP_DataReference? = nil
    var _newThumbnailImageData: TSP_DataReference? = nil
    var _oldThumbnailImageData: TSP_DataReference? = nil
    var _thumbnailAdjustedImageData: TSP_DataReference? = nil
    var _oldThumbnailAdjustedImageData: TSP_DataReference? = nil
    var _databaseNewImageData: TSP_Reference? = nil
    var _databaseOldImageData: TSP_Reference? = nil
    var _databaseOldOriginalImageData: TSP_Reference? = nil
    var _databaseNewOriginalImageData: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _newImageData = source._newImageData
      _oldImageData = source._oldImageData
      _oldOriginalImageData = source._oldOriginalImageData
      _oldNaturalSize = source._oldNaturalSize
      _newOriginalImageData = source._newOriginalImageData
      _oldImageAdjustments = source._oldImageAdjustments
      _oldAdjustedImageData = source._oldAdjustedImageData
      _oldEnhancedImageData = source._oldEnhancedImageData
      _imageAdjustments = source._imageAdjustments
      _adjustedImageData = source._adjustedImageData
      _enhancedImageData = source._enhancedImageData
      _newThumbnailImageData = source._newThumbnailImageData
      _oldThumbnailImageData = source._oldThumbnailImageData
      _thumbnailAdjustedImageData = source._thumbnailAdjustedImageData
      _oldThumbnailAdjustedImageData = source._oldThumbnailAdjustedImageData
      _databaseNewImageData = source._databaseNewImageData
      _databaseOldImageData = source._databaseOldImageData
      _databaseOldOriginalImageData = source._databaseOldOriginalImageData
      _databaseNewOriginalImageData = source._databaseNewOriginalImageData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._newImageData, !v.isInitialized {return false}
      if let v = _storage._oldImageData, !v.isInitialized {return false}
      if let v = _storage._oldOriginalImageData, !v.isInitialized {return false}
      if let v = _storage._oldNaturalSize, !v.isInitialized {return false}
      if let v = _storage._newOriginalImageData, !v.isInitialized {return false}
      if let v = _storage._oldAdjustedImageData, !v.isInitialized {return false}
      if let v = _storage._oldEnhancedImageData, !v.isInitialized {return false}
      if let v = _storage._adjustedImageData, !v.isInitialized {return false}
      if let v = _storage._enhancedImageData, !v.isInitialized {return false}
      if let v = _storage._newThumbnailImageData, !v.isInitialized {return false}
      if let v = _storage._oldThumbnailImageData, !v.isInitialized {return false}
      if let v = _storage._thumbnailAdjustedImageData, !v.isInitialized {return false}
      if let v = _storage._oldThumbnailAdjustedImageData, !v.isInitialized {return false}
      if let v = _storage._databaseNewImageData, !v.isInitialized {return false}
      if let v = _storage._databaseOldImageData, !v.isInitialized {return false}
      if let v = _storage._databaseOldOriginalImageData, !v.isInitialized {return false}
      if let v = _storage._databaseNewOriginalImageData, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._databaseNewImageData) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._databaseOldImageData) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._databaseOldOriginalImageData) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._oldNaturalSize) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._databaseNewOriginalImageData) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._newImageData) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._oldImageData) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._oldOriginalImageData) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._newOriginalImageData) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._oldImageAdjustments) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._oldAdjustedImageData) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._oldEnhancedImageData) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._imageAdjustments) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._adjustedImageData) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._enhancedImageData) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._newThumbnailImageData) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._oldThumbnailImageData) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._thumbnailAdjustedImageData) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._oldThumbnailAdjustedImageData) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._databaseNewImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._databaseOldImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._databaseOldOriginalImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._oldNaturalSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._databaseNewOriginalImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._newImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._oldImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._oldOriginalImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._newOriginalImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._oldImageAdjustments {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._oldAdjustedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._oldEnhancedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._imageAdjustments {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._adjustedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._enhancedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._newThumbnailImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._oldThumbnailImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._thumbnailAdjustedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._oldThumbnailAdjustedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ImageMediaCommandArchive, rhs: TSD_ImageMediaCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._newImageData != rhs_storage._newImageData {return false}
        if _storage._oldImageData != rhs_storage._oldImageData {return false}
        if _storage._oldOriginalImageData != rhs_storage._oldOriginalImageData {return false}
        if _storage._oldNaturalSize != rhs_storage._oldNaturalSize {return false}
        if _storage._newOriginalImageData != rhs_storage._newOriginalImageData {return false}
        if _storage._oldImageAdjustments != rhs_storage._oldImageAdjustments {return false}
        if _storage._oldAdjustedImageData != rhs_storage._oldAdjustedImageData {return false}
        if _storage._oldEnhancedImageData != rhs_storage._oldEnhancedImageData {return false}
        if _storage._imageAdjustments != rhs_storage._imageAdjustments {return false}
        if _storage._adjustedImageData != rhs_storage._adjustedImageData {return false}
        if _storage._enhancedImageData != rhs_storage._enhancedImageData {return false}
        if _storage._newThumbnailImageData != rhs_storage._newThumbnailImageData {return false}
        if _storage._oldThumbnailImageData != rhs_storage._oldThumbnailImageData {return false}
        if _storage._thumbnailAdjustedImageData != rhs_storage._thumbnailAdjustedImageData {return false}
        if _storage._oldThumbnailAdjustedImageData != rhs_storage._oldThumbnailAdjustedImageData {return false}
        if _storage._databaseNewImageData != rhs_storage._databaseNewImageData {return false}
        if _storage._databaseOldImageData != rhs_storage._databaseOldImageData {return false}
        if _storage._databaseOldOriginalImageData != rhs_storage._databaseOldOriginalImageData {return false}
        if _storage._databaseNewOriginalImageData != rhs_storage._databaseNewOriginalImageData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_MediaOriginalSizeCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaOriginalSizeCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}newOriginalSize\0\u{1}oldOriginalSize\0\u{1}propertyName\0")

  fileprivate class _StorageClass {
    var _super: TSD_InfoCommandArchive? = nil
    var _newOriginalSize: TSP_Size? = nil
    var _oldOriginalSize: TSP_Size? = nil
    var _propertyName: String? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _newOriginalSize = source._newOriginalSize
      _oldOriginalSize = source._oldOriginalSize
      _propertyName = source._propertyName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._propertyName == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._newOriginalSize, !v.isInitialized {return false}
      if let v = _storage._oldOriginalSize, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._newOriginalSize) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._oldOriginalSize) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._propertyName) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._newOriginalSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._oldOriginalSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._propertyName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_MediaOriginalSizeCommandArchive, rhs: TSD_MediaOriginalSizeCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._newOriginalSize != rhs_storage._newOriginalSize {return false}
        if _storage._oldOriginalSize != rhs_storage._oldOriginalSize {return false}
        if _storage._propertyName != rhs_storage._propertyName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_MediaInfoGeometryCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaInfoGeometryCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}newOriginalSize\0\u{1}oldOriginalSize\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._newOriginalSize == nil {return false}
    if self._oldOriginalSize == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._newOriginalSize, !v.isInitialized {return false}
    if let v = self._oldOriginalSize, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newOriginalSize) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._oldOriginalSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newOriginalSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._oldOriginalSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_MediaInfoGeometryCommandArchive, rhs: TSD_MediaInfoGeometryCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._newOriginalSize != rhs._newOriginalSize {return false}
    if lhs._oldOriginalSize != rhs._oldOriginalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ImageNaturalSizeCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageNaturalSizeCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}new_natural_size\0\u{3}old_natural_size\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._newNaturalSize, !v.isInitialized {return false}
    if let v = self._oldNaturalSize, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newNaturalSize) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._oldNaturalSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newNaturalSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._oldNaturalSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ImageNaturalSizeCommandArchive, rhs: TSD_ImageNaturalSizeCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._newNaturalSize != rhs._newNaturalSize {return false}
    if lhs._oldNaturalSize != rhs._oldNaturalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ImageMaskCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageMaskCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}newMaskInfo\0\u{1}oldMaskInfo\0\u{3}background_removed\0\u{3}old_background_removed\0")

  fileprivate class _StorageClass {
    var _super: TSD_InfoCommandArchive? = nil
    var _newMaskInfo: TSP_Reference? = nil
    var _oldMaskInfo: TSP_Reference? = nil
    var _backgroundRemoved: Bool? = nil
    var _oldBackgroundRemoved: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _newMaskInfo = source._newMaskInfo
      _oldMaskInfo = source._oldMaskInfo
      _backgroundRemoved = source._backgroundRemoved
      _oldBackgroundRemoved = source._oldBackgroundRemoved
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._newMaskInfo, !v.isInitialized {return false}
      if let v = _storage._oldMaskInfo, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._newMaskInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._oldMaskInfo) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._backgroundRemoved) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._oldBackgroundRemoved) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._newMaskInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._oldMaskInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._backgroundRemoved {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._oldBackgroundRemoved {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ImageMaskCommandArchive, rhs: TSD_ImageMaskCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._newMaskInfo != rhs_storage._newMaskInfo {return false}
        if _storage._oldMaskInfo != rhs_storage._oldMaskInfo {return false}
        if _storage._backgroundRemoved != rhs_storage._backgroundRemoved {return false}
        if _storage._oldBackgroundRemoved != rhs_storage._oldBackgroundRemoved {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ImageAdjustmentsCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageAdjustmentsCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}old_image_adjustments\0\u{3}new_image_adjustments\0\u{1}adjustedImageData\0\u{1}replacedAdjustedImageData\0\u{1}enhancedImageData\0\u{1}replacedEnhancedImageData\0\u{1}thumbnailAdjustedImageData\0\u{1}replacedThumbnailAdjustedImageData\0")

  fileprivate class _StorageClass {
    var _super: TSD_InfoCommandArchive? = nil
    var _oldImageAdjustments: TSD_ImageAdjustmentsArchive? = nil
    var _newImageAdjustments: TSD_ImageAdjustmentsArchive? = nil
    var _adjustedImageData: TSP_DataReference? = nil
    var _replacedAdjustedImageData: TSP_DataReference? = nil
    var _enhancedImageData: TSP_DataReference? = nil
    var _replacedEnhancedImageData: TSP_DataReference? = nil
    var _thumbnailAdjustedImageData: TSP_DataReference? = nil
    var _replacedThumbnailAdjustedImageData: TSP_DataReference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _oldImageAdjustments = source._oldImageAdjustments
      _newImageAdjustments = source._newImageAdjustments
      _adjustedImageData = source._adjustedImageData
      _replacedAdjustedImageData = source._replacedAdjustedImageData
      _enhancedImageData = source._enhancedImageData
      _replacedEnhancedImageData = source._replacedEnhancedImageData
      _thumbnailAdjustedImageData = source._thumbnailAdjustedImageData
      _replacedThumbnailAdjustedImageData = source._replacedThumbnailAdjustedImageData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._adjustedImageData, !v.isInitialized {return false}
      if let v = _storage._replacedAdjustedImageData, !v.isInitialized {return false}
      if let v = _storage._enhancedImageData, !v.isInitialized {return false}
      if let v = _storage._replacedEnhancedImageData, !v.isInitialized {return false}
      if let v = _storage._thumbnailAdjustedImageData, !v.isInitialized {return false}
      if let v = _storage._replacedThumbnailAdjustedImageData, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._oldImageAdjustments) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._newImageAdjustments) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._adjustedImageData) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._replacedAdjustedImageData) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._enhancedImageData) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._replacedEnhancedImageData) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._thumbnailAdjustedImageData) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._replacedThumbnailAdjustedImageData) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._oldImageAdjustments {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._newImageAdjustments {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._adjustedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._replacedAdjustedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._enhancedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._replacedEnhancedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._thumbnailAdjustedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._replacedThumbnailAdjustedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ImageAdjustmentsCommandArchive, rhs: TSD_ImageAdjustmentsCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._oldImageAdjustments != rhs_storage._oldImageAdjustments {return false}
        if _storage._newImageAdjustments != rhs_storage._newImageAdjustments {return false}
        if _storage._adjustedImageData != rhs_storage._adjustedImageData {return false}
        if _storage._replacedAdjustedImageData != rhs_storage._replacedAdjustedImageData {return false}
        if _storage._enhancedImageData != rhs_storage._enhancedImageData {return false}
        if _storage._replacedEnhancedImageData != rhs_storage._replacedEnhancedImageData {return false}
        if _storage._thumbnailAdjustedImageData != rhs_storage._thumbnailAdjustedImageData {return false}
        if _storage._replacedThumbnailAdjustedImageData != rhs_storage._replacedThumbnailAdjustedImageData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_MediaFlagsCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaFlagsCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{3}property_name\0\u{3}was_media_replaced\0\u{3}is_placeholder\0\u{3}old_was_media_replaced\0\u{3}old_is_placeholder\0")

  fileprivate class _StorageClass {
    var _super: TSD_InfoCommandArchive? = nil
    var _wasMediaReplaced: Bool? = nil
    var _isPlaceholder: Bool? = nil
    var _oldWasMediaReplaced: Bool? = nil
    var _oldIsPlaceholder: Bool? = nil
    var _propertyName: String? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _wasMediaReplaced = source._wasMediaReplaced
      _isPlaceholder = source._isPlaceholder
      _oldWasMediaReplaced = source._oldWasMediaReplaced
      _oldIsPlaceholder = source._oldIsPlaceholder
      _propertyName = source._propertyName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._propertyName == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._propertyName) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._wasMediaReplaced) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._isPlaceholder) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._oldWasMediaReplaced) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._oldIsPlaceholder) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._propertyName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._wasMediaReplaced {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._isPlaceholder {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._oldWasMediaReplaced {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._oldIsPlaceholder {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_MediaFlagsCommandArchive, rhs: TSD_MediaFlagsCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._wasMediaReplaced != rhs_storage._wasMediaReplaced {return false}
        if _storage._isPlaceholder != rhs_storage._isPlaceholder {return false}
        if _storage._oldWasMediaReplaced != rhs_storage._oldWasMediaReplaced {return false}
        if _storage._oldIsPlaceholder != rhs_storage._oldIsPlaceholder {return false}
        if _storage._propertyName != rhs_storage._propertyName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_DrawablesCommandGroupArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawablesCommandGroupArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}obsolete_selection\0\u{1}modelforselection\0\u{1}type\0\u{1}forDrag\0\u{1}archivedselection\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandGroupArchive? = nil
    var _obsoleteSelection: TSD_CanvasSelectionArchive? = nil
    var _modelforselection: TSP_Reference? = nil
    var _type: TSD_DrawablesCommandGroupArchive.DrawablesCommandGroupType? = nil
    var _forDrag: Bool? = nil
    var _archivedselection: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _obsoleteSelection = source._obsoleteSelection
      _modelforselection = source._modelforselection
      _type = source._type
      _forDrag = source._forDrag
      _archivedselection = source._archivedselection
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._obsoleteSelection, !v.isInitialized {return false}
      if let v = _storage._modelforselection, !v.isInitialized {return false}
      if let v = _storage._archivedselection, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._obsoleteSelection) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._modelforselection) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._forDrag) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._archivedselection) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._obsoleteSelection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._modelforselection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._forDrag {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._archivedselection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_DrawablesCommandGroupArchive, rhs: TSD_DrawablesCommandGroupArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._obsoleteSelection != rhs_storage._obsoleteSelection {return false}
        if _storage._modelforselection != rhs_storage._modelforselection {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._forDrag != rhs_storage._forDrag {return false}
        if _storage._archivedselection != rhs_storage._archivedselection {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_DrawablesCommandGroupArchive.DrawablesCommandGroupType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}Constructive\0\u{1}Destructive\0\u{1}InPlace\0")
}

extension TSD_ExteriorTextWrapCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExteriorTextWrapCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{2}old_exterior_text_wrap\0\u{1}type\0\u{1}direction\0\u{3}fit_type\0\u{1}margin\0\u{3}alpha_threshold\0\u{3}is_html_wrap\0")

  fileprivate class _StorageClass {
    var _super: TSD_InfoCommandArchive? = nil
    var _oldExteriorTextWrap: TSD_ExteriorTextWrapArchive? = nil
    var _type: UInt32? = nil
    var _direction: UInt32? = nil
    var _fitType: UInt32? = nil
    var _margin: Float? = nil
    var _alphaThreshold: Float? = nil
    var _isHtmlWrap: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _oldExteriorTextWrap = source._oldExteriorTextWrap
      _type = source._type
      _direction = source._direction
      _fitType = source._fitType
      _margin = source._margin
      _alphaThreshold = source._alphaThreshold
      _isHtmlWrap = source._isHtmlWrap
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._oldExteriorTextWrap) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._type) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._direction) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._fitType) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._margin) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._alphaThreshold) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._isHtmlWrap) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._oldExteriorTextWrap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._type {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._direction {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._fitType {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._margin {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._alphaThreshold {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._isHtmlWrap {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ExteriorTextWrapCommandArchive, rhs: TSD_ExteriorTextWrapCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._oldExteriorTextWrap != rhs_storage._oldExteriorTextWrap {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._direction != rhs_storage._direction {return false}
        if _storage._fitType != rhs_storage._fitType {return false}
        if _storage._margin != rhs_storage._margin {return false}
        if _storage._alphaThreshold != rhs_storage._alphaThreshold {return false}
        if _storage._isHtmlWrap != rhs_storage._isHtmlWrap {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_DrawableHyperlinkCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawableHyperlinkCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}oldhyperlink_url\0\u{3}newhyperlink_url\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._oldhyperlinkURL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._newhyperlinkURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oldhyperlinkURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newhyperlinkURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_DrawableHyperlinkCommandArchive, rhs: TSD_DrawableHyperlinkCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._oldhyperlinkURL != rhs._oldhyperlinkURL {return false}
    if lhs._newhyperlinkURL != rhs._newhyperlinkURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_CommentInvalidatingCommandSelectionBehaviorArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommentInvalidatingCommandSelectionBehaviorArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}annotation_displaying_command\0\u{3}begin_editing_on_undo\0\u{3}begin_editing_on_redo\0\u{3}should_invalidate_on_undo\0\u{3}should_invalidate_on_redo\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._annotationDisplayingCommand, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._annotationDisplayingCommand) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._beginEditingOnUndo) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._beginEditingOnRedo) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._shouldInvalidateOnUndo) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._shouldInvalidateOnRedo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._annotationDisplayingCommand {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._beginEditingOnUndo {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._beginEditingOnRedo {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._shouldInvalidateOnUndo {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._shouldInvalidateOnRedo {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_CommentInvalidatingCommandSelectionBehaviorArchive, rhs: TSD_CommentInvalidatingCommandSelectionBehaviorArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._annotationDisplayingCommand != rhs._annotationDisplayingCommand {return false}
    if lhs._beginEditingOnUndo != rhs._beginEditingOnUndo {return false}
    if lhs._beginEditingOnRedo != rhs._beginEditingOnRedo {return false}
    if lhs._shouldInvalidateOnUndo != rhs._shouldInvalidateOnUndo {return false}
    if lhs._shouldInvalidateOnRedo != rhs._shouldInvalidateOnRedo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ImageReplaceCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageReplaceCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}new_image_data\0\u{3}new_original_image_data\0\u{3}old_image_data\0\u{3}old_original_image_data\0\u{3}instant_alpha_path\0\u{3}old_instant_alpha_path\0\u{3}natural_size_for_IAPath\0\u{3}old_natural_size_for_IAPath\0\u{3}target_image_geometry\0\u{4}\u{2}old_target_image_geometry\0\u{3}target_mask_geometry\0\u{3}old_target_mask_geometry\0\u{3}image_adjustments\0\u{3}adjusted_image_data\0\u{3}enhanced_image_data\0\u{3}old_image_adjustments\0\u{3}old_adjusted_image_data\0\u{3}old_enhanced_image_data\0\u{3}thumbnail_image_data\0\u{3}old_thumbnail_image_data\0\u{3}thumbnail_adjusted_image_data\0\u{3}old_thumbnail_adjusted_image_data\0\u{3}natural_size\0\u{3}old_natural_size\0")

  fileprivate class _StorageClass {
    var _super: TSD_InfoCommandArchive? = nil
    var _newImageData: TSP_DataReference? = nil
    var _newOriginalImageData: TSP_DataReference? = nil
    var _oldImageData: TSP_DataReference? = nil
    var _oldOriginalImageData: TSP_DataReference? = nil
    var _instantAlphaPath: TSP_Path? = nil
    var _oldInstantAlphaPath: TSP_Path? = nil
    var _naturalSizeForIapath: TSP_Size? = nil
    var _oldNaturalSizeForIapath: TSP_Size? = nil
    var _targetImageGeometry: TSD_GeometryArchive? = nil
    var _oldTargetImageGeometry: TSD_GeometryArchive? = nil
    var _targetMaskGeometry: TSD_GeometryArchive? = nil
    var _oldTargetMaskGeometry: TSD_GeometryArchive? = nil
    var _imageAdjustments: TSD_ImageAdjustmentsArchive? = nil
    var _adjustedImageData: TSP_DataReference? = nil
    var _enhancedImageData: TSP_DataReference? = nil
    var _oldImageAdjustments: TSD_ImageAdjustmentsArchive? = nil
    var _oldAdjustedImageData: TSP_DataReference? = nil
    var _oldEnhancedImageData: TSP_DataReference? = nil
    var _thumbnailImageData: TSP_DataReference? = nil
    var _oldThumbnailImageData: TSP_DataReference? = nil
    var _thumbnailAdjustedImageData: TSP_DataReference? = nil
    var _oldThumbnailAdjustedImageData: TSP_DataReference? = nil
    var _naturalSize: TSP_Size? = nil
    var _oldNaturalSize: TSP_Size? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _newImageData = source._newImageData
      _newOriginalImageData = source._newOriginalImageData
      _oldImageData = source._oldImageData
      _oldOriginalImageData = source._oldOriginalImageData
      _instantAlphaPath = source._instantAlphaPath
      _oldInstantAlphaPath = source._oldInstantAlphaPath
      _naturalSizeForIapath = source._naturalSizeForIapath
      _oldNaturalSizeForIapath = source._oldNaturalSizeForIapath
      _targetImageGeometry = source._targetImageGeometry
      _oldTargetImageGeometry = source._oldTargetImageGeometry
      _targetMaskGeometry = source._targetMaskGeometry
      _oldTargetMaskGeometry = source._oldTargetMaskGeometry
      _imageAdjustments = source._imageAdjustments
      _adjustedImageData = source._adjustedImageData
      _enhancedImageData = source._enhancedImageData
      _oldImageAdjustments = source._oldImageAdjustments
      _oldAdjustedImageData = source._oldAdjustedImageData
      _oldEnhancedImageData = source._oldEnhancedImageData
      _thumbnailImageData = source._thumbnailImageData
      _oldThumbnailImageData = source._oldThumbnailImageData
      _thumbnailAdjustedImageData = source._thumbnailAdjustedImageData
      _oldThumbnailAdjustedImageData = source._oldThumbnailAdjustedImageData
      _naturalSize = source._naturalSize
      _oldNaturalSize = source._oldNaturalSize
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._newImageData, !v.isInitialized {return false}
      if let v = _storage._newOriginalImageData, !v.isInitialized {return false}
      if let v = _storage._oldImageData, !v.isInitialized {return false}
      if let v = _storage._oldOriginalImageData, !v.isInitialized {return false}
      if let v = _storage._instantAlphaPath, !v.isInitialized {return false}
      if let v = _storage._oldInstantAlphaPath, !v.isInitialized {return false}
      if let v = _storage._naturalSizeForIapath, !v.isInitialized {return false}
      if let v = _storage._oldNaturalSizeForIapath, !v.isInitialized {return false}
      if let v = _storage._targetImageGeometry, !v.isInitialized {return false}
      if let v = _storage._oldTargetImageGeometry, !v.isInitialized {return false}
      if let v = _storage._targetMaskGeometry, !v.isInitialized {return false}
      if let v = _storage._oldTargetMaskGeometry, !v.isInitialized {return false}
      if let v = _storage._adjustedImageData, !v.isInitialized {return false}
      if let v = _storage._enhancedImageData, !v.isInitialized {return false}
      if let v = _storage._oldAdjustedImageData, !v.isInitialized {return false}
      if let v = _storage._oldEnhancedImageData, !v.isInitialized {return false}
      if let v = _storage._thumbnailImageData, !v.isInitialized {return false}
      if let v = _storage._oldThumbnailImageData, !v.isInitialized {return false}
      if let v = _storage._thumbnailAdjustedImageData, !v.isInitialized {return false}
      if let v = _storage._oldThumbnailAdjustedImageData, !v.isInitialized {return false}
      if let v = _storage._naturalSize, !v.isInitialized {return false}
      if let v = _storage._oldNaturalSize, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._newImageData) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._newOriginalImageData) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._oldImageData) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._oldOriginalImageData) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._instantAlphaPath) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._oldInstantAlphaPath) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._naturalSizeForIapath) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._oldNaturalSizeForIapath) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._targetImageGeometry) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._oldTargetImageGeometry) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._targetMaskGeometry) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._oldTargetMaskGeometry) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._imageAdjustments) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._adjustedImageData) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._enhancedImageData) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._oldImageAdjustments) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._oldAdjustedImageData) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._oldEnhancedImageData) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._thumbnailImageData) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._oldThumbnailImageData) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._thumbnailAdjustedImageData) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._oldThumbnailAdjustedImageData) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._naturalSize) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._oldNaturalSize) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._newImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._newOriginalImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._oldImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._oldOriginalImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._instantAlphaPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._oldInstantAlphaPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._naturalSizeForIapath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._oldNaturalSizeForIapath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._targetImageGeometry {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._oldTargetImageGeometry {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._targetMaskGeometry {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._oldTargetMaskGeometry {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._imageAdjustments {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._adjustedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._enhancedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._oldImageAdjustments {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._oldAdjustedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._oldEnhancedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._thumbnailImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._oldThumbnailImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._thumbnailAdjustedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._oldThumbnailAdjustedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._naturalSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._oldNaturalSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ImageReplaceCommandArchive, rhs: TSD_ImageReplaceCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._newImageData != rhs_storage._newImageData {return false}
        if _storage._newOriginalImageData != rhs_storage._newOriginalImageData {return false}
        if _storage._oldImageData != rhs_storage._oldImageData {return false}
        if _storage._oldOriginalImageData != rhs_storage._oldOriginalImageData {return false}
        if _storage._instantAlphaPath != rhs_storage._instantAlphaPath {return false}
        if _storage._oldInstantAlphaPath != rhs_storage._oldInstantAlphaPath {return false}
        if _storage._naturalSizeForIapath != rhs_storage._naturalSizeForIapath {return false}
        if _storage._oldNaturalSizeForIapath != rhs_storage._oldNaturalSizeForIapath {return false}
        if _storage._targetImageGeometry != rhs_storage._targetImageGeometry {return false}
        if _storage._oldTargetImageGeometry != rhs_storage._oldTargetImageGeometry {return false}
        if _storage._targetMaskGeometry != rhs_storage._targetMaskGeometry {return false}
        if _storage._oldTargetMaskGeometry != rhs_storage._oldTargetMaskGeometry {return false}
        if _storage._imageAdjustments != rhs_storage._imageAdjustments {return false}
        if _storage._adjustedImageData != rhs_storage._adjustedImageData {return false}
        if _storage._enhancedImageData != rhs_storage._enhancedImageData {return false}
        if _storage._oldImageAdjustments != rhs_storage._oldImageAdjustments {return false}
        if _storage._oldAdjustedImageData != rhs_storage._oldAdjustedImageData {return false}
        if _storage._oldEnhancedImageData != rhs_storage._oldEnhancedImageData {return false}
        if _storage._thumbnailImageData != rhs_storage._thumbnailImageData {return false}
        if _storage._oldThumbnailImageData != rhs_storage._oldThumbnailImageData {return false}
        if _storage._thumbnailAdjustedImageData != rhs_storage._thumbnailAdjustedImageData {return false}
        if _storage._oldThumbnailAdjustedImageData != rhs_storage._oldThumbnailAdjustedImageData {return false}
        if _storage._naturalSize != rhs_storage._naturalSize {return false}
        if _storage._oldNaturalSize != rhs_storage._oldNaturalSize {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_DrawableLockCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawableLockCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}locked\0\u{3}was_locked\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._locked) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._wasLocked) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._locked {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._wasLocked {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_DrawableLockCommandArchive, rhs: TSD_DrawableLockCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._locked != rhs._locked {return false}
    if lhs._wasLocked != rhs._wasLocked {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_DrawableInfoCommentCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawableInfoCommentCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}old_comment\0\u{3}new_comment\0\u{3}forward_variant\0\u{3}inverse_variant\0")

  fileprivate class _StorageClass {
    var _super: TSD_InfoCommandArchive? = nil
    var _oldComment: TSP_Reference? = nil
    var _newComment: TSP_Reference? = nil
    var _forwardVariant: TSD_CommentCommandVariant? = nil
    var _inverseVariant: TSD_CommentCommandVariant? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _oldComment = source._oldComment
      _newComment = source._newComment
      _forwardVariant = source._forwardVariant
      _inverseVariant = source._inverseVariant
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._oldComment, !v.isInitialized {return false}
      if let v = _storage._newComment, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._oldComment) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._newComment) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._forwardVariant) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._inverseVariant) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._oldComment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._newComment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._forwardVariant {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._inverseVariant {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_DrawableInfoCommentCommandArchive, rhs: TSD_DrawableInfoCommentCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._oldComment != rhs_storage._oldComment {return false}
        if _storage._newComment != rhs_storage._newComment {return false}
        if _storage._forwardVariant != rhs_storage._forwardVariant {return false}
        if _storage._inverseVariant != rhs_storage._inverseVariant {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_DrawablePencilAnnotationCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawablePencilAnnotationCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}pencil_annotation_to_add\0\u{3}pencil_annotation_to_remove\0")

  fileprivate class _StorageClass {
    var _super: TSD_InfoCommandArchive? = nil
    var _pencilAnnotationToAdd: TSP_Reference? = nil
    var _pencilAnnotationToRemove: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _pencilAnnotationToAdd = source._pencilAnnotationToAdd
      _pencilAnnotationToRemove = source._pencilAnnotationToRemove
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._pencilAnnotationToAdd, !v.isInitialized {return false}
      if let v = _storage._pencilAnnotationToRemove, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._pencilAnnotationToAdd) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._pencilAnnotationToRemove) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._pencilAnnotationToAdd {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._pencilAnnotationToRemove {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_DrawablePencilAnnotationCommandArchive, rhs: TSD_DrawablePencilAnnotationCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._pencilAnnotationToAdd != rhs_storage._pencilAnnotationToAdd {return false}
        if _storage._pencilAnnotationToRemove != rhs_storage._pencilAnnotationToRemove {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_AbstractGuideCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AbstractGuideCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{6}old_guides\0\u{3}new_guides\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.oldGuides) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.newGuides) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.oldGuides.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldGuides, fieldNumber: 7)
    }
    if !self.newGuides.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.newGuides, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_AbstractGuideCommandArchive, rhs: TSD_AbstractGuideCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.oldGuides != rhs.oldGuides {return false}
    if lhs.newGuides != rhs.newGuides {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_GuideCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GuideCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}storage_id_path\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._storageIDPath == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._storageIDPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._storageIDPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._storageIDPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_GuideCommandArchive, rhs: TSD_GuideCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._storageIDPath != rhs._storageIDPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_DrawableAspectRatioLockedCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawableAspectRatioLockedCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}aspect_ratio_locked\0\u{3}was_aspect_ratio_locked\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._aspectRatioLocked) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._wasAspectRatioLocked) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._aspectRatioLocked {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._wasAspectRatioLocked {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_DrawableAspectRatioLockedCommandArchive, rhs: TSD_DrawableAspectRatioLockedCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._aspectRatioLocked != rhs._aspectRatioLocked {return false}
    if lhs._wasAspectRatioLocked != rhs._wasAspectRatioLocked {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_DrawableAccessibilityDescriptionCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawableAccessibilityDescriptionCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}accessibility_description\0\u{3}old_accessibility_description\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._accessibilityDescription) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._oldAccessibilityDescription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accessibilityDescription {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._oldAccessibilityDescription {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_DrawableAccessibilityDescriptionCommandArchive, rhs: TSD_DrawableAccessibilityDescriptionCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._accessibilityDescription != rhs._accessibilityDescription {return false}
    if lhs._oldAccessibilityDescription != rhs._oldAccessibilityDescription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_PasteStyleCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PasteStyleCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}new_style\0\u{4}\u{2}tail_end_on_left\0\u{3}rollback_style\0")

  fileprivate class _StorageClass {
    var _super: TSD_AbstractStyleCommandArchive? = nil
    var _newStyle: TSP_Reference? = nil
    var _rollbackStyle: TSP_Reference? = nil
    var _tailEndOnLeft: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _newStyle = source._newStyle
      _rollbackStyle = source._rollbackStyle
      _tailEndOnLeft = source._tailEndOnLeft
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._newStyle, !v.isInitialized {return false}
      if let v = _storage._rollbackStyle, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._newStyle) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._tailEndOnLeft) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._rollbackStyle) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._newStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._tailEndOnLeft {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._rollbackStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_PasteStyleCommandArchive, rhs: TSD_PasteStyleCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._newStyle != rhs_storage._newStyle {return false}
        if _storage._rollbackStyle != rhs_storage._rollbackStyle {return false}
        if _storage._tailEndOnLeft != rhs_storage._tailEndOnLeft {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ImageInfoAbstractGeometryCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageInfoAbstractGeometryCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}new_image_geometry\0\u{3}old_image_geometry\0\u{3}new_mask_geometry\0\u{3}old_mask_geometry\0\u{3}new_mask_path_source\0\u{3}old_mask_path_source\0\u{3}new_image_original_size\0\u{3}old_image_original_size\0\u{3}background_removed\0\u{3}old_background_removed\0")

  fileprivate class _StorageClass {
    var _super: TSD_InfoCommandArchive? = nil
    var _newImageGeometry: TSD_GeometryArchive? = nil
    var _oldImageGeometry: TSD_GeometryArchive? = nil
    var _newMaskGeometry: TSD_GeometryArchive? = nil
    var _oldMaskGeometry: TSD_GeometryArchive? = nil
    var _newMaskPathSource: TSD_PathSourceArchive? = nil
    var _oldMaskPathSource: TSD_PathSourceArchive? = nil
    var _newImageOriginalSize: TSP_Size? = nil
    var _oldImageOriginalSize: TSP_Size? = nil
    var _backgroundRemoved: Bool? = nil
    var _oldBackgroundRemoved: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _newImageGeometry = source._newImageGeometry
      _oldImageGeometry = source._oldImageGeometry
      _newMaskGeometry = source._newMaskGeometry
      _oldMaskGeometry = source._oldMaskGeometry
      _newMaskPathSource = source._newMaskPathSource
      _oldMaskPathSource = source._oldMaskPathSource
      _newImageOriginalSize = source._newImageOriginalSize
      _oldImageOriginalSize = source._oldImageOriginalSize
      _backgroundRemoved = source._backgroundRemoved
      _oldBackgroundRemoved = source._oldBackgroundRemoved
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._newImageGeometry, !v.isInitialized {return false}
      if let v = _storage._oldImageGeometry, !v.isInitialized {return false}
      if let v = _storage._newMaskGeometry, !v.isInitialized {return false}
      if let v = _storage._oldMaskGeometry, !v.isInitialized {return false}
      if let v = _storage._newMaskPathSource, !v.isInitialized {return false}
      if let v = _storage._oldMaskPathSource, !v.isInitialized {return false}
      if let v = _storage._newImageOriginalSize, !v.isInitialized {return false}
      if let v = _storage._oldImageOriginalSize, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._newImageGeometry) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._oldImageGeometry) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._newMaskGeometry) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._oldMaskGeometry) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._newMaskPathSource) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._oldMaskPathSource) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._newImageOriginalSize) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._oldImageOriginalSize) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._backgroundRemoved) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._oldBackgroundRemoved) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._newImageGeometry {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._oldImageGeometry {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._newMaskGeometry {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._oldMaskGeometry {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._newMaskPathSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._oldMaskPathSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._newImageOriginalSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._oldImageOriginalSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._backgroundRemoved {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._oldBackgroundRemoved {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ImageInfoAbstractGeometryCommandArchive, rhs: TSD_ImageInfoAbstractGeometryCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._newImageGeometry != rhs_storage._newImageGeometry {return false}
        if _storage._oldImageGeometry != rhs_storage._oldImageGeometry {return false}
        if _storage._newMaskGeometry != rhs_storage._newMaskGeometry {return false}
        if _storage._oldMaskGeometry != rhs_storage._oldMaskGeometry {return false}
        if _storage._newMaskPathSource != rhs_storage._newMaskPathSource {return false}
        if _storage._oldMaskPathSource != rhs_storage._oldMaskPathSource {return false}
        if _storage._newImageOriginalSize != rhs_storage._newImageOriginalSize {return false}
        if _storage._oldImageOriginalSize != rhs_storage._oldImageOriginalSize {return false}
        if _storage._backgroundRemoved != rhs_storage._backgroundRemoved {return false}
        if _storage._oldBackgroundRemoved != rhs_storage._oldBackgroundRemoved {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ImageInfoGeometryCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageInfoGeometryCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ImageInfoGeometryCommandArchive, rhs: TSD_ImageInfoGeometryCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ImageInfoMaskGeometryCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageInfoMaskGeometryCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ImageInfoMaskGeometryCommandArchive, rhs: TSD_ImageInfoMaskGeometryCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_InfoCollectionSelectionTransformerHelperArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InfoCollectionSelectionTransformerHelperArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}info_uuid_path_list\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.infoUuidPathList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.infoUuidPathList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.infoUuidPathList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infoUuidPathList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_InfoCollectionSelectionTransformerHelperArchive, rhs: TSD_InfoCollectionSelectionTransformerHelperArchive) -> Bool {
    if lhs.infoUuidPathList != rhs.infoUuidPathList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_DrawableSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawableSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}transformer_helper\0\u{3}untransformed_drawable_selection\0")

  public var isInitialized: Bool {
    if self._transformerHelper == nil {return false}
    if self._untransformedDrawableSelection == nil {return false}
    if let v = self._transformerHelper, !v.isInitialized {return false}
    if let v = self._untransformedDrawableSelection, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transformerHelper) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._untransformedDrawableSelection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transformerHelper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._untransformedDrawableSelection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_DrawableSelectionTransformerArchive, rhs: TSD_DrawableSelectionTransformerArchive) -> Bool {
    if lhs._transformerHelper != rhs._transformerHelper {return false}
    if lhs._untransformedDrawableSelection != rhs._untransformedDrawableSelection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_InfoHyperlinkSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InfoHyperlinkSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_InfoHyperlinkSelectionTransformerArchive, rhs: TSD_InfoHyperlinkSelectionTransformerArchive) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_CanvasSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CanvasSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}transformer_helper\0")

  public var isInitialized: Bool {
    if self._transformerHelper == nil {return false}
    if let v = self._transformerHelper, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transformerHelper) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transformerHelper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_CanvasSelectionTransformerArchive, rhs: TSD_CanvasSelectionTransformerArchive) -> Bool {
    if lhs._transformerHelper != rhs._transformerHelper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_PathSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PathSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_PathSelectionTransformerArchive, rhs: TSD_PathSelectionTransformerArchive) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ShapeSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShapeSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ShapeSelectionTransformerArchive, rhs: TSD_ShapeSelectionTransformerArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_GroupSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_GroupSelectionTransformerArchive, rhs: TSD_GroupSelectionTransformerArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_PencilAnnotationSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PencilAnnotationSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}pencil_annotation_uuid\0")

  public var isInitialized: Bool {
    if self._pencilAnnotationUuid == nil {return false}
    if let v = self._pencilAnnotationUuid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pencilAnnotationUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pencilAnnotationUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_PencilAnnotationSelectionTransformerArchive, rhs: TSD_PencilAnnotationSelectionTransformerArchive) -> Bool {
    if lhs._pencilAnnotationUuid != rhs._pencilAnnotationUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_FreehandDrawingOpacityCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FreehandDrawingOpacityCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}opacity\0\u{3}old_opacity\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._opacity) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self._oldOpacity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._opacity {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._oldOpacity {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_FreehandDrawingOpacityCommandArchive, rhs: TSD_FreehandDrawingOpacityCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._opacity != rhs._opacity {return false}
    if lhs._oldOpacity != rhs._oldOpacity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_FreehandDrawingAnimationCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FreehandDrawingAnimationCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}animation\0\u{3}old_animation\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._animation) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._oldAnimation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._animation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._oldAnimation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_FreehandDrawingAnimationCommandArchive, rhs: TSD_FreehandDrawingAnimationCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._animation != rhs._animation {return false}
    if lhs._oldAnimation != rhs._oldAnimation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_InsertCaptionOrTitleCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InsertCaptionOrTitleCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}drawable_info_id_path\0\u{3}caption_or_title_info\0\u{3}added_caption_or_title_uuid\0\u{3}caption_or_title_kind\0\u{3}undo_object\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _drawableInfoIDPath: TSP_UUIDPath? = nil
    var _captionOrTitleInfo: TSP_Reference? = nil
    var _addedCaptionOrTitleUuid: TSP_UUID? = nil
    var _captionOrTitleKind: TSD_CaptionOrTitleKind? = nil
    var _undoObject: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _drawableInfoIDPath = source._drawableInfoIDPath
      _captionOrTitleInfo = source._captionOrTitleInfo
      _addedCaptionOrTitleUuid = source._addedCaptionOrTitleUuid
      _captionOrTitleKind = source._captionOrTitleKind
      _undoObject = source._undoObject
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._drawableInfoIDPath, !v.isInitialized {return false}
      if let v = _storage._captionOrTitleInfo, !v.isInitialized {return false}
      if let v = _storage._addedCaptionOrTitleUuid, !v.isInitialized {return false}
      if let v = _storage._undoObject, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._drawableInfoIDPath) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._captionOrTitleInfo) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._addedCaptionOrTitleUuid) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._captionOrTitleKind) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._undoObject) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._drawableInfoIDPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._captionOrTitleInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._addedCaptionOrTitleUuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._captionOrTitleKind {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._undoObject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_InsertCaptionOrTitleCommandArchive, rhs: TSD_InsertCaptionOrTitleCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._drawableInfoIDPath != rhs_storage._drawableInfoIDPath {return false}
        if _storage._captionOrTitleInfo != rhs_storage._captionOrTitleInfo {return false}
        if _storage._addedCaptionOrTitleUuid != rhs_storage._addedCaptionOrTitleUuid {return false}
        if _storage._captionOrTitleKind != rhs_storage._captionOrTitleKind {return false}
        if _storage._undoObject != rhs_storage._undoObject {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_RemoveCaptionOrTitleCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveCaptionOrTitleCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}drawable_info_id_path\0\u{3}removed_caption_or_title_info\0\u{3}removed_caption_or_title_uuid\0\u{3}caption_or_title_kind\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _drawableInfoIDPath: TSP_UUIDPath? = nil
    var _removedCaptionOrTitleInfo: TSP_Reference? = nil
    var _removedCaptionOrTitleUuid: TSP_UUID? = nil
    var _captionOrTitleKind: TSD_CaptionOrTitleKind? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _drawableInfoIDPath = source._drawableInfoIDPath
      _removedCaptionOrTitleInfo = source._removedCaptionOrTitleInfo
      _removedCaptionOrTitleUuid = source._removedCaptionOrTitleUuid
      _captionOrTitleKind = source._captionOrTitleKind
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._drawableInfoIDPath, !v.isInitialized {return false}
      if let v = _storage._removedCaptionOrTitleInfo, !v.isInitialized {return false}
      if let v = _storage._removedCaptionOrTitleUuid, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._drawableInfoIDPath) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._removedCaptionOrTitleInfo) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._removedCaptionOrTitleUuid) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._captionOrTitleKind) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._drawableInfoIDPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._removedCaptionOrTitleInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._removedCaptionOrTitleUuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._captionOrTitleKind {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_RemoveCaptionOrTitleCommandArchive, rhs: TSD_RemoveCaptionOrTitleCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._drawableInfoIDPath != rhs_storage._drawableInfoIDPath {return false}
        if _storage._removedCaptionOrTitleInfo != rhs_storage._removedCaptionOrTitleInfo {return false}
        if _storage._removedCaptionOrTitleUuid != rhs_storage._removedCaptionOrTitleUuid {return false}
        if _storage._captionOrTitleKind != rhs_storage._captionOrTitleKind {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_SetCaptionOrTitleVisibilityCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetCaptionOrTitleVisibilityCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}caption_or_title_kind\0\u{1}hidden\0\u{3}was_hidden\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._captionOrTitleKind) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._hidden) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._wasHidden) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._captionOrTitleKind {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hidden {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._wasHidden {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_SetCaptionOrTitleVisibilityCommandArchive, rhs: TSD_SetCaptionOrTitleVisibilityCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._captionOrTitleKind != rhs._captionOrTitleKind {return false}
    if lhs._hidden != rhs._hidden {return false}
    if lhs._wasHidden != rhs._wasHidden {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
