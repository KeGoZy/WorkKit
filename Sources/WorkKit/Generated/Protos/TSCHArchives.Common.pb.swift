// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TSCHArchives.Common.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum TSCH_ChartType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case undefinedChartType = 0
  case columnChartType2D = 1
  case barChartType2D = 2
  case lineChartType2D = 3
  case areaChartType2D = 4
  case pieChartType2D = 5
  case stackedColumnChartType2D = 6
  case stackedBarChartType2D = 7
  case stackedAreaChartType2D = 8
  case scatterChartType2D = 9
  case mixedChartType2D = 10
  case twoAxisChartType2D = 11
  case columnChartType3D = 12
  case barChartType3D = 13
  case lineChartType3D = 14
  case areaChartType3D = 15
  case pieChartType3D = 16
  case stackedColumnChartType3D = 17
  case stackedBarChartType3D = 18
  case stackedAreaChartType3D = 19
  case multiDataColumnChartType2D = 20
  case multiDataBarChartType2D = 21
  case bubbleChartType2D = 22
  case multiDataScatterChartType2D = 23
  case multiDataBubbleChartType2D = 24
  case donutChartType2D = 25
  case donutChartType3D = 26
  case radarChartType2D = 27

  init() {
    self = .undefinedChartType
  }

}

enum TSCH_AxisType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case unknown = 0
  case x = 1
  case y = 2
  case pie = 3
  case size = 4
  case polarRadius = 5
  case polarAngle = 6

  init() {
    self = .unknown
  }

}

enum TSCH_ScatterFormat: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case unknown = 0
  case separateX = 1
  case sharedX = 2

  init() {
    self = .unknown
  }

}

enum TSCH_SeriesDirection: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case unknown = 0
  case byRow = 1
  case byColumn = 2

  init() {
    self = .unknown
  }

}

enum TSCH_NumberValueType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case decimal = 0
  case currency = 1
  case percentage = 2
  case scientific = 3
  case fraction = 4
  case base = 5
  case unknown = -999

  init() {
    self = .decimal
  }

}

enum TSCH_NegativeNumberStyle: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case minus = 0
  case red = 1
  case parentheses = 2
  case redAndParentheses = 3
  case none = 4

  init() {
    self = .minus
  }

}

enum TSCH_FractionAccuracy: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case conflicting = 0
  case upToOneDigit = -1
  case upToTwoDigits = -2
  case upToThreeDigits = -3
  case halves = 2
  case quarters = 4
  case eighths = 8
  case sixteenths = 16
  case tenths = 10
  case hundredths = 100

  init() {
    self = .conflicting
  }

}

struct TSCH_RectArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var origin: TSP_Point {
    get {return _origin ?? TSP_Point()}
    set {_origin = newValue}
  }
  /// Returns true if `origin` has been explicitly set.
  var hasOrigin: Bool {return self._origin != nil}
  /// Clears the value of `origin`. Subsequent reads from it will return its default value.
  mutating func clearOrigin() {self._origin = nil}

  var size: TSP_Size {
    get {return _size ?? TSP_Size()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _origin: TSP_Point? = nil
  fileprivate var _size: TSP_Size? = nil
}

struct TSCH_ChartsNSNumberDoubleArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var numberArchive: Double {
    get {return _numberArchive ?? 0}
    set {_numberArchive = newValue}
  }
  /// Returns true if `numberArchive` has been explicitly set.
  var hasNumberArchive: Bool {return self._numberArchive != nil}
  /// Clears the value of `numberArchive`. Subsequent reads from it will return its default value.
  mutating func clearNumberArchive() {self._numberArchive = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _numberArchive: Double? = nil
}

struct TSCH_ChartsNSArrayOfNSNumberDoubleArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var numbers: [Double] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSCH_DEPRECATEDChart3DFillArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fill: TSD_FillArchive {
    get {return _fill ?? TSD_FillArchive()}
    set {_fill = newValue}
  }
  /// Returns true if `fill` has been explicitly set.
  var hasFill: Bool {return self._fill != nil}
  /// Clears the value of `fill`. Subsequent reads from it will return its default value.
  mutating func clearFill() {self._fill = nil}

  var lightingmodel: TSCH_Chart3DLightingModelArchive {
    get {return _lightingmodel ?? TSCH_Chart3DLightingModelArchive()}
    set {_lightingmodel = newValue}
  }
  /// Returns true if `lightingmodel` has been explicitly set.
  var hasLightingmodel: Bool {return self._lightingmodel != nil}
  /// Clears the value of `lightingmodel`. Subsequent reads from it will return its default value.
  mutating func clearLightingmodel() {self._lightingmodel = nil}

  var texturesetID: String {
    get {return _texturesetID ?? String()}
    set {_texturesetID = newValue}
  }
  /// Returns true if `texturesetID` has been explicitly set.
  var hasTexturesetID: Bool {return self._texturesetID != nil}
  /// Clears the value of `texturesetID`. Subsequent reads from it will return its default value.
  mutating func clearTexturesetID() {self._texturesetID = nil}

  var fillType: TSCH_FillPropertyType {
    get {return _fillType ?? .undefined}
    set {_fillType = newValue}
  }
  /// Returns true if `fillType` has been explicitly set.
  var hasFillType: Bool {return self._fillType != nil}
  /// Clears the value of `fillType`. Subsequent reads from it will return its default value.
  mutating func clearFillType() {self._fillType = nil}

  var seriesIndex: UInt32 {
    get {return _seriesIndex ?? 0}
    set {_seriesIndex = newValue}
  }
  /// Returns true if `seriesIndex` has been explicitly set.
  var hasSeriesIndex: Bool {return self._seriesIndex != nil}
  /// Clears the value of `seriesIndex`. Subsequent reads from it will return its default value.
  mutating func clearSeriesIndex() {self._seriesIndex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fill: TSD_FillArchive? = nil
  fileprivate var _lightingmodel: TSCH_Chart3DLightingModelArchive? = nil
  fileprivate var _texturesetID: String? = nil
  fileprivate var _fillType: TSCH_FillPropertyType? = nil
  fileprivate var _seriesIndex: UInt32? = nil
}

struct TSCH_ChartStyleArchive: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_StyleArchive {
    get {return _super ?? TSS_StyleArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _super: TSS_StyleArchive? = nil
}

struct TSCH_ChartNonStyleArchive: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_StyleArchive {
    get {return _super ?? TSS_StyleArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _super: TSS_StyleArchive? = nil
}

struct TSCH_LegendStyleArchive: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_StyleArchive {
    get {return _super ?? TSS_StyleArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _super: TSS_StyleArchive? = nil
}

struct TSCH_LegendNonStyleArchive: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_StyleArchive {
    get {return _super ?? TSS_StyleArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _super: TSS_StyleArchive? = nil
}

struct TSCH_ChartAxisStyleArchive: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_StyleArchive {
    get {return _super ?? TSS_StyleArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _super: TSS_StyleArchive? = nil
}

struct TSCH_ChartAxisNonStyleArchive: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_StyleArchive {
    get {return _super ?? TSS_StyleArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _super: TSS_StyleArchive? = nil
}

struct TSCH_ChartSeriesStyleArchive: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_StyleArchive {
    get {return _super ?? TSS_StyleArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _super: TSS_StyleArchive? = nil
}

struct TSCH_ChartSeriesNonStyleArchive: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_StyleArchive {
    get {return _super ?? TSS_StyleArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _super: TSS_StyleArchive? = nil
}

struct TSCH_GridValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var numericValue: Double {
    get {return _numericValue ?? 0}
    set {_numericValue = newValue}
  }
  /// Returns true if `numericValue` has been explicitly set.
  var hasNumericValue: Bool {return self._numericValue != nil}
  /// Clears the value of `numericValue`. Subsequent reads from it will return its default value.
  mutating func clearNumericValue() {self._numericValue = nil}

  var dateValue10: Double {
    get {return _dateValue10 ?? 0}
    set {_dateValue10 = newValue}
  }
  /// Returns true if `dateValue10` has been explicitly set.
  var hasDateValue10: Bool {return self._dateValue10 != nil}
  /// Clears the value of `dateValue10`. Subsequent reads from it will return its default value.
  mutating func clearDateValue10() {self._dateValue10 = nil}

  var durationValue: Double {
    get {return _durationValue ?? 0}
    set {_durationValue = newValue}
  }
  /// Returns true if `durationValue` has been explicitly set.
  var hasDurationValue: Bool {return self._durationValue != nil}
  /// Clears the value of `durationValue`. Subsequent reads from it will return its default value.
  mutating func clearDurationValue() {self._durationValue = nil}

  var dateValue: Double {
    get {return _dateValue ?? 0}
    set {_dateValue = newValue}
  }
  /// Returns true if `dateValue` has been explicitly set.
  var hasDateValue: Bool {return self._dateValue != nil}
  /// Clears the value of `dateValue`. Subsequent reads from it will return its default value.
  mutating func clearDateValue() {self._dateValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _numericValue: Double? = nil
  fileprivate var _dateValue10: Double? = nil
  fileprivate var _durationValue: Double? = nil
  fileprivate var _dateValue: Double? = nil
}

struct TSCH_GridRow: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: [TSCH_GridValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSCH_ReferenceLineStyleArchive: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_StyleArchive {
    get {return _super ?? TSS_StyleArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _super: TSS_StyleArchive? = nil
}

struct TSCH_ReferenceLineNonStyleArchive: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_StyleArchive {
    get {return _super ?? TSS_StyleArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _super: TSS_StyleArchive? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TSCH"

extension TSCH_ChartType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0undefinedChartType\0\u{1}columnChartType2D\0\u{1}barChartType2D\0\u{1}lineChartType2D\0\u{1}areaChartType2D\0\u{1}pieChartType2D\0\u{1}stackedColumnChartType2D\0\u{1}stackedBarChartType2D\0\u{1}stackedAreaChartType2D\0\u{1}scatterChartType2D\0\u{1}mixedChartType2D\0\u{1}twoAxisChartType2D\0\u{1}columnChartType3D\0\u{1}barChartType3D\0\u{1}lineChartType3D\0\u{1}areaChartType3D\0\u{1}pieChartType3D\0\u{1}stackedColumnChartType3D\0\u{1}stackedBarChartType3D\0\u{1}stackedAreaChartType3D\0\u{1}multiDataColumnChartType2D\0\u{1}multiDataBarChartType2D\0\u{1}bubbleChartType2D\0\u{1}multiDataScatterChartType2D\0\u{1}multiDataBubbleChartType2D\0\u{1}donutChartType2D\0\u{1}donutChartType3D\0\u{1}radarChartType2D\0")
}

extension TSCH_AxisType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0axis_type_unknown\0\u{1}axis_type_x\0\u{1}axis_type_y\0\u{1}axis_type_pie\0\u{1}axis_type_size\0\u{1}axis_type_polar_radius\0\u{1}axis_type_polar_angle\0")
}

extension TSCH_ScatterFormat: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0scatter_format_unknown\0\u{1}scatter_format_separate_x\0\u{1}scatter_format_shared_x\0")
}

extension TSCH_SeriesDirection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0series_direction_unknown\0\u{1}series_direction_by_row\0\u{1}series_direction_by_column\0")
}

extension TSCH_NumberValueType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}Yp\u{7f}\u{7f}\u{7f}\u{3}numberValueTypeUnknown\0\u{2}g\u{f}numberValueTypeDecimal\0\u{1}numberValueTypeCurrency\0\u{1}numberValueTypePercentage\0\u{1}numberValueTypeScientific\0\u{1}numberValueTypeFraction\0\u{1}numberValueTypeBase\0")
}

extension TSCH_NegativeNumberStyle: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0negativeNumberStyleMinus\0\u{1}negativeNumberStyleRed\0\u{1}negativeNumberStyleParentheses\0\u{1}negativeNumberStyleRedAndParentheses\0\u{1}negativeNumberStyleNone\0")
}

extension TSCH_FractionAccuracy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}}\u{7f}\u{7f}\u{7f}\u{7f}\u{3}fractionAccuracyUpToThreeDigits\0\u{1}fractionAccuracyUpToTwoDigits\0\u{1}fractionAccuracyUpToOneDigit\0\u{1}fractionAccuracyConflicting\0\u{2}\u{2}fractionAccuracyHalves\0\u{2}\u{2}fractionAccuracyQuarters\0\u{2}\u{4}fractionAccuracyEighths\0\u{2}\u{2}fractionAccuracyTenths\0\u{2}\u{6}fractionAccuracySixteenths\0\u{2}T\u{1}fractionAccuracyHundredths\0")
}

extension TSCH_RectArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RectArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}origin\0\u{1}size\0")

  public var isInitialized: Bool {
    if self._origin == nil {return false}
    if self._size == nil {return false}
    if let v = self._origin, !v.isInitialized {return false}
    if let v = self._size, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCH_RectArchive, rhs: TSCH_RectArchive) -> Bool {
    if lhs._origin != rhs._origin {return false}
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCH_ChartsNSNumberDoubleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChartsNSNumberDoubleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}number_archive\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._numberArchive) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._numberArchive {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCH_ChartsNSNumberDoubleArchive, rhs: TSCH_ChartsNSNumberDoubleArchive) -> Bool {
    if lhs._numberArchive != rhs._numberArchive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCH_ChartsNSArrayOfNSNumberDoubleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChartsNSArrayOfNSNumberDoubleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}numbers\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedDoubleField(value: &self.numbers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.numbers.isEmpty {
      try visitor.visitRepeatedDoubleField(value: self.numbers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCH_ChartsNSArrayOfNSNumberDoubleArchive, rhs: TSCH_ChartsNSArrayOfNSNumberDoubleArchive) -> Bool {
    if lhs.numbers != rhs.numbers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCH_DEPRECATEDChart3DFillArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DEPRECATEDChart3DFillArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}fill\0\u{1}lightingmodel\0\u{3}textureset_id\0\u{3}fill_type\0\u{3}series_index\0")

  public var isInitialized: Bool {
    if let v = self._fill, !v.isInitialized {return false}
    if let v = self._lightingmodel, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fill) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._lightingmodel) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._texturesetID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._fillType) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._seriesIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fill {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lightingmodel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._texturesetID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._fillType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._seriesIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCH_DEPRECATEDChart3DFillArchive, rhs: TSCH_DEPRECATEDChart3DFillArchive) -> Bool {
    if lhs._fill != rhs._fill {return false}
    if lhs._lightingmodel != rhs._lightingmodel {return false}
    if lhs._texturesetID != rhs._texturesetID {return false}
    if lhs._fillType != rhs._fillType {return false}
    if lhs._seriesIndex != rhs._seriesIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCH_ChartStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChartStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 10000..<536870912:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TSCH_ChartStyleArchive.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 10000, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCH_ChartStyleArchive, rhs: TSCH_ChartStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TSCH_ChartNonStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChartNonStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 10000..<536870912:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TSCH_ChartNonStyleArchive.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 10000, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCH_ChartNonStyleArchive, rhs: TSCH_ChartNonStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TSCH_LegendStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LegendStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 10000..<536870912:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TSCH_LegendStyleArchive.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 10000, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCH_LegendStyleArchive, rhs: TSCH_LegendStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TSCH_LegendNonStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LegendNonStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 10000..<536870912:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TSCH_LegendNonStyleArchive.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 10000, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCH_LegendNonStyleArchive, rhs: TSCH_LegendNonStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TSCH_ChartAxisStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChartAxisStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 10000..<536870912:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TSCH_ChartAxisStyleArchive.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 10000, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCH_ChartAxisStyleArchive, rhs: TSCH_ChartAxisStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TSCH_ChartAxisNonStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChartAxisNonStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 10000..<536870912:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TSCH_ChartAxisNonStyleArchive.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 10000, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCH_ChartAxisNonStyleArchive, rhs: TSCH_ChartAxisNonStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TSCH_ChartSeriesStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChartSeriesStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 10000..<536870912:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TSCH_ChartSeriesStyleArchive.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 10000, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCH_ChartSeriesStyleArchive, rhs: TSCH_ChartSeriesStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TSCH_ChartSeriesNonStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChartSeriesNonStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 10000..<536870912:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TSCH_ChartSeriesNonStyleArchive.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 10000, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCH_ChartSeriesNonStyleArchive, rhs: TSCH_ChartSeriesNonStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TSCH_GridValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GridValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}numeric_value\0\u{3}date_value_1_0\0\u{3}duration_value\0\u{3}date_value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._numericValue) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._dateValue10) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self._durationValue) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._dateValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._numericValue {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._dateValue10 {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._durationValue {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._dateValue {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCH_GridValue, rhs: TSCH_GridValue) -> Bool {
    if lhs._numericValue != rhs._numericValue {return false}
    if lhs._dateValue10 != rhs._dateValue10 {return false}
    if lhs._durationValue != rhs._durationValue {return false}
    if lhs._dateValue != rhs._dateValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCH_GridRow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GridRow"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCH_GridRow, rhs: TSCH_GridRow) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCH_ReferenceLineStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReferenceLineStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 10000..<536870912:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TSCH_ReferenceLineStyleArchive.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 10000, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCH_ReferenceLineStyleArchive, rhs: TSCH_ReferenceLineStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TSCH_ReferenceLineNonStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReferenceLineNonStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 10000..<536870912:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TSCH_ReferenceLineNonStyleArchive.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 10000, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCH_ReferenceLineNonStyleArchive, rhs: TSCH_ReferenceLineNonStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}
