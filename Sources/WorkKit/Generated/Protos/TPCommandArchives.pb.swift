// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TPCommandArchives.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct TP_InsertDrawablesCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var forPaste: Bool {
    get {return _storage._forPaste ?? false}
    set {_uniqueStorage()._forPaste = newValue}
  }
  /// Returns true if `forPaste` has been explicitly set.
  var hasForPaste: Bool {return _storage._forPaste != nil}
  /// Clears the value of `forPaste`. Subsequent reads from it will return its default value.
  mutating func clearForPaste() {_uniqueStorage()._forPaste = nil}

  var insertionType: TP_InsertDrawablesCommandArchive.InsertionType {
    get {return _storage._insertionType ?? .insertingPrototype}
    set {_uniqueStorage()._insertionType = newValue}
  }
  /// Returns true if `insertionType` has been explicitly set.
  var hasInsertionType: Bool {return _storage._insertionType != nil}
  /// Clears the value of `insertionType`. Subsequent reads from it will return its default value.
  mutating func clearInsertionType() {_uniqueStorage()._insertionType = nil}

  var argsList: [TSCK_AddIdOperationArgs] {
    get {return _storage._argsList}
    set {_uniqueStorage()._argsList = newValue}
  }

  var pageIndexList: [UInt32] {
    get {return _storage._pageIndexList}
    set {_uniqueStorage()._pageIndexList = newValue}
  }

  var drawableInfoList: [TSP_Reference] {
    get {return _storage._drawableInfoList}
    set {_uniqueStorage()._drawableInfoList = newValue}
  }

  var placeholderTagsList: [String] {
    get {return _storage._placeholderTagsList}
    set {_uniqueStorage()._placeholderTagsList = newValue}
  }

  var customFormatKeys: [TSP_UUID] {
    get {return _storage._customFormatKeys}
    set {_uniqueStorage()._customFormatKeys = newValue}
  }

  var drawableUndoObject: TSP_Reference {
    get {return _storage._drawableUndoObject ?? TSP_Reference()}
    set {_uniqueStorage()._drawableUndoObject = newValue}
  }
  /// Returns true if `drawableUndoObject` has been explicitly set.
  var hasDrawableUndoObject: Bool {return _storage._drawableUndoObject != nil}
  /// Clears the value of `drawableUndoObject`. Subsequent reads from it will return its default value.
  mutating func clearDrawableUndoObject() {_uniqueStorage()._drawableUndoObject = nil}

  var savedNextUntitledResolverIndex: UInt32 {
    get {return _storage._savedNextUntitledResolverIndex ?? 0}
    set {_uniqueStorage()._savedNextUntitledResolverIndex = newValue}
  }
  /// Returns true if `savedNextUntitledResolverIndex` has been explicitly set.
  var hasSavedNextUntitledResolverIndex: Bool {return _storage._savedNextUntitledResolverIndex != nil}
  /// Clears the value of `savedNextUntitledResolverIndex`. Subsequent reads from it will return its default value.
  mutating func clearSavedNextUntitledResolverIndex() {_uniqueStorage()._savedNextUntitledResolverIndex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum InsertionType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case insertingPrototype = 0
    case pasting = 1
    case cloning = 2

    init() {
      self = .insertingPrototype
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TP_MoveDrawablesPageIndexCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var pageIndex: UInt32 {
    get {return _storage._pageIndex ?? 0}
    set {_uniqueStorage()._pageIndex = newValue}
  }
  /// Returns true if `pageIndex` has been explicitly set.
  var hasPageIndex: Bool {return _storage._pageIndex != nil}
  /// Clears the value of `pageIndex`. Subsequent reads from it will return its default value.
  mutating func clearPageIndex() {_uniqueStorage()._pageIndex = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var drawables: [TP_MoveDrawablesPageIndexCommandArchive.Drawable] {
    get {return _storage._drawables}
    set {_uniqueStorage()._drawables = newValue}
  }

  /// NOTE: This field was marked as deprecated in the .proto file.
  var maintainZOrder: Bool {
    get {return _storage._maintainZOrder ?? false}
    set {_uniqueStorage()._maintainZOrder = newValue}
  }
  /// Returns true if `maintainZOrder` has been explicitly set.
  var hasMaintainZOrder: Bool {return _storage._maintainZOrder != nil}
  /// Clears the value of `maintainZOrder`. Subsequent reads from it will return its default value.
  mutating func clearMaintainZOrder() {_uniqueStorage()._maintainZOrder = nil}

  var drawableInfoIDPathList: [TSP_UUIDPath] {
    get {return _storage._drawableInfoIDPathList}
    set {_uniqueStorage()._drawableInfoIDPathList = newValue}
  }

  var pageIndexList: [UInt32] {
    get {return _storage._pageIndexList}
    set {_uniqueStorage()._pageIndexList = newValue}
  }

  var originalPageIndexList: [UInt32] {
    get {return _storage._originalPageIndexList}
    set {_uniqueStorage()._originalPageIndexList = newValue}
  }

  var tagsList: [String] {
    get {return _storage._tagsList}
    set {_uniqueStorage()._tagsList = newValue}
  }

  var originalTagsList: [String] {
    get {return _storage._originalTagsList}
    set {_uniqueStorage()._originalTagsList = newValue}
  }

  var preserveTags: Bool {
    get {return _storage._preserveTags ?? false}
    set {_uniqueStorage()._preserveTags = newValue}
  }
  /// Returns true if `preserveTags` has been explicitly set.
  var hasPreserveTags: Bool {return _storage._preserveTags != nil}
  /// Clears the value of `preserveTags`. Subsequent reads from it will return its default value.
  mutating func clearPreserveTags() {_uniqueStorage()._preserveTags = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Drawable: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var drawable: TSP_Reference {
      get {return _drawable ?? TSP_Reference()}
      set {_drawable = newValue}
    }
    /// Returns true if `drawable` has been explicitly set.
    var hasDrawable: Bool {return self._drawable != nil}
    /// Clears the value of `drawable`. Subsequent reads from it will return its default value.
    mutating func clearDrawable() {self._drawable = nil}

    var zOrder: UInt32 {
      get {return _zOrder ?? 0}
      set {_zOrder = newValue}
    }
    /// Returns true if `zOrder` has been explicitly set.
    var hasZOrder: Bool {return self._zOrder != nil}
    /// Clears the value of `zOrder`. Subsequent reads from it will return its default value.
    mutating func clearZOrder() {self._zOrder = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _drawable: TSP_Reference? = nil
    fileprivate var _zOrder: UInt32? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TP_InsertSectionBreakCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_StorageActionCommandArchive {
    get {return _super ?? TSWP_StorageActionCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_StorageActionCommandArchive? = nil
}

struct TP_MoveDrawableZOrderCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var argsList: [TSCK_RearrangeIdOperationArgs] = []

  var actionStringIndex: UInt32 {
    get {return _actionStringIndex ?? 0}
    set {_actionStringIndex = newValue}
  }
  /// Returns true if `actionStringIndex` has been explicitly set.
  var hasActionStringIndex: Bool {return self._actionStringIndex != nil}
  /// Clears the value of `actionStringIndex`. Subsequent reads from it will return its default value.
  mutating func clearActionStringIndex() {self._actionStringIndex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _actionStringIndex: UInt32? = nil
}

struct TP_RemoveDrawablesCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var argsList: [TSCK_RemoveIdOperationArgs] = []

  var drawableInfoList: [TSP_Reference] = []

  var pageIndexList: [UInt32] = []

  var tagsList: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
}

struct TP_ChangeSectionMarginsCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var section: TSP_Reference {
    get {return _section ?? TSP_Reference()}
    set {_section = newValue}
  }
  /// Returns true if `section` has been explicitly set.
  var hasSection: Bool {return self._section != nil}
  /// Clears the value of `section`. Subsequent reads from it will return its default value.
  mutating func clearSection() {self._section = nil}

  var margin: TP_ChangeSectionMarginsCommandArchive.SectionMargin {
    get {return _margin ?? .kSectionMarginLeft}
    set {_margin = newValue}
  }
  /// Returns true if `margin` has been explicitly set.
  var hasMargin: Bool {return self._margin != nil}
  /// Clears the value of `margin`. Subsequent reads from it will return its default value.
  mutating func clearMargin() {self._margin = nil}

  var marginValue: Float {
    get {return _marginValue ?? 0}
    set {_marginValue = newValue}
  }
  /// Returns true if `marginValue` has been explicitly set.
  var hasMarginValue: Bool {return self._marginValue != nil}
  /// Clears the value of `marginValue`. Subsequent reads from it will return its default value.
  mutating func clearMarginValue() {self._marginValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum SectionMargin: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kSectionMarginLeft = 0
    case kSectionMarginRight = 1
    case kSectionMarginTop = 2
    case kSectionMarginBottom = 3
    case kSectionMarginHeader = 4
    case kSectionMarginFooter = 5

    init() {
      self = .kSectionMarginLeft
    }

  }

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _section: TSP_Reference? = nil
  fileprivate var _margin: TP_ChangeSectionMarginsCommandArchive.SectionMargin? = nil
  fileprivate var _marginValue: Float? = nil
}

struct TP_InsertSectionTemplateDrawablesCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var obsoleteSection: TSP_Reference {
    get {return _storage._obsoleteSection ?? TSP_Reference()}
    set {_uniqueStorage()._obsoleteSection = newValue}
  }
  /// Returns true if `obsoleteSection` has been explicitly set.
  var hasObsoleteSection: Bool {return _storage._obsoleteSection != nil}
  /// Clears the value of `obsoleteSection`. Subsequent reads from it will return its default value.
  mutating func clearObsoleteSection() {_uniqueStorage()._obsoleteSection = nil}

  var sectionTemplateDrawables: [TSP_Reference] {
    get {return _storage._sectionTemplateDrawables}
    set {_uniqueStorage()._sectionTemplateDrawables = newValue}
  }

  var drawableIndex: UInt32 {
    get {return _storage._drawableIndex ?? 0}
    set {_uniqueStorage()._drawableIndex = newValue}
  }
  /// Returns true if `drawableIndex` has been explicitly set.
  var hasDrawableIndex: Bool {return _storage._drawableIndex != nil}
  /// Clears the value of `drawableIndex`. Subsequent reads from it will return its default value.
  mutating func clearDrawableIndex() {_uniqueStorage()._drawableIndex = nil}

  var sectionTemplateDrawableProvider: TSP_Reference {
    get {return _storage._sectionTemplateDrawableProvider ?? TSP_Reference()}
    set {_uniqueStorage()._sectionTemplateDrawableProvider = newValue}
  }
  /// Returns true if `sectionTemplateDrawableProvider` has been explicitly set.
  var hasSectionTemplateDrawableProvider: Bool {return _storage._sectionTemplateDrawableProvider != nil}
  /// Clears the value of `sectionTemplateDrawableProvider`. Subsequent reads from it will return its default value.
  mutating func clearSectionTemplateDrawableProvider() {_uniqueStorage()._sectionTemplateDrawableProvider = nil}

  var customFormatKeys: [TSP_UUID] {
    get {return _storage._customFormatKeys}
    set {_uniqueStorage()._customFormatKeys = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TP_MoveSectionTemplateDrawableZOrderCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var obsoleteSection: TSP_Reference {
    get {return _storage._obsoleteSection ?? TSP_Reference()}
    set {_uniqueStorage()._obsoleteSection = newValue}
  }
  /// Returns true if `obsoleteSection` has been explicitly set.
  var hasObsoleteSection: Bool {return _storage._obsoleteSection != nil}
  /// Clears the value of `obsoleteSection`. Subsequent reads from it will return its default value.
  mutating func clearObsoleteSection() {_uniqueStorage()._obsoleteSection = nil}

  var sectionTemplateDrawables: [TSP_Reference] {
    get {return _storage._sectionTemplateDrawables}
    set {_uniqueStorage()._sectionTemplateDrawables = newValue}
  }

  var indexes: [UInt32] {
    get {return _storage._indexes}
    set {_uniqueStorage()._indexes = newValue}
  }

  var sectionTemplateDrawableProvider: TSP_Reference {
    get {return _storage._sectionTemplateDrawableProvider ?? TSP_Reference()}
    set {_uniqueStorage()._sectionTemplateDrawableProvider = newValue}
  }
  /// Returns true if `sectionTemplateDrawableProvider` has been explicitly set.
  var hasSectionTemplateDrawableProvider: Bool {return _storage._sectionTemplateDrawableProvider != nil}
  /// Clears the value of `sectionTemplateDrawableProvider`. Subsequent reads from it will return its default value.
  mutating func clearSectionTemplateDrawableProvider() {_uniqueStorage()._sectionTemplateDrawableProvider = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TP_RemoveSectionTemplateDrawablesCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var obsoleteSection: TSP_Reference {
    get {return _storage._obsoleteSection ?? TSP_Reference()}
    set {_uniqueStorage()._obsoleteSection = newValue}
  }
  /// Returns true if `obsoleteSection` has been explicitly set.
  var hasObsoleteSection: Bool {return _storage._obsoleteSection != nil}
  /// Clears the value of `obsoleteSection`. Subsequent reads from it will return its default value.
  mutating func clearObsoleteSection() {_uniqueStorage()._obsoleteSection = nil}

  var sectionTemplateDrawables: [TP_RemoveSectionTemplateDrawablesCommandArchive.SectionTemplateDrawable] {
    get {return _storage._sectionTemplateDrawables}
    set {_uniqueStorage()._sectionTemplateDrawables = newValue}
  }

  var sectionTemplateDrawableProvider: TSP_Reference {
    get {return _storage._sectionTemplateDrawableProvider ?? TSP_Reference()}
    set {_uniqueStorage()._sectionTemplateDrawableProvider = newValue}
  }
  /// Returns true if `sectionTemplateDrawableProvider` has been explicitly set.
  var hasSectionTemplateDrawableProvider: Bool {return _storage._sectionTemplateDrawableProvider != nil}
  /// Clears the value of `sectionTemplateDrawableProvider`. Subsequent reads from it will return its default value.
  mutating func clearSectionTemplateDrawableProvider() {_uniqueStorage()._sectionTemplateDrawableProvider = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct SectionTemplateDrawable: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var drawable: TSP_Reference {
      get {return _drawable ?? TSP_Reference()}
      set {_drawable = newValue}
    }
    /// Returns true if `drawable` has been explicitly set.
    var hasDrawable: Bool {return self._drawable != nil}
    /// Clears the value of `drawable`. Subsequent reads from it will return its default value.
    mutating func clearDrawable() {self._drawable = nil}

    var drawableIndex: UInt32 {
      get {return _drawableIndex ?? 0}
      set {_drawableIndex = newValue}
    }
    /// Returns true if `drawableIndex` has been explicitly set.
    var hasDrawableIndex: Bool {return self._drawableIndex != nil}
    /// Clears the value of `drawableIndex`. Subsequent reads from it will return its default value.
    mutating func clearDrawableIndex() {self._drawableIndex = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _drawable: TSP_Reference? = nil
    fileprivate var _drawableIndex: UInt32? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TP_PasteSectionTemplateDrawablesCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var section: TSP_Reference {
    get {return _section ?? TSP_Reference()}
    set {_section = newValue}
  }
  /// Returns true if `section` has been explicitly set.
  var hasSection: Bool {return self._section != nil}
  /// Clears the value of `section`. Subsequent reads from it will return its default value.
  mutating func clearSection() {self._section = nil}

  var sectionTemplateDrawables: [TSP_Reference] = []

  var drawableIndex: UInt32 {
    get {return _drawableIndex ?? 0}
    set {_drawableIndex = newValue}
  }
  /// Returns true if `drawableIndex` has been explicitly set.
  var hasDrawableIndex: Bool {return self._drawableIndex != nil}
  /// Clears the value of `drawableIndex`. Subsequent reads from it will return its default value.
  mutating func clearDrawableIndex() {self._drawableIndex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _section: TSP_Reference? = nil
  fileprivate var _drawableIndex: UInt32? = nil
}

struct TP_MoveDrawablesAttachedCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_StorageActionCommandArchive {
    get {return _super ?? TSWP_StorageActionCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var argsList: [TSCK_IdPlacementOperationArgs] = []

  var rangeList: [TSP_Range] = []

  var drawableInfoIDPathList: [TSP_UUIDPath] = []

  var positionList: [TP_MoveDrawablesAttachedCommandArchive.GSSPCharIndexAndPosition] = []

  var exteriorTextWrapList: [TSD_ExteriorTextWrapArchive] = []

  var originalPageIndexList: [UInt32] = []

  var originalExteriorTextWrapList: [TSD_ExteriorTextWrapArchive] = []

  var originalAttachmentList: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct GSSPCharIndexAndPosition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var charIndex: Int32 {
      get {return _charIndex ?? 0}
      set {_charIndex = newValue}
    }
    /// Returns true if `charIndex` has been explicitly set.
    var hasCharIndex: Bool {return self._charIndex != nil}
    /// Clears the value of `charIndex`. Subsequent reads from it will return its default value.
    mutating func clearCharIndex() {self._charIndex = nil}

    var hOffsetType: UInt32 {
      get {return _hOffsetType ?? 0}
      set {_hOffsetType = newValue}
    }
    /// Returns true if `hOffsetType` has been explicitly set.
    var hasHOffsetType: Bool {return self._hOffsetType != nil}
    /// Clears the value of `hOffsetType`. Subsequent reads from it will return its default value.
    mutating func clearHOffsetType() {self._hOffsetType = nil}

    var hOffset: Float {
      get {return _hOffset ?? 0}
      set {_hOffset = newValue}
    }
    /// Returns true if `hOffset` has been explicitly set.
    var hasHOffset: Bool {return self._hOffset != nil}
    /// Clears the value of `hOffset`. Subsequent reads from it will return its default value.
    mutating func clearHOffset() {self._hOffset = nil}

    var vOffsetType: UInt32 {
      get {return _vOffsetType ?? 0}
      set {_vOffsetType = newValue}
    }
    /// Returns true if `vOffsetType` has been explicitly set.
    var hasVOffsetType: Bool {return self._vOffsetType != nil}
    /// Clears the value of `vOffsetType`. Subsequent reads from it will return its default value.
    mutating func clearVOffsetType() {self._vOffsetType = nil}

    var vOffset: Float {
      get {return _vOffset ?? 0}
      set {_vOffset = newValue}
    }
    /// Returns true if `vOffset` has been explicitly set.
    var hasVOffset: Bool {return self._vOffset != nil}
    /// Clears the value of `vOffset`. Subsequent reads from it will return its default value.
    mutating func clearVOffset() {self._vOffset = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _charIndex: Int32? = nil
    fileprivate var _hOffsetType: UInt32? = nil
    fileprivate var _hOffset: Float? = nil
    fileprivate var _vOffsetType: UInt32? = nil
    fileprivate var _vOffset: Float? = nil
  }

  init() {}

  fileprivate var _super: TSWP_StorageActionCommandArchive? = nil
}

struct TP_MoveDrawablesFloatingCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_StorageActionCommandArchive {
    get {return _super ?? TSWP_StorageActionCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var argsList: [TSCK_IdPlacementOperationArgs] = []

  var rangeList: [TSP_Range] = []

  var drawableInfoIDPathList: [TSP_UUIDPath] = []

  var pageIndexList: [UInt32] = []

  var exteriorTextWrapList: [TSD_ExteriorTextWrapArchive] = []

  var originalAttachmentList: [TSP_Reference] = []

  var originalExteriorTextWrapList: [TSD_ExteriorTextWrapArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_StorageActionCommandArchive? = nil
}

struct TP_ChangeFootnoteFormatCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var format: TP_ChangeFootnoteFormatCommandArchive.FootnoteFormat {
    get {return _format ?? .kFootnoteFormatNumeric}
    set {_format = newValue}
  }
  /// Returns true if `format` has been explicitly set.
  var hasFormat: Bool {return self._format != nil}
  /// Clears the value of `format`. Subsequent reads from it will return its default value.
  mutating func clearFormat() {self._format = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum FootnoteFormat: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kFootnoteFormatNumeric = 0
    case kFootnoteFormatRoman = 1
    case kFootnoteFormatSymbolic = 2
    case kFootnoteFormatJapaneseNumeric = 3
    case kFootnoteFormatJapaneseIdeographic = 4
    case kFootnoteFormatArabicNumeric = 5

    init() {
      self = .kFootnoteFormatNumeric
    }

  }

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _format: TP_ChangeFootnoteFormatCommandArchive.FootnoteFormat? = nil
}

struct TP_ChangeFootnoteKindCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var kind: TP_ChangeFootnoteKindCommandArchive.FootnoteKind {
    get {return _kind ?? .kFootnoteKindFootnotes}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {self._kind = nil}

  var undoTransaction: TSWP_UndoTransaction {
    get {return _undoTransaction ?? TSWP_UndoTransaction()}
    set {_undoTransaction = newValue}
  }
  /// Returns true if `undoTransaction` has been explicitly set.
  var hasUndoTransaction: Bool {return self._undoTransaction != nil}
  /// Clears the value of `undoTransaction`. Subsequent reads from it will return its default value.
  mutating func clearUndoTransaction() {self._undoTransaction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum FootnoteKind: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kFootnoteKindFootnotes = 0
    case kFootnoteKindDocumentEndnotes = 1
    case kFootnoteKindSectionEndnotes = 2

    init() {
      self = .kFootnoteKindFootnotes
    }

  }

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _kind: TP_ChangeFootnoteKindCommandArchive.FootnoteKind? = nil
  fileprivate var _undoTransaction: TSWP_UndoTransaction? = nil
}

struct TP_ChangeFootnoteNumberingCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var numbering: TP_ChangeFootnoteNumberingCommandArchive.FootnoteNumbering {
    get {return _numbering ?? .kFootnoteNumberingContinuous}
    set {_numbering = newValue}
  }
  /// Returns true if `numbering` has been explicitly set.
  var hasNumbering: Bool {return self._numbering != nil}
  /// Clears the value of `numbering`. Subsequent reads from it will return its default value.
  mutating func clearNumbering() {self._numbering = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum FootnoteNumbering: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kFootnoteNumberingContinuous = 0
    case kFootnoteNumberingRestartEachPage = 1
    case kFootnoteNumberingRestartEachSection = 2

    init() {
      self = .kFootnoteNumberingContinuous
    }

  }

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _numbering: TP_ChangeFootnoteNumberingCommandArchive.FootnoteNumbering? = nil
}

struct TP_ChangeFootnoteSpacingCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var footnoteSpacing: Int32 {
    get {return _footnoteSpacing ?? 0}
    set {_footnoteSpacing = newValue}
  }
  /// Returns true if `footnoteSpacing` has been explicitly set.
  var hasFootnoteSpacing: Bool {return self._footnoteSpacing != nil}
  /// Clears the value of `footnoteSpacing`. Subsequent reads from it will return its default value.
  mutating func clearFootnoteSpacing() {self._footnoteSpacing = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _footnoteSpacing: Int32? = nil
}

struct TP_MoveInlineDrawableAnchoredCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_StorageActionCommandArchive {
    get {return _storage._super ?? TSWP_StorageActionCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var idPlacementOperationArgs: TSCK_IdPlacementOperationArgs {
    get {return _storage._idPlacementOperationArgs ?? TSCK_IdPlacementOperationArgs()}
    set {_uniqueStorage()._idPlacementOperationArgs = newValue}
  }
  /// Returns true if `idPlacementOperationArgs` has been explicitly set.
  var hasIDPlacementOperationArgs: Bool {return _storage._idPlacementOperationArgs != nil}
  /// Clears the value of `idPlacementOperationArgs`. Subsequent reads from it will return its default value.
  mutating func clearIDPlacementOperationArgs() {_uniqueStorage()._idPlacementOperationArgs = nil}

  var replacementRangeLocation: UInt32 {
    get {return _storage._replacementRangeLocation ?? 0}
    set {_uniqueStorage()._replacementRangeLocation = newValue}
  }
  /// Returns true if `replacementRangeLocation` has been explicitly set.
  var hasReplacementRangeLocation: Bool {return _storage._replacementRangeLocation != nil}
  /// Clears the value of `replacementRangeLocation`. Subsequent reads from it will return its default value.
  mutating func clearReplacementRangeLocation() {_uniqueStorage()._replacementRangeLocation = nil}

  var replacementRangeLength: UInt32 {
    get {return _storage._replacementRangeLength ?? 0}
    set {_uniqueStorage()._replacementRangeLength = newValue}
  }
  /// Returns true if `replacementRangeLength` has been explicitly set.
  var hasReplacementRangeLength: Bool {return _storage._replacementRangeLength != nil}
  /// Clears the value of `replacementRangeLength`. Subsequent reads from it will return its default value.
  mutating func clearReplacementRangeLength() {_uniqueStorage()._replacementRangeLength = nil}

  var drawableInfoIDPath: TSP_UUIDPath {
    get {return _storage._drawableInfoIDPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._drawableInfoIDPath = newValue}
  }
  /// Returns true if `drawableInfoIDPath` has been explicitly set.
  var hasDrawableInfoIDPath: Bool {return _storage._drawableInfoIDPath != nil}
  /// Clears the value of `drawableInfoIDPath`. Subsequent reads from it will return its default value.
  mutating func clearDrawableInfoIDPath() {_uniqueStorage()._drawableInfoIDPath = nil}

  var exteriorTextWrap: TSD_ExteriorTextWrapArchive {
    get {return _storage._exteriorTextWrap ?? TSD_ExteriorTextWrapArchive()}
    set {_uniqueStorage()._exteriorTextWrap = newValue}
  }
  /// Returns true if `exteriorTextWrap` has been explicitly set.
  var hasExteriorTextWrap: Bool {return _storage._exteriorTextWrap != nil}
  /// Clears the value of `exteriorTextWrap`. Subsequent reads from it will return its default value.
  mutating func clearExteriorTextWrap() {_uniqueStorage()._exteriorTextWrap = nil}

  var originalExteriorTextWrap: TSD_ExteriorTextWrapArchive {
    get {return _storage._originalExteriorTextWrap ?? TSD_ExteriorTextWrapArchive()}
    set {_uniqueStorage()._originalExteriorTextWrap = newValue}
  }
  /// Returns true if `originalExteriorTextWrap` has been explicitly set.
  var hasOriginalExteriorTextWrap: Bool {return _storage._originalExteriorTextWrap != nil}
  /// Clears the value of `originalExteriorTextWrap`. Subsequent reads from it will return its default value.
  mutating func clearOriginalExteriorTextWrap() {_uniqueStorage()._originalExteriorTextWrap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TP_MoveAnchoredDrawableInlineCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_StorageActionCommandArchive {
    get {return _storage._super ?? TSWP_StorageActionCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var idPlacementOperationArgs: TSCK_IdPlacementOperationArgs {
    get {return _storage._idPlacementOperationArgs ?? TSCK_IdPlacementOperationArgs()}
    set {_uniqueStorage()._idPlacementOperationArgs = newValue}
  }
  /// Returns true if `idPlacementOperationArgs` has been explicitly set.
  var hasIDPlacementOperationArgs: Bool {return _storage._idPlacementOperationArgs != nil}
  /// Clears the value of `idPlacementOperationArgs`. Subsequent reads from it will return its default value.
  mutating func clearIDPlacementOperationArgs() {_uniqueStorage()._idPlacementOperationArgs = nil}

  var replacementRangeLocation: UInt32 {
    get {return _storage._replacementRangeLocation ?? 0}
    set {_uniqueStorage()._replacementRangeLocation = newValue}
  }
  /// Returns true if `replacementRangeLocation` has been explicitly set.
  var hasReplacementRangeLocation: Bool {return _storage._replacementRangeLocation != nil}
  /// Clears the value of `replacementRangeLocation`. Subsequent reads from it will return its default value.
  mutating func clearReplacementRangeLocation() {_uniqueStorage()._replacementRangeLocation = nil}

  var replacementRangeLength: UInt32 {
    get {return _storage._replacementRangeLength ?? 0}
    set {_uniqueStorage()._replacementRangeLength = newValue}
  }
  /// Returns true if `replacementRangeLength` has been explicitly set.
  var hasReplacementRangeLength: Bool {return _storage._replacementRangeLength != nil}
  /// Clears the value of `replacementRangeLength`. Subsequent reads from it will return its default value.
  mutating func clearReplacementRangeLength() {_uniqueStorage()._replacementRangeLength = nil}

  var drawableInfoIDPath: TSP_UUIDPath {
    get {return _storage._drawableInfoIDPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._drawableInfoIDPath = newValue}
  }
  /// Returns true if `drawableInfoIDPath` has been explicitly set.
  var hasDrawableInfoIDPath: Bool {return _storage._drawableInfoIDPath != nil}
  /// Clears the value of `drawableInfoIDPath`. Subsequent reads from it will return its default value.
  mutating func clearDrawableInfoIDPath() {_uniqueStorage()._drawableInfoIDPath = nil}

  var exteriorTextWrap: TSD_ExteriorTextWrapArchive {
    get {return _storage._exteriorTextWrap ?? TSD_ExteriorTextWrapArchive()}
    set {_uniqueStorage()._exteriorTextWrap = newValue}
  }
  /// Returns true if `exteriorTextWrap` has been explicitly set.
  var hasExteriorTextWrap: Bool {return _storage._exteriorTextWrap != nil}
  /// Clears the value of `exteriorTextWrap`. Subsequent reads from it will return its default value.
  mutating func clearExteriorTextWrap() {_uniqueStorage()._exteriorTextWrap = nil}

  var originalExteriorTextWrap: TSD_ExteriorTextWrapArchive {
    get {return _storage._originalExteriorTextWrap ?? TSD_ExteriorTextWrapArchive()}
    set {_uniqueStorage()._originalExteriorTextWrap = newValue}
  }
  /// Returns true if `originalExteriorTextWrap` has been explicitly set.
  var hasOriginalExteriorTextWrap: Bool {return _storage._originalExteriorTextWrap != nil}
  /// Clears the value of `originalExteriorTextWrap`. Subsequent reads from it will return its default value.
  mutating func clearOriginalExteriorTextWrap() {_uniqueStorage()._originalExteriorTextWrap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TP_InsertFootnoteCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_StorageActionCommandArchive {
    get {return _super ?? TSWP_StorageActionCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_StorageActionCommandArchive? = nil
}

struct TP_ToggleBodyLayoutDirectionCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var newDirectionIsVertical: Bool {
    get {return _newDirectionIsVertical ?? false}
    set {_newDirectionIsVertical = newValue}
  }
  /// Returns true if `newDirectionIsVertical` has been explicitly set.
  var hasNewDirectionIsVertical: Bool {return self._newDirectionIsVertical != nil}
  /// Clears the value of `newDirectionIsVertical`. Subsequent reads from it will return its default value.
  mutating func clearNewDirectionIsVertical() {self._newDirectionIsVertical = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _newDirectionIsVertical: Bool? = nil
}

struct TP_TrackChangesCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var trackChanges: Bool {
    get {return _storage._trackChanges ?? false}
    set {_uniqueStorage()._trackChanges = newValue}
  }
  /// Returns true if `trackChanges` has been explicitly set.
  var hasTrackChanges: Bool {return _storage._trackChanges != nil}
  /// Clears the value of `trackChanges`. Subsequent reads from it will return its default value.
  mutating func clearTrackChanges() {_uniqueStorage()._trackChanges = nil}

  var changeSessionHistory: [TSP_Reference] {
    get {return _storage._changeSessionHistory}
    set {_uniqueStorage()._changeSessionHistory = newValue}
  }

  /// NOTE: This field was marked as deprecated in the .proto file.
  var paused: Bool {
    get {return _storage._paused ?? false}
    set {_uniqueStorage()._paused = newValue}
  }
  /// Returns true if `paused` has been explicitly set.
  var hasPaused: Bool {return _storage._paused != nil}
  /// Clears the value of `paused`. Subsequent reads from it will return its default value.
  mutating func clearPaused() {_uniqueStorage()._paused = nil}

  var mostRecentChangeSession: TSP_Reference {
    get {return _storage._mostRecentChangeSession ?? TSP_Reference()}
    set {_uniqueStorage()._mostRecentChangeSession = newValue}
  }
  /// Returns true if `mostRecentChangeSession` has been explicitly set.
  var hasMostRecentChangeSession: Bool {return _storage._mostRecentChangeSession != nil}
  /// Clears the value of `mostRecentChangeSession`. Subsequent reads from it will return its default value.
  mutating func clearMostRecentChangeSession() {_uniqueStorage()._mostRecentChangeSession = nil}

  var oldTrackChanges: Bool {
    get {return _storage._oldTrackChanges ?? false}
    set {_uniqueStorage()._oldTrackChanges = newValue}
  }
  /// Returns true if `oldTrackChanges` has been explicitly set.
  var hasOldTrackChanges: Bool {return _storage._oldTrackChanges != nil}
  /// Clears the value of `oldTrackChanges`. Subsequent reads from it will return its default value.
  mutating func clearOldTrackChanges() {_uniqueStorage()._oldTrackChanges = nil}

  var oldChangeSessionHistory: [TSP_Reference] {
    get {return _storage._oldChangeSessionHistory}
    set {_uniqueStorage()._oldChangeSessionHistory = newValue}
  }

  var oldMostRecentChangeSession: TSP_Reference {
    get {return _storage._oldMostRecentChangeSession ?? TSP_Reference()}
    set {_uniqueStorage()._oldMostRecentChangeSession = newValue}
  }
  /// Returns true if `oldMostRecentChangeSession` has been explicitly set.
  var hasOldMostRecentChangeSession: Bool {return _storage._oldMostRecentChangeSession != nil}
  /// Clears the value of `oldMostRecentChangeSession`. Subsequent reads from it will return its default value.
  mutating func clearOldMostRecentChangeSession() {_uniqueStorage()._oldMostRecentChangeSession = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TP_PauseChangeTrackingCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var paused: Bool {
    get {return _paused ?? false}
    set {_paused = newValue}
  }
  /// Returns true if `paused` has been explicitly set.
  var hasPaused: Bool {return self._paused != nil}
  /// Clears the value of `paused`. Subsequent reads from it will return its default value.
  mutating func clearPaused() {self._paused = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _paused: Bool? = nil
}

struct TP_SectionGuideCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_AbstractGuideCommandArchive {
    get {return _super ?? TSD_AbstractGuideCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var sectionIDPath: TSP_UUIDPath {
    get {return _sectionIDPath ?? TSP_UUIDPath()}
    set {_sectionIDPath = newValue}
  }
  /// Returns true if `sectionIDPath` has been explicitly set.
  var hasSectionIDPath: Bool {return self._sectionIDPath != nil}
  /// Clears the value of `sectionIDPath`. Subsequent reads from it will return its default value.
  mutating func clearSectionIDPath() {self._sectionIDPath = nil}

  var pageIndex: UInt32 {
    get {return _pageIndex ?? 0}
    set {_pageIndex = newValue}
  }
  /// Returns true if `pageIndex` has been explicitly set.
  var hasPageIndex: Bool {return self._pageIndex != nil}
  /// Clears the value of `pageIndex`. Subsequent reads from it will return its default value.
  mutating func clearPageIndex() {self._pageIndex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_AbstractGuideCommandArchive? = nil
  fileprivate var _sectionIDPath: TSP_UUIDPath? = nil
  fileprivate var _pageIndex: UInt32? = nil
}

struct TP_ReplaceHeaderFooterStorageCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var headerFooterStorageIDPath: TSP_UUIDPath {
    get {return _storage._headerFooterStorageIDPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._headerFooterStorageIDPath = newValue}
  }
  /// Returns true if `headerFooterStorageIDPath` has been explicitly set.
  var hasHeaderFooterStorageIDPath: Bool {return _storage._headerFooterStorageIDPath != nil}
  /// Clears the value of `headerFooterStorageIDPath`. Subsequent reads from it will return its default value.
  mutating func clearHeaderFooterStorageIDPath() {_uniqueStorage()._headerFooterStorageIDPath = nil}

  var replacementHeaderFooterStorage: TSP_Reference {
    get {return _storage._replacementHeaderFooterStorage ?? TSP_Reference()}
    set {_uniqueStorage()._replacementHeaderFooterStorage = newValue}
  }
  /// Returns true if `replacementHeaderFooterStorage` has been explicitly set.
  var hasReplacementHeaderFooterStorage: Bool {return _storage._replacementHeaderFooterStorage != nil}
  /// Clears the value of `replacementHeaderFooterStorage`. Subsequent reads from it will return its default value.
  mutating func clearReplacementHeaderFooterStorage() {_uniqueStorage()._replacementHeaderFooterStorage = nil}

  var replacementHeaderFooterStorageUndoObject: TSP_Reference {
    get {return _storage._replacementHeaderFooterStorageUndoObject ?? TSP_Reference()}
    set {_uniqueStorage()._replacementHeaderFooterStorageUndoObject = newValue}
  }
  /// Returns true if `replacementHeaderFooterStorageUndoObject` has been explicitly set.
  var hasReplacementHeaderFooterStorageUndoObject: Bool {return _storage._replacementHeaderFooterStorageUndoObject != nil}
  /// Clears the value of `replacementHeaderFooterStorageUndoObject`. Subsequent reads from it will return its default value.
  mutating func clearReplacementHeaderFooterStorageUndoObject() {_uniqueStorage()._replacementHeaderFooterStorageUndoObject = nil}

  var oldHeaderFooterStorage: TSP_Reference {
    get {return _storage._oldHeaderFooterStorage ?? TSP_Reference()}
    set {_uniqueStorage()._oldHeaderFooterStorage = newValue}
  }
  /// Returns true if `oldHeaderFooterStorage` has been explicitly set.
  var hasOldHeaderFooterStorage: Bool {return _storage._oldHeaderFooterStorage != nil}
  /// Clears the value of `oldHeaderFooterStorage`. Subsequent reads from it will return its default value.
  mutating func clearOldHeaderFooterStorage() {_uniqueStorage()._oldHeaderFooterStorage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TP_PrototypeForUndoChangePageTemplateForSection: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var idPathForTemplateInDocument: TSP_UUIDPath {
    get {return _idPathForTemplateInDocument ?? TSP_UUIDPath()}
    set {_idPathForTemplateInDocument = newValue}
  }
  /// Returns true if `idPathForTemplateInDocument` has been explicitly set.
  var hasIDPathForTemplateInDocument: Bool {return self._idPathForTemplateInDocument != nil}
  /// Clears the value of `idPathForTemplateInDocument`. Subsequent reads from it will return its default value.
  mutating func clearIDPathForTemplateInDocument() {self._idPathForTemplateInDocument = nil}

  var internalPageTemplate: TSP_Reference {
    get {return _internalPageTemplate ?? TSP_Reference()}
    set {_internalPageTemplate = newValue}
  }
  /// Returns true if `internalPageTemplate` has been explicitly set.
  var hasInternalPageTemplate: Bool {return self._internalPageTemplate != nil}
  /// Clears the value of `internalPageTemplate`. Subsequent reads from it will return its default value.
  mutating func clearInternalPageTemplate() {self._internalPageTemplate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _idPathForTemplateInDocument: TSP_UUIDPath? = nil
  fileprivate var _internalPageTemplate: TSP_Reference? = nil
}

struct TP_ChangePageTemplateForSectionCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var sectionIDPath: TSP_UUIDPath {
    get {return _storage._sectionIDPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._sectionIDPath = newValue}
  }
  /// Returns true if `sectionIDPath` has been explicitly set.
  var hasSectionIDPath: Bool {return _storage._sectionIDPath != nil}
  /// Clears the value of `sectionIDPath`. Subsequent reads from it will return its default value.
  mutating func clearSectionIDPath() {_uniqueStorage()._sectionIDPath = nil}

  var pageTemplate: TSP_Reference {
    get {return _storage._pageTemplate ?? TSP_Reference()}
    set {_uniqueStorage()._pageTemplate = newValue}
  }
  /// Returns true if `pageTemplate` has been explicitly set.
  var hasPageTemplate: Bool {return _storage._pageTemplate != nil}
  /// Clears the value of `pageTemplate`. Subsequent reads from it will return its default value.
  mutating func clearPageTemplate() {_uniqueStorage()._pageTemplate = nil}

  var oldPageTemplate: TSP_Reference {
    get {return _storage._oldPageTemplate ?? TSP_Reference()}
    set {_uniqueStorage()._oldPageTemplate = newValue}
  }
  /// Returns true if `oldPageTemplate` has been explicitly set.
  var hasOldPageTemplate: Bool {return _storage._oldPageTemplate != nil}
  /// Clears the value of `oldPageTemplate`. Subsequent reads from it will return its default value.
  mutating func clearOldPageTemplate() {_uniqueStorage()._oldPageTemplate = nil}

  var isUndoRedo: Bool {
    get {return _storage._isUndoRedo ?? false}
    set {_uniqueStorage()._isUndoRedo = newValue}
  }
  /// Returns true if `isUndoRedo` has been explicitly set.
  var hasIsUndoRedo: Bool {return _storage._isUndoRedo != nil}
  /// Clears the value of `isUndoRedo`. Subsequent reads from it will return its default value.
  mutating func clearIsUndoRedo() {_uniqueStorage()._isUndoRedo = nil}

  var targetPrototype: TSP_Reference {
    get {return _storage._targetPrototype ?? TSP_Reference()}
    set {_uniqueStorage()._targetPrototype = newValue}
  }
  /// Returns true if `targetPrototype` has been explicitly set.
  var hasTargetPrototype: Bool {return _storage._targetPrototype != nil}
  /// Clears the value of `targetPrototype`. Subsequent reads from it will return its default value.
  mutating func clearTargetPrototype() {_uniqueStorage()._targetPrototype = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TP_AllFootnoteSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var allFootnoteSelection: TSP_Reference {
    get {return _allFootnoteSelection ?? TSP_Reference()}
    set {_allFootnoteSelection = newValue}
  }
  /// Returns true if `allFootnoteSelection` has been explicitly set.
  var hasAllFootnoteSelection: Bool {return self._allFootnoteSelection != nil}
  /// Clears the value of `allFootnoteSelection`. Subsequent reads from it will return its default value.
  mutating func clearAllFootnoteSelection() {self._allFootnoteSelection = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _allFootnoteSelection: TSP_Reference? = nil
}

struct TP_DocumentSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var documentSelection: TSP_Reference {
    get {return _documentSelection ?? TSP_Reference()}
    set {_documentSelection = newValue}
  }
  /// Returns true if `documentSelection` has been explicitly set.
  var hasDocumentSelection: Bool {return self._documentSelection != nil}
  /// Clears the value of `documentSelection`. Subsequent reads from it will return its default value.
  mutating func clearDocumentSelection() {self._documentSelection = nil}

  var storageUuidPath: TSP_UUIDPath {
    get {return _storageUuidPath ?? TSP_UUIDPath()}
    set {_storageUuidPath = newValue}
  }
  /// Returns true if `storageUuidPath` has been explicitly set.
  var hasStorageUuidPath: Bool {return self._storageUuidPath != nil}
  /// Clears the value of `storageUuidPath`. Subsequent reads from it will return its default value.
  mutating func clearStorageUuidPath() {self._storageUuidPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _documentSelection: TSP_Reference? = nil
  fileprivate var _storageUuidPath: TSP_UUIDPath? = nil
}

struct TP_CanvasSelectionTransformerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_SelectionTransformerArchive {
    get {return _super ?? TSWP_SelectionTransformerArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var infosCollectionHelper: TSD_InfoCollectionSelectionTransformerHelperArchive {
    get {return _infosCollectionHelper ?? TSD_InfoCollectionSelectionTransformerHelperArchive()}
    set {_infosCollectionHelper = newValue}
  }
  /// Returns true if `infosCollectionHelper` has been explicitly set.
  var hasInfosCollectionHelper: Bool {return self._infosCollectionHelper != nil}
  /// Clears the value of `infosCollectionHelper`. Subsequent reads from it will return its default value.
  mutating func clearInfosCollectionHelper() {self._infosCollectionHelper = nil}

  var excludedInfosCollectionHelper: TSD_InfoCollectionSelectionTransformerHelperArchive {
    get {return _excludedInfosCollectionHelper ?? TSD_InfoCollectionSelectionTransformerHelperArchive()}
    set {_excludedInfosCollectionHelper = newValue}
  }
  /// Returns true if `excludedInfosCollectionHelper` has been explicitly set.
  var hasExcludedInfosCollectionHelper: Bool {return self._excludedInfosCollectionHelper != nil}
  /// Clears the value of `excludedInfosCollectionHelper`. Subsequent reads from it will return its default value.
  mutating func clearExcludedInfosCollectionHelper() {self._excludedInfosCollectionHelper = nil}

  var additionalInfosCollectionHelper: TSD_InfoCollectionSelectionTransformerHelperArchive {
    get {return _additionalInfosCollectionHelper ?? TSD_InfoCollectionSelectionTransformerHelperArchive()}
    set {_additionalInfosCollectionHelper = newValue}
  }
  /// Returns true if `additionalInfosCollectionHelper` has been explicitly set.
  var hasAdditionalInfosCollectionHelper: Bool {return self._additionalInfosCollectionHelper != nil}
  /// Clears the value of `additionalInfosCollectionHelper`. Subsequent reads from it will return its default value.
  mutating func clearAdditionalInfosCollectionHelper() {self._additionalInfosCollectionHelper = nil}

  var headerOrFootnoteStorageUuidPath: TSP_UUIDPath {
    get {return _headerOrFootnoteStorageUuidPath ?? TSP_UUIDPath()}
    set {_headerOrFootnoteStorageUuidPath = newValue}
  }
  /// Returns true if `headerOrFootnoteStorageUuidPath` has been explicitly set.
  var hasHeaderOrFootnoteStorageUuidPath: Bool {return self._headerOrFootnoteStorageUuidPath != nil}
  /// Clears the value of `headerOrFootnoteStorageUuidPath`. Subsequent reads from it will return its default value.
  mutating func clearHeaderOrFootnoteStorageUuidPath() {self._headerOrFootnoteStorageUuidPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_SelectionTransformerArchive? = nil
  fileprivate var _infosCollectionHelper: TSD_InfoCollectionSelectionTransformerHelperArchive? = nil
  fileprivate var _excludedInfosCollectionHelper: TSD_InfoCollectionSelectionTransformerHelperArchive? = nil
  fileprivate var _additionalInfosCollectionHelper: TSD_InfoCollectionSelectionTransformerHelperArchive? = nil
  fileprivate var _headerOrFootnoteStorageUuidPath: TSP_UUIDPath? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TP"

extension TP_InsertDrawablesCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InsertDrawablesCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}for_paste\0\u{3}args_list\0\u{3}page_index_list\0\u{3}drawable_info_list\0\u{3}custom_format_keys\0\u{3}drawable_undo_object\0\u{3}saved_next_untitled_resolver_index\0\u{3}placeholder_tags_list\0\u{3}insertion_type\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _forPaste: Bool? = nil
    var _insertionType: TP_InsertDrawablesCommandArchive.InsertionType? = nil
    var _argsList: [TSCK_AddIdOperationArgs] = []
    var _pageIndexList: [UInt32] = []
    var _drawableInfoList: [TSP_Reference] = []
    var _placeholderTagsList: [String] = []
    var _customFormatKeys: [TSP_UUID] = []
    var _drawableUndoObject: TSP_Reference? = nil
    var _savedNextUntitledResolverIndex: UInt32? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _forPaste = source._forPaste
      _insertionType = source._insertionType
      _argsList = source._argsList
      _pageIndexList = source._pageIndexList
      _drawableInfoList = source._drawableInfoList
      _placeholderTagsList = source._placeholderTagsList
      _customFormatKeys = source._customFormatKeys
      _drawableUndoObject = source._drawableUndoObject
      _savedNextUntitledResolverIndex = source._savedNextUntitledResolverIndex
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._argsList) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._drawableInfoList) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._customFormatKeys) {return false}
      if let v = _storage._drawableUndoObject, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._forPaste) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._argsList) }()
        case 4: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._pageIndexList) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._drawableInfoList) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._customFormatKeys) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._drawableUndoObject) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._savedNextUntitledResolverIndex) }()
        case 9: try { try decoder.decodeRepeatedStringField(value: &_storage._placeholderTagsList) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._insertionType) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._forPaste {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      if !_storage._argsList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._argsList, fieldNumber: 3)
      }
      if !_storage._pageIndexList.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._pageIndexList, fieldNumber: 4)
      }
      if !_storage._drawableInfoList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._drawableInfoList, fieldNumber: 5)
      }
      if !_storage._customFormatKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._customFormatKeys, fieldNumber: 6)
      }
      try { if let v = _storage._drawableUndoObject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._savedNextUntitledResolverIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
      } }()
      if !_storage._placeholderTagsList.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._placeholderTagsList, fieldNumber: 9)
      }
      try { if let v = _storage._insertionType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_InsertDrawablesCommandArchive, rhs: TP_InsertDrawablesCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._forPaste != rhs_storage._forPaste {return false}
        if _storage._insertionType != rhs_storage._insertionType {return false}
        if _storage._argsList != rhs_storage._argsList {return false}
        if _storage._pageIndexList != rhs_storage._pageIndexList {return false}
        if _storage._drawableInfoList != rhs_storage._drawableInfoList {return false}
        if _storage._placeholderTagsList != rhs_storage._placeholderTagsList {return false}
        if _storage._customFormatKeys != rhs_storage._customFormatKeys {return false}
        if _storage._drawableUndoObject != rhs_storage._drawableUndoObject {return false}
        if _storage._savedNextUntitledResolverIndex != rhs_storage._savedNextUntitledResolverIndex {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_InsertDrawablesCommandArchive.InsertionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0InsertingPrototype\0\u{1}Pasting\0\u{1}Cloning\0")
}

extension TP_MoveDrawablesPageIndexCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MoveDrawablesPageIndexCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}page_index\0\u{1}drawables\0\u{3}maintain_z_order\0\u{3}drawable_info_id_path_list\0\u{3}page_index_list\0\u{3}original_page_index_list\0\u{3}tags_list\0\u{3}original_tags_list\0\u{3}preserve_tags\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _pageIndex: UInt32? = nil
    var _drawables: [TP_MoveDrawablesPageIndexCommandArchive.Drawable] = []
    var _maintainZOrder: Bool? = nil
    var _drawableInfoIDPathList: [TSP_UUIDPath] = []
    var _pageIndexList: [UInt32] = []
    var _originalPageIndexList: [UInt32] = []
    var _tagsList: [String] = []
    var _originalTagsList: [String] = []
    var _preserveTags: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _pageIndex = source._pageIndex
      _drawables = source._drawables
      _maintainZOrder = source._maintainZOrder
      _drawableInfoIDPathList = source._drawableInfoIDPathList
      _pageIndexList = source._pageIndexList
      _originalPageIndexList = source._originalPageIndexList
      _tagsList = source._tagsList
      _originalTagsList = source._originalTagsList
      _preserveTags = source._preserveTags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._drawables) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._drawableInfoIDPathList) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._pageIndex) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._drawables) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._maintainZOrder) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._drawableInfoIDPathList) }()
        case 6: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._pageIndexList) }()
        case 7: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._originalPageIndexList) }()
        case 8: try { try decoder.decodeRepeatedStringField(value: &_storage._tagsList) }()
        case 9: try { try decoder.decodeRepeatedStringField(value: &_storage._originalTagsList) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._preserveTags) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._pageIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      } }()
      if !_storage._drawables.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._drawables, fieldNumber: 3)
      }
      try { if let v = _storage._maintainZOrder {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      if !_storage._drawableInfoIDPathList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._drawableInfoIDPathList, fieldNumber: 5)
      }
      if !_storage._pageIndexList.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._pageIndexList, fieldNumber: 6)
      }
      if !_storage._originalPageIndexList.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._originalPageIndexList, fieldNumber: 7)
      }
      if !_storage._tagsList.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tagsList, fieldNumber: 8)
      }
      if !_storage._originalTagsList.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._originalTagsList, fieldNumber: 9)
      }
      try { if let v = _storage._preserveTags {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_MoveDrawablesPageIndexCommandArchive, rhs: TP_MoveDrawablesPageIndexCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._pageIndex != rhs_storage._pageIndex {return false}
        if _storage._drawables != rhs_storage._drawables {return false}
        if _storage._maintainZOrder != rhs_storage._maintainZOrder {return false}
        if _storage._drawableInfoIDPathList != rhs_storage._drawableInfoIDPathList {return false}
        if _storage._pageIndexList != rhs_storage._pageIndexList {return false}
        if _storage._originalPageIndexList != rhs_storage._originalPageIndexList {return false}
        if _storage._tagsList != rhs_storage._tagsList {return false}
        if _storage._originalTagsList != rhs_storage._originalTagsList {return false}
        if _storage._preserveTags != rhs_storage._preserveTags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_MoveDrawablesPageIndexCommandArchive.Drawable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TP_MoveDrawablesPageIndexCommandArchive.protoMessageName + ".Drawable"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}drawable\0\u{3}z_order\0")

  public var isInitialized: Bool {
    if let v = self._drawable, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._drawable) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._zOrder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._drawable {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._zOrder {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_MoveDrawablesPageIndexCommandArchive.Drawable, rhs: TP_MoveDrawablesPageIndexCommandArchive.Drawable) -> Bool {
    if lhs._drawable != rhs._drawable {return false}
    if lhs._zOrder != rhs._zOrder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_InsertSectionBreakCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InsertSectionBreakCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_InsertSectionBreakCommandArchive, rhs: TP_InsertSectionBreakCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_MoveDrawableZOrderCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MoveDrawableZOrderCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}args_list\0\u{3}action_string_index\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.argsList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.argsList) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._actionStringIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.argsList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.argsList, fieldNumber: 2)
    }
    try { if let v = self._actionStringIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_MoveDrawableZOrderCommandArchive, rhs: TP_MoveDrawableZOrderCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.argsList != rhs.argsList {return false}
    if lhs._actionStringIndex != rhs._actionStringIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_RemoveDrawablesCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveDrawablesCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}args_list\0\u{3}drawable_info_list\0\u{3}page_index_list\0\u{3}tags_list\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.argsList) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.drawableInfoList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.argsList) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.drawableInfoList) }()
      case 4: try { try decoder.decodeRepeatedUInt32Field(value: &self.pageIndexList) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.tagsList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.argsList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.argsList, fieldNumber: 2)
    }
    if !self.drawableInfoList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.drawableInfoList, fieldNumber: 3)
    }
    if !self.pageIndexList.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.pageIndexList, fieldNumber: 4)
    }
    if !self.tagsList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tagsList, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_RemoveDrawablesCommandArchive, rhs: TP_RemoveDrawablesCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.argsList != rhs.argsList {return false}
    if lhs.drawableInfoList != rhs.drawableInfoList {return false}
    if lhs.pageIndexList != rhs.pageIndexList {return false}
    if lhs.tagsList != rhs.tagsList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_ChangeSectionMarginsCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeSectionMarginsCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}section\0\u{1}margin\0\u{3}margin_value\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._section, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._section) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._margin) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._marginValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._section {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._margin {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._marginValue {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_ChangeSectionMarginsCommandArchive, rhs: TP_ChangeSectionMarginsCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._section != rhs._section {return false}
    if lhs._margin != rhs._margin {return false}
    if lhs._marginValue != rhs._marginValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_ChangeSectionMarginsCommandArchive.SectionMargin: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kSectionMarginLeft\0\u{1}kSectionMarginRight\0\u{1}kSectionMarginTop\0\u{1}kSectionMarginBottom\0\u{1}kSectionMarginHeader\0\u{1}kSectionMarginFooter\0")
}

extension TP_InsertSectionTemplateDrawablesCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InsertSectionTemplateDrawablesCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}OBSOLETE_section\0\u{3}section_template_drawables\0\u{3}drawable_index\0\u{3}section_template_drawable_provider\0\u{3}custom_format_keys\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _obsoleteSection: TSP_Reference? = nil
    var _sectionTemplateDrawables: [TSP_Reference] = []
    var _drawableIndex: UInt32? = nil
    var _sectionTemplateDrawableProvider: TSP_Reference? = nil
    var _customFormatKeys: [TSP_UUID] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _obsoleteSection = source._obsoleteSection
      _sectionTemplateDrawables = source._sectionTemplateDrawables
      _drawableIndex = source._drawableIndex
      _sectionTemplateDrawableProvider = source._sectionTemplateDrawableProvider
      _customFormatKeys = source._customFormatKeys
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._obsoleteSection, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._sectionTemplateDrawables) {return false}
      if let v = _storage._sectionTemplateDrawableProvider, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._customFormatKeys) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._obsoleteSection) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._sectionTemplateDrawables) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._drawableIndex) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._sectionTemplateDrawableProvider) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._customFormatKeys) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._obsoleteSection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._sectionTemplateDrawables.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sectionTemplateDrawables, fieldNumber: 3)
      }
      try { if let v = _storage._drawableIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._sectionTemplateDrawableProvider {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._customFormatKeys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._customFormatKeys, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_InsertSectionTemplateDrawablesCommandArchive, rhs: TP_InsertSectionTemplateDrawablesCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._obsoleteSection != rhs_storage._obsoleteSection {return false}
        if _storage._sectionTemplateDrawables != rhs_storage._sectionTemplateDrawables {return false}
        if _storage._drawableIndex != rhs_storage._drawableIndex {return false}
        if _storage._sectionTemplateDrawableProvider != rhs_storage._sectionTemplateDrawableProvider {return false}
        if _storage._customFormatKeys != rhs_storage._customFormatKeys {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_MoveSectionTemplateDrawableZOrderCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MoveSectionTemplateDrawableZOrderCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}OBSOLETE_section\0\u{3}section_template_drawables\0\u{1}indexes\0\u{3}section_template_drawable_provider\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _obsoleteSection: TSP_Reference? = nil
    var _sectionTemplateDrawables: [TSP_Reference] = []
    var _indexes: [UInt32] = []
    var _sectionTemplateDrawableProvider: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _obsoleteSection = source._obsoleteSection
      _sectionTemplateDrawables = source._sectionTemplateDrawables
      _indexes = source._indexes
      _sectionTemplateDrawableProvider = source._sectionTemplateDrawableProvider
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._obsoleteSection, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._sectionTemplateDrawables) {return false}
      if let v = _storage._sectionTemplateDrawableProvider, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._obsoleteSection) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._sectionTemplateDrawables) }()
        case 4: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._indexes) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._sectionTemplateDrawableProvider) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._obsoleteSection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._sectionTemplateDrawables.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sectionTemplateDrawables, fieldNumber: 3)
      }
      if !_storage._indexes.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._indexes, fieldNumber: 4)
      }
      try { if let v = _storage._sectionTemplateDrawableProvider {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_MoveSectionTemplateDrawableZOrderCommandArchive, rhs: TP_MoveSectionTemplateDrawableZOrderCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._obsoleteSection != rhs_storage._obsoleteSection {return false}
        if _storage._sectionTemplateDrawables != rhs_storage._sectionTemplateDrawables {return false}
        if _storage._indexes != rhs_storage._indexes {return false}
        if _storage._sectionTemplateDrawableProvider != rhs_storage._sectionTemplateDrawableProvider {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_RemoveSectionTemplateDrawablesCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveSectionTemplateDrawablesCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}OBSOLETE_section\0\u{3}section_template_drawables\0\u{3}section_template_drawable_provider\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _obsoleteSection: TSP_Reference? = nil
    var _sectionTemplateDrawables: [TP_RemoveSectionTemplateDrawablesCommandArchive.SectionTemplateDrawable] = []
    var _sectionTemplateDrawableProvider: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _obsoleteSection = source._obsoleteSection
      _sectionTemplateDrawables = source._sectionTemplateDrawables
      _sectionTemplateDrawableProvider = source._sectionTemplateDrawableProvider
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._obsoleteSection, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._sectionTemplateDrawables) {return false}
      if let v = _storage._sectionTemplateDrawableProvider, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._obsoleteSection) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._sectionTemplateDrawables) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._sectionTemplateDrawableProvider) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._obsoleteSection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._sectionTemplateDrawables.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sectionTemplateDrawables, fieldNumber: 3)
      }
      try { if let v = _storage._sectionTemplateDrawableProvider {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_RemoveSectionTemplateDrawablesCommandArchive, rhs: TP_RemoveSectionTemplateDrawablesCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._obsoleteSection != rhs_storage._obsoleteSection {return false}
        if _storage._sectionTemplateDrawables != rhs_storage._sectionTemplateDrawables {return false}
        if _storage._sectionTemplateDrawableProvider != rhs_storage._sectionTemplateDrawableProvider {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_RemoveSectionTemplateDrawablesCommandArchive.SectionTemplateDrawable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TP_RemoveSectionTemplateDrawablesCommandArchive.protoMessageName + ".SectionTemplateDrawable"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}drawable\0\u{3}drawable_index\0")

  public var isInitialized: Bool {
    if let v = self._drawable, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._drawable) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._drawableIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._drawable {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._drawableIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_RemoveSectionTemplateDrawablesCommandArchive.SectionTemplateDrawable, rhs: TP_RemoveSectionTemplateDrawablesCommandArchive.SectionTemplateDrawable) -> Bool {
    if lhs._drawable != rhs._drawable {return false}
    if lhs._drawableIndex != rhs._drawableIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_PasteSectionTemplateDrawablesCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PasteSectionTemplateDrawablesCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}section\0\u{3}section_template_drawables\0\u{3}drawable_index\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._section, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.sectionTemplateDrawables) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._section) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.sectionTemplateDrawables) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._drawableIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._section {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.sectionTemplateDrawables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sectionTemplateDrawables, fieldNumber: 3)
    }
    try { if let v = self._drawableIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_PasteSectionTemplateDrawablesCommandArchive, rhs: TP_PasteSectionTemplateDrawablesCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._section != rhs._section {return false}
    if lhs.sectionTemplateDrawables != rhs.sectionTemplateDrawables {return false}
    if lhs._drawableIndex != rhs._drawableIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_MoveDrawablesAttachedCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MoveDrawablesAttachedCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}args_list\0\u{3}range_list\0\u{3}drawable_info_id_path_list\0\u{3}position_list\0\u{3}exterior_text_wrap_list\0\u{3}original_page_index_list\0\u{3}original_exterior_text_wrap_list\0\u{3}original_attachment_list\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.argsList) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rangeList) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.drawableInfoIDPathList) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.originalAttachmentList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.argsList) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.rangeList) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.drawableInfoIDPathList) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.positionList) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.exteriorTextWrapList) }()
      case 7: try { try decoder.decodeRepeatedUInt32Field(value: &self.originalPageIndexList) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.originalExteriorTextWrapList) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.originalAttachmentList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.argsList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.argsList, fieldNumber: 2)
    }
    if !self.rangeList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rangeList, fieldNumber: 3)
    }
    if !self.drawableInfoIDPathList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.drawableInfoIDPathList, fieldNumber: 4)
    }
    if !self.positionList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.positionList, fieldNumber: 5)
    }
    if !self.exteriorTextWrapList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exteriorTextWrapList, fieldNumber: 6)
    }
    if !self.originalPageIndexList.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.originalPageIndexList, fieldNumber: 7)
    }
    if !self.originalExteriorTextWrapList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.originalExteriorTextWrapList, fieldNumber: 8)
    }
    if !self.originalAttachmentList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.originalAttachmentList, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_MoveDrawablesAttachedCommandArchive, rhs: TP_MoveDrawablesAttachedCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.argsList != rhs.argsList {return false}
    if lhs.rangeList != rhs.rangeList {return false}
    if lhs.drawableInfoIDPathList != rhs.drawableInfoIDPathList {return false}
    if lhs.positionList != rhs.positionList {return false}
    if lhs.exteriorTextWrapList != rhs.exteriorTextWrapList {return false}
    if lhs.originalPageIndexList != rhs.originalPageIndexList {return false}
    if lhs.originalExteriorTextWrapList != rhs.originalExteriorTextWrapList {return false}
    if lhs.originalAttachmentList != rhs.originalAttachmentList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_MoveDrawablesAttachedCommandArchive.GSSPCharIndexAndPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TP_MoveDrawablesAttachedCommandArchive.protoMessageName + ".GSSPCharIndexAndPosition"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}char_index\0\u{3}h_offset_type\0\u{3}h_offset\0\u{3}v_offset_type\0\u{3}v_offset\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._charIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._hOffsetType) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._hOffset) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._vOffsetType) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._vOffset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._charIndex {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._hOffsetType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hOffset {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._vOffsetType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._vOffset {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_MoveDrawablesAttachedCommandArchive.GSSPCharIndexAndPosition, rhs: TP_MoveDrawablesAttachedCommandArchive.GSSPCharIndexAndPosition) -> Bool {
    if lhs._charIndex != rhs._charIndex {return false}
    if lhs._hOffsetType != rhs._hOffsetType {return false}
    if lhs._hOffset != rhs._hOffset {return false}
    if lhs._vOffsetType != rhs._vOffsetType {return false}
    if lhs._vOffset != rhs._vOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_MoveDrawablesFloatingCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MoveDrawablesFloatingCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}args_list\0\u{3}range_list\0\u{3}drawable_info_id_path_list\0\u{3}page_index_list\0\u{3}exterior_text_wrap_list\0\u{3}original_attachment_list\0\u{3}original_exterior_text_wrap_list\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.argsList) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rangeList) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.drawableInfoIDPathList) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.originalAttachmentList) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.argsList) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.rangeList) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.drawableInfoIDPathList) }()
      case 5: try { try decoder.decodeRepeatedUInt32Field(value: &self.pageIndexList) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.exteriorTextWrapList) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.originalAttachmentList) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.originalExteriorTextWrapList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.argsList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.argsList, fieldNumber: 2)
    }
    if !self.rangeList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rangeList, fieldNumber: 3)
    }
    if !self.drawableInfoIDPathList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.drawableInfoIDPathList, fieldNumber: 4)
    }
    if !self.pageIndexList.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.pageIndexList, fieldNumber: 5)
    }
    if !self.exteriorTextWrapList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exteriorTextWrapList, fieldNumber: 6)
    }
    if !self.originalAttachmentList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.originalAttachmentList, fieldNumber: 7)
    }
    if !self.originalExteriorTextWrapList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.originalExteriorTextWrapList, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_MoveDrawablesFloatingCommandArchive, rhs: TP_MoveDrawablesFloatingCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.argsList != rhs.argsList {return false}
    if lhs.rangeList != rhs.rangeList {return false}
    if lhs.drawableInfoIDPathList != rhs.drawableInfoIDPathList {return false}
    if lhs.pageIndexList != rhs.pageIndexList {return false}
    if lhs.exteriorTextWrapList != rhs.exteriorTextWrapList {return false}
    if lhs.originalAttachmentList != rhs.originalAttachmentList {return false}
    if lhs.originalExteriorTextWrapList != rhs.originalExteriorTextWrapList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_ChangeFootnoteFormatCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeFootnoteFormatCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}format\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._format) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._format {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_ChangeFootnoteFormatCommandArchive, rhs: TP_ChangeFootnoteFormatCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._format != rhs._format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_ChangeFootnoteFormatCommandArchive.FootnoteFormat: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kFootnoteFormatNumeric\0\u{1}kFootnoteFormatRoman\0\u{1}kFootnoteFormatSymbolic\0\u{1}kFootnoteFormatJapaneseNumeric\0\u{1}kFootnoteFormatJapaneseIdeographic\0\u{1}kFootnoteFormatArabicNumeric\0")
}

extension TP_ChangeFootnoteKindCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeFootnoteKindCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}kind\0\u{3}undo_transaction\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._undoTransaction, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._kind) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._undoTransaction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._kind {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._undoTransaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_ChangeFootnoteKindCommandArchive, rhs: TP_ChangeFootnoteKindCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._kind != rhs._kind {return false}
    if lhs._undoTransaction != rhs._undoTransaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_ChangeFootnoteKindCommandArchive.FootnoteKind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kFootnoteKindFootnotes\0\u{1}kFootnoteKindDocumentEndnotes\0\u{1}kFootnoteKindSectionEndnotes\0")
}

extension TP_ChangeFootnoteNumberingCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeFootnoteNumberingCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}numbering\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._numbering) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._numbering {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_ChangeFootnoteNumberingCommandArchive, rhs: TP_ChangeFootnoteNumberingCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._numbering != rhs._numbering {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_ChangeFootnoteNumberingCommandArchive.FootnoteNumbering: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kFootnoteNumberingContinuous\0\u{1}kFootnoteNumberingRestartEachPage\0\u{1}kFootnoteNumberingRestartEachSection\0")
}

extension TP_ChangeFootnoteSpacingCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeFootnoteSpacingCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}footnote_spacing\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._footnoteSpacing) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._footnoteSpacing {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_ChangeFootnoteSpacingCommandArchive, rhs: TP_ChangeFootnoteSpacingCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._footnoteSpacing != rhs._footnoteSpacing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_MoveInlineDrawableAnchoredCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MoveInlineDrawableAnchoredCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}id_placement_operation_args\0\u{3}replacement_range_location\0\u{3}replacement_range_length\0\u{3}drawable_info_id_path\0\u{3}exterior_text_wrap\0\u{3}original_exterior_text_wrap\0")

  fileprivate class _StorageClass {
    var _super: TSWP_StorageActionCommandArchive? = nil
    var _idPlacementOperationArgs: TSCK_IdPlacementOperationArgs? = nil
    var _replacementRangeLocation: UInt32? = nil
    var _replacementRangeLength: UInt32? = nil
    var _drawableInfoIDPath: TSP_UUIDPath? = nil
    var _exteriorTextWrap: TSD_ExteriorTextWrapArchive? = nil
    var _originalExteriorTextWrap: TSD_ExteriorTextWrapArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _idPlacementOperationArgs = source._idPlacementOperationArgs
      _replacementRangeLocation = source._replacementRangeLocation
      _replacementRangeLength = source._replacementRangeLength
      _drawableInfoIDPath = source._drawableInfoIDPath
      _exteriorTextWrap = source._exteriorTextWrap
      _originalExteriorTextWrap = source._originalExteriorTextWrap
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._idPlacementOperationArgs, !v.isInitialized {return false}
      if let v = _storage._drawableInfoIDPath, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._idPlacementOperationArgs) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._replacementRangeLocation) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._replacementRangeLength) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._drawableInfoIDPath) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._exteriorTextWrap) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._originalExteriorTextWrap) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._idPlacementOperationArgs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._replacementRangeLocation {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._replacementRangeLength {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._drawableInfoIDPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._exteriorTextWrap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._originalExteriorTextWrap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_MoveInlineDrawableAnchoredCommandArchive, rhs: TP_MoveInlineDrawableAnchoredCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._idPlacementOperationArgs != rhs_storage._idPlacementOperationArgs {return false}
        if _storage._replacementRangeLocation != rhs_storage._replacementRangeLocation {return false}
        if _storage._replacementRangeLength != rhs_storage._replacementRangeLength {return false}
        if _storage._drawableInfoIDPath != rhs_storage._drawableInfoIDPath {return false}
        if _storage._exteriorTextWrap != rhs_storage._exteriorTextWrap {return false}
        if _storage._originalExteriorTextWrap != rhs_storage._originalExteriorTextWrap {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_MoveAnchoredDrawableInlineCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MoveAnchoredDrawableInlineCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}id_placement_operation_args\0\u{3}replacement_range_location\0\u{3}replacement_range_length\0\u{3}drawable_info_id_path\0\u{3}exterior_text_wrap\0\u{3}original_exterior_text_wrap\0")

  fileprivate class _StorageClass {
    var _super: TSWP_StorageActionCommandArchive? = nil
    var _idPlacementOperationArgs: TSCK_IdPlacementOperationArgs? = nil
    var _replacementRangeLocation: UInt32? = nil
    var _replacementRangeLength: UInt32? = nil
    var _drawableInfoIDPath: TSP_UUIDPath? = nil
    var _exteriorTextWrap: TSD_ExteriorTextWrapArchive? = nil
    var _originalExteriorTextWrap: TSD_ExteriorTextWrapArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _idPlacementOperationArgs = source._idPlacementOperationArgs
      _replacementRangeLocation = source._replacementRangeLocation
      _replacementRangeLength = source._replacementRangeLength
      _drawableInfoIDPath = source._drawableInfoIDPath
      _exteriorTextWrap = source._exteriorTextWrap
      _originalExteriorTextWrap = source._originalExteriorTextWrap
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._idPlacementOperationArgs, !v.isInitialized {return false}
      if let v = _storage._drawableInfoIDPath, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._idPlacementOperationArgs) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._replacementRangeLocation) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._replacementRangeLength) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._drawableInfoIDPath) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._exteriorTextWrap) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._originalExteriorTextWrap) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._idPlacementOperationArgs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._replacementRangeLocation {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._replacementRangeLength {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._drawableInfoIDPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._exteriorTextWrap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._originalExteriorTextWrap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_MoveAnchoredDrawableInlineCommandArchive, rhs: TP_MoveAnchoredDrawableInlineCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._idPlacementOperationArgs != rhs_storage._idPlacementOperationArgs {return false}
        if _storage._replacementRangeLocation != rhs_storage._replacementRangeLocation {return false}
        if _storage._replacementRangeLength != rhs_storage._replacementRangeLength {return false}
        if _storage._drawableInfoIDPath != rhs_storage._drawableInfoIDPath {return false}
        if _storage._exteriorTextWrap != rhs_storage._exteriorTextWrap {return false}
        if _storage._originalExteriorTextWrap != rhs_storage._originalExteriorTextWrap {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_InsertFootnoteCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InsertFootnoteCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_InsertFootnoteCommandArchive, rhs: TP_InsertFootnoteCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_ToggleBodyLayoutDirectionCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ToggleBodyLayoutDirectionCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}new_direction_is_vertical\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._newDirectionIsVertical) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newDirectionIsVertical {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_ToggleBodyLayoutDirectionCommandArchive, rhs: TP_ToggleBodyLayoutDirectionCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._newDirectionIsVertical != rhs._newDirectionIsVertical {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_TrackChangesCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrackChangesCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}track_changes\0\u{3}change_session_history\0\u{1}paused\0\u{3}most_recent_change_session\0\u{3}old_track_changes\0\u{3}old_change_session_history\0\u{3}old_most_recent_change_session\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _trackChanges: Bool? = nil
    var _changeSessionHistory: [TSP_Reference] = []
    var _paused: Bool? = nil
    var _mostRecentChangeSession: TSP_Reference? = nil
    var _oldTrackChanges: Bool? = nil
    var _oldChangeSessionHistory: [TSP_Reference] = []
    var _oldMostRecentChangeSession: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _trackChanges = source._trackChanges
      _changeSessionHistory = source._changeSessionHistory
      _paused = source._paused
      _mostRecentChangeSession = source._mostRecentChangeSession
      _oldTrackChanges = source._oldTrackChanges
      _oldChangeSessionHistory = source._oldChangeSessionHistory
      _oldMostRecentChangeSession = source._oldMostRecentChangeSession
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._changeSessionHistory) {return false}
      if let v = _storage._mostRecentChangeSession, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._oldChangeSessionHistory) {return false}
      if let v = _storage._oldMostRecentChangeSession, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._trackChanges) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._changeSessionHistory) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._paused) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._mostRecentChangeSession) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._oldTrackChanges) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._oldChangeSessionHistory) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._oldMostRecentChangeSession) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._trackChanges {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      if !_storage._changeSessionHistory.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._changeSessionHistory, fieldNumber: 3)
      }
      try { if let v = _storage._paused {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._mostRecentChangeSession {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._oldTrackChanges {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      if !_storage._oldChangeSessionHistory.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oldChangeSessionHistory, fieldNumber: 7)
      }
      try { if let v = _storage._oldMostRecentChangeSession {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_TrackChangesCommandArchive, rhs: TP_TrackChangesCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._trackChanges != rhs_storage._trackChanges {return false}
        if _storage._changeSessionHistory != rhs_storage._changeSessionHistory {return false}
        if _storage._paused != rhs_storage._paused {return false}
        if _storage._mostRecentChangeSession != rhs_storage._mostRecentChangeSession {return false}
        if _storage._oldTrackChanges != rhs_storage._oldTrackChanges {return false}
        if _storage._oldChangeSessionHistory != rhs_storage._oldChangeSessionHistory {return false}
        if _storage._oldMostRecentChangeSession != rhs_storage._oldMostRecentChangeSession {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_PauseChangeTrackingCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PauseChangeTrackingCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}paused\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._paused) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._paused {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_PauseChangeTrackingCommandArchive, rhs: TP_PauseChangeTrackingCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._paused != rhs._paused {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_SectionGuideCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SectionGuideCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}section_id_path\0\u{3}page_index\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._sectionIDPath == nil {return false}
    if self._pageIndex == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._sectionIDPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sectionIDPath) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._pageIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sectionIDPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pageIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_SectionGuideCommandArchive, rhs: TP_SectionGuideCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._sectionIDPath != rhs._sectionIDPath {return false}
    if lhs._pageIndex != rhs._pageIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_ReplaceHeaderFooterStorageCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReplaceHeaderFooterStorageCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}header_footer_storage_id_path\0\u{3}replacement_header_footer_storage\0\u{3}replacement_header_footer_storage_undo_object\0\u{3}old_header_footer_storage\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _headerFooterStorageIDPath: TSP_UUIDPath? = nil
    var _replacementHeaderFooterStorage: TSP_Reference? = nil
    var _replacementHeaderFooterStorageUndoObject: TSP_Reference? = nil
    var _oldHeaderFooterStorage: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _headerFooterStorageIDPath = source._headerFooterStorageIDPath
      _replacementHeaderFooterStorage = source._replacementHeaderFooterStorage
      _replacementHeaderFooterStorageUndoObject = source._replacementHeaderFooterStorageUndoObject
      _oldHeaderFooterStorage = source._oldHeaderFooterStorage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._headerFooterStorageIDPath, !v.isInitialized {return false}
      if let v = _storage._replacementHeaderFooterStorage, !v.isInitialized {return false}
      if let v = _storage._replacementHeaderFooterStorageUndoObject, !v.isInitialized {return false}
      if let v = _storage._oldHeaderFooterStorage, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._headerFooterStorageIDPath) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._replacementHeaderFooterStorage) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._replacementHeaderFooterStorageUndoObject) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._oldHeaderFooterStorage) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._headerFooterStorageIDPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._replacementHeaderFooterStorage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._replacementHeaderFooterStorageUndoObject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._oldHeaderFooterStorage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_ReplaceHeaderFooterStorageCommandArchive, rhs: TP_ReplaceHeaderFooterStorageCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._headerFooterStorageIDPath != rhs_storage._headerFooterStorageIDPath {return false}
        if _storage._replacementHeaderFooterStorage != rhs_storage._replacementHeaderFooterStorage {return false}
        if _storage._replacementHeaderFooterStorageUndoObject != rhs_storage._replacementHeaderFooterStorageUndoObject {return false}
        if _storage._oldHeaderFooterStorage != rhs_storage._oldHeaderFooterStorage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_PrototypeForUndoChangePageTemplateForSection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PrototypeForUndoChangePageTemplateForSection"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}id_path_for_template_in_document\0\u{3}internal_page_template\0")

  public var isInitialized: Bool {
    if self._internalPageTemplate == nil {return false}
    if let v = self._idPathForTemplateInDocument, !v.isInitialized {return false}
    if let v = self._internalPageTemplate, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._idPathForTemplateInDocument) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._internalPageTemplate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._idPathForTemplateInDocument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._internalPageTemplate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_PrototypeForUndoChangePageTemplateForSection, rhs: TP_PrototypeForUndoChangePageTemplateForSection) -> Bool {
    if lhs._idPathForTemplateInDocument != rhs._idPathForTemplateInDocument {return false}
    if lhs._internalPageTemplate != rhs._internalPageTemplate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_ChangePageTemplateForSectionCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangePageTemplateForSectionCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}section_id_path\0\u{3}page_template\0\u{3}old_page_template\0\u{3}is_undo_redo\0\u{3}target_prototype\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _sectionIDPath: TSP_UUIDPath? = nil
    var _pageTemplate: TSP_Reference? = nil
    var _oldPageTemplate: TSP_Reference? = nil
    var _isUndoRedo: Bool? = nil
    var _targetPrototype: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _sectionIDPath = source._sectionIDPath
      _pageTemplate = source._pageTemplate
      _oldPageTemplate = source._oldPageTemplate
      _isUndoRedo = source._isUndoRedo
      _targetPrototype = source._targetPrototype
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._sectionIDPath == nil {return false}
      if _storage._pageTemplate == nil {return false}
      if _storage._isUndoRedo == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._sectionIDPath, !v.isInitialized {return false}
      if let v = _storage._pageTemplate, !v.isInitialized {return false}
      if let v = _storage._oldPageTemplate, !v.isInitialized {return false}
      if let v = _storage._targetPrototype, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._sectionIDPath) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._pageTemplate) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._oldPageTemplate) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._isUndoRedo) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._targetPrototype) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._sectionIDPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._pageTemplate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._oldPageTemplate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._isUndoRedo {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._targetPrototype {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_ChangePageTemplateForSectionCommandArchive, rhs: TP_ChangePageTemplateForSectionCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._sectionIDPath != rhs_storage._sectionIDPath {return false}
        if _storage._pageTemplate != rhs_storage._pageTemplate {return false}
        if _storage._oldPageTemplate != rhs_storage._oldPageTemplate {return false}
        if _storage._isUndoRedo != rhs_storage._isUndoRedo {return false}
        if _storage._targetPrototype != rhs_storage._targetPrototype {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_AllFootnoteSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AllFootnoteSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}all_footnote_selection\0")

  public var isInitialized: Bool {
    if self._allFootnoteSelection == nil {return false}
    if let v = self._allFootnoteSelection, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._allFootnoteSelection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._allFootnoteSelection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_AllFootnoteSelectionTransformerArchive, rhs: TP_AllFootnoteSelectionTransformerArchive) -> Bool {
    if lhs._allFootnoteSelection != rhs._allFootnoteSelection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_DocumentSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}document_selection\0\u{3}storage_uuid_path\0")

  public var isInitialized: Bool {
    if self._documentSelection == nil {return false}
    if self._storageUuidPath == nil {return false}
    if let v = self._documentSelection, !v.isInitialized {return false}
    if let v = self._storageUuidPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._documentSelection) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._storageUuidPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._documentSelection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._storageUuidPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_DocumentSelectionTransformerArchive, rhs: TP_DocumentSelectionTransformerArchive) -> Bool {
    if lhs._documentSelection != rhs._documentSelection {return false}
    if lhs._storageUuidPath != rhs._storageUuidPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TP_CanvasSelectionTransformerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CanvasSelectionTransformerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}infos_collection_helper\0\u{3}excluded_infos_collection_helper\0\u{3}additional_infos_collection_helper\0\u{3}header_or_footnote_storage_uuid_path\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._infosCollectionHelper == nil {return false}
    if self._excludedInfosCollectionHelper == nil {return false}
    if self._additionalInfosCollectionHelper == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._infosCollectionHelper, !v.isInitialized {return false}
    if let v = self._excludedInfosCollectionHelper, !v.isInitialized {return false}
    if let v = self._additionalInfosCollectionHelper, !v.isInitialized {return false}
    if let v = self._headerOrFootnoteStorageUuidPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._infosCollectionHelper) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._excludedInfosCollectionHelper) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._additionalInfosCollectionHelper) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._headerOrFootnoteStorageUuidPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._infosCollectionHelper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._excludedInfosCollectionHelper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._additionalInfosCollectionHelper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._headerOrFootnoteStorageUuidPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TP_CanvasSelectionTransformerArchive, rhs: TP_CanvasSelectionTransformerArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._infosCollectionHelper != rhs._infosCollectionHelper {return false}
    if lhs._excludedInfosCollectionHelper != rhs._excludedInfosCollectionHelper {return false}
    if lhs._additionalInfosCollectionHelper != rhs._additionalInfosCollectionHelper {return false}
    if lhs._headerOrFootnoteStorageUuidPath != rhs._headerOrFootnoteStorageUuidPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
