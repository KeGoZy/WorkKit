// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TSCKArchives.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct TSCK_CollaborationCommandHistoryArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var largeArray: TSP_LargeArray {
    get {return _largeArray ?? TSP_LargeArray()}
    set {_largeArray = newValue}
  }
  /// Returns true if `largeArray` has been explicitly set.
  var hasLargeArray: Bool {return self._largeArray != nil}
  /// Clears the value of `largeArray`. Subsequent reads from it will return its default value.
  mutating func clearLargeArray() {self._largeArray = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _largeArray: TSP_LargeArray? = nil
}

struct TSCK_CollaborationCommandHistoryArraySegment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var largeObjectArraySegment: TSP_LargeObjectArraySegment {
    get {return _largeObjectArraySegment ?? TSP_LargeObjectArraySegment()}
    set {_largeObjectArraySegment = newValue}
  }
  /// Returns true if `largeObjectArraySegment` has been explicitly set.
  var hasLargeObjectArraySegment: Bool {return self._largeObjectArraySegment != nil}
  /// Clears the value of `largeObjectArraySegment`. Subsequent reads from it will return its default value.
  mutating func clearLargeObjectArraySegment() {self._largeObjectArraySegment = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _largeObjectArraySegment: TSP_LargeObjectArraySegment? = nil
}

struct TSCK_CollaborationCommandHistory: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var localIdentifier: TSP_UUID {
    get {return _localIdentifier ?? TSP_UUID()}
    set {_localIdentifier = newValue}
  }
  /// Returns true if `localIdentifier` has been explicitly set.
  var hasLocalIdentifier: Bool {return self._localIdentifier != nil}
  /// Clears the value of `localIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearLocalIdentifier() {self._localIdentifier = nil}

  var undoItems: TSCK_CollaborationCommandHistory.ItemList {
    get {return _undoItems ?? TSCK_CollaborationCommandHistory.ItemList()}
    set {_undoItems = newValue}
  }
  /// Returns true if `undoItems` has been explicitly set.
  var hasUndoItems: Bool {return self._undoItems != nil}
  /// Clears the value of `undoItems`. Subsequent reads from it will return its default value.
  mutating func clearUndoItems() {self._undoItems = nil}

  var redoItems: TSCK_CollaborationCommandHistory.ItemList {
    get {return _redoItems ?? TSCK_CollaborationCommandHistory.ItemList()}
    set {_redoItems = newValue}
  }
  /// Returns true if `redoItems` has been explicitly set.
  var hasRedoItems: Bool {return self._redoItems != nil}
  /// Clears the value of `redoItems`. Subsequent reads from it will return its default value.
  mutating func clearRedoItems() {self._redoItems = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ItemList: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var itemsArray: TSP_Reference {
      get {return _itemsArray ?? TSP_Reference()}
      set {_itemsArray = newValue}
    }
    /// Returns true if `itemsArray` has been explicitly set.
    var hasItemsArray: Bool {return self._itemsArray != nil}
    /// Clears the value of `itemsArray`. Subsequent reads from it will return its default value.
    mutating func clearItemsArray() {self._itemsArray = nil}

    var transformerEntries: [TSP_Reference] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _itemsArray: TSP_Reference? = nil
  }

  init() {}

  fileprivate var _localIdentifier: TSP_UUID? = nil
  fileprivate var _undoItems: TSCK_CollaborationCommandHistory.ItemList? = nil
  fileprivate var _redoItems: TSCK_CollaborationCommandHistory.ItemList? = nil
}

struct TSCK_CollaborationCommandHistoryItem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var command: TSP_Reference {
    get {return _command ?? TSP_Reference()}
    set {_command = newValue}
  }
  /// Returns true if `command` has been explicitly set.
  var hasCommand: Bool {return self._command != nil}
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  mutating func clearCommand() {self._command = nil}

  var actionString: String {
    get {return _actionString ?? String()}
    set {_actionString = newValue}
  }
  /// Returns true if `actionString` has been explicitly set.
  var hasActionString: Bool {return self._actionString != nil}
  /// Clears the value of `actionString`. Subsequent reads from it will return its default value.
  mutating func clearActionString() {self._actionString = nil}

  var behavior: TSP_Reference {
    get {return _behavior ?? TSP_Reference()}
    set {_behavior = newValue}
  }
  /// Returns true if `behavior` has been explicitly set.
  var hasBehavior: Bool {return self._behavior != nil}
  /// Clears the value of `behavior`. Subsequent reads from it will return its default value.
  mutating func clearBehavior() {self._behavior = nil}

  var coalescingGroup: TSP_Reference {
    get {return _coalescingGroup ?? TSP_Reference()}
    set {_coalescingGroup = newValue}
  }
  /// Returns true if `coalescingGroup` has been explicitly set.
  var hasCoalescingGroup: Bool {return self._coalescingGroup != nil}
  /// Clears the value of `coalescingGroup`. Subsequent reads from it will return its default value.
  mutating func clearCoalescingGroup() {self._coalescingGroup = nil}

  var revisionSequence: UInt64 {
    get {return _revisionSequence ?? 0}
    set {_revisionSequence = newValue}
  }
  /// Returns true if `revisionSequence` has been explicitly set.
  var hasRevisionSequence: Bool {return self._revisionSequence != nil}
  /// Clears the value of `revisionSequence`. Subsequent reads from it will return its default value.
  mutating func clearRevisionSequence() {self._revisionSequence = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _command: TSP_Reference? = nil
  fileprivate var _actionString: String? = nil
  fileprivate var _behavior: TSP_Reference? = nil
  fileprivate var _coalescingGroup: TSP_Reference? = nil
  fileprivate var _revisionSequence: UInt64? = nil
}

struct TSCK_CollaborationCommandHistoryCoalescingGroup: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodes: [TSP_Reference] = []

  var didCoalesceAllCommands: Bool {
    get {return _didCoalesceAllCommands ?? false}
    set {_didCoalesceAllCommands = newValue}
  }
  /// Returns true if `didCoalesceAllCommands` has been explicitly set.
  var hasDidCoalesceAllCommands: Bool {return self._didCoalesceAllCommands != nil}
  /// Clears the value of `didCoalesceAllCommands`. Subsequent reads from it will return its default value.
  mutating func clearDidCoalesceAllCommands() {self._didCoalesceAllCommands = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _didCoalesceAllCommands: Bool? = nil
}

struct TSCK_CollaborationCommandHistoryCoalescingGroupNode: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var command: TSP_Reference {
    get {return _command ?? TSP_Reference()}
    set {_command = newValue}
  }
  /// Returns true if `command` has been explicitly set.
  var hasCommand: Bool {return self._command != nil}
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  mutating func clearCommand() {self._command = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _command: TSP_Reference? = nil
}

struct TSCK_CollaborationCommandHistoryOriginatingCommandAcknowledgementObserver: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var coalescingGroup: TSP_Reference {
    get {return _coalescingGroup ?? TSP_Reference()}
    set {_coalescingGroup = newValue}
  }
  /// Returns true if `coalescingGroup` has been explicitly set.
  var hasCoalescingGroup: Bool {return self._coalescingGroup != nil}
  /// Clears the value of `coalescingGroup`. Subsequent reads from it will return its default value.
  mutating func clearCoalescingGroup() {self._coalescingGroup = nil}

  var node: TSP_Reference {
    get {return _node ?? TSP_Reference()}
    set {_node = newValue}
  }
  /// Returns true if `node` has been explicitly set.
  var hasNode: Bool {return self._node != nil}
  /// Clears the value of `node`. Subsequent reads from it will return its default value.
  mutating func clearNode() {self._node = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _coalescingGroup: TSP_Reference? = nil
  fileprivate var _node: TSP_Reference? = nil
}

struct TSCK_DocumentSupportCollaborationState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var collaborationCommandHistory: TSP_Reference {
    get {return _collaborationCommandHistory ?? TSP_Reference()}
    set {_collaborationCommandHistory = newValue}
  }
  /// Returns true if `collaborationCommandHistory` has been explicitly set.
  var hasCollaborationCommandHistory: Bool {return self._collaborationCommandHistory != nil}
  /// Clears the value of `collaborationCommandHistory`. Subsequent reads from it will return its default value.
  mutating func clearCollaborationCommandHistory() {self._collaborationCommandHistory = nil}

  var collaborationSessionState: TSP_Reference {
    get {return _collaborationSessionState ?? TSP_Reference()}
    set {_collaborationSessionState = newValue}
  }
  /// Returns true if `collaborationSessionState` has been explicitly set.
  var hasCollaborationSessionState: Bool {return self._collaborationSessionState != nil}
  /// Clears the value of `collaborationSessionState`. Subsequent reads from it will return its default value.
  mutating func clearCollaborationSessionState() {self._collaborationSessionState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _collaborationCommandHistory: TSP_Reference? = nil
  fileprivate var _collaborationSessionState: TSP_Reference? = nil
}

struct TSCK_SetAnnotationAuthorColorCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var annotationAuthor: TSP_Reference {
    get {return _storage._annotationAuthor ?? TSP_Reference()}
    set {_uniqueStorage()._annotationAuthor = newValue}
  }
  /// Returns true if `annotationAuthor` has been explicitly set.
  var hasAnnotationAuthor: Bool {return _storage._annotationAuthor != nil}
  /// Clears the value of `annotationAuthor`. Subsequent reads from it will return its default value.
  mutating func clearAnnotationAuthor() {_uniqueStorage()._annotationAuthor = nil}

  var color: TSP_Color {
    get {return _storage._color ?? TSP_Color()}
    set {_uniqueStorage()._color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return _storage._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {_uniqueStorage()._color = nil}

  var oldColor: TSP_Color {
    get {return _storage._oldColor ?? TSP_Color()}
    set {_uniqueStorage()._oldColor = newValue}
  }
  /// Returns true if `oldColor` has been explicitly set.
  var hasOldColor: Bool {return _storage._oldColor != nil}
  /// Clears the value of `oldColor`. Subsequent reads from it will return its default value.
  mutating func clearOldColor() {_uniqueStorage()._oldColor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSCK_SetActivityAuthorShareParticipantIDCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var activityAuthor: TSP_Reference {
    get {return _activityAuthor ?? TSP_Reference()}
    set {_activityAuthor = newValue}
  }
  /// Returns true if `activityAuthor` has been explicitly set.
  var hasActivityAuthor: Bool {return self._activityAuthor != nil}
  /// Clears the value of `activityAuthor`. Subsequent reads from it will return its default value.
  mutating func clearActivityAuthor() {self._activityAuthor = nil}

  var shareParticipantID: String {
    get {return _shareParticipantID ?? String()}
    set {_shareParticipantID = newValue}
  }
  /// Returns true if `shareParticipantID` has been explicitly set.
  var hasShareParticipantID: Bool {return self._shareParticipantID != nil}
  /// Clears the value of `shareParticipantID`. Subsequent reads from it will return its default value.
  mutating func clearShareParticipantID() {self._shareParticipantID = nil}

  var oldShareParticipantID: String {
    get {return _oldShareParticipantID ?? String()}
    set {_oldShareParticipantID = newValue}
  }
  /// Returns true if `oldShareParticipantID` has been explicitly set.
  var hasOldShareParticipantID: Bool {return self._oldShareParticipantID != nil}
  /// Clears the value of `oldShareParticipantID`. Subsequent reads from it will return its default value.
  mutating func clearOldShareParticipantID() {self._oldShareParticipantID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _activityAuthor: TSP_Reference? = nil
  fileprivate var _shareParticipantID: String? = nil
  fileprivate var _oldShareParticipantID: String? = nil
}

struct TSCK_IdOperationArgs: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var idPath: TSP_UUIDPath {
    get {return _idPath ?? TSP_UUIDPath()}
    set {_idPath = newValue}
  }
  /// Returns true if `idPath` has been explicitly set.
  var hasIDPath: Bool {return self._idPath != nil}
  /// Clears the value of `idPath`. Subsequent reads from it will return its default value.
  mutating func clearIDPath() {self._idPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _idPath: TSP_UUIDPath? = nil
}

struct TSCK_AddIdOperationArgs: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSCK_IdOperationArgs {
    get {return _super ?? TSCK_IdOperationArgs()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var index: Int32 {
    get {return _index ?? 0}
    set {_index = newValue}
  }
  /// Returns true if `index` has been explicitly set.
  var hasIndex: Bool {return self._index != nil}
  /// Clears the value of `index`. Subsequent reads from it will return its default value.
  mutating func clearIndex() {self._index = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSCK_IdOperationArgs? = nil
  fileprivate var _index: Int32? = nil
}

struct TSCK_RemoveIdOperationArgs: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSCK_IdOperationArgs {
    get {return _super ?? TSCK_IdOperationArgs()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var index: Int32 {
    get {return _index ?? 0}
    set {_index = newValue}
  }
  /// Returns true if `index` has been explicitly set.
  var hasIndex: Bool {return self._index != nil}
  /// Clears the value of `index`. Subsequent reads from it will return its default value.
  mutating func clearIndex() {self._index = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSCK_IdOperationArgs? = nil
  fileprivate var _index: Int32? = nil
}

struct TSCK_RearrangeIdOperationArgs: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSCK_IdOperationArgs {
    get {return _super ?? TSCK_IdOperationArgs()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var fromIndex: Int32 {
    get {return _fromIndex ?? 0}
    set {_fromIndex = newValue}
  }
  /// Returns true if `fromIndex` has been explicitly set.
  var hasFromIndex: Bool {return self._fromIndex != nil}
  /// Clears the value of `fromIndex`. Subsequent reads from it will return its default value.
  mutating func clearFromIndex() {self._fromIndex = nil}

  var toIndex: Int32 {
    get {return _toIndex ?? 0}
    set {_toIndex = newValue}
  }
  /// Returns true if `toIndex` has been explicitly set.
  var hasToIndex: Bool {return self._toIndex != nil}
  /// Clears the value of `toIndex`. Subsequent reads from it will return its default value.
  mutating func clearToIndex() {self._toIndex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSCK_IdOperationArgs? = nil
  fileprivate var _fromIndex: Int32? = nil
  fileprivate var _toIndex: Int32? = nil
}

struct TSCK_IdPlacementOperationArgs: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSCK_IdOperationArgs {
    get {return _super ?? TSCK_IdOperationArgs()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var fromIndex: Int32 {
    get {return _fromIndex ?? 0}
    set {_fromIndex = newValue}
  }
  /// Returns true if `fromIndex` has been explicitly set.
  var hasFromIndex: Bool {return self._fromIndex != nil}
  /// Clears the value of `fromIndex`. Subsequent reads from it will return its default value.
  mutating func clearFromIndex() {self._fromIndex = nil}

  var toIndex: Int32 {
    get {return _toIndex ?? 0}
    set {_toIndex = newValue}
  }
  /// Returns true if `toIndex` has been explicitly set.
  var hasToIndex: Bool {return self._toIndex != nil}
  /// Clears the value of `toIndex`. Subsequent reads from it will return its default value.
  mutating func clearToIndex() {self._toIndex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSCK_IdOperationArgs? = nil
  fileprivate var _fromIndex: Int32? = nil
  fileprivate var _toIndex: Int32? = nil
}

struct TSCK_ActivityCommitCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var activity: TSP_Reference {
    get {return _storage._activity ?? TSP_Reference()}
    set {_uniqueStorage()._activity = newValue}
  }
  /// Returns true if `activity` has been explicitly set.
  var hasActivity: Bool {return _storage._activity != nil}
  /// Clears the value of `activity`. Subsequent reads from it will return its default value.
  mutating func clearActivity() {_uniqueStorage()._activity = nil}

  var author: TSP_Reference {
    get {return _storage._author ?? TSP_Reference()}
    set {_uniqueStorage()._author = newValue}
  }
  /// Returns true if `author` has been explicitly set.
  var hasAuthor: Bool {return _storage._author != nil}
  /// Clears the value of `author`. Subsequent reads from it will return its default value.
  mutating func clearAuthor() {_uniqueStorage()._author = nil}

  var wasActivityCommitted: Bool {
    get {return _storage._wasActivityCommitted ?? true}
    set {_uniqueStorage()._wasActivityCommitted = newValue}
  }
  /// Returns true if `wasActivityCommitted` has been explicitly set.
  var hasWasActivityCommitted: Bool {return _storage._wasActivityCommitted != nil}
  /// Clears the value of `wasActivityCommitted`. Subsequent reads from it will return its default value.
  mutating func clearWasActivityCommitted() {_uniqueStorage()._wasActivityCommitted = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSCK_ExecuteTestBetweenRollbackAndReapplyCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
}

struct TSCK_CreateLocalStorageSnapshotCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var snapshotID: String {
    get {return _snapshotID ?? String()}
    set {_snapshotID = newValue}
  }
  /// Returns true if `snapshotID` has been explicitly set.
  var hasSnapshotID: Bool {return self._snapshotID != nil}
  /// Clears the value of `snapshotID`. Subsequent reads from it will return its default value.
  mutating func clearSnapshotID() {self._snapshotID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _snapshotID: String? = nil
}

struct TSCK_BlockDiffsAtCurrentRevisionCommand: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
}

struct TSCK_TransformerEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequence: UInt64 {
    get {return _sequence ?? 0}
    set {_sequence = newValue}
  }
  /// Returns true if `sequence` has been explicitly set.
  var hasSequence: Bool {return self._sequence != nil}
  /// Clears the value of `sequence`. Subsequent reads from it will return its default value.
  mutating func clearSequence() {self._sequence = nil}

  var creationTime: Double {
    get {return _creationTime ?? 0}
    set {_creationTime = newValue}
  }
  /// Returns true if `creationTime` has been explicitly set.
  var hasCreationTime: Bool {return self._creationTime != nil}
  /// Clears the value of `creationTime`. Subsequent reads from it will return its default value.
  mutating func clearCreationTime() {self._creationTime = nil}

  var transformer: TSK_OperationTransformer {
    get {return _transformer ?? TSK_OperationTransformer()}
    set {_transformer = newValue}
  }
  /// Returns true if `transformer` has been explicitly set.
  var hasTransformer: Bool {return self._transformer != nil}
  /// Clears the value of `transformer`. Subsequent reads from it will return its default value.
  mutating func clearTransformer() {self._transformer = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sequence: UInt64? = nil
  fileprivate var _creationTime: Double? = nil
  fileprivate var _transformer: TSK_OperationTransformer? = nil
}

struct TSCK_CollaborationAppliedCommandDocumentRevisionMapping: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var command: TSP_Reference {
    get {return _command ?? TSP_Reference()}
    set {_command = newValue}
  }
  /// Returns true if `command` has been explicitly set.
  var hasCommand: Bool {return self._command != nil}
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  mutating func clearCommand() {self._command = nil}

  var documentRevisionIdentifier: TSP_UUID {
    get {return _documentRevisionIdentifier ?? TSP_UUID()}
    set {_documentRevisionIdentifier = newValue}
  }
  /// Returns true if `documentRevisionIdentifier` has been explicitly set.
  var hasDocumentRevisionIdentifier: Bool {return self._documentRevisionIdentifier != nil}
  /// Clears the value of `documentRevisionIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearDocumentRevisionIdentifier() {self._documentRevisionIdentifier = nil}

  var documentRevisionSequence: Int32 {
    get {return _documentRevisionSequence ?? 0}
    set {_documentRevisionSequence = newValue}
  }
  /// Returns true if `documentRevisionSequence` has been explicitly set.
  var hasDocumentRevisionSequence: Bool {return self._documentRevisionSequence != nil}
  /// Clears the value of `documentRevisionSequence`. Subsequent reads from it will return its default value.
  mutating func clearDocumentRevisionSequence() {self._documentRevisionSequence = nil}

  var remainingCommandOperations: [TSK_Operation] = []

  var timestamp: TSP_Date {
    get {return _timestamp ?? TSP_Date()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _command: TSP_Reference? = nil
  fileprivate var _documentRevisionIdentifier: TSP_UUID? = nil
  fileprivate var _documentRevisionSequence: Int32? = nil
  fileprivate var _timestamp: TSP_Date? = nil
}

struct TSCK_CollaborationDocumentSessionState: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var collaboratorIds: [String] {
    get {return _storage._collaboratorIds}
    set {_uniqueStorage()._collaboratorIds = newValue}
  }

  var rsvpCommandQueueItems: [TSP_Reference] {
    get {return _storage._rsvpCommandQueueItems}
    set {_uniqueStorage()._rsvpCommandQueueItems = newValue}
  }

  var collaboratorCursorTransformerEntries: [TSP_Reference] {
    get {return _storage._collaboratorCursorTransformerEntries}
    set {_uniqueStorage()._collaboratorCursorTransformerEntries = newValue}
  }

  var acknowledgedCommandsPendingResumeProcessDiffs: [TSP_Reference] {
    get {return _storage._acknowledgedCommandsPendingResumeProcessDiffs}
    set {_uniqueStorage()._acknowledgedCommandsPendingResumeProcessDiffs = newValue}
  }

  var unprocessedCommandsPendingResumeProcessDiffs: [TSP_Reference] {
    get {return _storage._unprocessedCommandsPendingResumeProcessDiffs}
    set {_uniqueStorage()._unprocessedCommandsPendingResumeProcessDiffs = newValue}
  }

  var commandAcknowledgementObserverEntries: [TSCK_CollaborationDocumentSessionState.AcknowledgementObserverEntry] {
    get {return _storage._commandAcknowledgementObserverEntries}
    set {_uniqueStorage()._commandAcknowledgementObserverEntries = newValue}
  }

  var transformerFromUnprocessedCommandOperationsEntries: [TSP_Reference] {
    get {return _storage._transformerFromUnprocessedCommandOperationsEntries}
    set {_uniqueStorage()._transformerFromUnprocessedCommandOperationsEntries = newValue}
  }

  var mailboxRequestDocumentRevisionSequence: Int32 {
    get {return _storage._mailboxRequestDocumentRevisionSequence ?? 0}
    set {_uniqueStorage()._mailboxRequestDocumentRevisionSequence = newValue}
  }
  /// Returns true if `mailboxRequestDocumentRevisionSequence` has been explicitly set.
  var hasMailboxRequestDocumentRevisionSequence: Bool {return _storage._mailboxRequestDocumentRevisionSequence != nil}
  /// Clears the value of `mailboxRequestDocumentRevisionSequence`. Subsequent reads from it will return its default value.
  mutating func clearMailboxRequestDocumentRevisionSequence() {_uniqueStorage()._mailboxRequestDocumentRevisionSequence = nil}

  var mailboxRequestDocumentRevisionIdentifier: TSP_UUID {
    get {return _storage._mailboxRequestDocumentRevisionIdentifier ?? TSP_UUID()}
    set {_uniqueStorage()._mailboxRequestDocumentRevisionIdentifier = newValue}
  }
  /// Returns true if `mailboxRequestDocumentRevisionIdentifier` has been explicitly set.
  var hasMailboxRequestDocumentRevisionIdentifier: Bool {return _storage._mailboxRequestDocumentRevisionIdentifier != nil}
  /// Clears the value of `mailboxRequestDocumentRevisionIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearMailboxRequestDocumentRevisionIdentifier() {_uniqueStorage()._mailboxRequestDocumentRevisionIdentifier = nil}

  var lastSendPendingCommandQueueItemWasMovedFromRsvpCommandQueue: Bool {
    get {return _storage._lastSendPendingCommandQueueItemWasMovedFromRsvpCommandQueue ?? false}
    set {_uniqueStorage()._lastSendPendingCommandQueueItemWasMovedFromRsvpCommandQueue = newValue}
  }
  /// Returns true if `lastSendPendingCommandQueueItemWasMovedFromRsvpCommandQueue` has been explicitly set.
  var hasLastSendPendingCommandQueueItemWasMovedFromRsvpCommandQueue: Bool {return _storage._lastSendPendingCommandQueueItemWasMovedFromRsvpCommandQueue != nil}
  /// Clears the value of `lastSendPendingCommandQueueItemWasMovedFromRsvpCommandQueue`. Subsequent reads from it will return its default value.
  mutating func clearLastSendPendingCommandQueueItemWasMovedFromRsvpCommandQueue() {_uniqueStorage()._lastSendPendingCommandQueueItemWasMovedFromRsvpCommandQueue = nil}

  var lastCommandSendMarkerSequence: Int32 {
    get {return _storage._lastCommandSendMarkerSequence ?? 0}
    set {_uniqueStorage()._lastCommandSendMarkerSequence = newValue}
  }
  /// Returns true if `lastCommandSendMarkerSequence` has been explicitly set.
  var hasLastCommandSendMarkerSequence: Bool {return _storage._lastCommandSendMarkerSequence != nil}
  /// Clears the value of `lastCommandSendMarkerSequence`. Subsequent reads from it will return its default value.
  mutating func clearLastCommandSendMarkerSequence() {_uniqueStorage()._lastCommandSendMarkerSequence = nil}

  var lastCommandSendMarkerIdentifier: TSP_UUID {
    get {return _storage._lastCommandSendMarkerIdentifier ?? TSP_UUID()}
    set {_uniqueStorage()._lastCommandSendMarkerIdentifier = newValue}
  }
  /// Returns true if `lastCommandSendMarkerIdentifier` has been explicitly set.
  var hasLastCommandSendMarkerIdentifier: Bool {return _storage._lastCommandSendMarkerIdentifier != nil}
  /// Clears the value of `lastCommandSendMarkerIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearLastCommandSendMarkerIdentifier() {_uniqueStorage()._lastCommandSendMarkerIdentifier = nil}

  var skippedAcknowledgedCommandsPendingResumeProcessDiffs: [TSP_Reference] {
    get {return _storage._skippedAcknowledgedCommandsPendingResumeProcessDiffs}
    set {_uniqueStorage()._skippedAcknowledgedCommandsPendingResumeProcessDiffs = newValue}
  }

  var lastTooOldCommandIdentifier: TSP_UUID {
    get {return _storage._lastTooOldCommandIdentifier ?? TSP_UUID()}
    set {_uniqueStorage()._lastTooOldCommandIdentifier = newValue}
  }
  /// Returns true if `lastTooOldCommandIdentifier` has been explicitly set.
  var hasLastTooOldCommandIdentifier: Bool {return _storage._lastTooOldCommandIdentifier != nil}
  /// Clears the value of `lastTooOldCommandIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearLastTooOldCommandIdentifier() {_uniqueStorage()._lastTooOldCommandIdentifier = nil}

  var unprocessedOperationEntriesPendingResumeProcessDiffs: TSP_Reference {
    get {return _storage._unprocessedOperationEntriesPendingResumeProcessDiffs ?? TSP_Reference()}
    set {_uniqueStorage()._unprocessedOperationEntriesPendingResumeProcessDiffs = newValue}
  }
  /// Returns true if `unprocessedOperationEntriesPendingResumeProcessDiffs` has been explicitly set.
  var hasUnprocessedOperationEntriesPendingResumeProcessDiffs: Bool {return _storage._unprocessedOperationEntriesPendingResumeProcessDiffs != nil}
  /// Clears the value of `unprocessedOperationEntriesPendingResumeProcessDiffs`. Subsequent reads from it will return its default value.
  mutating func clearUnprocessedOperationEntriesPendingResumeProcessDiffs() {_uniqueStorage()._unprocessedOperationEntriesPendingResumeProcessDiffs = nil}

  var sendPendingCommandQueue: TSP_Reference {
    get {return _storage._sendPendingCommandQueue ?? TSP_Reference()}
    set {_uniqueStorage()._sendPendingCommandQueue = newValue}
  }
  /// Returns true if `sendPendingCommandQueue` has been explicitly set.
  var hasSendPendingCommandQueue: Bool {return _storage._sendPendingCommandQueue != nil}
  /// Clears the value of `sendPendingCommandQueue`. Subsequent reads from it will return its default value.
  mutating func clearSendPendingCommandQueue() {_uniqueStorage()._sendPendingCommandQueue = nil}

  var countOfSendPendingCommandQueueItemsMovedFromRsvpQueue: UInt64 {
    get {return _storage._countOfSendPendingCommandQueueItemsMovedFromRsvpQueue ?? 0}
    set {_uniqueStorage()._countOfSendPendingCommandQueueItemsMovedFromRsvpQueue = newValue}
  }
  /// Returns true if `countOfSendPendingCommandQueueItemsMovedFromRsvpQueue` has been explicitly set.
  var hasCountOfSendPendingCommandQueueItemsMovedFromRsvpQueue: Bool {return _storage._countOfSendPendingCommandQueueItemsMovedFromRsvpQueue != nil}
  /// Clears the value of `countOfSendPendingCommandQueueItemsMovedFromRsvpQueue`. Subsequent reads from it will return its default value.
  mutating func clearCountOfSendPendingCommandQueueItemsMovedFromRsvpQueue() {_uniqueStorage()._countOfSendPendingCommandQueueItemsMovedFromRsvpQueue = nil}

  var lastEnqueuedDocumentLoadCommandIdentifier: TSP_UUID {
    get {return _storage._lastEnqueuedDocumentLoadCommandIdentifier ?? TSP_UUID()}
    set {_uniqueStorage()._lastEnqueuedDocumentLoadCommandIdentifier = newValue}
  }
  /// Returns true if `lastEnqueuedDocumentLoadCommandIdentifier` has been explicitly set.
  var hasLastEnqueuedDocumentLoadCommandIdentifier: Bool {return _storage._lastEnqueuedDocumentLoadCommandIdentifier != nil}
  /// Clears the value of `lastEnqueuedDocumentLoadCommandIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearLastEnqueuedDocumentLoadCommandIdentifier() {_uniqueStorage()._lastEnqueuedDocumentLoadCommandIdentifier = nil}

  var appliedCommandDocumentRevisionMappingsToNotifyPendingResumeProcessDiffs: [TSCK_CollaborationAppliedCommandDocumentRevisionMapping] {
    get {return _storage._appliedCommandDocumentRevisionMappingsToNotifyPendingResumeProcessDiffs}
    set {_uniqueStorage()._appliedCommandDocumentRevisionMappingsToNotifyPendingResumeProcessDiffs = newValue}
  }

  var countOfCommandQueueItemsInLastOutgoingCommandGroup: UInt64 {
    get {return _storage._countOfCommandQueueItemsInLastOutgoingCommandGroup ?? 0}
    set {_uniqueStorage()._countOfCommandQueueItemsInLastOutgoingCommandGroup = newValue}
  }
  /// Returns true if `countOfCommandQueueItemsInLastOutgoingCommandGroup` has been explicitly set.
  var hasCountOfCommandQueueItemsInLastOutgoingCommandGroup: Bool {return _storage._countOfCommandQueueItemsInLastOutgoingCommandGroup != nil}
  /// Clears the value of `countOfCommandQueueItemsInLastOutgoingCommandGroup`. Subsequent reads from it will return its default value.
  mutating func clearCountOfCommandQueueItemsInLastOutgoingCommandGroup() {_uniqueStorage()._countOfCommandQueueItemsInLastOutgoingCommandGroup = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct AcknowledgementObserverEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var commandIdentifier: TSP_UUID {
      get {return _commandIdentifier ?? TSP_UUID()}
      set {_commandIdentifier = newValue}
    }
    /// Returns true if `commandIdentifier` has been explicitly set.
    var hasCommandIdentifier: Bool {return self._commandIdentifier != nil}
    /// Clears the value of `commandIdentifier`. Subsequent reads from it will return its default value.
    mutating func clearCommandIdentifier() {self._commandIdentifier = nil}

    var acknowledgementObservers: [TSP_Reference] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _commandIdentifier: TSP_UUID? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSCK_OperationStorageEntryArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var largeArray: TSP_LargeArray {
    get {return _largeArray ?? TSP_LargeArray()}
    set {_largeArray = newValue}
  }
  /// Returns true if `largeArray` has been explicitly set.
  var hasLargeArray: Bool {return self._largeArray != nil}
  /// Clears the value of `largeArray`. Subsequent reads from it will return its default value.
  mutating func clearLargeArray() {self._largeArray = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _largeArray: TSP_LargeArray? = nil
}

struct TSCK_OperationStorageEntryArraySegment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var largeArraySegment: TSP_LargeArraySegment {
    get {return _largeArraySegment ?? TSP_LargeArraySegment()}
    set {_largeArraySegment = newValue}
  }
  /// Returns true if `largeArraySegment` has been explicitly set.
  var hasLargeArraySegment: Bool {return self._largeArraySegment != nil}
  /// Clears the value of `largeArraySegment`. Subsequent reads from it will return its default value.
  mutating func clearLargeArraySegment() {self._largeArraySegment = nil}

  var elements: [TSK_OperationStorageEntry] = []

  var lastDocumentRevisionSequenceBeforeSegment: Int32 {
    get {return _lastDocumentRevisionSequenceBeforeSegment ?? 0}
    set {_lastDocumentRevisionSequenceBeforeSegment = newValue}
  }
  /// Returns true if `lastDocumentRevisionSequenceBeforeSegment` has been explicitly set.
  var hasLastDocumentRevisionSequenceBeforeSegment: Bool {return self._lastDocumentRevisionSequenceBeforeSegment != nil}
  /// Clears the value of `lastDocumentRevisionSequenceBeforeSegment`. Subsequent reads from it will return its default value.
  mutating func clearLastDocumentRevisionSequenceBeforeSegment() {self._lastDocumentRevisionSequenceBeforeSegment = nil}

  var lastDocumentRevisionSequence: Int32 {
    get {return _lastDocumentRevisionSequence ?? 0}
    set {_lastDocumentRevisionSequence = newValue}
  }
  /// Returns true if `lastDocumentRevisionSequence` has been explicitly set.
  var hasLastDocumentRevisionSequence: Bool {return self._lastDocumentRevisionSequence != nil}
  /// Clears the value of `lastDocumentRevisionSequence`. Subsequent reads from it will return its default value.
  mutating func clearLastDocumentRevisionSequence() {self._lastDocumentRevisionSequence = nil}

  var segmentFirstEntryCreationTime: Double {
    get {return _segmentFirstEntryCreationTime ?? 0}
    set {_segmentFirstEntryCreationTime = newValue}
  }
  /// Returns true if `segmentFirstEntryCreationTime` has been explicitly set.
  var hasSegmentFirstEntryCreationTime: Bool {return self._segmentFirstEntryCreationTime != nil}
  /// Clears the value of `segmentFirstEntryCreationTime`. Subsequent reads from it will return its default value.
  mutating func clearSegmentFirstEntryCreationTime() {self._segmentFirstEntryCreationTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _largeArraySegment: TSP_LargeArraySegment? = nil
  fileprivate var _lastDocumentRevisionSequenceBeforeSegment: Int32? = nil
  fileprivate var _lastDocumentRevisionSequence: Int32? = nil
  fileprivate var _segmentFirstEntryCreationTime: Double? = nil
}

struct TSCK_OperationStorage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: TSP_Reference {
    get {return _entries ?? TSP_Reference()}
    set {_entries = newValue}
  }
  /// Returns true if `entries` has been explicitly set.
  var hasEntries: Bool {return self._entries != nil}
  /// Clears the value of `entries`. Subsequent reads from it will return its default value.
  mutating func clearEntries() {self._entries = nil}

  var operationCount: UInt64 {
    get {return _operationCount ?? 0}
    set {_operationCount = newValue}
  }
  /// Returns true if `operationCount` has been explicitly set.
  var hasOperationCount: Bool {return self._operationCount != nil}
  /// Clears the value of `operationCount`. Subsequent reads from it will return its default value.
  mutating func clearOperationCount() {self._operationCount = nil}

  var lastDocumentRevisionSequence: Int32 {
    get {return _lastDocumentRevisionSequence ?? 0}
    set {_lastDocumentRevisionSequence = newValue}
  }
  /// Returns true if `lastDocumentRevisionSequence` has been explicitly set.
  var hasLastDocumentRevisionSequence: Bool {return self._lastDocumentRevisionSequence != nil}
  /// Clears the value of `lastDocumentRevisionSequence`. Subsequent reads from it will return its default value.
  mutating func clearLastDocumentRevisionSequence() {self._lastDocumentRevisionSequence = nil}

  var lastDocumentRevisionIdentifier: [UInt64] = []

  var lastUnskippableDocumentRevisionBeforeEntriesSequence: Int32 {
    get {return _lastUnskippableDocumentRevisionBeforeEntriesSequence ?? 0}
    set {_lastUnskippableDocumentRevisionBeforeEntriesSequence = newValue}
  }
  /// Returns true if `lastUnskippableDocumentRevisionBeforeEntriesSequence` has been explicitly set.
  var hasLastUnskippableDocumentRevisionBeforeEntriesSequence: Bool {return self._lastUnskippableDocumentRevisionBeforeEntriesSequence != nil}
  /// Clears the value of `lastUnskippableDocumentRevisionBeforeEntriesSequence`. Subsequent reads from it will return its default value.
  mutating func clearLastUnskippableDocumentRevisionBeforeEntriesSequence() {self._lastUnskippableDocumentRevisionBeforeEntriesSequence = nil}

  var lastUnskippableDocumentRevisionBeforeEntriesIdentifier: [UInt64] = []

  var lastUnskippableDocumentRevisionInEntriesSequence: Int32 {
    get {return _lastUnskippableDocumentRevisionInEntriesSequence ?? 0}
    set {_lastUnskippableDocumentRevisionInEntriesSequence = newValue}
  }
  /// Returns true if `lastUnskippableDocumentRevisionInEntriesSequence` has been explicitly set.
  var hasLastUnskippableDocumentRevisionInEntriesSequence: Bool {return self._lastUnskippableDocumentRevisionInEntriesSequence != nil}
  /// Clears the value of `lastUnskippableDocumentRevisionInEntriesSequence`. Subsequent reads from it will return its default value.
  mutating func clearLastUnskippableDocumentRevisionInEntriesSequence() {self._lastUnskippableDocumentRevisionInEntriesSequence = nil}

  var lastUnskippableDocumentRevisionInEntriesIdentifier: [UInt64] = []

  var daysWithAnEntry: TSP_IndexSet {
    get {return _daysWithAnEntry ?? TSP_IndexSet()}
    set {_daysWithAnEntry = newValue}
  }
  /// Returns true if `daysWithAnEntry` has been explicitly set.
  var hasDaysWithAnEntry: Bool {return self._daysWithAnEntry != nil}
  /// Clears the value of `daysWithAnEntry`. Subsequent reads from it will return its default value.
  mutating func clearDaysWithAnEntry() {self._daysWithAnEntry = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _entries: TSP_Reference? = nil
  fileprivate var _operationCount: UInt64? = nil
  fileprivate var _lastDocumentRevisionSequence: Int32? = nil
  fileprivate var _lastUnskippableDocumentRevisionBeforeEntriesSequence: Int32? = nil
  fileprivate var _lastUnskippableDocumentRevisionInEntriesSequence: Int32? = nil
  fileprivate var _daysWithAnEntry: TSP_IndexSet? = nil
}

struct TSCK_OutgoingCommandQueue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var largeObjectArray: TSP_LargeObjectArray {
    get {return _largeObjectArray ?? TSP_LargeObjectArray()}
    set {_largeObjectArray = newValue}
  }
  /// Returns true if `largeObjectArray` has been explicitly set.
  var hasLargeObjectArray: Bool {return self._largeObjectArray != nil}
  /// Clears the value of `largeObjectArray`. Subsequent reads from it will return its default value.
  mutating func clearLargeObjectArray() {self._largeObjectArray = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _largeObjectArray: TSP_LargeObjectArray? = nil
}

struct TSCK_OutgoingCommandQueueSegment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var largeObjectArraySegment: TSP_LargeObjectArraySegment {
    get {return _largeObjectArraySegment ?? TSP_LargeObjectArraySegment()}
    set {_largeObjectArraySegment = newValue}
  }
  /// Returns true if `largeObjectArraySegment` has been explicitly set.
  var hasLargeObjectArraySegment: Bool {return self._largeObjectArraySegment != nil}
  /// Clears the value of `largeObjectArraySegment`. Subsequent reads from it will return its default value.
  mutating func clearLargeObjectArraySegment() {self._largeObjectArraySegment = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _largeObjectArraySegment: TSP_LargeObjectArraySegment? = nil
}

struct TSCK_CommandAssetChunkArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var digest: String {
    get {return _digest ?? String()}
    set {_digest = newValue}
  }
  /// Returns true if `digest` has been explicitly set.
  var hasDigest: Bool {return self._digest != nil}
  /// Clears the value of `digest`. Subsequent reads from it will return its default value.
  mutating func clearDigest() {self._digest = nil}

  var assetChunk: String {
    get {return _assetChunk ?? String()}
    set {_assetChunk = newValue}
  }
  /// Returns true if `assetChunk` has been explicitly set.
  var hasAssetChunk: Bool {return self._assetChunk != nil}
  /// Clears the value of `assetChunk`. Subsequent reads from it will return its default value.
  mutating func clearAssetChunk() {self._assetChunk = nil}

  var assetChunkLength: Int64 {
    get {return _assetChunkLength ?? 0}
    set {_assetChunkLength = newValue}
  }
  /// Returns true if `assetChunkLength` has been explicitly set.
  var hasAssetChunkLength: Bool {return self._assetChunkLength != nil}
  /// Clears the value of `assetChunkLength`. Subsequent reads from it will return its default value.
  mutating func clearAssetChunkLength() {self._assetChunkLength = nil}

  var resumePosition: Int64 {
    get {return _resumePosition ?? 0}
    set {_resumePosition = newValue}
  }
  /// Returns true if `resumePosition` has been explicitly set.
  var hasResumePosition: Bool {return self._resumePosition != nil}
  /// Clears the value of `resumePosition`. Subsequent reads from it will return its default value.
  mutating func clearResumePosition() {self._resumePosition = nil}

  var materializedLength: Int64 {
    get {return _materializedLength ?? 0}
    set {_materializedLength = newValue}
  }
  /// Returns true if `materializedLength` has been explicitly set.
  var hasMaterializedLength: Bool {return self._materializedLength != nil}
  /// Clears the value of `materializedLength`. Subsequent reads from it will return its default value.
  mutating func clearMaterializedLength() {self._materializedLength = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _digest: String? = nil
  fileprivate var _assetChunk: String? = nil
  fileprivate var _assetChunkLength: Int64? = nil
  fileprivate var _resumePosition: Int64? = nil
  fileprivate var _materializedLength: Int64? = nil
}

struct TSCK_AssetUploadStatusCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var infoList: [TSCK_AssetUploadStatusCommandArchive.AssetUploadStatusInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct AssetUploadStatusInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var digest: String {
      get {return _digest ?? String()}
      set {_digest = newValue}
    }
    /// Returns true if `digest` has been explicitly set.
    var hasDigest: Bool {return self._digest != nil}
    /// Clears the value of `digest`. Subsequent reads from it will return its default value.
    mutating func clearDigest() {self._digest = nil}

    var uploadStatus: TSP_DataUploadStatus {
      get {return _uploadStatus ?? .pending}
      set {_uploadStatus = newValue}
    }
    /// Returns true if `uploadStatus` has been explicitly set.
    var hasUploadStatus: Bool {return self._uploadStatus != nil}
    /// Clears the value of `uploadStatus`. Subsequent reads from it will return its default value.
    mutating func clearUploadStatus() {self._uploadStatus = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _digest: String? = nil
    fileprivate var _uploadStatus: TSP_DataUploadStatus? = nil
  }

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
}

struct TSCK_AssetUnmaterializedOnServerCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var digestList: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
}

struct TSCK_CollaboratorCursorArchive: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var idPath: TSP_UUIDPath {
    get {return _idPath ?? TSP_UUIDPath()}
    set {_idPath = newValue}
  }
  /// Returns true if `idPath` has been explicitly set.
  var hasIDPath: Bool {return self._idPath != nil}
  /// Clears the value of `idPath`. Subsequent reads from it will return its default value.
  mutating func clearIDPath() {self._idPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _idPath: TSP_UUIDPath? = nil
}

struct TSCK_ActivityStreamArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var acknowledgedActivityArray: TSP_Reference {
    get {return _storage._acknowledgedActivityArray ?? TSP_Reference()}
    set {_uniqueStorage()._acknowledgedActivityArray = newValue}
  }
  /// Returns true if `acknowledgedActivityArray` has been explicitly set.
  var hasAcknowledgedActivityArray: Bool {return _storage._acknowledgedActivityArray != nil}
  /// Clears the value of `acknowledgedActivityArray`. Subsequent reads from it will return its default value.
  mutating func clearAcknowledgedActivityArray() {_uniqueStorage()._acknowledgedActivityArray = nil}

  var unacknowledgedLocalActivityArray: TSP_Reference {
    get {return _storage._unacknowledgedLocalActivityArray ?? TSP_Reference()}
    set {_uniqueStorage()._unacknowledgedLocalActivityArray = newValue}
  }
  /// Returns true if `unacknowledgedLocalActivityArray` has been explicitly set.
  var hasUnacknowledgedLocalActivityArray: Bool {return _storage._unacknowledgedLocalActivityArray != nil}
  /// Clears the value of `unacknowledgedLocalActivityArray`. Subsequent reads from it will return its default value.
  mutating func clearUnacknowledgedLocalActivityArray() {_uniqueStorage()._unacknowledgedLocalActivityArray = nil}

  var authorCache: TSP_Reference {
    get {return _storage._authorCache ?? TSP_Reference()}
    set {_uniqueStorage()._authorCache = newValue}
  }
  /// Returns true if `authorCache` has been explicitly set.
  var hasAuthorCache: Bool {return _storage._authorCache != nil}
  /// Clears the value of `authorCache`. Subsequent reads from it will return its default value.
  mutating func clearAuthorCache() {_uniqueStorage()._authorCache = nil}

  var unacknowledgedRemoteActivityArray: TSP_Reference {
    get {return _storage._unacknowledgedRemoteActivityArray ?? TSP_Reference()}
    set {_uniqueStorage()._unacknowledgedRemoteActivityArray = newValue}
  }
  /// Returns true if `unacknowledgedRemoteActivityArray` has been explicitly set.
  var hasUnacknowledgedRemoteActivityArray: Bool {return _storage._unacknowledgedRemoteActivityArray != nil}
  /// Clears the value of `unacknowledgedRemoteActivityArray`. Subsequent reads from it will return its default value.
  mutating func clearUnacknowledgedRemoteActivityArray() {_uniqueStorage()._unacknowledgedRemoteActivityArray = nil}

  var didUpgradeCommentsToActivities: Bool {
    get {return _storage._didUpgradeCommentsToActivities ?? false}
    set {_uniqueStorage()._didUpgradeCommentsToActivities = newValue}
  }
  /// Returns true if `didUpgradeCommentsToActivities` has been explicitly set.
  var hasDidUpgradeCommentsToActivities: Bool {return _storage._didUpgradeCommentsToActivities != nil}
  /// Clears the value of `didUpgradeCommentsToActivities`. Subsequent reads from it will return its default value.
  mutating func clearDidUpgradeCommentsToActivities() {_uniqueStorage()._didUpgradeCommentsToActivities = nil}

  var activityStreamTransformationState: TSCK_ActivityStreamTransformationStateArchive {
    get {return _storage._activityStreamTransformationState ?? TSCK_ActivityStreamTransformationStateArchive()}
    set {_uniqueStorage()._activityStreamTransformationState = newValue}
  }
  /// Returns true if `activityStreamTransformationState` has been explicitly set.
  var hasActivityStreamTransformationState: Bool {return _storage._activityStreamTransformationState != nil}
  /// Clears the value of `activityStreamTransformationState`. Subsequent reads from it will return its default value.
  mutating func clearActivityStreamTransformationState() {_uniqueStorage()._activityStreamTransformationState = nil}

  var activityCounter: TSCK_ActivityStreamActivityCounterArchive {
    get {return _storage._activityCounter ?? TSCK_ActivityStreamActivityCounterArchive()}
    set {_uniqueStorage()._activityCounter = newValue}
  }
  /// Returns true if `activityCounter` has been explicitly set.
  var hasActivityCounter: Bool {return _storage._activityCounter != nil}
  /// Clears the value of `activityCounter`. Subsequent reads from it will return its default value.
  mutating func clearActivityCounter() {_uniqueStorage()._activityCounter = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSCK_ActivityStreamActivityArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var largeArray: TSP_LargeObjectArray {
    get {return _largeArray ?? TSP_LargeObjectArray()}
    set {_largeArray = newValue}
  }
  /// Returns true if `largeArray` has been explicitly set.
  var hasLargeArray: Bool {return self._largeArray != nil}
  /// Clears the value of `largeArray`. Subsequent reads from it will return its default value.
  mutating func clearLargeArray() {self._largeArray = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _largeArray: TSP_LargeObjectArray? = nil
}

struct TSCK_ActivityStreamActivityArraySegment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var largeArraySegment: TSP_LargeObjectArraySegment {
    get {return _largeArraySegment ?? TSP_LargeObjectArraySegment()}
    set {_largeArraySegment = newValue}
  }
  /// Returns true if `largeArraySegment` has been explicitly set.
  var hasLargeArraySegment: Bool {return self._largeArraySegment != nil}
  /// Clears the value of `largeArraySegment`. Subsequent reads from it will return its default value.
  mutating func clearLargeArraySegment() {self._largeArraySegment = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _largeArraySegment: TSP_LargeObjectArraySegment? = nil
}

struct TSCK_ActivityArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cursorCollectionPersistenceWrappers: [TSP_Reference] = []

  var authorIdentifier: TSP_UUID {
    get {return _authorIdentifier ?? TSP_UUID()}
    set {_authorIdentifier = newValue}
  }
  /// Returns true if `authorIdentifier` has been explicitly set.
  var hasAuthorIdentifier: Bool {return self._authorIdentifier != nil}
  /// Clears the value of `authorIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearAuthorIdentifier() {self._authorIdentifier = nil}

  var nondirectionalActionType: Int32 {
    get {return _nondirectionalActionType ?? 0}
    set {_nondirectionalActionType = newValue}
  }
  /// Returns true if `nondirectionalActionType` has been explicitly set.
  var hasNondirectionalActionType: Bool {return self._nondirectionalActionType != nil}
  /// Clears the value of `nondirectionalActionType`. Subsequent reads from it will return its default value.
  mutating func clearNondirectionalActionType() {self._nondirectionalActionType = nil}

  var direction: Int32 {
    get {return _direction ?? 0}
    set {_direction = newValue}
  }
  /// Returns true if `direction` has been explicitly set.
  var hasDirection: Bool {return self._direction != nil}
  /// Clears the value of `direction`. Subsequent reads from it will return its default value.
  mutating func clearDirection() {self._direction = nil}

  var shouldSendNotification: Bool {
    get {return _shouldSendNotification ?? false}
    set {_shouldSendNotification = newValue}
  }
  /// Returns true if `shouldSendNotification` has been explicitly set.
  var hasShouldSendNotification: Bool {return self._shouldSendNotification != nil}
  /// Clears the value of `shouldSendNotification`. Subsequent reads from it will return its default value.
  mutating func clearShouldSendNotification() {self._shouldSendNotification = nil}

  var timestamp: TSP_Date {
    get {return _timestamp ?? TSP_Date()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var revisionSequence: Int32 {
    get {return _revisionSequence ?? 0}
    set {_revisionSequence = newValue}
  }
  /// Returns true if `revisionSequence` has been explicitly set.
  var hasRevisionSequence: Bool {return self._revisionSequence != nil}
  /// Clears the value of `revisionSequence`. Subsequent reads from it will return its default value.
  mutating func clearRevisionSequence() {self._revisionSequence = nil}

  var additionalNavigationInfo: TSCK_ActivityNavigationInfoArchive {
    get {return _additionalNavigationInfo ?? TSCK_ActivityNavigationInfoArchive()}
    set {_additionalNavigationInfo = newValue}
  }
  /// Returns true if `additionalNavigationInfo` has been explicitly set.
  var hasAdditionalNavigationInfo: Bool {return self._additionalNavigationInfo != nil}
  /// Clears the value of `additionalNavigationInfo`. Subsequent reads from it will return its default value.
  mutating func clearAdditionalNavigationInfo() {self._additionalNavigationInfo = nil}

  var didPrepareSerializedStringOnServer: Bool {
    get {return _didPrepareSerializedStringOnServer ?? false}
    set {_didPrepareSerializedStringOnServer = newValue}
  }
  /// Returns true if `didPrepareSerializedStringOnServer` has been explicitly set.
  var hasDidPrepareSerializedStringOnServer: Bool {return self._didPrepareSerializedStringOnServer != nil}
  /// Clears the value of `didPrepareSerializedStringOnServer`. Subsequent reads from it will return its default value.
  mutating func clearDidPrepareSerializedStringOnServer() {self._didPrepareSerializedStringOnServer = nil}

  var oldestRevisionSequenceOfNextActivities: Int32 {
    get {return _oldestRevisionSequenceOfNextActivities ?? 0}
    set {_oldestRevisionSequenceOfNextActivities = newValue}
  }
  /// Returns true if `oldestRevisionSequenceOfNextActivities` has been explicitly set.
  var hasOldestRevisionSequenceOfNextActivities: Bool {return self._oldestRevisionSequenceOfNextActivities != nil}
  /// Clears the value of `oldestRevisionSequenceOfNextActivities`. Subsequent reads from it will return its default value.
  mutating func clearOldestRevisionSequenceOfNextActivities() {self._oldestRevisionSequenceOfNextActivities = nil}

  var actionSubType: Int32 {
    get {return _actionSubType ?? 0}
    set {_actionSubType = newValue}
  }
  /// Returns true if `actionSubType` has been explicitly set.
  var hasActionSubType: Bool {return self._actionSubType != nil}
  /// Clears the value of `actionSubType`. Subsequent reads from it will return its default value.
  mutating func clearActionSubType() {self._actionSubType = nil}

  var minUpdatableVersion: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _authorIdentifier: TSP_UUID? = nil
  fileprivate var _nondirectionalActionType: Int32? = nil
  fileprivate var _direction: Int32? = nil
  fileprivate var _shouldSendNotification: Bool? = nil
  fileprivate var _timestamp: TSP_Date? = nil
  fileprivate var _revisionSequence: Int32? = nil
  fileprivate var _additionalNavigationInfo: TSCK_ActivityNavigationInfoArchive? = nil
  fileprivate var _didPrepareSerializedStringOnServer: Bool? = nil
  fileprivate var _oldestRevisionSequenceOfNextActivities: Int32? = nil
  fileprivate var _actionSubType: Int32? = nil
}

struct TSCK_ActivityAuthorArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var color: TSP_Color {
    get {return _color ?? TSP_Color()}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {self._color = nil}

  var publicIds: [String] = []

  var isPublicAuthor: Bool {
    get {return _isPublicAuthor ?? false}
    set {_isPublicAuthor = newValue}
  }
  /// Returns true if `isPublicAuthor` has been explicitly set.
  var hasIsPublicAuthor: Bool {return self._isPublicAuthor != nil}
  /// Clears the value of `isPublicAuthor`. Subsequent reads from it will return its default value.
  mutating func clearIsPublicAuthor() {self._isPublicAuthor = nil}

  var shareParticipantID: String {
    get {return _shareParticipantID ?? String()}
    set {_shareParticipantID = newValue}
  }
  /// Returns true if `shareParticipantID` has been explicitly set.
  var hasShareParticipantID: Bool {return self._shareParticipantID != nil}
  /// Clears the value of `shareParticipantID`. Subsequent reads from it will return its default value.
  mutating func clearShareParticipantID() {self._shareParticipantID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _color: TSP_Color? = nil
  fileprivate var _isPublicAuthor: Bool? = nil
  fileprivate var _shareParticipantID: String? = nil
}

struct TSCK_CommandActivityBehaviorArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var selectionPathStorages: [TSP_Reference] = []

  var actionType: TSCK_CommandActivityBehaviorArchive.ActionType {
    get {return _actionType ?? .unknown}
    set {_actionType = newValue}
  }
  /// Returns true if `actionType` has been explicitly set.
  var hasActionType: Bool {return self._actionType != nil}
  /// Clears the value of `actionType`. Subsequent reads from it will return its default value.
  mutating func clearActionType() {self._actionType = nil}

  var shouldSendNotification: Bool {
    get {return _shouldSendNotification ?? false}
    set {_shouldSendNotification = newValue}
  }
  /// Returns true if `shouldSendNotification` has been explicitly set.
  var hasShouldSendNotification: Bool {return self._shouldSendNotification != nil}
  /// Clears the value of `shouldSendNotification`. Subsequent reads from it will return its default value.
  mutating func clearShouldSendNotification() {self._shouldSendNotification = nil}

  var additionalNavigationInfo: TSCK_ActivityNavigationInfoArchive {
    get {return _additionalNavigationInfo ?? TSCK_ActivityNavigationInfoArchive()}
    set {_additionalNavigationInfo = newValue}
  }
  /// Returns true if `additionalNavigationInfo` has been explicitly set.
  var hasAdditionalNavigationInfo: Bool {return self._additionalNavigationInfo != nil}
  /// Clears the value of `additionalNavigationInfo`. Subsequent reads from it will return its default value.
  mutating func clearAdditionalNavigationInfo() {self._additionalNavigationInfo = nil}

  var actionSubType: TSCK_CommandActivityBehaviorArchive.ActionSubType {
    get {return _actionSubType ?? .none}
    set {_actionSubType = newValue}
  }
  /// Returns true if `actionSubType` has been explicitly set.
  var hasActionSubType: Bool {return self._actionSubType != nil}
  /// Clears the value of `actionSubType`. Subsequent reads from it will return its default value.
  mutating func clearActionSubType() {self._actionSubType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ActionType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case unknown = 0
    case firstJoin = 1
    case add = 2
    case modify = 3
    case comment = 4
    case reply = 5
    case paste = 6
    case password = 7
    case restore = 8
    case remove = 9
    case editText = 10
    case group = 11
    case ungroup = 12
    case replace = 13

    init() {
      self = .unknown
    }

  }

  enum ActionSubType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case none = 0
    case filterTable = 1
    case sortTable = 2
    case categorizeTable = 3
    case changeTemplateSlide = 4
    case changeChartType = 5
    case moveDrawable = 6
    case resizeDrawable = 7
    case addOrRemovePage = 8
    case hyperlink = 9
    case skipSlide = 10
    case unskipSlide = 11
    case changeBackground = 12
    case changePageTemplate = 13
    case insertPageNumber = 14
    case refreshPivotTable = 15
    case addPassword = 16
    case changePassword = 17
    case removePassword = 18
    case bookmark = 19
    case equation = 20
    case sectionBreak = 21
    case moveColumn = 22
    case linkTextbox = 23
    case newTextboxThread = 24
    case changeTextboxThread = 25
    case conditionalHighlightTableCell = 26
    case dataFormatTableCell = 27

    init() {
      self = .none
    }

  }

  init() {}

  fileprivate var _actionType: TSCK_CommandActivityBehaviorArchive.ActionType? = nil
  fileprivate var _shouldSendNotification: Bool? = nil
  fileprivate var _additionalNavigationInfo: TSCK_ActivityNavigationInfoArchive? = nil
  fileprivate var _actionSubType: TSCK_CommandActivityBehaviorArchive.ActionSubType? = nil
}

struct TSCK_ActivityCursorCollectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var idCursors: [TSCK_CollaboratorCursorArchive] = []

  var textCursor: TSCK_CollaboratorCursorArchive {
    get {return _textCursor ?? TSCK_CollaboratorCursorArchive()}
    set {_textCursor = newValue}
  }
  /// Returns true if `textCursor` has been explicitly set.
  var hasTextCursor: Bool {return self._textCursor != nil}
  /// Clears the value of `textCursor`. Subsequent reads from it will return its default value.
  mutating func clearTextCursor() {self._textCursor = nil}

  var tableCursor: TSCK_CollaboratorCursorArchive {
    get {return _tableCursor ?? TSCK_CollaboratorCursorArchive()}
    set {_tableCursor = newValue}
  }
  /// Returns true if `tableCursor` has been explicitly set.
  var hasTableCursor: Bool {return self._tableCursor != nil}
  /// Clears the value of `tableCursor`. Subsequent reads from it will return its default value.
  mutating func clearTableCursor() {self._tableCursor = nil}

  var cdeCursor: TSCK_CollaboratorCursorArchive {
    get {return _cdeCursor ?? TSCK_CollaboratorCursorArchive()}
    set {_cdeCursor = newValue}
  }
  /// Returns true if `cdeCursor` has been explicitly set.
  var hasCdeCursor: Bool {return self._cdeCursor != nil}
  /// Clears the value of `cdeCursor`. Subsequent reads from it will return its default value.
  mutating func clearCdeCursor() {self._cdeCursor = nil}

  var chartTitleCursor: TSCK_CollaboratorCursorArchive {
    get {return _chartTitleCursor ?? TSCK_CollaboratorCursorArchive()}
    set {_chartTitleCursor = newValue}
  }
  /// Returns true if `chartTitleCursor` has been explicitly set.
  var hasChartTitleCursor: Bool {return self._chartTitleCursor != nil}
  /// Clears the value of `chartTitleCursor`. Subsequent reads from it will return its default value.
  mutating func clearChartTitleCursor() {self._chartTitleCursor = nil}

  var galleryItemCursor: TSCK_CollaboratorCursorArchive {
    get {return _galleryItemCursor ?? TSCK_CollaboratorCursorArchive()}
    set {_galleryItemCursor = newValue}
  }
  /// Returns true if `galleryItemCursor` has been explicitly set.
  var hasGalleryItemCursor: Bool {return self._galleryItemCursor != nil}
  /// Clears the value of `galleryItemCursor`. Subsequent reads from it will return its default value.
  mutating func clearGalleryItemCursor() {self._galleryItemCursor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _textCursor: TSCK_CollaboratorCursorArchive? = nil
  fileprivate var _tableCursor: TSCK_CollaboratorCursorArchive? = nil
  fileprivate var _cdeCursor: TSCK_CollaboratorCursorArchive? = nil
  fileprivate var _chartTitleCursor: TSCK_CollaboratorCursorArchive? = nil
  fileprivate var _galleryItemCursor: TSCK_CollaboratorCursorArchive? = nil
}

struct TSCK_ActivityCursorCollectionPersistenceWrapperArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var activityCursorCollection: TSCK_ActivityCursorCollectionArchive {
    get {return _activityCursorCollection ?? TSCK_ActivityCursorCollectionArchive()}
    set {_activityCursorCollection = newValue}
  }
  /// Returns true if `activityCursorCollection` has been explicitly set.
  var hasActivityCursorCollection: Bool {return self._activityCursorCollection != nil}
  /// Clears the value of `activityCursorCollection`. Subsequent reads from it will return its default value.
  mutating func clearActivityCursorCollection() {self._activityCursorCollection = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _activityCursorCollection: TSCK_ActivityCursorCollectionArchive? = nil
}

struct TSCK_ActivityNavigationInfoArchive: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
}

struct TSCK_CommentActivityNavigationInfoArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var commentID: String {
    get {return _commentID ?? String()}
    set {_commentID = newValue}
  }
  /// Returns true if `commentID` has been explicitly set.
  var hasCommentID: Bool {return self._commentID != nil}
  /// Clears the value of `commentID`. Subsequent reads from it will return its default value.
  mutating func clearCommentID() {self._commentID = nil}

  var parentUuid: TSP_UUID {
    get {return _parentUuid ?? TSP_UUID()}
    set {_parentUuid = newValue}
  }
  /// Returns true if `parentUuid` has been explicitly set.
  var hasParentUuid: Bool {return self._parentUuid != nil}
  /// Clears the value of `parentUuid`. Subsequent reads from it will return its default value.
  mutating func clearParentUuid() {self._parentUuid = nil}

  var storageUuid: TSP_UUID {
    get {return _storageUuid ?? TSP_UUID()}
    set {_storageUuid = newValue}
  }
  /// Returns true if `storageUuid` has been explicitly set.
  var hasStorageUuid: Bool {return self._storageUuid != nil}
  /// Clears the value of `storageUuid`. Subsequent reads from it will return its default value.
  mutating func clearStorageUuid() {self._storageUuid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commentID: String? = nil
  fileprivate var _parentUuid: TSP_UUID? = nil
  fileprivate var _storageUuid: TSP_UUID? = nil
}

struct TSCK_ActivityAuthorCacheArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var shareParticipantIDCache: [TSCK_ActivityAuthorCacheArchive.ShareParticipantIDCache] = []

  var fallbackPublicIDCache: [TSCK_ActivityAuthorCacheArchive.PublicIDCache] = []

  var indexCache: [TSCK_ActivityAuthorCacheArchive.IndexCache] = []

  var firstJoinCache: [TSCK_ActivityAuthorCacheArchive.FirstJoinCache] = []

  var authors: [TSP_Reference] = []

  var lastAuditDate: TSP_Date {
    get {return _lastAuditDate ?? TSP_Date()}
    set {_lastAuditDate = newValue}
  }
  /// Returns true if `lastAuditDate` has been explicitly set.
  var hasLastAuditDate: Bool {return self._lastAuditDate != nil}
  /// Clears the value of `lastAuditDate`. Subsequent reads from it will return its default value.
  mutating func clearLastAuditDate() {self._lastAuditDate = nil}

  var authorIdentifiersToRemove: [TSP_UUID] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ShareParticipantIDCache: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var identifier: TSP_UUID {
      get {return _identifier ?? TSP_UUID()}
      set {_identifier = newValue}
    }
    /// Returns true if `identifier` has been explicitly set.
    var hasIdentifier: Bool {return self._identifier != nil}
    /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
    mutating func clearIdentifier() {self._identifier = nil}

    var shareParticipantID: String {
      get {return _shareParticipantID ?? String()}
      set {_shareParticipantID = newValue}
    }
    /// Returns true if `shareParticipantID` has been explicitly set.
    var hasShareParticipantID: Bool {return self._shareParticipantID != nil}
    /// Clears the value of `shareParticipantID`. Subsequent reads from it will return its default value.
    mutating func clearShareParticipantID() {self._shareParticipantID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _identifier: TSP_UUID? = nil
    fileprivate var _shareParticipantID: String? = nil
  }

  struct PublicIDCache: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var identifier: TSP_UUID {
      get {return _identifier ?? TSP_UUID()}
      set {_identifier = newValue}
    }
    /// Returns true if `identifier` has been explicitly set.
    var hasIdentifier: Bool {return self._identifier != nil}
    /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
    mutating func clearIdentifier() {self._identifier = nil}

    var publicIdentifier: String {
      get {return _publicIdentifier ?? String()}
      set {_publicIdentifier = newValue}
    }
    /// Returns true if `publicIdentifier` has been explicitly set.
    var hasPublicIdentifier: Bool {return self._publicIdentifier != nil}
    /// Clears the value of `publicIdentifier`. Subsequent reads from it will return its default value.
    mutating func clearPublicIdentifier() {self._publicIdentifier = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _identifier: TSP_UUID? = nil
    fileprivate var _publicIdentifier: String? = nil
  }

  struct IndexCache: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var identifier: TSP_UUID {
      get {return _identifier ?? TSP_UUID()}
      set {_identifier = newValue}
    }
    /// Returns true if `identifier` has been explicitly set.
    var hasIdentifier: Bool {return self._identifier != nil}
    /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
    mutating func clearIdentifier() {self._identifier = nil}

    var authorIndex: UInt64 {
      get {return _authorIndex ?? 0}
      set {_authorIndex = newValue}
    }
    /// Returns true if `authorIndex` has been explicitly set.
    var hasAuthorIndex: Bool {return self._authorIndex != nil}
    /// Clears the value of `authorIndex`. Subsequent reads from it will return its default value.
    mutating func clearAuthorIndex() {self._authorIndex = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _identifier: TSP_UUID? = nil
    fileprivate var _authorIndex: UInt64? = nil
  }

  struct FirstJoinCache: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var identifier: TSP_UUID {
      get {return _identifier ?? TSP_UUID()}
      set {_identifier = newValue}
    }
    /// Returns true if `identifier` has been explicitly set.
    var hasIdentifier: Bool {return self._identifier != nil}
    /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
    mutating func clearIdentifier() {self._identifier = nil}

    var firstJoinDate: TSP_Date {
      get {return _firstJoinDate ?? TSP_Date()}
      set {_firstJoinDate = newValue}
    }
    /// Returns true if `firstJoinDate` has been explicitly set.
    var hasFirstJoinDate: Bool {return self._firstJoinDate != nil}
    /// Clears the value of `firstJoinDate`. Subsequent reads from it will return its default value.
    mutating func clearFirstJoinDate() {self._firstJoinDate = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _identifier: TSP_UUID? = nil
    fileprivate var _firstJoinDate: TSP_Date? = nil
  }

  init() {}

  fileprivate var _lastAuditDate: TSP_Date? = nil
}

struct TSCK_ActivityOnlyCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
}

struct TSCK_ActivityNotificationItemArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Int32 {
    get {return _type ?? 0}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var uniqueIdentifier: TSP_UUID {
    get {return _uniqueIdentifier ?? TSP_UUID()}
    set {_uniqueIdentifier = newValue}
  }
  /// Returns true if `uniqueIdentifier` has been explicitly set.
  var hasUniqueIdentifier: Bool {return self._uniqueIdentifier != nil}
  /// Clears the value of `uniqueIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearUniqueIdentifier() {self._uniqueIdentifier = nil}

  var activities: [TSP_Reference] = []

  var firstTimestamp: TSP_Date {
    get {return _firstTimestamp ?? TSP_Date()}
    set {_firstTimestamp = newValue}
  }
  /// Returns true if `firstTimestamp` has been explicitly set.
  var hasFirstTimestamp: Bool {return self._firstTimestamp != nil}
  /// Clears the value of `firstTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearFirstTimestamp() {self._firstTimestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: Int32? = nil
  fileprivate var _uniqueIdentifier: TSP_UUID? = nil
  fileprivate var _firstTimestamp: TSP_Date? = nil
}

struct TSCK_ActivityNotificationParticipantCacheArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var notificationItems: [TSP_Reference] = []

  var lastEditNotificationItemSentDate: TSP_Date {
    get {return _lastEditNotificationItemSentDate ?? TSP_Date()}
    set {_lastEditNotificationItemSentDate = newValue}
  }
  /// Returns true if `lastEditNotificationItemSentDate` has been explicitly set.
  var hasLastEditNotificationItemSentDate: Bool {return self._lastEditNotificationItemSentDate != nil}
  /// Clears the value of `lastEditNotificationItemSentDate`. Subsequent reads from it will return its default value.
  mutating func clearLastEditNotificationItemSentDate() {self._lastEditNotificationItemSentDate = nil}

  var senderFailedToEnqueueAttempts: [TSCK_ActivityNotificationParticipantCacheArchive.UniqueIdentifierAndAttempts] = []

  var privateID: String {
    get {return _privateID ?? String()}
    set {_privateID = newValue}
  }
  /// Returns true if `privateID` has been explicitly set.
  var hasPrivateID: Bool {return self._privateID != nil}
  /// Clears the value of `privateID`. Subsequent reads from it will return its default value.
  mutating func clearPrivateID() {self._privateID = nil}

  var lastCommentNotificationItemSentDate: TSP_Date {
    get {return _lastCommentNotificationItemSentDate ?? TSP_Date()}
    set {_lastCommentNotificationItemSentDate = newValue}
  }
  /// Returns true if `lastCommentNotificationItemSentDate` has been explicitly set.
  var hasLastCommentNotificationItemSentDate: Bool {return self._lastCommentNotificationItemSentDate != nil}
  /// Clears the value of `lastCommentNotificationItemSentDate`. Subsequent reads from it will return its default value.
  mutating func clearLastCommentNotificationItemSentDate() {self._lastCommentNotificationItemSentDate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct UniqueIdentifierAndAttempts: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uniqueIdentifier: TSP_UUID {
      get {return _uniqueIdentifier ?? TSP_UUID()}
      set {_uniqueIdentifier = newValue}
    }
    /// Returns true if `uniqueIdentifier` has been explicitly set.
    var hasUniqueIdentifier: Bool {return self._uniqueIdentifier != nil}
    /// Clears the value of `uniqueIdentifier`. Subsequent reads from it will return its default value.
    mutating func clearUniqueIdentifier() {self._uniqueIdentifier = nil}

    var attempts: UInt32 {
      get {return _attempts ?? 0}
      set {_attempts = newValue}
    }
    /// Returns true if `attempts` has been explicitly set.
    var hasAttempts: Bool {return self._attempts != nil}
    /// Clears the value of `attempts`. Subsequent reads from it will return its default value.
    mutating func clearAttempts() {self._attempts = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _uniqueIdentifier: TSP_UUID? = nil
    fileprivate var _attempts: UInt32? = nil
  }

  init() {}

  fileprivate var _lastEditNotificationItemSentDate: TSP_Date? = nil
  fileprivate var _privateID: String? = nil
  fileprivate var _lastCommentNotificationItemSentDate: TSP_Date? = nil
}

struct TSCK_ActivityNotificationQueueArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unprocessedNotificationItems: [TSP_Reference] = []

  var pendingParticipantCaches: [TSP_Reference] = []

  var sentParticipantCaches: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSCK_ActivityStreamTransformationStateArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nextActivityToTransformIndex: Int32 {
    get {return _nextActivityToTransformIndex ?? 0}
    set {_nextActivityToTransformIndex = newValue}
  }
  /// Returns true if `nextActivityToTransformIndex` has been explicitly set.
  var hasNextActivityToTransformIndex: Bool {return self._nextActivityToTransformIndex != nil}
  /// Clears the value of `nextActivityToTransformIndex`. Subsequent reads from it will return its default value.
  mutating func clearNextActivityToTransformIndex() {self._nextActivityToTransformIndex = nil}

  var oldestRevisionSequenceAfterTransformed: Int32 {
    get {return _oldestRevisionSequenceAfterTransformed ?? 0}
    set {_oldestRevisionSequenceAfterTransformed = newValue}
  }
  /// Returns true if `oldestRevisionSequenceAfterTransformed` has been explicitly set.
  var hasOldestRevisionSequenceAfterTransformed: Bool {return self._oldestRevisionSequenceAfterTransformed != nil}
  /// Clears the value of `oldestRevisionSequenceAfterTransformed`. Subsequent reads from it will return its default value.
  mutating func clearOldestRevisionSequenceAfterTransformed() {self._oldestRevisionSequenceAfterTransformed = nil}

  var lastActivityCoalescedDate: TSP_Date {
    get {return _lastActivityCoalescedDate ?? TSP_Date()}
    set {_lastActivityCoalescedDate = newValue}
  }
  /// Returns true if `lastActivityCoalescedDate` has been explicitly set.
  var hasLastActivityCoalescedDate: Bool {return self._lastActivityCoalescedDate != nil}
  /// Clears the value of `lastActivityCoalescedDate`. Subsequent reads from it will return its default value.
  mutating func clearLastActivityCoalescedDate() {self._lastActivityCoalescedDate = nil}

  var actionType: TSCK_ActivityStreamTransformationStateArchive.ActionType {
    get {return _actionType ?? .trasnform}
    set {_actionType = newValue}
  }
  /// Returns true if `actionType` has been explicitly set.
  var hasActionType: Bool {return self._actionType != nil}
  /// Clears the value of `actionType`. Subsequent reads from it will return its default value.
  mutating func clearActionType() {self._actionType = nil}

  var transformToDocumentRevisionSequence: Int32 {
    get {return _transformToDocumentRevisionSequence ?? 0}
    set {_transformToDocumentRevisionSequence = newValue}
  }
  /// Returns true if `transformToDocumentRevisionSequence` has been explicitly set.
  var hasTransformToDocumentRevisionSequence: Bool {return self._transformToDocumentRevisionSequence != nil}
  /// Clears the value of `transformToDocumentRevisionSequence`. Subsequent reads from it will return its default value.
  mutating func clearTransformToDocumentRevisionSequence() {self._transformToDocumentRevisionSequence = nil}

  var transformToDocumentRevisionIdentifier: [UInt64] = []

  var timestampOfLastActivityWhenLastActivityCoalescing: Double {
    get {return _timestampOfLastActivityWhenLastActivityCoalescing ?? 0}
    set {_timestampOfLastActivityWhenLastActivityCoalescing = newValue}
  }
  /// Returns true if `timestampOfLastActivityWhenLastActivityCoalescing` has been explicitly set.
  var hasTimestampOfLastActivityWhenLastActivityCoalescing: Bool {return self._timestampOfLastActivityWhenLastActivityCoalescing != nil}
  /// Clears the value of `timestampOfLastActivityWhenLastActivityCoalescing`. Subsequent reads from it will return its default value.
  mutating func clearTimestampOfLastActivityWhenLastActivityCoalescing() {self._timestampOfLastActivityWhenLastActivityCoalescing = nil}

  var preservingRevisionSequenceOrder: Bool {
    get {return _preservingRevisionSequenceOrder ?? false}
    set {_preservingRevisionSequenceOrder = newValue}
  }
  /// Returns true if `preservingRevisionSequenceOrder` has been explicitly set.
  var hasPreservingRevisionSequenceOrder: Bool {return self._preservingRevisionSequenceOrder != nil}
  /// Clears the value of `preservingRevisionSequenceOrder`. Subsequent reads from it will return its default value.
  mutating func clearPreservingRevisionSequenceOrder() {self._preservingRevisionSequenceOrder = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ActionType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case trasnform = 0
    case coalesce = 1

    init() {
      self = .trasnform
    }

  }

  init() {}

  fileprivate var _nextActivityToTransformIndex: Int32? = nil
  fileprivate var _oldestRevisionSequenceAfterTransformed: Int32? = nil
  fileprivate var _lastActivityCoalescedDate: TSP_Date? = nil
  fileprivate var _actionType: TSCK_ActivityStreamTransformationStateArchive.ActionType? = nil
  fileprivate var _transformToDocumentRevisionSequence: Int32? = nil
  fileprivate var _timestampOfLastActivityWhenLastActivityCoalescing: Double? = nil
  fileprivate var _preservingRevisionSequenceOrder: Bool? = nil
}

struct TSCK_ActivityStreamActivityCounterArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionTypeCounter: [TSCK_ActivityStreamActivityCounterArchive.ActionTypeCounter] = []

  var cursorTypeCounter: [TSCK_ActivityStreamActivityCounterArchive.CursorTypeCounter] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ActionTypeCounter: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var actionType: Int32 {
      get {return _actionType ?? 0}
      set {_actionType = newValue}
    }
    /// Returns true if `actionType` has been explicitly set.
    var hasActionType: Bool {return self._actionType != nil}
    /// Clears the value of `actionType`. Subsequent reads from it will return its default value.
    mutating func clearActionType() {self._actionType = nil}

    var count: UInt32 {
      get {return _count ?? 0}
      set {_count = newValue}
    }
    /// Returns true if `count` has been explicitly set.
    var hasCount: Bool {return self._count != nil}
    /// Clears the value of `count`. Subsequent reads from it will return its default value.
    mutating func clearCount() {self._count = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _actionType: Int32? = nil
    fileprivate var _count: UInt32? = nil
  }

  struct CursorTypeCounter: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var cursorType: Int32 {
      get {return _cursorType ?? 0}
      set {_cursorType = newValue}
    }
    /// Returns true if `cursorType` has been explicitly set.
    var hasCursorType: Bool {return self._cursorType != nil}
    /// Clears the value of `cursorType`. Subsequent reads from it will return its default value.
    mutating func clearCursorType() {self._cursorType = nil}

    var count: UInt32 {
      get {return _count ?? 0}
      set {_count = newValue}
    }
    /// Returns true if `count` has been explicitly set.
    var hasCount: Bool {return self._count != nil}
    /// Clears the value of `count`. Subsequent reads from it will return its default value.
    mutating func clearCount() {self._count = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _cursorType: Int32? = nil
    fileprivate var _count: UInt32? = nil
  }

  init() {}
}

struct TSCK_ActivityStreamRemovedAuthorAuditorPendingStateArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var currentAuthorIdentifiers: [TSP_UUID] = []

  var datesToAudit: [TSCK_ActivityStreamRemovedAuthorAuditorPendingStateArchive.DateToAuditAndType] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct DateToAuditAndType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dateToAudit: TSP_Date {
      get {return _dateToAudit ?? TSP_Date()}
      set {_dateToAudit = newValue}
    }
    /// Returns true if `dateToAudit` has been explicitly set.
    var hasDateToAudit: Bool {return self._dateToAudit != nil}
    /// Clears the value of `dateToAudit`. Subsequent reads from it will return its default value.
    mutating func clearDateToAudit() {self._dateToAudit = nil}

    var type: Int32 {
      get {return _type ?? 0}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _dateToAudit: TSP_Date? = nil
    fileprivate var _type: Int32? = nil
  }

  init() {}
}

// MARK: - Extension support defined in TSCKArchives.proto.

// MARK: - Extension Properties

// Swift Extensions on the extended Messages to add easy access to the declared
// extension fields. The names are based on the extension field name from the proto
// declaration. To avoid naming collisions, the names are prefixed with the name of
// the scope where the extend directive occurs.

extension TSCK_ActivityNavigationInfoArchive {

  var TSCK_CommentActivityNavigationInfoArchive_commentActivityNavigationInfo: TSCK_CommentActivityNavigationInfoArchive {
    get {return getExtensionValue(ext: TSCK_CommentActivityNavigationInfoArchive.Extensions.comment_activity_navigation_info) ?? TSCK_CommentActivityNavigationInfoArchive()}
    set {setExtensionValue(ext: TSCK_CommentActivityNavigationInfoArchive.Extensions.comment_activity_navigation_info, value: newValue)}
  }
  /// Returns true if extension `TSCK_CommentActivityNavigationInfoArchive.Extensions.comment_activity_navigation_info`
  /// has been explicitly set.
  var hasTSCK_CommentActivityNavigationInfoArchive_commentActivityNavigationInfo: Bool {
    return hasExtensionValue(ext: TSCK_CommentActivityNavigationInfoArchive.Extensions.comment_activity_navigation_info)
  }
  /// Clears the value of extension `TSCK_CommentActivityNavigationInfoArchive.Extensions.comment_activity_navigation_info`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTSCK_CommentActivityNavigationInfoArchive_commentActivityNavigationInfo() {
    clearExtensionValue(ext: TSCK_CommentActivityNavigationInfoArchive.Extensions.comment_activity_navigation_info)
  }

}

// MARK: - File's ExtensionMap: TSCK_Tsckarchives_Extensions

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
let TSCK_Tsckarchives_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  TSCK_CommentActivityNavigationInfoArchive.Extensions.comment_activity_navigation_info
]

// Extension Objects - The only reason these might be needed is when manually
// constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
// accessors for the extension fields on the messages directly.

extension TSCK_CommentActivityNavigationInfoArchive {
  enum Extensions {
    static let comment_activity_navigation_info = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TSCK_CommentActivityNavigationInfoArchive>, TSCK_ActivityNavigationInfoArchive>(
      _protobuf_fieldNumber: 100,
      fieldName: "TSCK.CommentActivityNavigationInfoArchive.comment_activity_navigation_info"
    )
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TSCK"

extension TSCK_CollaborationCommandHistoryArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CollaborationCommandHistoryArray"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}large_array\0")

  public var isInitialized: Bool {
    if self._largeArray == nil {return false}
    if let v = self._largeArray, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._largeArray) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._largeArray {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_CollaborationCommandHistoryArray, rhs: TSCK_CollaborationCommandHistoryArray) -> Bool {
    if lhs._largeArray != rhs._largeArray {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_CollaborationCommandHistoryArraySegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CollaborationCommandHistoryArraySegment"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}large_object_array_segment\0")

  public var isInitialized: Bool {
    if self._largeObjectArraySegment == nil {return false}
    if let v = self._largeObjectArraySegment, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._largeObjectArraySegment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._largeObjectArraySegment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_CollaborationCommandHistoryArraySegment, rhs: TSCK_CollaborationCommandHistoryArraySegment) -> Bool {
    if lhs._largeObjectArraySegment != rhs._largeObjectArraySegment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_CollaborationCommandHistory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CollaborationCommandHistory"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}local_identifier\0\u{3}undo_items\0\u{3}redo_items\0")

  public var isInitialized: Bool {
    if let v = self._localIdentifier, !v.isInitialized {return false}
    if let v = self._undoItems, !v.isInitialized {return false}
    if let v = self._redoItems, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._localIdentifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._undoItems) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._redoItems) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._localIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._undoItems {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._redoItems {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_CollaborationCommandHistory, rhs: TSCK_CollaborationCommandHistory) -> Bool {
    if lhs._localIdentifier != rhs._localIdentifier {return false}
    if lhs._undoItems != rhs._undoItems {return false}
    if lhs._redoItems != rhs._redoItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_CollaborationCommandHistory.ItemList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCK_CollaborationCommandHistory.protoMessageName + ".ItemList"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}items_array\0\u{3}transformer_entries\0")

  public var isInitialized: Bool {
    if let v = self._itemsArray, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.transformerEntries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._itemsArray) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.transformerEntries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._itemsArray {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.transformerEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transformerEntries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_CollaborationCommandHistory.ItemList, rhs: TSCK_CollaborationCommandHistory.ItemList) -> Bool {
    if lhs._itemsArray != rhs._itemsArray {return false}
    if lhs.transformerEntries != rhs.transformerEntries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_CollaborationCommandHistoryItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CollaborationCommandHistoryItem"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}command\0\u{3}action_string\0\u{1}behavior\0\u{3}coalescing_group\0\u{3}revision_sequence\0")

  public var isInitialized: Bool {
    if let v = self._command, !v.isInitialized {return false}
    if let v = self._behavior, !v.isInitialized {return false}
    if let v = self._coalescingGroup, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._command) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._actionString) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._behavior) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._coalescingGroup) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._revisionSequence) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._command {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._actionString {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._behavior {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._coalescingGroup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._revisionSequence {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_CollaborationCommandHistoryItem, rhs: TSCK_CollaborationCommandHistoryItem) -> Bool {
    if lhs._command != rhs._command {return false}
    if lhs._actionString != rhs._actionString {return false}
    if lhs._behavior != rhs._behavior {return false}
    if lhs._coalescingGroup != rhs._coalescingGroup {return false}
    if lhs._revisionSequence != rhs._revisionSequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_CollaborationCommandHistoryCoalescingGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CollaborationCommandHistoryCoalescingGroup"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}nodes\0\u{3}did_coalesce_all_commands\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.nodes) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._didCoalesceAllCommands) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    try { if let v = self._didCoalesceAllCommands {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_CollaborationCommandHistoryCoalescingGroup, rhs: TSCK_CollaborationCommandHistoryCoalescingGroup) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs._didCoalesceAllCommands != rhs._didCoalesceAllCommands {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_CollaborationCommandHistoryCoalescingGroupNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CollaborationCommandHistoryCoalescingGroupNode"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}command\0")

  public var isInitialized: Bool {
    if let v = self._command, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._command) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._command {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_CollaborationCommandHistoryCoalescingGroupNode, rhs: TSCK_CollaborationCommandHistoryCoalescingGroupNode) -> Bool {
    if lhs._command != rhs._command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_CollaborationCommandHistoryOriginatingCommandAcknowledgementObserver: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CollaborationCommandHistoryOriginatingCommandAcknowledgementObserver"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}coalescing_group\0\u{1}node\0")

  public var isInitialized: Bool {
    if let v = self._coalescingGroup, !v.isInitialized {return false}
    if let v = self._node, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coalescingGroup) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._node) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coalescingGroup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._node {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_CollaborationCommandHistoryOriginatingCommandAcknowledgementObserver, rhs: TSCK_CollaborationCommandHistoryOriginatingCommandAcknowledgementObserver) -> Bool {
    if lhs._coalescingGroup != rhs._coalescingGroup {return false}
    if lhs._node != rhs._node {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_DocumentSupportCollaborationState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentSupportCollaborationState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collaboration_command_history\0\u{3}collaboration_session_state\0")

  public var isInitialized: Bool {
    if let v = self._collaborationCommandHistory, !v.isInitialized {return false}
    if let v = self._collaborationSessionState, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._collaborationCommandHistory) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._collaborationSessionState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._collaborationCommandHistory {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._collaborationSessionState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_DocumentSupportCollaborationState, rhs: TSCK_DocumentSupportCollaborationState) -> Bool {
    if lhs._collaborationCommandHistory != rhs._collaborationCommandHistory {return false}
    if lhs._collaborationSessionState != rhs._collaborationSessionState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_SetAnnotationAuthorColorCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetAnnotationAuthorColorCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}annotation_author\0\u{1}color\0\u{3}old_color\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _annotationAuthor: TSP_Reference? = nil
    var _color: TSP_Color? = nil
    var _oldColor: TSP_Color? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _annotationAuthor = source._annotationAuthor
      _color = source._color
      _oldColor = source._oldColor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._annotationAuthor, !v.isInitialized {return false}
      if let v = _storage._color, !v.isInitialized {return false}
      if let v = _storage._oldColor, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._annotationAuthor) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._color) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._oldColor) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._annotationAuthor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._color {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._oldColor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_SetAnnotationAuthorColorCommandArchive, rhs: TSCK_SetAnnotationAuthorColorCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._annotationAuthor != rhs_storage._annotationAuthor {return false}
        if _storage._color != rhs_storage._color {return false}
        if _storage._oldColor != rhs_storage._oldColor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_SetActivityAuthorShareParticipantIDCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetActivityAuthorShareParticipantIDCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}activity_author\0\u{3}share_participant_id\0\u{3}old_share_participant_id\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._activityAuthor, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._activityAuthor) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._shareParticipantID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._oldShareParticipantID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._activityAuthor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._shareParticipantID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._oldShareParticipantID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_SetActivityAuthorShareParticipantIDCommandArchive, rhs: TSCK_SetActivityAuthorShareParticipantIDCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._activityAuthor != rhs._activityAuthor {return false}
    if lhs._shareParticipantID != rhs._shareParticipantID {return false}
    if lhs._oldShareParticipantID != rhs._oldShareParticipantID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_IdOperationArgs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IdOperationArgs"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}id_path\0")

  public var isInitialized: Bool {
    if self._idPath == nil {return false}
    if let v = self._idPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._idPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._idPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_IdOperationArgs, rhs: TSCK_IdOperationArgs) -> Bool {
    if lhs._idPath != rhs._idPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_AddIdOperationArgs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddIdOperationArgs"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}index\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._index == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._index {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_AddIdOperationArgs, rhs: TSCK_AddIdOperationArgs) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._index != rhs._index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_RemoveIdOperationArgs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveIdOperationArgs"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}index\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._index == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._index {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_RemoveIdOperationArgs, rhs: TSCK_RemoveIdOperationArgs) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._index != rhs._index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_RearrangeIdOperationArgs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RearrangeIdOperationArgs"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}from_index\0\u{3}to_index\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._fromIndex == nil {return false}
    if self._toIndex == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._fromIndex) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._toIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fromIndex {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._toIndex {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_RearrangeIdOperationArgs, rhs: TSCK_RearrangeIdOperationArgs) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._fromIndex != rhs._fromIndex {return false}
    if lhs._toIndex != rhs._toIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_IdPlacementOperationArgs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IdPlacementOperationArgs"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}from_index\0\u{3}to_index\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._fromIndex == nil {return false}
    if self._toIndex == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._fromIndex) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._toIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fromIndex {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._toIndex {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_IdPlacementOperationArgs, rhs: TSCK_IdPlacementOperationArgs) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._fromIndex != rhs._fromIndex {return false}
    if lhs._toIndex != rhs._toIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityCommitCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivityCommitCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}activity\0\u{1}author\0\u{3}was_activity_committed\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _activity: TSP_Reference? = nil
    var _author: TSP_Reference? = nil
    var _wasActivityCommitted: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _activity = source._activity
      _author = source._author
      _wasActivityCommitted = source._wasActivityCommitted
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._activity, !v.isInitialized {return false}
      if let v = _storage._author, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._activity) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._author) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._wasActivityCommitted) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._activity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._author {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._wasActivityCommitted {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityCommitCommandArchive, rhs: TSCK_ActivityCommitCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._activity != rhs_storage._activity {return false}
        if _storage._author != rhs_storage._author {return false}
        if _storage._wasActivityCommitted != rhs_storage._wasActivityCommitted {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ExecuteTestBetweenRollbackAndReapplyCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecuteTestBetweenRollbackAndReapplyCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ExecuteTestBetweenRollbackAndReapplyCommandArchive, rhs: TSCK_ExecuteTestBetweenRollbackAndReapplyCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_CreateLocalStorageSnapshotCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateLocalStorageSnapshotCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}snapshot_id\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._snapshotID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._snapshotID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_CreateLocalStorageSnapshotCommandArchive, rhs: TSCK_CreateLocalStorageSnapshotCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._snapshotID != rhs._snapshotID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_BlockDiffsAtCurrentRevisionCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockDiffsAtCurrentRevisionCommand"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_BlockDiffsAtCurrentRevisionCommand, rhs: TSCK_BlockDiffsAtCurrentRevisionCommand) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_TransformerEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransformerEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}sequence\0\u{3}creation_time\0\u{1}transformer\0")

  public var isInitialized: Bool {
    if self._sequence == nil {return false}
    if self._creationTime == nil {return false}
    if self._transformer == nil {return false}
    if let v = self._transformer, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._sequence) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._creationTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._transformer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sequence {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._creationTime {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._transformer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_TransformerEntry, rhs: TSCK_TransformerEntry) -> Bool {
    if lhs._sequence != rhs._sequence {return false}
    if lhs._creationTime != rhs._creationTime {return false}
    if lhs._transformer != rhs._transformer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_CollaborationAppliedCommandDocumentRevisionMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CollaborationAppliedCommandDocumentRevisionMapping"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}command\0\u{3}document_revision_identifier\0\u{3}document_revision_sequence\0\u{3}remaining_command_operations\0\u{1}timestamp\0")

  public var isInitialized: Bool {
    if let v = self._command, !v.isInitialized {return false}
    if let v = self._documentRevisionIdentifier, !v.isInitialized {return false}
    if let v = self._timestamp, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._command) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._documentRevisionIdentifier) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._documentRevisionSequence) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.remainingCommandOperations) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._command {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._documentRevisionIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._documentRevisionSequence {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    if !self.remainingCommandOperations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.remainingCommandOperations, fieldNumber: 4)
    }
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_CollaborationAppliedCommandDocumentRevisionMapping, rhs: TSCK_CollaborationAppliedCommandDocumentRevisionMapping) -> Bool {
    if lhs._command != rhs._command {return false}
    if lhs._documentRevisionIdentifier != rhs._documentRevisionIdentifier {return false}
    if lhs._documentRevisionSequence != rhs._documentRevisionSequence {return false}
    if lhs.remainingCommandOperations != rhs.remainingCommandOperations {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_CollaborationDocumentSessionState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CollaborationDocumentSessionState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collaborator_ids\0\u{4}\u{2}rsvp_command_queue_items\0\u{3}collaborator_cursor_transformer_entries\0\u{3}acknowledged_commands_pending_resume_process_diffs\0\u{3}unprocessed_commands_pending_resume_process_diffs\0\u{3}command_acknowledgement_observer_entries\0\u{3}transformer_from_unprocessed_command_operations_entries\0\u{4}\u{2}mailbox_request_document_revision_sequence\0\u{3}mailbox_request_document_revision_identifier\0\u{3}last_send_pending_command_queue_item_was_moved_from_rsvp_command_queue\0\u{3}last_command_send_marker_sequence\0\u{3}last_command_send_marker_identifier\0\u{3}skipped_acknowledged_commands_pending_resume_process_diffs\0\u{3}last_too_old_command_identifier\0\u{3}unprocessed_operation_entries_pending_resume_process_diffs\0\u{3}send_pending_command_queue\0\u{3}count_of_send_pending_command_queue_items_moved_from_rsvp_queue\0\u{3}last_enqueued_document_load_command_identifier\0\u{3}applied_command_document_revision_mappings_to_notify_pending_resume_process_diffs\0\u{3}count_of_command_queue_items_in_last_outgoing_command_group\0")

  fileprivate class _StorageClass {
    var _collaboratorIds: [String] = []
    var _rsvpCommandQueueItems: [TSP_Reference] = []
    var _collaboratorCursorTransformerEntries: [TSP_Reference] = []
    var _acknowledgedCommandsPendingResumeProcessDiffs: [TSP_Reference] = []
    var _unprocessedCommandsPendingResumeProcessDiffs: [TSP_Reference] = []
    var _commandAcknowledgementObserverEntries: [TSCK_CollaborationDocumentSessionState.AcknowledgementObserverEntry] = []
    var _transformerFromUnprocessedCommandOperationsEntries: [TSP_Reference] = []
    var _mailboxRequestDocumentRevisionSequence: Int32? = nil
    var _mailboxRequestDocumentRevisionIdentifier: TSP_UUID? = nil
    var _lastSendPendingCommandQueueItemWasMovedFromRsvpCommandQueue: Bool? = nil
    var _lastCommandSendMarkerSequence: Int32? = nil
    var _lastCommandSendMarkerIdentifier: TSP_UUID? = nil
    var _skippedAcknowledgedCommandsPendingResumeProcessDiffs: [TSP_Reference] = []
    var _lastTooOldCommandIdentifier: TSP_UUID? = nil
    var _unprocessedOperationEntriesPendingResumeProcessDiffs: TSP_Reference? = nil
    var _sendPendingCommandQueue: TSP_Reference? = nil
    var _countOfSendPendingCommandQueueItemsMovedFromRsvpQueue: UInt64? = nil
    var _lastEnqueuedDocumentLoadCommandIdentifier: TSP_UUID? = nil
    var _appliedCommandDocumentRevisionMappingsToNotifyPendingResumeProcessDiffs: [TSCK_CollaborationAppliedCommandDocumentRevisionMapping] = []
    var _countOfCommandQueueItemsInLastOutgoingCommandGroup: UInt64? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _collaboratorIds = source._collaboratorIds
      _rsvpCommandQueueItems = source._rsvpCommandQueueItems
      _collaboratorCursorTransformerEntries = source._collaboratorCursorTransformerEntries
      _acknowledgedCommandsPendingResumeProcessDiffs = source._acknowledgedCommandsPendingResumeProcessDiffs
      _unprocessedCommandsPendingResumeProcessDiffs = source._unprocessedCommandsPendingResumeProcessDiffs
      _commandAcknowledgementObserverEntries = source._commandAcknowledgementObserverEntries
      _transformerFromUnprocessedCommandOperationsEntries = source._transformerFromUnprocessedCommandOperationsEntries
      _mailboxRequestDocumentRevisionSequence = source._mailboxRequestDocumentRevisionSequence
      _mailboxRequestDocumentRevisionIdentifier = source._mailboxRequestDocumentRevisionIdentifier
      _lastSendPendingCommandQueueItemWasMovedFromRsvpCommandQueue = source._lastSendPendingCommandQueueItemWasMovedFromRsvpCommandQueue
      _lastCommandSendMarkerSequence = source._lastCommandSendMarkerSequence
      _lastCommandSendMarkerIdentifier = source._lastCommandSendMarkerIdentifier
      _skippedAcknowledgedCommandsPendingResumeProcessDiffs = source._skippedAcknowledgedCommandsPendingResumeProcessDiffs
      _lastTooOldCommandIdentifier = source._lastTooOldCommandIdentifier
      _unprocessedOperationEntriesPendingResumeProcessDiffs = source._unprocessedOperationEntriesPendingResumeProcessDiffs
      _sendPendingCommandQueue = source._sendPendingCommandQueue
      _countOfSendPendingCommandQueueItemsMovedFromRsvpQueue = source._countOfSendPendingCommandQueueItemsMovedFromRsvpQueue
      _lastEnqueuedDocumentLoadCommandIdentifier = source._lastEnqueuedDocumentLoadCommandIdentifier
      _appliedCommandDocumentRevisionMappingsToNotifyPendingResumeProcessDiffs = source._appliedCommandDocumentRevisionMappingsToNotifyPendingResumeProcessDiffs
      _countOfCommandQueueItemsInLastOutgoingCommandGroup = source._countOfCommandQueueItemsInLastOutgoingCommandGroup
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._rsvpCommandQueueItems) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._collaboratorCursorTransformerEntries) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._acknowledgedCommandsPendingResumeProcessDiffs) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._unprocessedCommandsPendingResumeProcessDiffs) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._commandAcknowledgementObserverEntries) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._transformerFromUnprocessedCommandOperationsEntries) {return false}
      if let v = _storage._mailboxRequestDocumentRevisionIdentifier, !v.isInitialized {return false}
      if let v = _storage._lastCommandSendMarkerIdentifier, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._skippedAcknowledgedCommandsPendingResumeProcessDiffs) {return false}
      if let v = _storage._lastTooOldCommandIdentifier, !v.isInitialized {return false}
      if let v = _storage._unprocessedOperationEntriesPendingResumeProcessDiffs, !v.isInitialized {return false}
      if let v = _storage._sendPendingCommandQueue, !v.isInitialized {return false}
      if let v = _storage._lastEnqueuedDocumentLoadCommandIdentifier, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._appliedCommandDocumentRevisionMappingsToNotifyPendingResumeProcessDiffs) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedStringField(value: &_storage._collaboratorIds) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._rsvpCommandQueueItems) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._collaboratorCursorTransformerEntries) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._acknowledgedCommandsPendingResumeProcessDiffs) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._unprocessedCommandsPendingResumeProcessDiffs) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._commandAcknowledgementObserverEntries) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._transformerFromUnprocessedCommandOperationsEntries) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._mailboxRequestDocumentRevisionSequence) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._mailboxRequestDocumentRevisionIdentifier) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._lastSendPendingCommandQueueItemWasMovedFromRsvpCommandQueue) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._lastCommandSendMarkerSequence) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._lastCommandSendMarkerIdentifier) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._skippedAcknowledgedCommandsPendingResumeProcessDiffs) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._lastTooOldCommandIdentifier) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._unprocessedOperationEntriesPendingResumeProcessDiffs) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._sendPendingCommandQueue) }()
        case 19: try { try decoder.decodeSingularUInt64Field(value: &_storage._countOfSendPendingCommandQueueItemsMovedFromRsvpQueue) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._lastEnqueuedDocumentLoadCommandIdentifier) }()
        case 21: try { try decoder.decodeRepeatedMessageField(value: &_storage._appliedCommandDocumentRevisionMappingsToNotifyPendingResumeProcessDiffs) }()
        case 22: try { try decoder.decodeSingularUInt64Field(value: &_storage._countOfCommandQueueItemsInLastOutgoingCommandGroup) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._collaboratorIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._collaboratorIds, fieldNumber: 1)
      }
      if !_storage._rsvpCommandQueueItems.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rsvpCommandQueueItems, fieldNumber: 3)
      }
      if !_storage._collaboratorCursorTransformerEntries.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._collaboratorCursorTransformerEntries, fieldNumber: 4)
      }
      if !_storage._acknowledgedCommandsPendingResumeProcessDiffs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._acknowledgedCommandsPendingResumeProcessDiffs, fieldNumber: 5)
      }
      if !_storage._unprocessedCommandsPendingResumeProcessDiffs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._unprocessedCommandsPendingResumeProcessDiffs, fieldNumber: 6)
      }
      if !_storage._commandAcknowledgementObserverEntries.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._commandAcknowledgementObserverEntries, fieldNumber: 7)
      }
      if !_storage._transformerFromUnprocessedCommandOperationsEntries.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._transformerFromUnprocessedCommandOperationsEntries, fieldNumber: 8)
      }
      try { if let v = _storage._mailboxRequestDocumentRevisionSequence {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._mailboxRequestDocumentRevisionIdentifier {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._lastSendPendingCommandQueueItemWasMovedFromRsvpCommandQueue {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._lastCommandSendMarkerSequence {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._lastCommandSendMarkerIdentifier {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if !_storage._skippedAcknowledgedCommandsPendingResumeProcessDiffs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._skippedAcknowledgedCommandsPendingResumeProcessDiffs, fieldNumber: 15)
      }
      try { if let v = _storage._lastTooOldCommandIdentifier {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._unprocessedOperationEntriesPendingResumeProcessDiffs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._sendPendingCommandQueue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._countOfSendPendingCommandQueueItemsMovedFromRsvpQueue {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._lastEnqueuedDocumentLoadCommandIdentifier {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if !_storage._appliedCommandDocumentRevisionMappingsToNotifyPendingResumeProcessDiffs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._appliedCommandDocumentRevisionMappingsToNotifyPendingResumeProcessDiffs, fieldNumber: 21)
      }
      try { if let v = _storage._countOfCommandQueueItemsInLastOutgoingCommandGroup {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 22)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_CollaborationDocumentSessionState, rhs: TSCK_CollaborationDocumentSessionState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._collaboratorIds != rhs_storage._collaboratorIds {return false}
        if _storage._rsvpCommandQueueItems != rhs_storage._rsvpCommandQueueItems {return false}
        if _storage._collaboratorCursorTransformerEntries != rhs_storage._collaboratorCursorTransformerEntries {return false}
        if _storage._acknowledgedCommandsPendingResumeProcessDiffs != rhs_storage._acknowledgedCommandsPendingResumeProcessDiffs {return false}
        if _storage._unprocessedCommandsPendingResumeProcessDiffs != rhs_storage._unprocessedCommandsPendingResumeProcessDiffs {return false}
        if _storage._commandAcknowledgementObserverEntries != rhs_storage._commandAcknowledgementObserverEntries {return false}
        if _storage._transformerFromUnprocessedCommandOperationsEntries != rhs_storage._transformerFromUnprocessedCommandOperationsEntries {return false}
        if _storage._mailboxRequestDocumentRevisionSequence != rhs_storage._mailboxRequestDocumentRevisionSequence {return false}
        if _storage._mailboxRequestDocumentRevisionIdentifier != rhs_storage._mailboxRequestDocumentRevisionIdentifier {return false}
        if _storage._lastSendPendingCommandQueueItemWasMovedFromRsvpCommandQueue != rhs_storage._lastSendPendingCommandQueueItemWasMovedFromRsvpCommandQueue {return false}
        if _storage._lastCommandSendMarkerSequence != rhs_storage._lastCommandSendMarkerSequence {return false}
        if _storage._lastCommandSendMarkerIdentifier != rhs_storage._lastCommandSendMarkerIdentifier {return false}
        if _storage._skippedAcknowledgedCommandsPendingResumeProcessDiffs != rhs_storage._skippedAcknowledgedCommandsPendingResumeProcessDiffs {return false}
        if _storage._lastTooOldCommandIdentifier != rhs_storage._lastTooOldCommandIdentifier {return false}
        if _storage._unprocessedOperationEntriesPendingResumeProcessDiffs != rhs_storage._unprocessedOperationEntriesPendingResumeProcessDiffs {return false}
        if _storage._sendPendingCommandQueue != rhs_storage._sendPendingCommandQueue {return false}
        if _storage._countOfSendPendingCommandQueueItemsMovedFromRsvpQueue != rhs_storage._countOfSendPendingCommandQueueItemsMovedFromRsvpQueue {return false}
        if _storage._lastEnqueuedDocumentLoadCommandIdentifier != rhs_storage._lastEnqueuedDocumentLoadCommandIdentifier {return false}
        if _storage._appliedCommandDocumentRevisionMappingsToNotifyPendingResumeProcessDiffs != rhs_storage._appliedCommandDocumentRevisionMappingsToNotifyPendingResumeProcessDiffs {return false}
        if _storage._countOfCommandQueueItemsInLastOutgoingCommandGroup != rhs_storage._countOfCommandQueueItemsInLastOutgoingCommandGroup {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_CollaborationDocumentSessionState.AcknowledgementObserverEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCK_CollaborationDocumentSessionState.protoMessageName + ".AcknowledgementObserverEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}command_identifier\0\u{3}acknowledgement_observers\0")

  public var isInitialized: Bool {
    if self._commandIdentifier == nil {return false}
    if let v = self._commandIdentifier, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.acknowledgementObservers) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandIdentifier) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.acknowledgementObservers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.acknowledgementObservers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.acknowledgementObservers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_CollaborationDocumentSessionState.AcknowledgementObserverEntry, rhs: TSCK_CollaborationDocumentSessionState.AcknowledgementObserverEntry) -> Bool {
    if lhs._commandIdentifier != rhs._commandIdentifier {return false}
    if lhs.acknowledgementObservers != rhs.acknowledgementObservers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_OperationStorageEntryArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OperationStorageEntryArray"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}large_array\0")

  public var isInitialized: Bool {
    if let v = self._largeArray, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._largeArray) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._largeArray {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_OperationStorageEntryArray, rhs: TSCK_OperationStorageEntryArray) -> Bool {
    if lhs._largeArray != rhs._largeArray {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_OperationStorageEntryArraySegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OperationStorageEntryArraySegment"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}large_array_segment\0\u{1}elements\0\u{3}last_document_revision_sequence_before_segment\0\u{3}last_document_revision_sequence\0\u{3}segment_first_entry_creation_time\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._largeArraySegment) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._lastDocumentRevisionSequenceBeforeSegment) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._lastDocumentRevisionSequence) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self._segmentFirstEntryCreationTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._largeArraySegment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 2)
    }
    try { if let v = self._lastDocumentRevisionSequenceBeforeSegment {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._lastDocumentRevisionSequence {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._segmentFirstEntryCreationTime {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_OperationStorageEntryArraySegment, rhs: TSCK_OperationStorageEntryArraySegment) -> Bool {
    if lhs._largeArraySegment != rhs._largeArraySegment {return false}
    if lhs.elements != rhs.elements {return false}
    if lhs._lastDocumentRevisionSequenceBeforeSegment != rhs._lastDocumentRevisionSequenceBeforeSegment {return false}
    if lhs._lastDocumentRevisionSequence != rhs._lastDocumentRevisionSequence {return false}
    if lhs._segmentFirstEntryCreationTime != rhs._segmentFirstEntryCreationTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_OperationStorage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OperationStorage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}entries\0\u{3}operation_count\0\u{3}last_document_revision_sequence\0\u{3}last_document_revision_identifier\0\u{3}last_unskippable_document_revision_before_entries_sequence\0\u{3}last_unskippable_document_revision_before_entries_identifier\0\u{3}last_unskippable_document_revision_in_entries_sequence\0\u{3}last_unskippable_document_revision_in_entries_identifier\0\u{3}days_with_an_entry\0")

  public var isInitialized: Bool {
    if self._entries == nil {return false}
    if self._operationCount == nil {return false}
    if let v = self._entries, !v.isInitialized {return false}
    if let v = self._daysWithAnEntry, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entries) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._operationCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._lastDocumentRevisionSequence) }()
      case 4: try { try decoder.decodeRepeatedFixed64Field(value: &self.lastDocumentRevisionIdentifier) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._lastUnskippableDocumentRevisionBeforeEntriesSequence) }()
      case 6: try { try decoder.decodeRepeatedFixed64Field(value: &self.lastUnskippableDocumentRevisionBeforeEntriesIdentifier) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self._lastUnskippableDocumentRevisionInEntriesSequence) }()
      case 8: try { try decoder.decodeRepeatedFixed64Field(value: &self.lastUnskippableDocumentRevisionInEntriesIdentifier) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._daysWithAnEntry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entries {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._operationCount {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lastDocumentRevisionSequence {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    if !self.lastDocumentRevisionIdentifier.isEmpty {
      try visitor.visitRepeatedFixed64Field(value: self.lastDocumentRevisionIdentifier, fieldNumber: 4)
    }
    try { if let v = self._lastUnskippableDocumentRevisionBeforeEntriesSequence {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    if !self.lastUnskippableDocumentRevisionBeforeEntriesIdentifier.isEmpty {
      try visitor.visitRepeatedFixed64Field(value: self.lastUnskippableDocumentRevisionBeforeEntriesIdentifier, fieldNumber: 6)
    }
    try { if let v = self._lastUnskippableDocumentRevisionInEntriesSequence {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    } }()
    if !self.lastUnskippableDocumentRevisionInEntriesIdentifier.isEmpty {
      try visitor.visitRepeatedFixed64Field(value: self.lastUnskippableDocumentRevisionInEntriesIdentifier, fieldNumber: 8)
    }
    try { if let v = self._daysWithAnEntry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_OperationStorage, rhs: TSCK_OperationStorage) -> Bool {
    if lhs._entries != rhs._entries {return false}
    if lhs._operationCount != rhs._operationCount {return false}
    if lhs._lastDocumentRevisionSequence != rhs._lastDocumentRevisionSequence {return false}
    if lhs.lastDocumentRevisionIdentifier != rhs.lastDocumentRevisionIdentifier {return false}
    if lhs._lastUnskippableDocumentRevisionBeforeEntriesSequence != rhs._lastUnskippableDocumentRevisionBeforeEntriesSequence {return false}
    if lhs.lastUnskippableDocumentRevisionBeforeEntriesIdentifier != rhs.lastUnskippableDocumentRevisionBeforeEntriesIdentifier {return false}
    if lhs._lastUnskippableDocumentRevisionInEntriesSequence != rhs._lastUnskippableDocumentRevisionInEntriesSequence {return false}
    if lhs.lastUnskippableDocumentRevisionInEntriesIdentifier != rhs.lastUnskippableDocumentRevisionInEntriesIdentifier {return false}
    if lhs._daysWithAnEntry != rhs._daysWithAnEntry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_OutgoingCommandQueue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OutgoingCommandQueue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}large_object_array\0")

  public var isInitialized: Bool {
    if let v = self._largeObjectArray, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._largeObjectArray) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._largeObjectArray {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_OutgoingCommandQueue, rhs: TSCK_OutgoingCommandQueue) -> Bool {
    if lhs._largeObjectArray != rhs._largeObjectArray {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_OutgoingCommandQueueSegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OutgoingCommandQueueSegment"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}large_object_array_segment\0")

  public var isInitialized: Bool {
    if let v = self._largeObjectArraySegment, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._largeObjectArraySegment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._largeObjectArraySegment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_OutgoingCommandQueueSegment, rhs: TSCK_OutgoingCommandQueueSegment) -> Bool {
    if lhs._largeObjectArraySegment != rhs._largeObjectArraySegment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_CommandAssetChunkArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandAssetChunkArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}digest\0\u{3}asset_chunk\0\u{3}asset_chunk_length\0\u{3}resume_position\0\u{3}materialized_length\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._assetChunkLength == nil {return false}
    if self._resumePosition == nil {return false}
    if self._materializedLength == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._digest) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._assetChunk) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._assetChunkLength) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self._resumePosition) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self._materializedLength) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._digest {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._assetChunk {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._assetChunkLength {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._resumePosition {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._materializedLength {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_CommandAssetChunkArchive, rhs: TSCK_CommandAssetChunkArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._digest != rhs._digest {return false}
    if lhs._assetChunk != rhs._assetChunk {return false}
    if lhs._assetChunkLength != rhs._assetChunkLength {return false}
    if lhs._resumePosition != rhs._resumePosition {return false}
    if lhs._materializedLength != rhs._materializedLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_AssetUploadStatusCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AssetUploadStatusCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}info_list\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.infoList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.infoList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infoList, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_AssetUploadStatusCommandArchive, rhs: TSCK_AssetUploadStatusCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.infoList != rhs.infoList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_AssetUploadStatusCommandArchive.AssetUploadStatusInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCK_AssetUploadStatusCommandArchive.protoMessageName + ".AssetUploadStatusInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}digest\0\u{3}upload_status\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._digest) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._uploadStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._digest {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._uploadStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_AssetUploadStatusCommandArchive.AssetUploadStatusInfo, rhs: TSCK_AssetUploadStatusCommandArchive.AssetUploadStatusInfo) -> Bool {
    if lhs._digest != rhs._digest {return false}
    if lhs._uploadStatus != rhs._uploadStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_AssetUnmaterializedOnServerCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AssetUnmaterializedOnServerCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}digest_list\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.digestList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.digestList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.digestList, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_AssetUnmaterializedOnServerCommandArchive, rhs: TSCK_AssetUnmaterializedOnServerCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.digestList != rhs.digestList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_CollaboratorCursorArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CollaboratorCursorArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}id_path\0")

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if let v = self._idPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._idPath) }()
      case 100..<1000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TSCK_CollaboratorCursorArchive.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._idPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 100, end: 1000)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_CollaboratorCursorArchive, rhs: TSCK_CollaboratorCursorArchive) -> Bool {
    if lhs._idPath != rhs._idPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TSCK_ActivityStreamArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivityStreamArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}acknowledged_activity_array\0\u{3}unacknowledged_local_activity_array\0\u{3}author_cache\0\u{4}\u{2}unacknowledged_remote_activity_array\0\u{3}did_upgrade_comments_to_activities\0\u{4}\u{9}activity_stream_transformation_state\0\u{3}activity_counter\0")

  fileprivate class _StorageClass {
    var _acknowledgedActivityArray: TSP_Reference? = nil
    var _unacknowledgedLocalActivityArray: TSP_Reference? = nil
    var _authorCache: TSP_Reference? = nil
    var _unacknowledgedRemoteActivityArray: TSP_Reference? = nil
    var _didUpgradeCommentsToActivities: Bool? = nil
    var _activityStreamTransformationState: TSCK_ActivityStreamTransformationStateArchive? = nil
    var _activityCounter: TSCK_ActivityStreamActivityCounterArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _acknowledgedActivityArray = source._acknowledgedActivityArray
      _unacknowledgedLocalActivityArray = source._unacknowledgedLocalActivityArray
      _authorCache = source._authorCache
      _unacknowledgedRemoteActivityArray = source._unacknowledgedRemoteActivityArray
      _didUpgradeCommentsToActivities = source._didUpgradeCommentsToActivities
      _activityStreamTransformationState = source._activityStreamTransformationState
      _activityCounter = source._activityCounter
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._acknowledgedActivityArray, !v.isInitialized {return false}
      if let v = _storage._unacknowledgedLocalActivityArray, !v.isInitialized {return false}
      if let v = _storage._authorCache, !v.isInitialized {return false}
      if let v = _storage._unacknowledgedRemoteActivityArray, !v.isInitialized {return false}
      if let v = _storage._activityStreamTransformationState, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._acknowledgedActivityArray) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._unacknowledgedLocalActivityArray) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._authorCache) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._unacknowledgedRemoteActivityArray) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._didUpgradeCommentsToActivities) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._activityStreamTransformationState) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._activityCounter) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._acknowledgedActivityArray {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._unacknowledgedLocalActivityArray {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._authorCache {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._unacknowledgedRemoteActivityArray {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._didUpgradeCommentsToActivities {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._activityStreamTransformationState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._activityCounter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityStreamArchive, rhs: TSCK_ActivityStreamArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._acknowledgedActivityArray != rhs_storage._acknowledgedActivityArray {return false}
        if _storage._unacknowledgedLocalActivityArray != rhs_storage._unacknowledgedLocalActivityArray {return false}
        if _storage._authorCache != rhs_storage._authorCache {return false}
        if _storage._unacknowledgedRemoteActivityArray != rhs_storage._unacknowledgedRemoteActivityArray {return false}
        if _storage._didUpgradeCommentsToActivities != rhs_storage._didUpgradeCommentsToActivities {return false}
        if _storage._activityStreamTransformationState != rhs_storage._activityStreamTransformationState {return false}
        if _storage._activityCounter != rhs_storage._activityCounter {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityStreamActivityArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivityStreamActivityArray"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}large_array\0")

  public var isInitialized: Bool {
    if let v = self._largeArray, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._largeArray) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._largeArray {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityStreamActivityArray, rhs: TSCK_ActivityStreamActivityArray) -> Bool {
    if lhs._largeArray != rhs._largeArray {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityStreamActivityArraySegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivityStreamActivityArraySegment"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}large_array_segment\0")

  public var isInitialized: Bool {
    if let v = self._largeArraySegment, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._largeArraySegment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._largeArraySegment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityStreamActivityArraySegment, rhs: TSCK_ActivityStreamActivityArraySegment) -> Bool {
    if lhs._largeArraySegment != rhs._largeArraySegment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivityArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cursor_collection_persistence_wrappers\0\u{3}author_identifier\0\u{3}nondirectional_action_type\0\u{1}direction\0\u{3}should_send_notification\0\u{1}timestamp\0\u{3}revision_sequence\0\u{3}additional_navigation_info\0\u{3}did_prepare_serialized_string_on_server\0\u{3}oldest_revision_sequence_of_next_activities\0\u{3}action_sub_type\0\u{3}min_updatable_version\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.cursorCollectionPersistenceWrappers) {return false}
    if let v = self._authorIdentifier, !v.isInitialized {return false}
    if let v = self._timestamp, !v.isInitialized {return false}
    if let v = self._additionalNavigationInfo, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cursorCollectionPersistenceWrappers) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._authorIdentifier) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._nondirectionalActionType) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._direction) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._shouldSendNotification) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self._revisionSequence) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._additionalNavigationInfo) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self._didPrepareSerializedStringOnServer) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self._oldestRevisionSequenceOfNextActivities) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self._actionSubType) }()
      case 12: try { try decoder.decodeRepeatedUInt32Field(value: &self.minUpdatableVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cursorCollectionPersistenceWrappers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cursorCollectionPersistenceWrappers, fieldNumber: 1)
    }
    try { if let v = self._authorIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._nondirectionalActionType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._direction {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._shouldSendNotification {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._revisionSequence {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._additionalNavigationInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._didPrepareSerializedStringOnServer {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._oldestRevisionSequenceOfNextActivities {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._actionSubType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
    } }()
    if !self.minUpdatableVersion.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.minUpdatableVersion, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityArchive, rhs: TSCK_ActivityArchive) -> Bool {
    if lhs.cursorCollectionPersistenceWrappers != rhs.cursorCollectionPersistenceWrappers {return false}
    if lhs._authorIdentifier != rhs._authorIdentifier {return false}
    if lhs._nondirectionalActionType != rhs._nondirectionalActionType {return false}
    if lhs._direction != rhs._direction {return false}
    if lhs._shouldSendNotification != rhs._shouldSendNotification {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._revisionSequence != rhs._revisionSequence {return false}
    if lhs._additionalNavigationInfo != rhs._additionalNavigationInfo {return false}
    if lhs._didPrepareSerializedStringOnServer != rhs._didPrepareSerializedStringOnServer {return false}
    if lhs._oldestRevisionSequenceOfNextActivities != rhs._oldestRevisionSequenceOfNextActivities {return false}
    if lhs._actionSubType != rhs._actionSubType {return false}
    if lhs.minUpdatableVersion != rhs.minUpdatableVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityAuthorArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivityAuthorArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}color\0\u{3}public_ids\0\u{3}is_public_author\0\u{3}share_participant_id\0")

  public var isInitialized: Bool {
    if let v = self._color, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.publicIds) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._isPublicAuthor) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._shareParticipantID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.publicIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.publicIds, fieldNumber: 3)
    }
    try { if let v = self._isPublicAuthor {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._shareParticipantID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityAuthorArchive, rhs: TSCK_ActivityAuthorArchive) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._color != rhs._color {return false}
    if lhs.publicIds != rhs.publicIds {return false}
    if lhs._isPublicAuthor != rhs._isPublicAuthor {return false}
    if lhs._shareParticipantID != rhs._shareParticipantID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_CommandActivityBehaviorArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandActivityBehaviorArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}selection_path_storages\0\u{3}action_type\0\u{3}should_send_notification\0\u{3}additional_navigation_info\0\u{3}action_sub_type\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.selectionPathStorages) {return false}
    if let v = self._additionalNavigationInfo, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.selectionPathStorages) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._actionType) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._shouldSendNotification) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._additionalNavigationInfo) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._actionSubType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.selectionPathStorages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.selectionPathStorages, fieldNumber: 1)
    }
    try { if let v = self._actionType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._shouldSendNotification {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._additionalNavigationInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._actionSubType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_CommandActivityBehaviorArchive, rhs: TSCK_CommandActivityBehaviorArchive) -> Bool {
    if lhs.selectionPathStorages != rhs.selectionPathStorages {return false}
    if lhs._actionType != rhs._actionType {return false}
    if lhs._shouldSendNotification != rhs._shouldSendNotification {return false}
    if lhs._additionalNavigationInfo != rhs._additionalNavigationInfo {return false}
    if lhs._actionSubType != rhs._actionSubType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_CommandActivityBehaviorArchive.ActionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Unknown\0\u{1}FirstJoin\0\u{1}Add\0\u{1}Modify\0\u{1}Comment\0\u{1}Reply\0\u{1}Paste\0\u{1}Password\0\u{1}Restore\0\u{1}Remove\0\u{1}EditText\0\u{1}Group\0\u{1}Ungroup\0\u{1}Replace\0")
}

extension TSCK_CommandActivityBehaviorArchive.ActionSubType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0None\0\u{1}FilterTable\0\u{1}SortTable\0\u{1}CategorizeTable\0\u{1}ChangeTemplateSlide\0\u{1}ChangeChartType\0\u{1}MoveDrawable\0\u{1}ResizeDrawable\0\u{1}AddOrRemovePage\0\u{1}Hyperlink\0\u{1}SkipSlide\0\u{1}UnskipSlide\0\u{1}ChangeBackground\0\u{1}ChangePageTemplate\0\u{1}InsertPageNumber\0\u{1}RefreshPivotTable\0\u{1}AddPassword\0\u{1}ChangePassword\0\u{1}RemovePassword\0\u{1}Bookmark\0\u{1}Equation\0\u{1}SectionBreak\0\u{1}MoveColumn\0\u{1}LinkTextbox\0\u{1}NewTextboxThread\0\u{1}ChangeTextboxThread\0\u{1}ConditionalHighlightTableCell\0\u{1}DataFormatTableCell\0")
}

extension TSCK_ActivityCursorCollectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivityCursorCollectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}id_cursors\0\u{3}text_cursor\0\u{3}table_cursor\0\u{3}cde_cursor\0\u{3}chart_title_cursor\0\u{3}gallery_item_cursor\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.idCursors) {return false}
    if let v = self._textCursor, !v.isInitialized {return false}
    if let v = self._tableCursor, !v.isInitialized {return false}
    if let v = self._cdeCursor, !v.isInitialized {return false}
    if let v = self._chartTitleCursor, !v.isInitialized {return false}
    if let v = self._galleryItemCursor, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.idCursors) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._textCursor) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tableCursor) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._cdeCursor) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._chartTitleCursor) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._galleryItemCursor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.idCursors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.idCursors, fieldNumber: 1)
    }
    try { if let v = self._textCursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._tableCursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._cdeCursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._chartTitleCursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._galleryItemCursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityCursorCollectionArchive, rhs: TSCK_ActivityCursorCollectionArchive) -> Bool {
    if lhs.idCursors != rhs.idCursors {return false}
    if lhs._textCursor != rhs._textCursor {return false}
    if lhs._tableCursor != rhs._tableCursor {return false}
    if lhs._cdeCursor != rhs._cdeCursor {return false}
    if lhs._chartTitleCursor != rhs._chartTitleCursor {return false}
    if lhs._galleryItemCursor != rhs._galleryItemCursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityCursorCollectionPersistenceWrapperArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivityCursorCollectionPersistenceWrapperArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}activity_cursor_collection\0")

  public var isInitialized: Bool {
    if let v = self._activityCursorCollection, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._activityCursorCollection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._activityCursorCollection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityCursorCollectionPersistenceWrapperArchive, rhs: TSCK_ActivityCursorCollectionPersistenceWrapperArchive) -> Bool {
    if lhs._activityCursorCollection != rhs._activityCursorCollection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityNavigationInfoArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivityNavigationInfoArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      if (100 <= fieldNumber && fieldNumber < 1000) {
        try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TSCK_ActivityNavigationInfoArchive.self, fieldNumber: fieldNumber)
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 100, end: 1000)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityNavigationInfoArchive, rhs: TSCK_ActivityNavigationInfoArchive) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TSCK_CommentActivityNavigationInfoArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommentActivityNavigationInfoArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}comment_id\0\u{3}parent_uuid\0\u{3}storage_uuid\0")

  public var isInitialized: Bool {
    if self._commentID == nil {return false}
    if self._parentUuid == nil {return false}
    if self._storageUuid == nil {return false}
    if let v = self._parentUuid, !v.isInitialized {return false}
    if let v = self._storageUuid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._commentID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._parentUuid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._storageUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commentID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._parentUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._storageUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_CommentActivityNavigationInfoArchive, rhs: TSCK_CommentActivityNavigationInfoArchive) -> Bool {
    if lhs._commentID != rhs._commentID {return false}
    if lhs._parentUuid != rhs._parentUuid {return false}
    if lhs._storageUuid != rhs._storageUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityAuthorCacheArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivityAuthorCacheArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}share_participant_id_cache\0\u{4}\u{2}fallback_public_id_cache\0\u{3}index_cache\0\u{3}first_join_cache\0\u{1}authors\0\u{3}last_audit_date\0\u{3}author_identifiers_to_remove\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.shareParticipantIDCache) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.fallbackPublicIDCache) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.indexCache) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.firstJoinCache) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.authors) {return false}
    if let v = self._lastAuditDate, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.authorIdentifiersToRemove) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.shareParticipantIDCache) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.fallbackPublicIDCache) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.indexCache) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.firstJoinCache) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.authors) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._lastAuditDate) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.authorIdentifiersToRemove) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.shareParticipantIDCache.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shareParticipantIDCache, fieldNumber: 1)
    }
    if !self.fallbackPublicIDCache.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fallbackPublicIDCache, fieldNumber: 3)
    }
    if !self.indexCache.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.indexCache, fieldNumber: 4)
    }
    if !self.firstJoinCache.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.firstJoinCache, fieldNumber: 5)
    }
    if !self.authors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.authors, fieldNumber: 6)
    }
    try { if let v = self._lastAuditDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.authorIdentifiersToRemove.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.authorIdentifiersToRemove, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityAuthorCacheArchive, rhs: TSCK_ActivityAuthorCacheArchive) -> Bool {
    if lhs.shareParticipantIDCache != rhs.shareParticipantIDCache {return false}
    if lhs.fallbackPublicIDCache != rhs.fallbackPublicIDCache {return false}
    if lhs.indexCache != rhs.indexCache {return false}
    if lhs.firstJoinCache != rhs.firstJoinCache {return false}
    if lhs.authors != rhs.authors {return false}
    if lhs._lastAuditDate != rhs._lastAuditDate {return false}
    if lhs.authorIdentifiersToRemove != rhs.authorIdentifiersToRemove {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityAuthorCacheArchive.ShareParticipantIDCache: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCK_ActivityAuthorCacheArchive.protoMessageName + ".ShareParticipantIDCache"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identifier\0\u{3}share_participant_id\0")

  public var isInitialized: Bool {
    if self._identifier == nil {return false}
    if self._shareParticipantID == nil {return false}
    if let v = self._identifier, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._shareParticipantID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._shareParticipantID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityAuthorCacheArchive.ShareParticipantIDCache, rhs: TSCK_ActivityAuthorCacheArchive.ShareParticipantIDCache) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs._shareParticipantID != rhs._shareParticipantID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityAuthorCacheArchive.PublicIDCache: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCK_ActivityAuthorCacheArchive.protoMessageName + ".PublicIDCache"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identifier\0\u{3}public_identifier\0")

  public var isInitialized: Bool {
    if self._identifier == nil {return false}
    if self._publicIdentifier == nil {return false}
    if let v = self._identifier, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._publicIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._publicIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityAuthorCacheArchive.PublicIDCache, rhs: TSCK_ActivityAuthorCacheArchive.PublicIDCache) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs._publicIdentifier != rhs._publicIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityAuthorCacheArchive.IndexCache: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCK_ActivityAuthorCacheArchive.protoMessageName + ".IndexCache"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identifier\0\u{3}author_index\0")

  public var isInitialized: Bool {
    if self._identifier == nil {return false}
    if self._authorIndex == nil {return false}
    if let v = self._identifier, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._authorIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._authorIndex {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityAuthorCacheArchive.IndexCache, rhs: TSCK_ActivityAuthorCacheArchive.IndexCache) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs._authorIndex != rhs._authorIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityAuthorCacheArchive.FirstJoinCache: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCK_ActivityAuthorCacheArchive.protoMessageName + ".FirstJoinCache"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identifier\0\u{3}first_join_date\0")

  public var isInitialized: Bool {
    if self._identifier == nil {return false}
    if let v = self._identifier, !v.isInitialized {return false}
    if let v = self._firstJoinDate, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._firstJoinDate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._firstJoinDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityAuthorCacheArchive.FirstJoinCache, rhs: TSCK_ActivityAuthorCacheArchive.FirstJoinCache) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs._firstJoinDate != rhs._firstJoinDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityOnlyCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivityOnlyCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityOnlyCommandArchive, rhs: TSCK_ActivityOnlyCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityNotificationItemArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivityNotificationItemArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{3}unique_identifier\0\u{1}activities\0\u{3}first_timestamp\0")

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if self._uniqueIdentifier == nil {return false}
    if let v = self._uniqueIdentifier, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.activities) {return false}
    if let v = self._firstTimestamp, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._uniqueIdentifier) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.activities) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._firstTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._uniqueIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.activities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.activities, fieldNumber: 3)
    }
    try { if let v = self._firstTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityNotificationItemArchive, rhs: TSCK_ActivityNotificationItemArchive) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._uniqueIdentifier != rhs._uniqueIdentifier {return false}
    if lhs.activities != rhs.activities {return false}
    if lhs._firstTimestamp != rhs._firstTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityNotificationParticipantCacheArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivityNotificationParticipantCacheArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}notification_items\0\u{3}last_edit_notification_item_sent_date\0\u{3}sender_failed_to_enqueue_attempts\0\u{3}private_id\0\u{3}last_comment_notification_item_sent_date\0")

  public var isInitialized: Bool {
    if self._privateID == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.notificationItems) {return false}
    if let v = self._lastEditNotificationItemSentDate, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.senderFailedToEnqueueAttempts) {return false}
    if let v = self._lastCommentNotificationItemSentDate, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.notificationItems) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._lastEditNotificationItemSentDate) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.senderFailedToEnqueueAttempts) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._privateID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._lastCommentNotificationItemSentDate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.notificationItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notificationItems, fieldNumber: 1)
    }
    try { if let v = self._lastEditNotificationItemSentDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.senderFailedToEnqueueAttempts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.senderFailedToEnqueueAttempts, fieldNumber: 3)
    }
    try { if let v = self._privateID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._lastCommentNotificationItemSentDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityNotificationParticipantCacheArchive, rhs: TSCK_ActivityNotificationParticipantCacheArchive) -> Bool {
    if lhs.notificationItems != rhs.notificationItems {return false}
    if lhs._lastEditNotificationItemSentDate != rhs._lastEditNotificationItemSentDate {return false}
    if lhs.senderFailedToEnqueueAttempts != rhs.senderFailedToEnqueueAttempts {return false}
    if lhs._privateID != rhs._privateID {return false}
    if lhs._lastCommentNotificationItemSentDate != rhs._lastCommentNotificationItemSentDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityNotificationParticipantCacheArchive.UniqueIdentifierAndAttempts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCK_ActivityNotificationParticipantCacheArchive.protoMessageName + ".UniqueIdentifierAndAttempts"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}unique_identifier\0\u{1}attempts\0")

  public var isInitialized: Bool {
    if self._uniqueIdentifier == nil {return false}
    if self._attempts == nil {return false}
    if let v = self._uniqueIdentifier, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uniqueIdentifier) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._attempts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uniqueIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._attempts {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityNotificationParticipantCacheArchive.UniqueIdentifierAndAttempts, rhs: TSCK_ActivityNotificationParticipantCacheArchive.UniqueIdentifierAndAttempts) -> Bool {
    if lhs._uniqueIdentifier != rhs._uniqueIdentifier {return false}
    if lhs._attempts != rhs._attempts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityNotificationQueueArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivityNotificationQueueArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}unprocessed_notification_items\0\u{4}\u{2}pending_participant_caches\0\u{4}\u{2}sent_participant_caches\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.unprocessedNotificationItems) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.pendingParticipantCaches) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.sentParticipantCaches) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.unprocessedNotificationItems) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.pendingParticipantCaches) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.sentParticipantCaches) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.unprocessedNotificationItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.unprocessedNotificationItems, fieldNumber: 1)
    }
    if !self.pendingParticipantCaches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pendingParticipantCaches, fieldNumber: 3)
    }
    if !self.sentParticipantCaches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sentParticipantCaches, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityNotificationQueueArchive, rhs: TSCK_ActivityNotificationQueueArchive) -> Bool {
    if lhs.unprocessedNotificationItems != rhs.unprocessedNotificationItems {return false}
    if lhs.pendingParticipantCaches != rhs.pendingParticipantCaches {return false}
    if lhs.sentParticipantCaches != rhs.sentParticipantCaches {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityStreamTransformationStateArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivityStreamTransformationStateArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}next_activity_to_transform_index\0\u{3}oldest_revision_sequence_after_transformed\0\u{3}last_activity_coalesced_date\0\u{3}action_type\0\u{3}transform_to_document_revision_sequence\0\u{3}transform_to_document_revision_identifier\0\u{3}timestamp_of_last_activity_when_last_activity_coalescing\0\u{3}preserving_revision_sequence_order\0")

  public var isInitialized: Bool {
    if self._nextActivityToTransformIndex == nil {return false}
    if let v = self._lastActivityCoalescedDate, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._nextActivityToTransformIndex) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._oldestRevisionSequenceAfterTransformed) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lastActivityCoalescedDate) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._actionType) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._transformToDocumentRevisionSequence) }()
      case 6: try { try decoder.decodeRepeatedFixed64Field(value: &self.transformToDocumentRevisionIdentifier) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self._timestampOfLastActivityWhenLastActivityCoalescing) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._preservingRevisionSequenceOrder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nextActivityToTransformIndex {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oldestRevisionSequenceAfterTransformed {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lastActivityCoalescedDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._actionType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._transformToDocumentRevisionSequence {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    if !self.transformToDocumentRevisionIdentifier.isEmpty {
      try visitor.visitRepeatedFixed64Field(value: self.transformToDocumentRevisionIdentifier, fieldNumber: 6)
    }
    try { if let v = self._timestampOfLastActivityWhenLastActivityCoalescing {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._preservingRevisionSequenceOrder {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityStreamTransformationStateArchive, rhs: TSCK_ActivityStreamTransformationStateArchive) -> Bool {
    if lhs._nextActivityToTransformIndex != rhs._nextActivityToTransformIndex {return false}
    if lhs._oldestRevisionSequenceAfterTransformed != rhs._oldestRevisionSequenceAfterTransformed {return false}
    if lhs._lastActivityCoalescedDate != rhs._lastActivityCoalescedDate {return false}
    if lhs._actionType != rhs._actionType {return false}
    if lhs._transformToDocumentRevisionSequence != rhs._transformToDocumentRevisionSequence {return false}
    if lhs.transformToDocumentRevisionIdentifier != rhs.transformToDocumentRevisionIdentifier {return false}
    if lhs._timestampOfLastActivityWhenLastActivityCoalescing != rhs._timestampOfLastActivityWhenLastActivityCoalescing {return false}
    if lhs._preservingRevisionSequenceOrder != rhs._preservingRevisionSequenceOrder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityStreamTransformationStateArchive.ActionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Trasnform\0\u{1}Coalesce\0")
}

extension TSCK_ActivityStreamActivityCounterArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivityStreamActivityCounterArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}action_type_counter\0\u{3}cursor_type_counter\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.actionTypeCounter) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.cursorTypeCounter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actionTypeCounter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actionTypeCounter, fieldNumber: 1)
    }
    if !self.cursorTypeCounter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cursorTypeCounter, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityStreamActivityCounterArchive, rhs: TSCK_ActivityStreamActivityCounterArchive) -> Bool {
    if lhs.actionTypeCounter != rhs.actionTypeCounter {return false}
    if lhs.cursorTypeCounter != rhs.cursorTypeCounter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityStreamActivityCounterArchive.ActionTypeCounter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCK_ActivityStreamActivityCounterArchive.protoMessageName + ".ActionTypeCounter"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}action_type\0\u{1}count\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._actionType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._count {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityStreamActivityCounterArchive.ActionTypeCounter, rhs: TSCK_ActivityStreamActivityCounterArchive.ActionTypeCounter) -> Bool {
    if lhs._actionType != rhs._actionType {return false}
    if lhs._count != rhs._count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityStreamActivityCounterArchive.CursorTypeCounter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCK_ActivityStreamActivityCounterArchive.protoMessageName + ".CursorTypeCounter"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cursor_type\0\u{1}count\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._cursorType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cursorType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._count {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityStreamActivityCounterArchive.CursorTypeCounter, rhs: TSCK_ActivityStreamActivityCounterArchive.CursorTypeCounter) -> Bool {
    if lhs._cursorType != rhs._cursorType {return false}
    if lhs._count != rhs._count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityStreamRemovedAuthorAuditorPendingStateArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivityStreamRemovedAuthorAuditorPendingStateArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}current_author_identifiers\0\u{4}\u{2}dates_to_audit\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.currentAuthorIdentifiers) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.datesToAudit) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.currentAuthorIdentifiers) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.datesToAudit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currentAuthorIdentifiers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.currentAuthorIdentifiers, fieldNumber: 1)
    }
    if !self.datesToAudit.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.datesToAudit, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityStreamRemovedAuthorAuditorPendingStateArchive, rhs: TSCK_ActivityStreamRemovedAuthorAuditorPendingStateArchive) -> Bool {
    if lhs.currentAuthorIdentifiers != rhs.currentAuthorIdentifiers {return false}
    if lhs.datesToAudit != rhs.datesToAudit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSCK_ActivityStreamRemovedAuthorAuditorPendingStateArchive.DateToAuditAndType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSCK_ActivityStreamRemovedAuthorAuditorPendingStateArchive.protoMessageName + ".DateToAuditAndType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}date_to_audit\0\u{1}type\0")

  public var isInitialized: Bool {
    if self._dateToAudit == nil {return false}
    if self._type == nil {return false}
    if let v = self._dateToAudit, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._dateToAudit) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._dateToAudit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSCK_ActivityStreamRemovedAuthorAuditorPendingStateArchive.DateToAuditAndType, rhs: TSCK_ActivityStreamRemovedAuthorAuditorPendingStateArchive.DateToAuditAndType) -> Bool {
    if lhs._dateToAudit != rhs._dateToAudit {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
