// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TSAArchives.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum TSA_GalleryInfoCaptionMode: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case none = 0
  case perImage = 1
  case allImages = 2

  init() {
    self = .none
  }

}

enum TSA_GalleryInfoProperty: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case galleryInfoCaptionProperty = 0

  init() {
    self = .galleryInfoCaptionProperty
  }

}

enum TSA_GalleryCaptionMode: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case none = 0
  case perImage = 1
  case allImages = 2

  init() {
    self = .none
  }

}

enum TSA_GalleryItemProperty: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case imageData = 0
  case thumbnailImageData = 1
  case accessibilityDescription = 2

  init() {
    self = .imageData
  }

}

struct TSA_DocumentArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_DocumentArchive {
    get {return _storage._super ?? TSK_DocumentArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var textPresetDisplayItems: [TSWP_TextPresetDisplayItemArchive] {
    get {return _storage._textPresetDisplayItems}
    set {_uniqueStorage()._textPresetDisplayItems = newValue}
  }

  var documentLanguage: String {
    get {return _storage._documentLanguage ?? String()}
    set {_uniqueStorage()._documentLanguage = newValue}
  }
  /// Returns true if `documentLanguage` has been explicitly set.
  var hasDocumentLanguage: Bool {return _storage._documentLanguage != nil}
  /// Clears the value of `documentLanguage`. Subsequent reads from it will return its default value.
  mutating func clearDocumentLanguage() {_uniqueStorage()._documentLanguage = nil}

  var calculationEngine: TSP_Reference {
    get {return _storage._calculationEngine ?? TSP_Reference()}
    set {_uniqueStorage()._calculationEngine = newValue}
  }
  /// Returns true if `calculationEngine` has been explicitly set.
  var hasCalculationEngine: Bool {return _storage._calculationEngine != nil}
  /// Clears the value of `calculationEngine`. Subsequent reads from it will return its default value.
  mutating func clearCalculationEngine() {_uniqueStorage()._calculationEngine = nil}

  var viewState: TSP_Reference {
    get {return _storage._viewState ?? TSP_Reference()}
    set {_uniqueStorage()._viewState = newValue}
  }
  /// Returns true if `viewState` has been explicitly set.
  var hasViewState: Bool {return _storage._viewState != nil}
  /// Clears the value of `viewState`. Subsequent reads from it will return its default value.
  mutating func clearViewState() {_uniqueStorage()._viewState = nil}

  var functionBrowserState: TSP_Reference {
    get {return _storage._functionBrowserState ?? TSP_Reference()}
    set {_uniqueStorage()._functionBrowserState = newValue}
  }
  /// Returns true if `functionBrowserState` has been explicitly set.
  var hasFunctionBrowserState: Bool {return _storage._functionBrowserState != nil}
  /// Clears the value of `functionBrowserState`. Subsequent reads from it will return its default value.
  mutating func clearFunctionBrowserState() {_uniqueStorage()._functionBrowserState = nil}

  var tablesCustomFormatList: TSP_Reference {
    get {return _storage._tablesCustomFormatList ?? TSP_Reference()}
    set {_uniqueStorage()._tablesCustomFormatList = newValue}
  }
  /// Returns true if `tablesCustomFormatList` has been explicitly set.
  var hasTablesCustomFormatList: Bool {return _storage._tablesCustomFormatList != nil}
  /// Clears the value of `tablesCustomFormatList`. Subsequent reads from it will return its default value.
  mutating func clearTablesCustomFormatList() {_uniqueStorage()._tablesCustomFormatList = nil}

  var needsMediaCompatibilityUpgrade: Bool {
    get {return _storage._needsMediaCompatibilityUpgrade ?? false}
    set {_uniqueStorage()._needsMediaCompatibilityUpgrade = newValue}
  }
  /// Returns true if `needsMediaCompatibilityUpgrade` has been explicitly set.
  var hasNeedsMediaCompatibilityUpgrade: Bool {return _storage._needsMediaCompatibilityUpgrade != nil}
  /// Clears the value of `needsMediaCompatibilityUpgrade`. Subsequent reads from it will return its default value.
  mutating func clearNeedsMediaCompatibilityUpgrade() {_uniqueStorage()._needsMediaCompatibilityUpgrade = nil}

  var templateIdentifier: String {
    get {return _storage._templateIdentifier ?? String()}
    set {_uniqueStorage()._templateIdentifier = newValue}
  }
  /// Returns true if `templateIdentifier` has been explicitly set.
  var hasTemplateIdentifier: Bool {return _storage._templateIdentifier != nil}
  /// Clears the value of `templateIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearTemplateIdentifier() {_uniqueStorage()._templateIdentifier = nil}

  var shortcutController: TSP_Reference {
    get {return _storage._shortcutController ?? TSP_Reference()}
    set {_uniqueStorage()._shortcutController = newValue}
  }
  /// Returns true if `shortcutController` has been explicitly set.
  var hasShortcutController: Bool {return _storage._shortcutController != nil}
  /// Clears the value of `shortcutController`. Subsequent reads from it will return its default value.
  mutating func clearShortcutController() {_uniqueStorage()._shortcutController = nil}

  var annotationCacheDeprecated: TSP_Reference {
    get {return _storage._annotationCacheDeprecated ?? TSP_Reference()}
    set {_uniqueStorage()._annotationCacheDeprecated = newValue}
  }
  /// Returns true if `annotationCacheDeprecated` has been explicitly set.
  var hasAnnotationCacheDeprecated: Bool {return _storage._annotationCacheDeprecated != nil}
  /// Clears the value of `annotationCacheDeprecated`. Subsequent reads from it will return its default value.
  mutating func clearAnnotationCacheDeprecated() {_uniqueStorage()._annotationCacheDeprecated = nil}

  var customFormatList: TSP_Reference {
    get {return _storage._customFormatList ?? TSP_Reference()}
    set {_uniqueStorage()._customFormatList = newValue}
  }
  /// Returns true if `customFormatList` has been explicitly set.
  var hasCustomFormatList: Bool {return _storage._customFormatList != nil}
  /// Clears the value of `customFormatList`. Subsequent reads from it will return its default value.
  mutating func clearCustomFormatList() {_uniqueStorage()._customFormatList = nil}

  var annotationCacheDeprecated2: TSP_Reference {
    get {return _storage._annotationCacheDeprecated2 ?? TSP_Reference()}
    set {_uniqueStorage()._annotationCacheDeprecated2 = newValue}
  }
  /// Returns true if `annotationCacheDeprecated2` has been explicitly set.
  var hasAnnotationCacheDeprecated2: Bool {return _storage._annotationCacheDeprecated2 != nil}
  /// Clears the value of `annotationCacheDeprecated2`. Subsequent reads from it will return its default value.
  mutating func clearAnnotationCacheDeprecated2() {_uniqueStorage()._annotationCacheDeprecated2 = nil}

  var collaborativeMediaCompatibilityUpgradeDidFail: Bool {
    get {return _storage._collaborativeMediaCompatibilityUpgradeDidFail ?? false}
    set {_uniqueStorage()._collaborativeMediaCompatibilityUpgradeDidFail = newValue}
  }
  /// Returns true if `collaborativeMediaCompatibilityUpgradeDidFail` has been explicitly set.
  var hasCollaborativeMediaCompatibilityUpgradeDidFail: Bool {return _storage._collaborativeMediaCompatibilityUpgradeDidFail != nil}
  /// Clears the value of `collaborativeMediaCompatibilityUpgradeDidFail`. Subsequent reads from it will return its default value.
  mutating func clearCollaborativeMediaCompatibilityUpgradeDidFail() {_uniqueStorage()._collaborativeMediaCompatibilityUpgradeDidFail = nil}

  var canUseHevc: Bool {
    get {return _storage._canUseHevc ?? false}
    set {_uniqueStorage()._canUseHevc = newValue}
  }
  /// Returns true if `canUseHevc` has been explicitly set.
  var hasCanUseHevc: Bool {return _storage._canUseHevc != nil}
  /// Clears the value of `canUseHevc`. Subsequent reads from it will return its default value.
  mutating func clearCanUseHevc() {_uniqueStorage()._canUseHevc = nil}

  var isContentSource: Bool {
    get {return _storage._isContentSource ?? false}
    set {_uniqueStorage()._isContentSource = newValue}
  }
  /// Returns true if `isContentSource` has been explicitly set.
  var hasIsContentSource: Bool {return _storage._isContentSource != nil}
  /// Clears the value of `isContentSource`. Subsequent reads from it will return its default value.
  mutating func clearIsContentSource() {_uniqueStorage()._isContentSource = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSA_FunctionBrowserStateArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var recentFunctions: [UInt32] = []

  var backFunctions: [UInt32] = []

  var forwardFunctions: [UInt32] = []

  var currentFunction: UInt32 {
    get {return _currentFunction ?? 0}
    set {_currentFunction = newValue}
  }
  /// Returns true if `currentFunction` has been explicitly set.
  var hasCurrentFunction: Bool {return self._currentFunction != nil}
  /// Clears the value of `currentFunction`. Subsequent reads from it will return its default value.
  mutating func clearCurrentFunction() {self._currentFunction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _currentFunction: UInt32? = nil
}

struct TSA_ThemePresetsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var captionStylePresets: [TSP_Reference] = []

  var svgImportStylePresets: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSA_ShortcutControllerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [TSA_ShortcutControllerArchive.ShortcutMapEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ShortcutMapEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var shortcut: String {
      get {return _shortcut ?? String()}
      set {_shortcut = newValue}
    }
    /// Returns true if `shortcut` has been explicitly set.
    var hasShortcut: Bool {return self._shortcut != nil}
    /// Clears the value of `shortcut`. Subsequent reads from it will return its default value.
    mutating func clearShortcut() {self._shortcut = nil}

    var style: TSP_Reference {
      get {return _style ?? TSP_Reference()}
      set {_style = newValue}
    }
    /// Returns true if `style` has been explicitly set.
    var hasStyle: Bool {return self._style != nil}
    /// Clears the value of `style`. Subsequent reads from it will return its default value.
    mutating func clearStyle() {self._style = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _shortcut: String? = nil
    fileprivate var _style: TSP_Reference? = nil
  }

  init() {}
}

struct TSA_PropagatePresetCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var presetChangeCommand: TSP_Reference {
    get {return _presetChangeCommand ?? TSP_Reference()}
    set {_presetChangeCommand = newValue}
  }
  /// Returns true if `presetChangeCommand` has been explicitly set.
  var hasPresetChangeCommand: Bool {return self._presetChangeCommand != nil}
  /// Clears the value of `presetChangeCommand`. Subsequent reads from it will return its default value.
  mutating func clearPresetChangeCommand() {self._presetChangeCommand = nil}

  var alwaysPreserveAppearance: Bool {
    get {return _alwaysPreserveAppearance ?? false}
    set {_alwaysPreserveAppearance = newValue}
  }
  /// Returns true if `alwaysPreserveAppearance` has been explicitly set.
  var hasAlwaysPreserveAppearance: Bool {return self._alwaysPreserveAppearance != nil}
  /// Clears the value of `alwaysPreserveAppearance`. Subsequent reads from it will return its default value.
  mutating func clearAlwaysPreserveAppearance() {self._alwaysPreserveAppearance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _presetChangeCommand: TSP_Reference? = nil
  fileprivate var _alwaysPreserveAppearance: Bool? = nil
}

struct TSA_ShortcutCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var oldStyle: TSP_Reference {
    get {return _storage._oldStyle ?? TSP_Reference()}
    set {_uniqueStorage()._oldStyle = newValue}
  }
  /// Returns true if `oldStyle` has been explicitly set.
  var hasOldStyle: Bool {return _storage._oldStyle != nil}
  /// Clears the value of `oldStyle`. Subsequent reads from it will return its default value.
  mutating func clearOldStyle() {_uniqueStorage()._oldStyle = nil}

  var newStyle: TSP_Reference {
    get {return _storage._newStyle ?? TSP_Reference()}
    set {_uniqueStorage()._newStyle = newValue}
  }
  /// Returns true if `newStyle` has been explicitly set.
  var hasNewStyle: Bool {return _storage._newStyle != nil}
  /// Clears the value of `newStyle`. Subsequent reads from it will return its default value.
  mutating func clearNewStyle() {_uniqueStorage()._newStyle = nil}

  var oldShortcut: String {
    get {return _storage._oldShortcut ?? String()}
    set {_uniqueStorage()._oldShortcut = newValue}
  }
  /// Returns true if `oldShortcut` has been explicitly set.
  var hasOldShortcut: Bool {return _storage._oldShortcut != nil}
  /// Clears the value of `oldShortcut`. Subsequent reads from it will return its default value.
  mutating func clearOldShortcut() {_uniqueStorage()._oldShortcut = nil}

  var newShortcut: String {
    get {return _storage._newShortcut ?? String()}
    set {_uniqueStorage()._newShortcut = newValue}
  }
  /// Returns true if `newShortcut` has been explicitly set.
  var hasNewShortcut: Bool {return _storage._newShortcut != nil}
  /// Clears the value of `newShortcut`. Subsequent reads from it will return its default value.
  mutating func clearNewShortcut() {_uniqueStorage()._newShortcut = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSA_AddCustomFormatCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var customFormat: TSK_CustomFormatArchive {
    get {return _customFormat ?? TSK_CustomFormatArchive()}
    set {_customFormat = newValue}
  }
  /// Returns true if `customFormat` has been explicitly set.
  var hasCustomFormat: Bool {return self._customFormat != nil}
  /// Clears the value of `customFormat`. Subsequent reads from it will return its default value.
  mutating func clearCustomFormat() {self._customFormat = nil}

  var customFormatKey: TSP_UUID {
    get {return _customFormatKey ?? TSP_UUID()}
    set {_customFormatKey = newValue}
  }
  /// Returns true if `customFormatKey` has been explicitly set.
  var hasCustomFormatKey: Bool {return self._customFormatKey != nil}
  /// Clears the value of `customFormatKey`. Subsequent reads from it will return its default value.
  mutating func clearCustomFormatKey() {self._customFormatKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _customFormat: TSK_CustomFormatArchive? = nil
  fileprivate var _customFormatKey: TSP_UUID? = nil
}

struct TSA_UpdateCustomFormatCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var customFormat: TSK_CustomFormatArchive {
    get {return _customFormat ?? TSK_CustomFormatArchive()}
    set {_customFormat = newValue}
  }
  /// Returns true if `customFormat` has been explicitly set.
  var hasCustomFormat: Bool {return self._customFormat != nil}
  /// Clears the value of `customFormat`. Subsequent reads from it will return its default value.
  mutating func clearCustomFormat() {self._customFormat = nil}

  var oldCustomFormat: TSK_CustomFormatArchive {
    get {return _oldCustomFormat ?? TSK_CustomFormatArchive()}
    set {_oldCustomFormat = newValue}
  }
  /// Returns true if `oldCustomFormat` has been explicitly set.
  var hasOldCustomFormat: Bool {return self._oldCustomFormat != nil}
  /// Clears the value of `oldCustomFormat`. Subsequent reads from it will return its default value.
  mutating func clearOldCustomFormat() {self._oldCustomFormat = nil}

  var customFormatKey: TSP_UUID {
    get {return _customFormatKey ?? TSP_UUID()}
    set {_customFormatKey = newValue}
  }
  /// Returns true if `customFormatKey` has been explicitly set.
  var hasCustomFormatKey: Bool {return self._customFormatKey != nil}
  /// Clears the value of `customFormatKey`. Subsequent reads from it will return its default value.
  mutating func clearCustomFormatKey() {self._customFormatKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _customFormat: TSK_CustomFormatArchive? = nil
  fileprivate var _oldCustomFormat: TSK_CustomFormatArchive? = nil
  fileprivate var _customFormatKey: TSP_UUID? = nil
}

struct TSA_ReplaceCustomFormatCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var customFormat: TSK_CustomFormatArchive {
    get {return _customFormat ?? TSK_CustomFormatArchive()}
    set {_customFormat = newValue}
  }
  /// Returns true if `customFormat` has been explicitly set.
  var hasCustomFormat: Bool {return self._customFormat != nil}
  /// Clears the value of `customFormat`. Subsequent reads from it will return its default value.
  mutating func clearCustomFormat() {self._customFormat = nil}

  var customFormatKey: TSP_UUID {
    get {return _customFormatKey ?? TSP_UUID()}
    set {_customFormatKey = newValue}
  }
  /// Returns true if `customFormatKey` has been explicitly set.
  var hasCustomFormatKey: Bool {return self._customFormatKey != nil}
  /// Clears the value of `customFormatKey`. Subsequent reads from it will return its default value.
  mutating func clearCustomFormatKey() {self._customFormatKey = nil}

  var replacementFormat: TSK_FormatStructArchive {
    get {return _replacementFormat ?? TSK_FormatStructArchive()}
    set {_replacementFormat = newValue}
  }
  /// Returns true if `replacementFormat` has been explicitly set.
  var hasReplacementFormat: Bool {return self._replacementFormat != nil}
  /// Clears the value of `replacementFormat`. Subsequent reads from it will return its default value.
  mutating func clearReplacementFormat() {self._replacementFormat = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _customFormat: TSK_CustomFormatArchive? = nil
  fileprivate var _customFormatKey: TSP_UUID? = nil
  fileprivate var _replacementFormat: TSK_FormatStructArchive? = nil
}

struct TSA_NeedsMediaCompatibilityUpgradeCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var needsMediaCompatibilityUpgrade: Bool {
    get {return _storage._needsMediaCompatibilityUpgrade ?? false}
    set {_uniqueStorage()._needsMediaCompatibilityUpgrade = newValue}
  }
  /// Returns true if `needsMediaCompatibilityUpgrade` has been explicitly set.
  var hasNeedsMediaCompatibilityUpgrade: Bool {return _storage._needsMediaCompatibilityUpgrade != nil}
  /// Clears the value of `needsMediaCompatibilityUpgrade`. Subsequent reads from it will return its default value.
  mutating func clearNeedsMediaCompatibilityUpgrade() {_uniqueStorage()._needsMediaCompatibilityUpgrade = nil}

  var oldNeedsMediaCompatibilityUpgrade: Bool {
    get {return _storage._oldNeedsMediaCompatibilityUpgrade ?? false}
    set {_uniqueStorage()._oldNeedsMediaCompatibilityUpgrade = newValue}
  }
  /// Returns true if `oldNeedsMediaCompatibilityUpgrade` has been explicitly set.
  var hasOldNeedsMediaCompatibilityUpgrade: Bool {return _storage._oldNeedsMediaCompatibilityUpgrade != nil}
  /// Clears the value of `oldNeedsMediaCompatibilityUpgrade`. Subsequent reads from it will return its default value.
  mutating func clearOldNeedsMediaCompatibilityUpgrade() {_uniqueStorage()._oldNeedsMediaCompatibilityUpgrade = nil}

  var collaborativeMediaCompatibilityUpgradeDidFail: Bool {
    get {return _storage._collaborativeMediaCompatibilityUpgradeDidFail ?? false}
    set {_uniqueStorage()._collaborativeMediaCompatibilityUpgradeDidFail = newValue}
  }
  /// Returns true if `collaborativeMediaCompatibilityUpgradeDidFail` has been explicitly set.
  var hasCollaborativeMediaCompatibilityUpgradeDidFail: Bool {return _storage._collaborativeMediaCompatibilityUpgradeDidFail != nil}
  /// Clears the value of `collaborativeMediaCompatibilityUpgradeDidFail`. Subsequent reads from it will return its default value.
  mutating func clearCollaborativeMediaCompatibilityUpgradeDidFail() {_uniqueStorage()._collaborativeMediaCompatibilityUpgradeDidFail = nil}

  var oldCollaborativeMediaCompatibilityUpgradeDidFail: Bool {
    get {return _storage._oldCollaborativeMediaCompatibilityUpgradeDidFail ?? false}
    set {_uniqueStorage()._oldCollaborativeMediaCompatibilityUpgradeDidFail = newValue}
  }
  /// Returns true if `oldCollaborativeMediaCompatibilityUpgradeDidFail` has been explicitly set.
  var hasOldCollaborativeMediaCompatibilityUpgradeDidFail: Bool {return _storage._oldCollaborativeMediaCompatibilityUpgradeDidFail != nil}
  /// Clears the value of `oldCollaborativeMediaCompatibilityUpgradeDidFail`. Subsequent reads from it will return its default value.
  mutating func clearOldCollaborativeMediaCompatibilityUpgradeDidFail() {_uniqueStorage()._oldCollaborativeMediaCompatibilityUpgradeDidFail = nil}

  var canUseHevc: Bool {
    get {return _storage._canUseHevc ?? false}
    set {_uniqueStorage()._canUseHevc = newValue}
  }
  /// Returns true if `canUseHevc` has been explicitly set.
  var hasCanUseHevc: Bool {return _storage._canUseHevc != nil}
  /// Clears the value of `canUseHevc`. Subsequent reads from it will return its default value.
  mutating func clearCanUseHevc() {_uniqueStorage()._canUseHevc = nil}

  var oldCanUseHevc: Bool {
    get {return _storage._oldCanUseHevc ?? false}
    set {_uniqueStorage()._oldCanUseHevc = newValue}
  }
  /// Returns true if `oldCanUseHevc` has been explicitly set.
  var hasOldCanUseHevc: Bool {return _storage._oldCanUseHevc != nil}
  /// Clears the value of `oldCanUseHevc`. Subsequent reads from it will return its default value.
  mutating func clearOldCanUseHevc() {_uniqueStorage()._oldCanUseHevc = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSA_ChangeDocumentLocaleCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var oldLocaleID: String {
    get {return _oldLocaleID ?? String()}
    set {_oldLocaleID = newValue}
  }
  /// Returns true if `oldLocaleID` has been explicitly set.
  var hasOldLocaleID: Bool {return self._oldLocaleID != nil}
  /// Clears the value of `oldLocaleID`. Subsequent reads from it will return its default value.
  mutating func clearOldLocaleID() {self._oldLocaleID = nil}

  var newLocaleID: String {
    get {return _newLocaleID ?? String()}
    set {_newLocaleID = newValue}
  }
  /// Returns true if `newLocaleID` has been explicitly set.
  var hasNewLocaleID: Bool {return self._newLocaleID != nil}
  /// Clears the value of `newLocaleID`. Subsequent reads from it will return its default value.
  mutating func clearNewLocaleID() {self._newLocaleID = nil}

  var oldFormattingSymbols: TSK_FormattingSymbolsArchive {
    get {return _oldFormattingSymbols ?? TSK_FormattingSymbolsArchive()}
    set {_oldFormattingSymbols = newValue}
  }
  /// Returns true if `oldFormattingSymbols` has been explicitly set.
  var hasOldFormattingSymbols: Bool {return self._oldFormattingSymbols != nil}
  /// Clears the value of `oldFormattingSymbols`. Subsequent reads from it will return its default value.
  mutating func clearOldFormattingSymbols() {self._oldFormattingSymbols = nil}

  var newFormattingSymbols: TSK_FormattingSymbolsArchive {
    get {return _newFormattingSymbols ?? TSK_FormattingSymbolsArchive()}
    set {_newFormattingSymbols = newValue}
  }
  /// Returns true if `newFormattingSymbols` has been explicitly set.
  var hasNewFormattingSymbols: Bool {return self._newFormattingSymbols != nil}
  /// Clears the value of `newFormattingSymbols`. Subsequent reads from it will return its default value.
  mutating func clearNewFormattingSymbols() {self._newFormattingSymbols = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _oldLocaleID: String? = nil
  fileprivate var _newLocaleID: String? = nil
  fileprivate var _oldFormattingSymbols: TSK_FormattingSymbolsArchive? = nil
  fileprivate var _newFormattingSymbols: TSK_FormattingSymbolsArchive? = nil
}

struct TSA_InducedVerifyObjectsWithServerCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var objectIDList: [TSP_UUID] {
    get {return _storage._objectIDList}
    set {_uniqueStorage()._objectIDList = newValue}
  }

  var objectIDListUndefined: Bool {
    get {return _storage._objectIDListUndefined ?? false}
    set {_uniqueStorage()._objectIDListUndefined = newValue}
  }
  /// Returns true if `objectIDListUndefined` has been explicitly set.
  var hasObjectIDListUndefined: Bool {return _storage._objectIDListUndefined != nil}
  /// Clears the value of `objectIDListUndefined`. Subsequent reads from it will return its default value.
  mutating func clearObjectIDListUndefined() {_uniqueStorage()._objectIDListUndefined = nil}

  var serverObjectSOSStringList: [String] {
    get {return _storage._serverObjectSOSStringList}
    set {_uniqueStorage()._serverObjectSOSStringList = newValue}
  }

  var serverObjectSOSStringListUndefined: Bool {
    get {return _storage._serverObjectSOSStringListUndefined ?? false}
    set {_uniqueStorage()._serverObjectSOSStringListUndefined = newValue}
  }
  /// Returns true if `serverObjectSOSStringListUndefined` has been explicitly set.
  var hasServerObjectSOSStringListUndefined: Bool {return _storage._serverObjectSOSStringListUndefined != nil}
  /// Clears the value of `serverObjectSOSStringListUndefined`. Subsequent reads from it will return its default value.
  mutating func clearServerObjectSOSStringListUndefined() {_uniqueStorage()._serverObjectSOSStringListUndefined = nil}

  var pendingRecalc: Bool {
    get {return _storage._pendingRecalc ?? false}
    set {_uniqueStorage()._pendingRecalc = newValue}
  }
  /// Returns true if `pendingRecalc` has been explicitly set.
  var hasPendingRecalc: Bool {return _storage._pendingRecalc != nil}
  /// Clears the value of `pendingRecalc`. Subsequent reads from it will return its default value.
  mutating func clearPendingRecalc() {_uniqueStorage()._pendingRecalc = nil}

  var remoteDataSyncKey: Double {
    get {return _storage._remoteDataSyncKey ?? 0}
    set {_uniqueStorage()._remoteDataSyncKey = newValue}
  }
  /// Returns true if `remoteDataSyncKey` has been explicitly set.
  var hasRemoteDataSyncKey: Bool {return _storage._remoteDataSyncKey != nil}
  /// Clears the value of `remoteDataSyncKey`. Subsequent reads from it will return its default value.
  mutating func clearRemoteDataSyncKey() {_uniqueStorage()._remoteDataSyncKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSA_InducedVerifyTransformHistoryWithServerCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var serverOperationStorageEntries: [TSK_OperationStorageEntry] = []

  var serverOperationStorageEntriesUndefined: Bool {
    get {return _serverOperationStorageEntriesUndefined ?? false}
    set {_serverOperationStorageEntriesUndefined = newValue}
  }
  /// Returns true if `serverOperationStorageEntriesUndefined` has been explicitly set.
  var hasServerOperationStorageEntriesUndefined: Bool {return self._serverOperationStorageEntriesUndefined != nil}
  /// Clears the value of `serverOperationStorageEntriesUndefined`. Subsequent reads from it will return its default value.
  mutating func clearServerOperationStorageEntriesUndefined() {self._serverOperationStorageEntriesUndefined = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _serverOperationStorageEntriesUndefined: Bool? = nil
}

struct TSA_StyleUpdatePropertyMapCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_StyleUpdatePropertyMapCommandArchive {
    get {return _super ?? TSWP_StyleUpdatePropertyMapCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_StyleUpdatePropertyMapCommandArchive? = nil
}

struct TSA_RemoteDataChangeCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var valueMap: TSCE_RemoteDataValueMapArchive {
    get {return _valueMap ?? TSCE_RemoteDataValueMapArchive()}
    set {_valueMap = newValue}
  }
  /// Returns true if `valueMap` has been explicitly set.
  var hasValueMap: Bool {return self._valueMap != nil}
  /// Clears the value of `valueMap`. Subsequent reads from it will return its default value.
  mutating func clearValueMap() {self._valueMap = nil}

  var quotes: [TSCE_StockArchive] = []

  var remoteDataSyncKey: Double {
    get {return _remoteDataSyncKey ?? 0}
    set {_remoteDataSyncKey = newValue}
  }
  /// Returns true if `remoteDataSyncKey` has been explicitly set.
  var hasRemoteDataSyncKey: Bool {return self._remoteDataSyncKey != nil}
  /// Clears the value of `remoteDataSyncKey`. Subsequent reads from it will return its default value.
  mutating func clearRemoteDataSyncKey() {self._remoteDataSyncKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _valueMap: TSCE_RemoteDataValueMapArchive? = nil
  fileprivate var _remoteDataSyncKey: Double? = nil
}

struct TSA_GalleryInfoSetValueCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _super ?? TSK_CommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var infoIDPath: TSP_UUIDPath {
    get {return _infoIDPath ?? TSP_UUIDPath()}
    set {_infoIDPath = newValue}
  }
  /// Returns true if `infoIDPath` has been explicitly set.
  var hasInfoIDPath: Bool {return self._infoIDPath != nil}
  /// Clears the value of `infoIDPath`. Subsequent reads from it will return its default value.
  mutating func clearInfoIDPath() {self._infoIDPath = nil}

  var property: TSA_GalleryInfoProperty {
    get {return _property ?? .galleryInfoCaptionProperty}
    set {_property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return self._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {self._property = nil}

  var value: TSA_GalleryInfoSetValueCommandArchive.PropertyValue {
    get {return _value ?? TSA_GalleryInfoSetValueCommandArchive.PropertyValue()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var oldValue: TSA_GalleryInfoSetValueCommandArchive.PropertyValue {
    get {return _oldValue ?? TSA_GalleryInfoSetValueCommandArchive.PropertyValue()}
    set {_oldValue = newValue}
  }
  /// Returns true if `oldValue` has been explicitly set.
  var hasOldValue: Bool {return self._oldValue != nil}
  /// Clears the value of `oldValue`. Subsequent reads from it will return its default value.
  mutating func clearOldValue() {self._oldValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PropertyValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var captionMode: TSA_GalleryInfoCaptionMode {
      get {return _captionMode ?? .none}
      set {_captionMode = newValue}
    }
    /// Returns true if `captionMode` has been explicitly set.
    var hasCaptionMode: Bool {return self._captionMode != nil}
    /// Clears the value of `captionMode`. Subsequent reads from it will return its default value.
    mutating func clearCaptionMode() {self._captionMode = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _captionMode: TSA_GalleryInfoCaptionMode? = nil
  }

  init() {}

  fileprivate var _super: TSK_CommandArchive? = nil
  fileprivate var _infoIDPath: TSP_UUIDPath? = nil
  fileprivate var _property: TSA_GalleryInfoProperty? = nil
  fileprivate var _value: TSA_GalleryInfoSetValueCommandArchive.PropertyValue? = nil
  fileprivate var _oldValue: TSA_GalleryInfoSetValueCommandArchive.PropertyValue? = nil
}

struct TSA_GalleryInfoInsertItemsCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_ContainerInsertChildrenCommandArchive {
    get {return _super ?? TSD_ContainerInsertChildrenCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var items: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_ContainerInsertChildrenCommandArchive? = nil
}

struct TSA_GalleryInfoRemoveItemsCommandArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_ContainerRemoveChildrenCommandArchive {
    get {return _super ?? TSD_ContainerRemoveChildrenCommandArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_ContainerRemoveChildrenCommandArchive? = nil
}

struct TSA_GalleryItemSetGeometryCommand: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var itemIDPath: TSP_UUIDPath {
    get {return _storage._itemIDPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._itemIDPath = newValue}
  }
  /// Returns true if `itemIDPath` has been explicitly set.
  var hasItemIDPath: Bool {return _storage._itemIDPath != nil}
  /// Clears the value of `itemIDPath`. Subsequent reads from it will return its default value.
  mutating func clearItemIDPath() {_uniqueStorage()._itemIDPath = nil}

  var offset: TSP_Point {
    get {return _storage._offset ?? TSP_Point()}
    set {_uniqueStorage()._offset = newValue}
  }
  /// Returns true if `offset` has been explicitly set.
  var hasOffset: Bool {return _storage._offset != nil}
  /// Clears the value of `offset`. Subsequent reads from it will return its default value.
  mutating func clearOffset() {_uniqueStorage()._offset = nil}

  var scale: Float {
    get {return _storage._scale ?? 1}
    set {_uniqueStorage()._scale = newValue}
  }
  /// Returns true if `scale` has been explicitly set.
  var hasScale: Bool {return _storage._scale != nil}
  /// Clears the value of `scale`. Subsequent reads from it will return its default value.
  mutating func clearScale() {_uniqueStorage()._scale = nil}

  var oldOffset: TSP_Point {
    get {return _storage._oldOffset ?? TSP_Point()}
    set {_uniqueStorage()._oldOffset = newValue}
  }
  /// Returns true if `oldOffset` has been explicitly set.
  var hasOldOffset: Bool {return _storage._oldOffset != nil}
  /// Clears the value of `oldOffset`. Subsequent reads from it will return its default value.
  mutating func clearOldOffset() {_uniqueStorage()._oldOffset = nil}

  var oldScale: Float {
    get {return _storage._oldScale ?? 0}
    set {_uniqueStorage()._oldScale = newValue}
  }
  /// Returns true if `oldScale` has been explicitly set.
  var hasOldScale: Bool {return _storage._oldScale != nil}
  /// Clears the value of `oldScale`. Subsequent reads from it will return its default value.
  mutating func clearOldScale() {_uniqueStorage()._oldScale = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSA_GalleryItem: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offset: TSP_Point {
    get {return _storage._offset ?? TSP_Point()}
    set {_uniqueStorage()._offset = newValue}
  }
  /// Returns true if `offset` has been explicitly set.
  var hasOffset: Bool {return _storage._offset != nil}
  /// Clears the value of `offset`. Subsequent reads from it will return its default value.
  mutating func clearOffset() {_uniqueStorage()._offset = nil}

  var scale: Float {
    get {return _storage._scale ?? 0}
    set {_uniqueStorage()._scale = newValue}
  }
  /// Returns true if `scale` has been explicitly set.
  var hasScale: Bool {return _storage._scale != nil}
  /// Clears the value of `scale`. Subsequent reads from it will return its default value.
  mutating func clearScale() {_uniqueStorage()._scale = nil}

  var imageData: TSP_DataReference {
    get {return _storage._imageData ?? TSP_DataReference()}
    set {_uniqueStorage()._imageData = newValue}
  }
  /// Returns true if `imageData` has been explicitly set.
  var hasImageData: Bool {return _storage._imageData != nil}
  /// Clears the value of `imageData`. Subsequent reads from it will return its default value.
  mutating func clearImageData() {_uniqueStorage()._imageData = nil}

  var thumbnailImageData: TSP_DataReference {
    get {return _storage._thumbnailImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._thumbnailImageData = newValue}
  }
  /// Returns true if `thumbnailImageData` has been explicitly set.
  var hasThumbnailImageData: Bool {return _storage._thumbnailImageData != nil}
  /// Clears the value of `thumbnailImageData`. Subsequent reads from it will return its default value.
  mutating func clearThumbnailImageData() {_uniqueStorage()._thumbnailImageData = nil}

  var imageAdjustments: TSD_ImageAdjustmentsArchive {
    get {return _storage._imageAdjustments ?? TSD_ImageAdjustmentsArchive()}
    set {_uniqueStorage()._imageAdjustments = newValue}
  }
  /// Returns true if `imageAdjustments` has been explicitly set.
  var hasImageAdjustments: Bool {return _storage._imageAdjustments != nil}
  /// Clears the value of `imageAdjustments`. Subsequent reads from it will return its default value.
  mutating func clearImageAdjustments() {_uniqueStorage()._imageAdjustments = nil}

  var adjustedImageData: TSP_DataReference {
    get {return _storage._adjustedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._adjustedImageData = newValue}
  }
  /// Returns true if `adjustedImageData` has been explicitly set.
  var hasAdjustedImageData: Bool {return _storage._adjustedImageData != nil}
  /// Clears the value of `adjustedImageData`. Subsequent reads from it will return its default value.
  mutating func clearAdjustedImageData() {_uniqueStorage()._adjustedImageData = nil}

  var thumbnailAdjustedImageData: TSP_DataReference {
    get {return _storage._thumbnailAdjustedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._thumbnailAdjustedImageData = newValue}
  }
  /// Returns true if `thumbnailAdjustedImageData` has been explicitly set.
  var hasThumbnailAdjustedImageData: Bool {return _storage._thumbnailAdjustedImageData != nil}
  /// Clears the value of `thumbnailAdjustedImageData`. Subsequent reads from it will return its default value.
  mutating func clearThumbnailAdjustedImageData() {_uniqueStorage()._thumbnailAdjustedImageData = nil}

  var captionStorage: TSP_Reference {
    get {return _storage._captionStorage ?? TSP_Reference()}
    set {_uniqueStorage()._captionStorage = newValue}
  }
  /// Returns true if `captionStorage` has been explicitly set.
  var hasCaptionStorage: Bool {return _storage._captionStorage != nil}
  /// Clears the value of `captionStorage`. Subsequent reads from it will return its default value.
  mutating func clearCaptionStorage() {_uniqueStorage()._captionStorage = nil}

  var accessibilityDescription: String {
    get {return _storage._accessibilityDescription ?? String()}
    set {_uniqueStorage()._accessibilityDescription = newValue}
  }
  /// Returns true if `accessibilityDescription` has been explicitly set.
  var hasAccessibilityDescription: Bool {return _storage._accessibilityDescription != nil}
  /// Clears the value of `accessibilityDescription`. Subsequent reads from it will return its default value.
  mutating func clearAccessibilityDescription() {_uniqueStorage()._accessibilityDescription = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSA_GalleryInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var items: [TSP_Reference] = []

  var captionMode: TSA_GalleryCaptionMode {
    get {return _captionMode ?? .none}
    set {_captionMode = newValue}
  }
  /// Returns true if `captionMode` has been explicitly set.
  var hasCaptionMode: Bool {return self._captionMode != nil}
  /// Clears the value of `captionMode`. Subsequent reads from it will return its default value.
  mutating func clearCaptionMode() {self._captionMode = nil}

  var captionStorage: TSP_Reference {
    get {return _captionStorage ?? TSP_Reference()}
    set {_captionStorage = newValue}
  }
  /// Returns true if `captionStorage` has been explicitly set.
  var hasCaptionStorage: Bool {return self._captionStorage != nil}
  /// Clears the value of `captionStorage`. Subsequent reads from it will return its default value.
  mutating func clearCaptionStorage() {self._captionStorage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _captionMode: TSA_GalleryCaptionMode? = nil
  fileprivate var _captionStorage: TSP_Reference? = nil
}

struct TSA_GallerySelectionTransformer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_DrawableSelectionTransformerArchive {
    get {return _super ?? TSD_DrawableSelectionTransformerArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var galleryUuidPath: TSP_UUIDPath {
    get {return _galleryUuidPath ?? TSP_UUIDPath()}
    set {_galleryUuidPath = newValue}
  }
  /// Returns true if `galleryUuidPath` has been explicitly set.
  var hasGalleryUuidPath: Bool {return self._galleryUuidPath != nil}
  /// Clears the value of `galleryUuidPath`. Subsequent reads from it will return its default value.
  mutating func clearGalleryUuidPath() {self._galleryUuidPath = nil}

  var captionStorageUuidPath: TSP_UUIDPath {
    get {return _captionStorageUuidPath ?? TSP_UUIDPath()}
    set {_captionStorageUuidPath = newValue}
  }
  /// Returns true if `captionStorageUuidPath` has been explicitly set.
  var hasCaptionStorageUuidPath: Bool {return self._captionStorageUuidPath != nil}
  /// Clears the value of `captionStorageUuidPath`. Subsequent reads from it will return its default value.
  mutating func clearCaptionStorageUuidPath() {self._captionStorageUuidPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_DrawableSelectionTransformerArchive? = nil
  fileprivate var _galleryUuidPath: TSP_UUIDPath? = nil
  fileprivate var _captionStorageUuidPath: TSP_UUIDPath? = nil
}

struct TSA_GalleryItemSelection: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var displayedItem: TSP_Reference {
    get {return _displayedItem ?? TSP_Reference()}
    set {_displayedItem = newValue}
  }
  /// Returns true if `displayedItem` has been explicitly set.
  var hasDisplayedItem: Bool {return self._displayedItem != nil}
  /// Clears the value of `displayedItem`. Subsequent reads from it will return its default value.
  mutating func clearDisplayedItem() {self._displayedItem = nil}

  var items: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _displayedItem: TSP_Reference? = nil
}

struct TSA_GalleryItemSelectionTransformer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transformerHelper: TSA_GalleryItemSelectionTransformerHelper {
    get {return _transformerHelper ?? TSA_GalleryItemSelectionTransformerHelper()}
    set {_transformerHelper = newValue}
  }
  /// Returns true if `transformerHelper` has been explicitly set.
  var hasTransformerHelper: Bool {return self._transformerHelper != nil}
  /// Clears the value of `transformerHelper`. Subsequent reads from it will return its default value.
  mutating func clearTransformerHelper() {self._transformerHelper = nil}

  var captionStorageUuidPath: TSP_UUIDPath {
    get {return _captionStorageUuidPath ?? TSP_UUIDPath()}
    set {_captionStorageUuidPath = newValue}
  }
  /// Returns true if `captionStorageUuidPath` has been explicitly set.
  var hasCaptionStorageUuidPath: Bool {return self._captionStorageUuidPath != nil}
  /// Clears the value of `captionStorageUuidPath`. Subsequent reads from it will return its default value.
  mutating func clearCaptionStorageUuidPath() {self._captionStorageUuidPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transformerHelper: TSA_GalleryItemSelectionTransformerHelper? = nil
  fileprivate var _captionStorageUuidPath: TSP_UUIDPath? = nil
}

struct TSA_GalleryItemSelectionTransformerHelper: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var displayedItemUuidPath: TSP_UUIDPath {
    get {return _displayedItemUuidPath ?? TSP_UUIDPath()}
    set {_displayedItemUuidPath = newValue}
  }
  /// Returns true if `displayedItemUuidPath` has been explicitly set.
  var hasDisplayedItemUuidPath: Bool {return self._displayedItemUuidPath != nil}
  /// Clears the value of `displayedItemUuidPath`. Subsequent reads from it will return its default value.
  mutating func clearDisplayedItemUuidPath() {self._displayedItemUuidPath = nil}

  var itemUuidPaths: [TSP_UUIDPath] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _displayedItemUuidPath: TSP_UUIDPath? = nil
}

struct TSA_GalleryItemSetValueCommand: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var itemIDPath: TSP_UUIDPath {
    get {return _storage._itemIDPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._itemIDPath = newValue}
  }
  /// Returns true if `itemIDPath` has been explicitly set.
  var hasItemIDPath: Bool {return _storage._itemIDPath != nil}
  /// Clears the value of `itemIDPath`. Subsequent reads from it will return its default value.
  mutating func clearItemIDPath() {_uniqueStorage()._itemIDPath = nil}

  var property: TSA_GalleryItemProperty {
    get {return _storage._property ?? .imageData}
    set {_uniqueStorage()._property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return _storage._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {_uniqueStorage()._property = nil}

  var value: TSA_GalleryItemSetValueCommand.PropertyValue {
    get {return _storage._value ?? TSA_GalleryItemSetValueCommand.PropertyValue()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {_uniqueStorage()._value = nil}

  var oldValue: TSA_GalleryItemSetValueCommand.PropertyValue {
    get {return _storage._oldValue ?? TSA_GalleryItemSetValueCommand.PropertyValue()}
    set {_uniqueStorage()._oldValue = newValue}
  }
  /// Returns true if `oldValue` has been explicitly set.
  var hasOldValue: Bool {return _storage._oldValue != nil}
  /// Clears the value of `oldValue`. Subsequent reads from it will return its default value.
  mutating func clearOldValue() {_uniqueStorage()._oldValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PropertyValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var imageData: TSP_DataReference {
      get {return _imageData ?? TSP_DataReference()}
      set {_imageData = newValue}
    }
    /// Returns true if `imageData` has been explicitly set.
    var hasImageData: Bool {return self._imageData != nil}
    /// Clears the value of `imageData`. Subsequent reads from it will return its default value.
    mutating func clearImageData() {self._imageData = nil}

    var accessibilityDescription: String {
      get {return _accessibilityDescription ?? String()}
      set {_accessibilityDescription = newValue}
    }
    /// Returns true if `accessibilityDescription` has been explicitly set.
    var hasAccessibilityDescription: Bool {return self._accessibilityDescription != nil}
    /// Clears the value of `accessibilityDescription`. Subsequent reads from it will return its default value.
    mutating func clearAccessibilityDescription() {self._accessibilityDescription = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _imageData: TSP_DataReference? = nil
    fileprivate var _accessibilityDescription: String? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSA_CollaboratorGalleryItemCursor: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var displayedItemID: TSP_UUID {
    get {return _displayedItemID ?? TSP_UUID()}
    set {_displayedItemID = newValue}
  }
  /// Returns true if `displayedItemID` has been explicitly set.
  var hasDisplayedItemID: Bool {return self._displayedItemID != nil}
  /// Clears the value of `displayedItemID`. Subsequent reads from it will return its default value.
  mutating func clearDisplayedItemID() {self._displayedItemID = nil}

  var itemIds: [TSP_UUID] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _displayedItemID: TSP_UUID? = nil
}

struct TSA_WebVideoInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var url: String {
    get {return _url ?? String()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {self._url = nil}

  var posterImageData: TSP_DataReference {
    get {return _posterImageData ?? TSP_DataReference()}
    set {_posterImageData = newValue}
  }
  /// Returns true if `posterImageData` has been explicitly set.
  var hasPosterImageData: Bool {return self._posterImageData != nil}
  /// Clears the value of `posterImageData`. Subsequent reads from it will return its default value.
  mutating func clearPosterImageData() {self._posterImageData = nil}

  var attribution: TSD_Attribution {
    get {return _attribution ?? TSD_Attribution()}
    set {_attribution = newValue}
  }
  /// Returns true if `attribution` has been explicitly set.
  var hasAttribution: Bool {return self._attribution != nil}
  /// Clears the value of `attribution`. Subsequent reads from it will return its default value.
  mutating func clearAttribution() {self._attribution = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _url: String? = nil
  fileprivate var _posterImageData: TSP_DataReference? = nil
  fileprivate var _attribution: TSD_Attribution? = nil
}

struct TSA_CaptionPlacementArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var captionAnchorLocation: Int32 {
    get {return _captionAnchorLocation ?? 0}
    set {_captionAnchorLocation = newValue}
  }
  /// Returns true if `captionAnchorLocation` has been explicitly set.
  var hasCaptionAnchorLocation: Bool {return self._captionAnchorLocation != nil}
  /// Clears the value of `captionAnchorLocation`. Subsequent reads from it will return its default value.
  mutating func clearCaptionAnchorLocation() {self._captionAnchorLocation = nil}

  var drawableAnchorLocation: Int32 {
    get {return _drawableAnchorLocation ?? 0}
    set {_drawableAnchorLocation = newValue}
  }
  /// Returns true if `drawableAnchorLocation` has been explicitly set.
  var hasDrawableAnchorLocation: Bool {return self._drawableAnchorLocation != nil}
  /// Clears the value of `drawableAnchorLocation`. Subsequent reads from it will return its default value.
  mutating func clearDrawableAnchorLocation() {self._drawableAnchorLocation = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _captionAnchorLocation: Int32? = nil
  fileprivate var _drawableAnchorLocation: Int32? = nil
}

struct TSA_CaptionInfoArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSWP_ShapeInfoArchive {
    get {return _super ?? TSWP_ShapeInfoArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var placement: TSP_Reference {
    get {return _placement ?? TSP_Reference()}
    set {_placement = newValue}
  }
  /// Returns true if `placement` has been explicitly set.
  var hasPlacement: Bool {return self._placement != nil}
  /// Clears the value of `placement`. Subsequent reads from it will return its default value.
  mutating func clearPlacement() {self._placement = nil}

  var childInfoKind: TSD_CaptionOrTitleKind {
    get {return _childInfoKind ?? .caption}
    set {_childInfoKind = newValue}
  }
  /// Returns true if `childInfoKind` has been explicitly set.
  var hasChildInfoKind: Bool {return self._childInfoKind != nil}
  /// Clears the value of `childInfoKind`. Subsequent reads from it will return its default value.
  mutating func clearChildInfoKind() {self._childInfoKind = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSWP_ShapeInfoArchive? = nil
  fileprivate var _placement: TSP_Reference? = nil
  fileprivate var _childInfoKind: TSD_CaptionOrTitleKind? = nil
}

struct TSA_TitlePlacementCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _storage._super ?? TSD_InfoCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var placingChildInfoKind: TSD_CaptionOrTitleKind {
    get {return _storage._placingChildInfoKind ?? .caption}
    set {_uniqueStorage()._placingChildInfoKind = newValue}
  }
  /// Returns true if `placingChildInfoKind` has been explicitly set.
  var hasPlacingChildInfoKind: Bool {return _storage._placingChildInfoKind != nil}
  /// Clears the value of `placingChildInfoKind`. Subsequent reads from it will return its default value.
  mutating func clearPlacingChildInfoKind() {_uniqueStorage()._placingChildInfoKind = nil}

  var placement: TSP_Reference {
    get {return _storage._placement ?? TSP_Reference()}
    set {_uniqueStorage()._placement = newValue}
  }
  /// Returns true if `placement` has been explicitly set.
  var hasPlacement: Bool {return _storage._placement != nil}
  /// Clears the value of `placement`. Subsequent reads from it will return its default value.
  mutating func clearPlacement() {_uniqueStorage()._placement = nil}

  var oldPlacement: TSP_Reference {
    get {return _storage._oldPlacement ?? TSP_Reference()}
    set {_uniqueStorage()._oldPlacement = newValue}
  }
  /// Returns true if `oldPlacement` has been explicitly set.
  var hasOldPlacement: Bool {return _storage._oldPlacement != nil}
  /// Clears the value of `oldPlacement`. Subsequent reads from it will return its default value.
  mutating func clearOldPlacement() {_uniqueStorage()._oldPlacement = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSA_Object3DInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectData: TSP_DataReference {
    get {return _objectData ?? TSP_DataReference()}
    set {_objectData = newValue}
  }
  /// Returns true if `objectData` has been explicitly set.
  var hasObjectData: Bool {return self._objectData != nil}
  /// Clears the value of `objectData`. Subsequent reads from it will return its default value.
  mutating func clearObjectData() {self._objectData = nil}

  var playsAnimations: Bool {
    get {return _playsAnimations ?? false}
    set {_playsAnimations = newValue}
  }
  /// Returns true if `playsAnimations` has been explicitly set.
  var hasPlaysAnimations: Bool {return self._playsAnimations != nil}
  /// Clears the value of `playsAnimations`. Subsequent reads from it will return its default value.
  mutating func clearPlaysAnimations() {self._playsAnimations = nil}

  var pose3D: TSP_Pose3D {
    get {return _pose3D ?? TSP_Pose3D()}
    set {_pose3D = newValue}
  }
  /// Returns true if `pose3D` has been explicitly set.
  var hasPose3D: Bool {return self._pose3D != nil}
  /// Clears the value of `pose3D`. Subsequent reads from it will return its default value.
  mutating func clearPose3D() {self._pose3D = nil}

  var boundingRect: TSP_Rect {
    get {return _boundingRect ?? TSP_Rect()}
    set {_boundingRect = newValue}
  }
  /// Returns true if `boundingRect` has been explicitly set.
  var hasBoundingRect: Bool {return self._boundingRect != nil}
  /// Clears the value of `boundingRect`. Subsequent reads from it will return its default value.
  mutating func clearBoundingRect() {self._boundingRect = nil}

  var thumbnailImageData: TSP_DataReference {
    get {return _thumbnailImageData ?? TSP_DataReference()}
    set {_thumbnailImageData = newValue}
  }
  /// Returns true if `thumbnailImageData` has been explicitly set.
  var hasThumbnailImageData: Bool {return self._thumbnailImageData != nil}
  /// Clears the value of `thumbnailImageData`. Subsequent reads from it will return its default value.
  mutating func clearThumbnailImageData() {self._thumbnailImageData = nil}

  var embeddedAnimations: Bool {
    get {return _embeddedAnimations ?? false}
    set {_embeddedAnimations = newValue}
  }
  /// Returns true if `embeddedAnimations` has been explicitly set.
  var hasEmbeddedAnimations: Bool {return self._embeddedAnimations != nil}
  /// Clears the value of `embeddedAnimations`. Subsequent reads from it will return its default value.
  mutating func clearEmbeddedAnimations() {self._embeddedAnimations = nil}

  var tracedPath: TSP_Path {
    get {return _tracedPath ?? TSP_Path()}
    set {_tracedPath = newValue}
  }
  /// Returns true if `tracedPath` has been explicitly set.
  var hasTracedPath: Bool {return self._tracedPath != nil}
  /// Clears the value of `tracedPath`. Subsequent reads from it will return its default value.
  mutating func clearTracedPath() {self._tracedPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _objectData: TSP_DataReference? = nil
  fileprivate var _playsAnimations: Bool? = nil
  fileprivate var _pose3D: TSP_Pose3D? = nil
  fileprivate var _boundingRect: TSP_Rect? = nil
  fileprivate var _thumbnailImageData: TSP_DataReference? = nil
  fileprivate var _embeddedAnimations: Bool? = nil
  fileprivate var _tracedPath: TSP_Path? = nil
}

struct TSA_Object3DInfoCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_InfoCommandArchive {
    get {return _storage._super ?? TSD_InfoCommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var info: TSP_Reference {
    get {return _storage._info ?? TSP_Reference()}
    set {_uniqueStorage()._info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return _storage._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {_uniqueStorage()._info = nil}

  var infoIDPath: TSP_UUIDPath {
    get {return _storage._infoIDPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._infoIDPath = newValue}
  }
  /// Returns true if `infoIDPath` has been explicitly set.
  var hasInfoIDPath: Bool {return _storage._infoIDPath != nil}
  /// Clears the value of `infoIDPath`. Subsequent reads from it will return its default value.
  mutating func clearInfoIDPath() {_uniqueStorage()._infoIDPath = nil}

  var thumbnailImageData: TSP_DataReference {
    get {return _storage._thumbnailImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._thumbnailImageData = newValue}
  }
  /// Returns true if `thumbnailImageData` has been explicitly set.
  var hasThumbnailImageData: Bool {return _storage._thumbnailImageData != nil}
  /// Clears the value of `thumbnailImageData`. Subsequent reads from it will return its default value.
  mutating func clearThumbnailImageData() {_uniqueStorage()._thumbnailImageData = nil}

  var oldThumbnailImageData: TSP_DataReference {
    get {return _storage._oldThumbnailImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._oldThumbnailImageData = newValue}
  }
  /// Returns true if `oldThumbnailImageData` has been explicitly set.
  var hasOldThumbnailImageData: Bool {return _storage._oldThumbnailImageData != nil}
  /// Clears the value of `oldThumbnailImageData`. Subsequent reads from it will return its default value.
  mutating func clearOldThumbnailImageData() {_uniqueStorage()._oldThumbnailImageData = nil}

  var pose3D: TSP_Pose3D {
    get {return _storage._pose3D ?? TSP_Pose3D()}
    set {_uniqueStorage()._pose3D = newValue}
  }
  /// Returns true if `pose3D` has been explicitly set.
  var hasPose3D: Bool {return _storage._pose3D != nil}
  /// Clears the value of `pose3D`. Subsequent reads from it will return its default value.
  mutating func clearPose3D() {_uniqueStorage()._pose3D = nil}

  var oldPose3D: TSP_Pose3D {
    get {return _storage._oldPose3D ?? TSP_Pose3D()}
    set {_uniqueStorage()._oldPose3D = newValue}
  }
  /// Returns true if `oldPose3D` has been explicitly set.
  var hasOldPose3D: Bool {return _storage._oldPose3D != nil}
  /// Clears the value of `oldPose3D`. Subsequent reads from it will return its default value.
  mutating func clearOldPose3D() {_uniqueStorage()._oldPose3D = nil}

  var boundingRect: TSP_Rect {
    get {return _storage._boundingRect ?? TSP_Rect()}
    set {_uniqueStorage()._boundingRect = newValue}
  }
  /// Returns true if `boundingRect` has been explicitly set.
  var hasBoundingRect: Bool {return _storage._boundingRect != nil}
  /// Clears the value of `boundingRect`. Subsequent reads from it will return its default value.
  mutating func clearBoundingRect() {_uniqueStorage()._boundingRect = nil}

  var oldBoundingRect: TSP_Rect {
    get {return _storage._oldBoundingRect ?? TSP_Rect()}
    set {_uniqueStorage()._oldBoundingRect = newValue}
  }
  /// Returns true if `oldBoundingRect` has been explicitly set.
  var hasOldBoundingRect: Bool {return _storage._oldBoundingRect != nil}
  /// Clears the value of `oldBoundingRect`. Subsequent reads from it will return its default value.
  mutating func clearOldBoundingRect() {_uniqueStorage()._oldBoundingRect = nil}

  var tracedPath: TSP_Path {
    get {return _storage._tracedPath ?? TSP_Path()}
    set {_uniqueStorage()._tracedPath = newValue}
  }
  /// Returns true if `tracedPath` has been explicitly set.
  var hasTracedPath: Bool {return _storage._tracedPath != nil}
  /// Clears the value of `tracedPath`. Subsequent reads from it will return its default value.
  mutating func clearTracedPath() {_uniqueStorage()._tracedPath = nil}

  var oldTracedPath: TSP_Path {
    get {return _storage._oldTracedPath ?? TSP_Path()}
    set {_uniqueStorage()._oldTracedPath = newValue}
  }
  /// Returns true if `oldTracedPath` has been explicitly set.
  var hasOldTracedPath: Bool {return _storage._oldTracedPath != nil}
  /// Clears the value of `oldTracedPath`. Subsequent reads from it will return its default value.
  mutating func clearOldTracedPath() {_uniqueStorage()._oldTracedPath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSA_Object3DInfoSetValueCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var object3DInfoIDPath: TSP_UUIDPath {
    get {return _storage._object3DInfoIDPath ?? TSP_UUIDPath()}
    set {_uniqueStorage()._object3DInfoIDPath = newValue}
  }
  /// Returns true if `object3DInfoIDPath` has been explicitly set.
  var hasObject3DInfoIDPath: Bool {return _storage._object3DInfoIDPath != nil}
  /// Clears the value of `object3DInfoIDPath`. Subsequent reads from it will return its default value.
  mutating func clearObject3DInfoIDPath() {_uniqueStorage()._object3DInfoIDPath = nil}

  var property: TSA_Object3DInfoSetValueCommandArchive.Property {
    get {return _storage._property ?? .playsAnimations}
    set {_uniqueStorage()._property = newValue}
  }
  /// Returns true if `property` has been explicitly set.
  var hasProperty: Bool {return _storage._property != nil}
  /// Clears the value of `property`. Subsequent reads from it will return its default value.
  mutating func clearProperty() {_uniqueStorage()._property = nil}

  var value: TSA_Object3DInfoSetValueCommandArchive.PropertyValue {
    get {return _storage._value ?? TSA_Object3DInfoSetValueCommandArchive.PropertyValue()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {_uniqueStorage()._value = nil}

  var oldValue: TSA_Object3DInfoSetValueCommandArchive.PropertyValue {
    get {return _storage._oldValue ?? TSA_Object3DInfoSetValueCommandArchive.PropertyValue()}
    set {_uniqueStorage()._oldValue = newValue}
  }
  /// Returns true if `oldValue` has been explicitly set.
  var hasOldValue: Bool {return _storage._oldValue != nil}
  /// Clears the value of `oldValue`. Subsequent reads from it will return its default value.
  mutating func clearOldValue() {_uniqueStorage()._oldValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Property: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case playsAnimations = 3
    case opacity = 9

    init() {
      self = .playsAnimations
    }

  }

  struct PropertyValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var playsAnimations: Bool {
      get {return _playsAnimations ?? false}
      set {_playsAnimations = newValue}
    }
    /// Returns true if `playsAnimations` has been explicitly set.
    var hasPlaysAnimations: Bool {return self._playsAnimations != nil}
    /// Clears the value of `playsAnimations`. Subsequent reads from it will return its default value.
    mutating func clearPlaysAnimations() {self._playsAnimations = nil}

    var opacity: Float {
      get {return _opacity ?? 0}
      set {_opacity = newValue}
    }
    /// Returns true if `opacity` has been explicitly set.
    var hasOpacity: Bool {return self._opacity != nil}
    /// Clears the value of `opacity`. Subsequent reads from it will return its default value.
    mutating func clearOpacity() {self._opacity = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _playsAnimations: Bool? = nil
    fileprivate var _opacity: Float? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Extension support defined in TSAArchives.proto.

// MARK: - Extension Properties

// Swift Extensions on the extended Messages to add easy access to the declared
// extension fields. The names are based on the extension field name from the proto
// declaration. To avoid naming collisions, the names are prefixed with the name of
// the scope where the extend directive occurs.

extension TSCK_CollaboratorCursorArchive {

  var TSA_CollaboratorGalleryItemCursor_galleryItemCursor: TSA_CollaboratorGalleryItemCursor {
    get {return getExtensionValue(ext: TSA_CollaboratorGalleryItemCursor.Extensions.gallery_item_cursor) ?? TSA_CollaboratorGalleryItemCursor()}
    set {setExtensionValue(ext: TSA_CollaboratorGalleryItemCursor.Extensions.gallery_item_cursor, value: newValue)}
  }
  /// Returns true if extension `TSA_CollaboratorGalleryItemCursor.Extensions.gallery_item_cursor`
  /// has been explicitly set.
  var hasTSA_CollaboratorGalleryItemCursor_galleryItemCursor: Bool {
    return hasExtensionValue(ext: TSA_CollaboratorGalleryItemCursor.Extensions.gallery_item_cursor)
  }
  /// Clears the value of extension `TSA_CollaboratorGalleryItemCursor.Extensions.gallery_item_cursor`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTSA_CollaboratorGalleryItemCursor_galleryItemCursor() {
    clearExtensionValue(ext: TSA_CollaboratorGalleryItemCursor.Extensions.gallery_item_cursor)
  }
}

extension TSD_ImageArchive {

  var TSA_GalleryInfo_galleryInfo: TSA_GalleryInfo {
    get {return getExtensionValue(ext: TSA_GalleryInfo.Extensions.gallery_info) ?? TSA_GalleryInfo()}
    set {setExtensionValue(ext: TSA_GalleryInfo.Extensions.gallery_info, value: newValue)}
  }
  /// Returns true if extension `TSA_GalleryInfo.Extensions.gallery_info`
  /// has been explicitly set.
  var hasTSA_GalleryInfo_galleryInfo: Bool {
    return hasExtensionValue(ext: TSA_GalleryInfo.Extensions.gallery_info)
  }
  /// Clears the value of extension `TSA_GalleryInfo.Extensions.gallery_info`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTSA_GalleryInfo_galleryInfo() {
    clearExtensionValue(ext: TSA_GalleryInfo.Extensions.gallery_info)
  }

  var TSA_WebVideoInfo_webVideoInfo: TSA_WebVideoInfo {
    get {return getExtensionValue(ext: TSA_WebVideoInfo.Extensions.web_video_info) ?? TSA_WebVideoInfo()}
    set {setExtensionValue(ext: TSA_WebVideoInfo.Extensions.web_video_info, value: newValue)}
  }
  /// Returns true if extension `TSA_WebVideoInfo.Extensions.web_video_info`
  /// has been explicitly set.
  var hasTSA_WebVideoInfo_webVideoInfo: Bool {
    return hasExtensionValue(ext: TSA_WebVideoInfo.Extensions.web_video_info)
  }
  /// Clears the value of extension `TSA_WebVideoInfo.Extensions.web_video_info`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTSA_WebVideoInfo_webVideoInfo() {
    clearExtensionValue(ext: TSA_WebVideoInfo.Extensions.web_video_info)
  }
}

extension TSD_MovieArchive {

  var TSA_Object3DInfo_object3DInfo: TSA_Object3DInfo {
    get {return getExtensionValue(ext: TSA_Object3DInfo.Extensions.object_3D_info) ?? TSA_Object3DInfo()}
    set {setExtensionValue(ext: TSA_Object3DInfo.Extensions.object_3D_info, value: newValue)}
  }
  /// Returns true if extension `TSA_Object3DInfo.Extensions.object_3D_info`
  /// has been explicitly set.
  var hasTSA_Object3DInfo_object3DInfo: Bool {
    return hasExtensionValue(ext: TSA_Object3DInfo.Extensions.object_3D_info)
  }
  /// Clears the value of extension `TSA_Object3DInfo.Extensions.object_3D_info`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTSA_Object3DInfo_object3DInfo() {
    clearExtensionValue(ext: TSA_Object3DInfo.Extensions.object_3D_info)
  }
}

extension TSS_ThemeArchive {

  var TSA_ThemePresetsArchive_extension: TSA_ThemePresetsArchive {
    get {return getExtensionValue(ext: TSA_ThemePresetsArchive.Extensions.extension) ?? TSA_ThemePresetsArchive()}
    set {setExtensionValue(ext: TSA_ThemePresetsArchive.Extensions.extension, value: newValue)}
  }
  /// Returns true if extension `TSA_ThemePresetsArchive.Extensions.extension`
  /// has been explicitly set.
  var hasTSA_ThemePresetsArchive_extension: Bool {
    return hasExtensionValue(ext: TSA_ThemePresetsArchive.Extensions.extension)
  }
  /// Clears the value of extension `TSA_ThemePresetsArchive.Extensions.extension`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTSA_ThemePresetsArchive_extension() {
    clearExtensionValue(ext: TSA_ThemePresetsArchive.Extensions.extension)
  }

}

// MARK: - File's ExtensionMap: TSA_Tsaarchives_Extensions

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
let TSA_Tsaarchives_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  TSA_ThemePresetsArchive.Extensions.extension,
  TSA_GalleryInfo.Extensions.gallery_info,
  TSA_CollaboratorGalleryItemCursor.Extensions.gallery_item_cursor,
  TSA_WebVideoInfo.Extensions.web_video_info,
  TSA_Object3DInfo.Extensions.object_3D_info
]

// Extension Objects - The only reason these might be needed is when manually
// constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
// accessors for the extension fields on the messages directly.

extension TSA_ThemePresetsArchive {
  enum Extensions {
    static let `extension` = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TSA_ThemePresetsArchive>, TSS_ThemeArchive>(
      _protobuf_fieldNumber: 210,
      fieldName: "TSA.ThemePresetsArchive.extension"
    )
  }
}

extension TSA_GalleryInfo {
  enum Extensions {
    static let gallery_info = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TSA_GalleryInfo>, TSD_ImageArchive>(
      _protobuf_fieldNumber: 200,
      fieldName: "TSA.GalleryInfo.gallery_info"
    )
  }
}

extension TSA_CollaboratorGalleryItemCursor {
  enum Extensions {
    static let gallery_item_cursor = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TSA_CollaboratorGalleryItemCursor>, TSCK_CollaboratorCursorArchive>(
      _protobuf_fieldNumber: 400,
      fieldName: "TSA.CollaboratorGalleryItemCursor.gallery_item_cursor"
    )
  }
}

extension TSA_WebVideoInfo {
  enum Extensions {
    static let web_video_info = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TSA_WebVideoInfo>, TSD_ImageArchive>(
      _protobuf_fieldNumber: 300,
      fieldName: "TSA.WebVideoInfo.web_video_info"
    )
  }
}

extension TSA_Object3DInfo {
  enum Extensions {
    static let object_3D_info = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TSA_Object3DInfo>, TSD_MovieArchive>(
      _protobuf_fieldNumber: 200,
      fieldName: "TSA.Object3DInfo.object_3D_info"
    )
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TSA"

extension TSA_GalleryInfoCaptionMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0GalleryInfoCaptionModeNone\0\u{1}GalleryInfoCaptionModePerImage\0\u{1}GalleryInfoCaptionModeAllImages\0")
}

extension TSA_GalleryInfoProperty: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0GalleryInfoCaptionProperty\0")
}

extension TSA_GalleryCaptionMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0GalleryCaptionModeNone\0\u{1}GalleryCaptionModePerImage\0\u{1}GalleryCaptionModeAllImages\0")
}

extension TSA_GalleryItemProperty: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0GalleryItemPropertyImageData\0\u{1}GalleryItemPropertyThumbnailImageData\0\u{1}GalleryItemPropertyAccessibilityDescription\0")
}

extension TSA_DocumentArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}text_preset_display_items\0\u{3}document_language\0\u{3}calculation_engine\0\u{3}view_state\0\u{3}function_browser_state\0\u{3}tables_custom_format_list\0\u{3}needs_media_compatibility_upgrade\0\u{3}template_identifier\0\u{3}shortcut_controller\0\u{3}annotation_cache_deprecated\0\u{3}custom_format_list\0\u{3}annotation_cache_deprecated_2\0\u{3}collaborative_media_compatibility_upgrade_did_fail\0\u{3}can_use_hevc\0\u{3}is_content_source\0")

  fileprivate class _StorageClass {
    var _super: TSK_DocumentArchive? = nil
    var _textPresetDisplayItems: [TSWP_TextPresetDisplayItemArchive] = []
    var _documentLanguage: String? = nil
    var _calculationEngine: TSP_Reference? = nil
    var _viewState: TSP_Reference? = nil
    var _functionBrowserState: TSP_Reference? = nil
    var _tablesCustomFormatList: TSP_Reference? = nil
    var _needsMediaCompatibilityUpgrade: Bool? = nil
    var _templateIdentifier: String? = nil
    var _shortcutController: TSP_Reference? = nil
    var _annotationCacheDeprecated: TSP_Reference? = nil
    var _customFormatList: TSP_Reference? = nil
    var _annotationCacheDeprecated2: TSP_Reference? = nil
    var _collaborativeMediaCompatibilityUpgradeDidFail: Bool? = nil
    var _canUseHevc: Bool? = nil
    var _isContentSource: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _textPresetDisplayItems = source._textPresetDisplayItems
      _documentLanguage = source._documentLanguage
      _calculationEngine = source._calculationEngine
      _viewState = source._viewState
      _functionBrowserState = source._functionBrowserState
      _tablesCustomFormatList = source._tablesCustomFormatList
      _needsMediaCompatibilityUpgrade = source._needsMediaCompatibilityUpgrade
      _templateIdentifier = source._templateIdentifier
      _shortcutController = source._shortcutController
      _annotationCacheDeprecated = source._annotationCacheDeprecated
      _customFormatList = source._customFormatList
      _annotationCacheDeprecated2 = source._annotationCacheDeprecated2
      _collaborativeMediaCompatibilityUpgradeDidFail = source._collaborativeMediaCompatibilityUpgradeDidFail
      _canUseHevc = source._canUseHevc
      _isContentSource = source._isContentSource
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._textPresetDisplayItems) {return false}
      if let v = _storage._calculationEngine, !v.isInitialized {return false}
      if let v = _storage._viewState, !v.isInitialized {return false}
      if let v = _storage._functionBrowserState, !v.isInitialized {return false}
      if let v = _storage._tablesCustomFormatList, !v.isInitialized {return false}
      if let v = _storage._shortcutController, !v.isInitialized {return false}
      if let v = _storage._annotationCacheDeprecated, !v.isInitialized {return false}
      if let v = _storage._customFormatList, !v.isInitialized {return false}
      if let v = _storage._annotationCacheDeprecated2, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._textPresetDisplayItems) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._documentLanguage) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._calculationEngine) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._viewState) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._functionBrowserState) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._tablesCustomFormatList) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._needsMediaCompatibilityUpgrade) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._templateIdentifier) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._shortcutController) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._annotationCacheDeprecated) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._customFormatList) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._annotationCacheDeprecated2) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._collaborativeMediaCompatibilityUpgradeDidFail) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._canUseHevc) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._isContentSource) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._textPresetDisplayItems.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._textPresetDisplayItems, fieldNumber: 2)
      }
      try { if let v = _storage._documentLanguage {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._calculationEngine {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._viewState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._functionBrowserState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._tablesCustomFormatList {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._needsMediaCompatibilityUpgrade {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._templateIdentifier {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._shortcutController {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._annotationCacheDeprecated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._customFormatList {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._annotationCacheDeprecated2 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._collaborativeMediaCompatibilityUpgradeDidFail {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._canUseHevc {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._isContentSource {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_DocumentArchive, rhs: TSA_DocumentArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._textPresetDisplayItems != rhs_storage._textPresetDisplayItems {return false}
        if _storage._documentLanguage != rhs_storage._documentLanguage {return false}
        if _storage._calculationEngine != rhs_storage._calculationEngine {return false}
        if _storage._viewState != rhs_storage._viewState {return false}
        if _storage._functionBrowserState != rhs_storage._functionBrowserState {return false}
        if _storage._tablesCustomFormatList != rhs_storage._tablesCustomFormatList {return false}
        if _storage._needsMediaCompatibilityUpgrade != rhs_storage._needsMediaCompatibilityUpgrade {return false}
        if _storage._templateIdentifier != rhs_storage._templateIdentifier {return false}
        if _storage._shortcutController != rhs_storage._shortcutController {return false}
        if _storage._annotationCacheDeprecated != rhs_storage._annotationCacheDeprecated {return false}
        if _storage._customFormatList != rhs_storage._customFormatList {return false}
        if _storage._annotationCacheDeprecated2 != rhs_storage._annotationCacheDeprecated2 {return false}
        if _storage._collaborativeMediaCompatibilityUpgradeDidFail != rhs_storage._collaborativeMediaCompatibilityUpgradeDidFail {return false}
        if _storage._canUseHevc != rhs_storage._canUseHevc {return false}
        if _storage._isContentSource != rhs_storage._isContentSource {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_FunctionBrowserStateArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FunctionBrowserStateArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}recent_functions\0\u{3}back_functions\0\u{3}forward_functions\0\u{3}current_function\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.recentFunctions) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.backFunctions) }()
      case 3: try { try decoder.decodeRepeatedUInt32Field(value: &self.forwardFunctions) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._currentFunction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.recentFunctions.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.recentFunctions, fieldNumber: 1)
    }
    if !self.backFunctions.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.backFunctions, fieldNumber: 2)
    }
    if !self.forwardFunctions.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.forwardFunctions, fieldNumber: 3)
    }
    try { if let v = self._currentFunction {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_FunctionBrowserStateArchive, rhs: TSA_FunctionBrowserStateArchive) -> Bool {
    if lhs.recentFunctions != rhs.recentFunctions {return false}
    if lhs.backFunctions != rhs.backFunctions {return false}
    if lhs.forwardFunctions != rhs.forwardFunctions {return false}
    if lhs._currentFunction != rhs._currentFunction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_ThemePresetsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThemePresetsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}caption_style_presets\0\u{3}svg_import_style_presets\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.captionStylePresets) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.svgImportStylePresets) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.captionStylePresets) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.svgImportStylePresets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.captionStylePresets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.captionStylePresets, fieldNumber: 1)
    }
    if !self.svgImportStylePresets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.svgImportStylePresets, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_ThemePresetsArchive, rhs: TSA_ThemePresetsArchive) -> Bool {
    if lhs.captionStylePresets != rhs.captionStylePresets {return false}
    if lhs.svgImportStylePresets != rhs.svgImportStylePresets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_ShortcutControllerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShortcutControllerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}entries\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.entries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_ShortcutControllerArchive, rhs: TSA_ShortcutControllerArchive) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_ShortcutControllerArchive.ShortcutMapEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSA_ShortcutControllerArchive.protoMessageName + ".ShortcutMapEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}shortcut\0\u{1}style\0")

  public var isInitialized: Bool {
    if self._shortcut == nil {return false}
    if self._style == nil {return false}
    if let v = self._style, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._shortcut) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._style) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._shortcut {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._style {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_ShortcutControllerArchive.ShortcutMapEntry, rhs: TSA_ShortcutControllerArchive.ShortcutMapEntry) -> Bool {
    if lhs._shortcut != rhs._shortcut {return false}
    if lhs._style != rhs._style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_PropagatePresetCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PropagatePresetCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}preset_change_command\0\u{3}always_preserve_appearance\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._presetChangeCommand == nil {return false}
    if self._alwaysPreserveAppearance == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._presetChangeCommand, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._presetChangeCommand) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._alwaysPreserveAppearance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._presetChangeCommand {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._alwaysPreserveAppearance {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_PropagatePresetCommandArchive, rhs: TSA_PropagatePresetCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._presetChangeCommand != rhs._presetChangeCommand {return false}
    if lhs._alwaysPreserveAppearance != rhs._alwaysPreserveAppearance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_ShortcutCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShortcutCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}old_style\0\u{3}new_style\0\u{3}old_shortcut\0\u{3}new_shortcut\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _oldStyle: TSP_Reference? = nil
    var _newStyle: TSP_Reference? = nil
    var _oldShortcut: String? = nil
    var _newShortcut: String? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _oldStyle = source._oldStyle
      _newStyle = source._newStyle
      _oldShortcut = source._oldShortcut
      _newShortcut = source._newShortcut
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._oldStyle, !v.isInitialized {return false}
      if let v = _storage._newStyle, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._oldStyle) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._newStyle) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._oldShortcut) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._newShortcut) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._oldStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._newStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._oldShortcut {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._newShortcut {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_ShortcutCommandArchive, rhs: TSA_ShortcutCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._oldStyle != rhs_storage._oldStyle {return false}
        if _storage._newStyle != rhs_storage._newStyle {return false}
        if _storage._oldShortcut != rhs_storage._oldShortcut {return false}
        if _storage._newShortcut != rhs_storage._newShortcut {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_AddCustomFormatCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddCustomFormatCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}custom_format\0\u{3}custom_format_key\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._customFormat, !v.isInitialized {return false}
    if let v = self._customFormatKey, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._customFormat) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._customFormatKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._customFormat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._customFormatKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_AddCustomFormatCommandArchive, rhs: TSA_AddCustomFormatCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._customFormat != rhs._customFormat {return false}
    if lhs._customFormatKey != rhs._customFormatKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_UpdateCustomFormatCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateCustomFormatCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}custom_format\0\u{3}old_custom_format\0\u{3}custom_format_key\0")

  public var isInitialized: Bool {
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._customFormat, !v.isInitialized {return false}
    if let v = self._oldCustomFormat, !v.isInitialized {return false}
    if let v = self._customFormatKey, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._customFormat) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._oldCustomFormat) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._customFormatKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._customFormat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._oldCustomFormat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._customFormatKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_UpdateCustomFormatCommandArchive, rhs: TSA_UpdateCustomFormatCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._customFormat != rhs._customFormat {return false}
    if lhs._oldCustomFormat != rhs._oldCustomFormat {return false}
    if lhs._customFormatKey != rhs._customFormatKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_ReplaceCustomFormatCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReplaceCustomFormatCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}custom_format\0\u{3}custom_format_key\0\u{3}replacement_format\0")

  public var isInitialized: Bool {
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._customFormat, !v.isInitialized {return false}
    if let v = self._customFormatKey, !v.isInitialized {return false}
    if let v = self._replacementFormat, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._customFormat) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._customFormatKey) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._replacementFormat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._customFormat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._customFormatKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._replacementFormat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_ReplaceCustomFormatCommandArchive, rhs: TSA_ReplaceCustomFormatCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._customFormat != rhs._customFormat {return false}
    if lhs._customFormatKey != rhs._customFormatKey {return false}
    if lhs._replacementFormat != rhs._replacementFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_NeedsMediaCompatibilityUpgradeCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NeedsMediaCompatibilityUpgradeCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}needs_media_compatibility_upgrade\0\u{3}old_needs_media_compatibility_upgrade\0\u{3}collaborative_media_compatibility_upgrade_did_fail\0\u{3}old_collaborative_media_compatibility_upgrade_did_fail\0\u{3}can_use_hevc\0\u{3}old_can_use_hevc\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _needsMediaCompatibilityUpgrade: Bool? = nil
    var _oldNeedsMediaCompatibilityUpgrade: Bool? = nil
    var _collaborativeMediaCompatibilityUpgradeDidFail: Bool? = nil
    var _oldCollaborativeMediaCompatibilityUpgradeDidFail: Bool? = nil
    var _canUseHevc: Bool? = nil
    var _oldCanUseHevc: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _needsMediaCompatibilityUpgrade = source._needsMediaCompatibilityUpgrade
      _oldNeedsMediaCompatibilityUpgrade = source._oldNeedsMediaCompatibilityUpgrade
      _collaborativeMediaCompatibilityUpgradeDidFail = source._collaborativeMediaCompatibilityUpgradeDidFail
      _oldCollaborativeMediaCompatibilityUpgradeDidFail = source._oldCollaborativeMediaCompatibilityUpgradeDidFail
      _canUseHevc = source._canUseHevc
      _oldCanUseHevc = source._oldCanUseHevc
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._needsMediaCompatibilityUpgrade) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._oldNeedsMediaCompatibilityUpgrade) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._collaborativeMediaCompatibilityUpgradeDidFail) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._oldCollaborativeMediaCompatibilityUpgradeDidFail) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._canUseHevc) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._oldCanUseHevc) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._needsMediaCompatibilityUpgrade {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._oldNeedsMediaCompatibilityUpgrade {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._collaborativeMediaCompatibilityUpgradeDidFail {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._oldCollaborativeMediaCompatibilityUpgradeDidFail {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._canUseHevc {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._oldCanUseHevc {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_NeedsMediaCompatibilityUpgradeCommandArchive, rhs: TSA_NeedsMediaCompatibilityUpgradeCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._needsMediaCompatibilityUpgrade != rhs_storage._needsMediaCompatibilityUpgrade {return false}
        if _storage._oldNeedsMediaCompatibilityUpgrade != rhs_storage._oldNeedsMediaCompatibilityUpgrade {return false}
        if _storage._collaborativeMediaCompatibilityUpgradeDidFail != rhs_storage._collaborativeMediaCompatibilityUpgradeDidFail {return false}
        if _storage._oldCollaborativeMediaCompatibilityUpgradeDidFail != rhs_storage._oldCollaborativeMediaCompatibilityUpgradeDidFail {return false}
        if _storage._canUseHevc != rhs_storage._canUseHevc {return false}
        if _storage._oldCanUseHevc != rhs_storage._oldCanUseHevc {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_ChangeDocumentLocaleCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeDocumentLocaleCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}old_locale_id\0\u{3}new_locale_id\0\u{3}old_formatting_symbols\0\u{3}new_formatting_symbols\0")

  public var isInitialized: Bool {
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._oldFormattingSymbols, !v.isInitialized {return false}
    if let v = self._newFormattingSymbols, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._oldLocaleID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._newLocaleID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._oldFormattingSymbols) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._newFormattingSymbols) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oldLocaleID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newLocaleID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._oldFormattingSymbols {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._newFormattingSymbols {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_ChangeDocumentLocaleCommandArchive, rhs: TSA_ChangeDocumentLocaleCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._oldLocaleID != rhs._oldLocaleID {return false}
    if lhs._newLocaleID != rhs._newLocaleID {return false}
    if lhs._oldFormattingSymbols != rhs._oldFormattingSymbols {return false}
    if lhs._newFormattingSymbols != rhs._newFormattingSymbols {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_InducedVerifyObjectsWithServerCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InducedVerifyObjectsWithServerCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}object_id_list\0\u{3}object_id_list_undefined\0\u{3}server_object_s_o_s_string_list\0\u{3}server_object_s_o_s_string_list_undefined\0\u{3}pending_recalc\0\u{3}remote_data_sync_key\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _objectIDList: [TSP_UUID] = []
    var _objectIDListUndefined: Bool? = nil
    var _serverObjectSOSStringList: [String] = []
    var _serverObjectSOSStringListUndefined: Bool? = nil
    var _pendingRecalc: Bool? = nil
    var _remoteDataSyncKey: Double? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _objectIDList = source._objectIDList
      _objectIDListUndefined = source._objectIDListUndefined
      _serverObjectSOSStringList = source._serverObjectSOSStringList
      _serverObjectSOSStringListUndefined = source._serverObjectSOSStringListUndefined
      _pendingRecalc = source._pendingRecalc
      _remoteDataSyncKey = source._remoteDataSyncKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._pendingRecalc == nil {return false}
      if _storage._remoteDataSyncKey == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._objectIDList) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._objectIDList) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._objectIDListUndefined) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._serverObjectSOSStringList) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._serverObjectSOSStringListUndefined) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._pendingRecalc) }()
        case 7: try { try decoder.decodeSingularDoubleField(value: &_storage._remoteDataSyncKey) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._objectIDList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._objectIDList, fieldNumber: 2)
      }
      try { if let v = _storage._objectIDListUndefined {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      if !_storage._serverObjectSOSStringList.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._serverObjectSOSStringList, fieldNumber: 4)
      }
      try { if let v = _storage._serverObjectSOSStringListUndefined {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._pendingRecalc {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._remoteDataSyncKey {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_InducedVerifyObjectsWithServerCommandArchive, rhs: TSA_InducedVerifyObjectsWithServerCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._objectIDList != rhs_storage._objectIDList {return false}
        if _storage._objectIDListUndefined != rhs_storage._objectIDListUndefined {return false}
        if _storage._serverObjectSOSStringList != rhs_storage._serverObjectSOSStringList {return false}
        if _storage._serverObjectSOSStringListUndefined != rhs_storage._serverObjectSOSStringListUndefined {return false}
        if _storage._pendingRecalc != rhs_storage._pendingRecalc {return false}
        if _storage._remoteDataSyncKey != rhs_storage._remoteDataSyncKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_InducedVerifyTransformHistoryWithServerCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InducedVerifyTransformHistoryWithServerCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}server_operation_storage_entries\0\u{3}server_operation_storage_entries_undefined\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.serverOperationStorageEntries) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._serverOperationStorageEntriesUndefined) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.serverOperationStorageEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serverOperationStorageEntries, fieldNumber: 2)
    }
    try { if let v = self._serverOperationStorageEntriesUndefined {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_InducedVerifyTransformHistoryWithServerCommandArchive, rhs: TSA_InducedVerifyTransformHistoryWithServerCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.serverOperationStorageEntries != rhs.serverOperationStorageEntries {return false}
    if lhs._serverOperationStorageEntriesUndefined != rhs._serverOperationStorageEntriesUndefined {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_StyleUpdatePropertyMapCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StyleUpdatePropertyMapCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_StyleUpdatePropertyMapCommandArchive, rhs: TSA_StyleUpdatePropertyMapCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_RemoteDataChangeCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteDataChangeCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}value_map\0\u{1}quotes\0\u{3}remote_data_sync_key\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if self._valueMap == nil {return false}
    if self._remoteDataSyncKey == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._valueMap, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.quotes) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._valueMap) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.quotes) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._remoteDataSyncKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._valueMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.quotes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quotes, fieldNumber: 3)
    }
    try { if let v = self._remoteDataSyncKey {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_RemoteDataChangeCommandArchive, rhs: TSA_RemoteDataChangeCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._valueMap != rhs._valueMap {return false}
    if lhs.quotes != rhs.quotes {return false}
    if lhs._remoteDataSyncKey != rhs._remoteDataSyncKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_GalleryInfoSetValueCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GalleryInfoSetValueCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}info_id_path\0\u{1}property\0\u{1}value\0\u{3}old_value\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._infoIDPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._infoIDPath) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._property) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._oldValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._infoIDPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._property {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._oldValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_GalleryInfoSetValueCommandArchive, rhs: TSA_GalleryInfoSetValueCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._infoIDPath != rhs._infoIDPath {return false}
    if lhs._property != rhs._property {return false}
    if lhs._value != rhs._value {return false}
    if lhs._oldValue != rhs._oldValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_GalleryInfoSetValueCommandArchive.PropertyValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSA_GalleryInfoSetValueCommandArchive.protoMessageName + ".PropertyValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}caption_mode\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._captionMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._captionMode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_GalleryInfoSetValueCommandArchive.PropertyValue, rhs: TSA_GalleryInfoSetValueCommandArchive.PropertyValue) -> Bool {
    if lhs._captionMode != rhs._captionMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_GalleryInfoInsertItemsCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GalleryInfoInsertItemsCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}items\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.items) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_GalleryInfoInsertItemsCommandArchive, rhs: TSA_GalleryInfoInsertItemsCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_GalleryInfoRemoveItemsCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GalleryInfoRemoveItemsCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_GalleryInfoRemoveItemsCommandArchive, rhs: TSA_GalleryInfoRemoveItemsCommandArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_GalleryItemSetGeometryCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GalleryItemSetGeometryCommand"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}item_id_path\0\u{1}offset\0\u{1}scale\0\u{3}old_offset\0\u{3}old_scale\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _itemIDPath: TSP_UUIDPath? = nil
    var _offset: TSP_Point? = nil
    var _scale: Float? = nil
    var _oldOffset: TSP_Point? = nil
    var _oldScale: Float? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _itemIDPath = source._itemIDPath
      _offset = source._offset
      _scale = source._scale
      _oldOffset = source._oldOffset
      _oldScale = source._oldScale
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._itemIDPath, !v.isInitialized {return false}
      if let v = _storage._offset, !v.isInitialized {return false}
      if let v = _storage._oldOffset, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._itemIDPath) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._offset) }()
        case 4: try { try decoder.decodeSingularFloatField(value: &_storage._scale) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._oldOffset) }()
        case 6: try { try decoder.decodeSingularFloatField(value: &_storage._oldScale) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._itemIDPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._offset {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._scale {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._oldOffset {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._oldScale {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_GalleryItemSetGeometryCommand, rhs: TSA_GalleryItemSetGeometryCommand) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._itemIDPath != rhs_storage._itemIDPath {return false}
        if _storage._offset != rhs_storage._offset {return false}
        if _storage._scale != rhs_storage._scale {return false}
        if _storage._oldOffset != rhs_storage._oldOffset {return false}
        if _storage._oldScale != rhs_storage._oldScale {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_GalleryItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GalleryItem"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}offset\0\u{1}scale\0\u{3}image_data\0\u{3}thumbnail_image_data\0\u{3}image_adjustments\0\u{3}adjusted_image_data\0\u{3}thumbnail_adjusted_image_data\0\u{3}caption_storage\0\u{3}accessibility_description\0")

  fileprivate class _StorageClass {
    var _offset: TSP_Point? = nil
    var _scale: Float? = nil
    var _imageData: TSP_DataReference? = nil
    var _thumbnailImageData: TSP_DataReference? = nil
    var _imageAdjustments: TSD_ImageAdjustmentsArchive? = nil
    var _adjustedImageData: TSP_DataReference? = nil
    var _thumbnailAdjustedImageData: TSP_DataReference? = nil
    var _captionStorage: TSP_Reference? = nil
    var _accessibilityDescription: String? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _offset = source._offset
      _scale = source._scale
      _imageData = source._imageData
      _thumbnailImageData = source._thumbnailImageData
      _imageAdjustments = source._imageAdjustments
      _adjustedImageData = source._adjustedImageData
      _thumbnailAdjustedImageData = source._thumbnailAdjustedImageData
      _captionStorage = source._captionStorage
      _accessibilityDescription = source._accessibilityDescription
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._offset, !v.isInitialized {return false}
      if let v = _storage._imageData, !v.isInitialized {return false}
      if let v = _storage._thumbnailImageData, !v.isInitialized {return false}
      if let v = _storage._adjustedImageData, !v.isInitialized {return false}
      if let v = _storage._thumbnailAdjustedImageData, !v.isInitialized {return false}
      if let v = _storage._captionStorage, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._offset) }()
        case 2: try { try decoder.decodeSingularFloatField(value: &_storage._scale) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._imageData) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._thumbnailImageData) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._imageAdjustments) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._adjustedImageData) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._thumbnailAdjustedImageData) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._captionStorage) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._accessibilityDescription) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._offset {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._scale {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._imageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._thumbnailImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._imageAdjustments {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._adjustedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._thumbnailAdjustedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._captionStorage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._accessibilityDescription {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_GalleryItem, rhs: TSA_GalleryItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._offset != rhs_storage._offset {return false}
        if _storage._scale != rhs_storage._scale {return false}
        if _storage._imageData != rhs_storage._imageData {return false}
        if _storage._thumbnailImageData != rhs_storage._thumbnailImageData {return false}
        if _storage._imageAdjustments != rhs_storage._imageAdjustments {return false}
        if _storage._adjustedImageData != rhs_storage._adjustedImageData {return false}
        if _storage._thumbnailAdjustedImageData != rhs_storage._thumbnailAdjustedImageData {return false}
        if _storage._captionStorage != rhs_storage._captionStorage {return false}
        if _storage._accessibilityDescription != rhs_storage._accessibilityDescription {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_GalleryInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GalleryInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}items\0\u{3}caption_mode\0\u{3}caption_storage\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.items) {return false}
    if let v = self._captionStorage, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._captionMode) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._captionStorage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try { if let v = self._captionMode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._captionStorage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_GalleryInfo, rhs: TSA_GalleryInfo) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs._captionMode != rhs._captionMode {return false}
    if lhs._captionStorage != rhs._captionStorage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_GallerySelectionTransformer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GallerySelectionTransformer"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}gallery_uuid_path\0\u{3}caption_storage_uuid_path\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._galleryUuidPath, !v.isInitialized {return false}
    if let v = self._captionStorageUuidPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._galleryUuidPath) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._captionStorageUuidPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._galleryUuidPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._captionStorageUuidPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_GallerySelectionTransformer, rhs: TSA_GallerySelectionTransformer) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._galleryUuidPath != rhs._galleryUuidPath {return false}
    if lhs._captionStorageUuidPath != rhs._captionStorageUuidPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_GalleryItemSelection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GalleryItemSelection"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}displayed_item\0\u{1}items\0")

  public var isInitialized: Bool {
    if let v = self._displayedItem, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.items) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._displayedItem) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._displayedItem {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_GalleryItemSelection, rhs: TSA_GalleryItemSelection) -> Bool {
    if lhs._displayedItem != rhs._displayedItem {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_GalleryItemSelectionTransformer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GalleryItemSelectionTransformer"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}transformer_helper\0\u{3}caption_storage_uuid_path\0")

  public var isInitialized: Bool {
    if let v = self._transformerHelper, !v.isInitialized {return false}
    if let v = self._captionStorageUuidPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transformerHelper) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._captionStorageUuidPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transformerHelper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._captionStorageUuidPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_GalleryItemSelectionTransformer, rhs: TSA_GalleryItemSelectionTransformer) -> Bool {
    if lhs._transformerHelper != rhs._transformerHelper {return false}
    if lhs._captionStorageUuidPath != rhs._captionStorageUuidPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_GalleryItemSelectionTransformerHelper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GalleryItemSelectionTransformerHelper"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}displayed_item_uuid_path\0\u{3}item_uuid_paths\0")

  public var isInitialized: Bool {
    if let v = self._displayedItemUuidPath, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.itemUuidPaths) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._displayedItemUuidPath) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.itemUuidPaths) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._displayedItemUuidPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.itemUuidPaths.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.itemUuidPaths, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_GalleryItemSelectionTransformerHelper, rhs: TSA_GalleryItemSelectionTransformerHelper) -> Bool {
    if lhs._displayedItemUuidPath != rhs._displayedItemUuidPath {return false}
    if lhs.itemUuidPaths != rhs.itemUuidPaths {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_GalleryItemSetValueCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GalleryItemSetValueCommand"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}item_id_path\0\u{1}property\0\u{1}value\0\u{3}old_value\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _itemIDPath: TSP_UUIDPath? = nil
    var _property: TSA_GalleryItemProperty? = nil
    var _value: TSA_GalleryItemSetValueCommand.PropertyValue? = nil
    var _oldValue: TSA_GalleryItemSetValueCommand.PropertyValue? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _itemIDPath = source._itemIDPath
      _property = source._property
      _value = source._value
      _oldValue = source._oldValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._itemIDPath, !v.isInitialized {return false}
      if let v = _storage._value, !v.isInitialized {return false}
      if let v = _storage._oldValue, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._itemIDPath) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._property) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._value) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._oldValue) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._itemIDPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._property {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._oldValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_GalleryItemSetValueCommand, rhs: TSA_GalleryItemSetValueCommand) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._itemIDPath != rhs_storage._itemIDPath {return false}
        if _storage._property != rhs_storage._property {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._oldValue != rhs_storage._oldValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_GalleryItemSetValueCommand.PropertyValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSA_GalleryItemSetValueCommand.protoMessageName + ".PropertyValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}image_data\0\u{3}accessibility_description\0")

  public var isInitialized: Bool {
    if let v = self._imageData, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._imageData) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._accessibilityDescription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._imageData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accessibilityDescription {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_GalleryItemSetValueCommand.PropertyValue, rhs: TSA_GalleryItemSetValueCommand.PropertyValue) -> Bool {
    if lhs._imageData != rhs._imageData {return false}
    if lhs._accessibilityDescription != rhs._accessibilityDescription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_CollaboratorGalleryItemCursor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CollaboratorGalleryItemCursor"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}displayed_item_id\0\u{3}item_ids\0")

  public var isInitialized: Bool {
    if let v = self._displayedItemID, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.itemIds) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._displayedItemID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.itemIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._displayedItemID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.itemIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.itemIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_CollaboratorGalleryItemCursor, rhs: TSA_CollaboratorGalleryItemCursor) -> Bool {
    if lhs._displayedItemID != rhs._displayedItemID {return false}
    if lhs.itemIds != rhs.itemIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_WebVideoInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WebVideoInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}url\0\u{3}poster_image_data\0\u{1}attribution\0")

  public var isInitialized: Bool {
    if let v = self._posterImageData, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._url) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._posterImageData) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._attribution) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._posterImageData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._attribution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_WebVideoInfo, rhs: TSA_WebVideoInfo) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs._posterImageData != rhs._posterImageData {return false}
    if lhs._attribution != rhs._attribution {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_CaptionPlacementArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CaptionPlacementArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}caption_anchor_location\0\u{3}drawable_anchor_location\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._captionAnchorLocation) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._drawableAnchorLocation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._captionAnchorLocation {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._drawableAnchorLocation {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_CaptionPlacementArchive, rhs: TSA_CaptionPlacementArchive) -> Bool {
    if lhs._captionAnchorLocation != rhs._captionAnchorLocation {return false}
    if lhs._drawableAnchorLocation != rhs._drawableAnchorLocation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_CaptionInfoArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CaptionInfoArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}placement\0\u{1}childInfoKind\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._placement, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._placement) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._childInfoKind) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._placement {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._childInfoKind {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_CaptionInfoArchive, rhs: TSA_CaptionInfoArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._placement != rhs._placement {return false}
    if lhs._childInfoKind != rhs._childInfoKind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_TitlePlacementCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TitlePlacementCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}placing_child_info_kind\0\u{1}placement\0\u{3}old_placement\0")

  fileprivate class _StorageClass {
    var _super: TSD_InfoCommandArchive? = nil
    var _placingChildInfoKind: TSD_CaptionOrTitleKind? = nil
    var _placement: TSP_Reference? = nil
    var _oldPlacement: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _placingChildInfoKind = source._placingChildInfoKind
      _placement = source._placement
      _oldPlacement = source._oldPlacement
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._placement, !v.isInitialized {return false}
      if let v = _storage._oldPlacement, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._placingChildInfoKind) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._placement) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._oldPlacement) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._placingChildInfoKind {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._placement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._oldPlacement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_TitlePlacementCommandArchive, rhs: TSA_TitlePlacementCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._placingChildInfoKind != rhs_storage._placingChildInfoKind {return false}
        if _storage._placement != rhs_storage._placement {return false}
        if _storage._oldPlacement != rhs_storage._oldPlacement {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_Object3DInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Object3DInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}object_data\0\u{3}plays_animations\0\u{1}pose3d\0\u{1}boundingRect\0\u{3}thumbnail_image_data\0\u{3}embedded_animations\0\u{1}tracedPath\0")

  public var isInitialized: Bool {
    if let v = self._objectData, !v.isInitialized {return false}
    if let v = self._pose3D, !v.isInitialized {return false}
    if let v = self._boundingRect, !v.isInitialized {return false}
    if let v = self._thumbnailImageData, !v.isInitialized {return false}
    if let v = self._tracedPath, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._objectData) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._playsAnimations) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pose3D) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._boundingRect) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._thumbnailImageData) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._embeddedAnimations) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._tracedPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._objectData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._playsAnimations {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pose3D {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._boundingRect {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._thumbnailImageData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._embeddedAnimations {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._tracedPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_Object3DInfo, rhs: TSA_Object3DInfo) -> Bool {
    if lhs._objectData != rhs._objectData {return false}
    if lhs._playsAnimations != rhs._playsAnimations {return false}
    if lhs._pose3D != rhs._pose3D {return false}
    if lhs._boundingRect != rhs._boundingRect {return false}
    if lhs._thumbnailImageData != rhs._thumbnailImageData {return false}
    if lhs._embeddedAnimations != rhs._embeddedAnimations {return false}
    if lhs._tracedPath != rhs._tracedPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_Object3DInfoCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Object3DInfoCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}info\0\u{3}info_id_path\0\u{3}thumbnail_image_data\0\u{3}old_thumbnail_image_data\0\u{1}pose3d\0\u{3}old_pose3d\0\u{1}boundingRect\0\u{1}oldBoundingRect\0\u{1}tracedPath\0\u{1}oldTracedPath\0")

  fileprivate class _StorageClass {
    var _super: TSD_InfoCommandArchive? = nil
    var _info: TSP_Reference? = nil
    var _infoIDPath: TSP_UUIDPath? = nil
    var _thumbnailImageData: TSP_DataReference? = nil
    var _oldThumbnailImageData: TSP_DataReference? = nil
    var _pose3D: TSP_Pose3D? = nil
    var _oldPose3D: TSP_Pose3D? = nil
    var _boundingRect: TSP_Rect? = nil
    var _oldBoundingRect: TSP_Rect? = nil
    var _tracedPath: TSP_Path? = nil
    var _oldTracedPath: TSP_Path? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _info = source._info
      _infoIDPath = source._infoIDPath
      _thumbnailImageData = source._thumbnailImageData
      _oldThumbnailImageData = source._oldThumbnailImageData
      _pose3D = source._pose3D
      _oldPose3D = source._oldPose3D
      _boundingRect = source._boundingRect
      _oldBoundingRect = source._oldBoundingRect
      _tracedPath = source._tracedPath
      _oldTracedPath = source._oldTracedPath
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._info, !v.isInitialized {return false}
      if let v = _storage._infoIDPath, !v.isInitialized {return false}
      if let v = _storage._thumbnailImageData, !v.isInitialized {return false}
      if let v = _storage._oldThumbnailImageData, !v.isInitialized {return false}
      if let v = _storage._pose3D, !v.isInitialized {return false}
      if let v = _storage._oldPose3D, !v.isInitialized {return false}
      if let v = _storage._boundingRect, !v.isInitialized {return false}
      if let v = _storage._oldBoundingRect, !v.isInitialized {return false}
      if let v = _storage._tracedPath, !v.isInitialized {return false}
      if let v = _storage._oldTracedPath, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._info) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._infoIDPath) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._thumbnailImageData) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._oldThumbnailImageData) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._pose3D) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._oldPose3D) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._boundingRect) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._oldBoundingRect) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._tracedPath) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._oldTracedPath) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._infoIDPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._thumbnailImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._oldThumbnailImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._pose3D {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._oldPose3D {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._boundingRect {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._oldBoundingRect {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._tracedPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._oldTracedPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_Object3DInfoCommandArchive, rhs: TSA_Object3DInfoCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._info != rhs_storage._info {return false}
        if _storage._infoIDPath != rhs_storage._infoIDPath {return false}
        if _storage._thumbnailImageData != rhs_storage._thumbnailImageData {return false}
        if _storage._oldThumbnailImageData != rhs_storage._oldThumbnailImageData {return false}
        if _storage._pose3D != rhs_storage._pose3D {return false}
        if _storage._oldPose3D != rhs_storage._oldPose3D {return false}
        if _storage._boundingRect != rhs_storage._boundingRect {return false}
        if _storage._oldBoundingRect != rhs_storage._oldBoundingRect {return false}
        if _storage._tracedPath != rhs_storage._tracedPath {return false}
        if _storage._oldTracedPath != rhs_storage._oldTracedPath {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_Object3DInfoSetValueCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Object3DInfoSetValueCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}object_3d_info_id_path\0\u{1}property\0\u{1}value\0\u{3}old_value\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _object3DInfoIDPath: TSP_UUIDPath? = nil
    var _property: TSA_Object3DInfoSetValueCommandArchive.Property? = nil
    var _value: TSA_Object3DInfoSetValueCommandArchive.PropertyValue? = nil
    var _oldValue: TSA_Object3DInfoSetValueCommandArchive.PropertyValue? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _object3DInfoIDPath = source._object3DInfoIDPath
      _property = source._property
      _value = source._value
      _oldValue = source._oldValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._object3DInfoIDPath == nil {return false}
      if _storage._property == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._object3DInfoIDPath, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._object3DInfoIDPath) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._property) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._value) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._oldValue) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._object3DInfoIDPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._property {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._oldValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_Object3DInfoSetValueCommandArchive, rhs: TSA_Object3DInfoSetValueCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._object3DInfoIDPath != rhs_storage._object3DInfoIDPath {return false}
        if _storage._property != rhs_storage._property {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._oldValue != rhs_storage._oldValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSA_Object3DInfoSetValueCommandArchive.Property: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{3}PlaysAnimations\0\u{2}\u{6}Opacity\0")
}

extension TSA_Object3DInfoSetValueCommandArchive.PropertyValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSA_Object3DInfoSetValueCommandArchive.protoMessageName + ".PropertyValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{4}plays_animations\0\u{2}\u{6}opacity\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try { try decoder.decodeSingularBoolField(value: &self._playsAnimations) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self._opacity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._playsAnimations {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._opacity {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSA_Object3DInfoSetValueCommandArchive.PropertyValue, rhs: TSA_Object3DInfoSetValueCommandArchive.PropertyValue) -> Bool {
    if lhs._playsAnimations != rhs._playsAnimations {return false}
    if lhs._opacity != rhs._opacity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
