// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: TSDArchives.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum TSD_LineJoin: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case miterJoin = 0
  case roundJoin = 1
  case bevelJoin = 2

  init() {
    self = .miterJoin
  }

}

struct TSD_EdgeInsetsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var top: Float {
    get {return _top ?? 0}
    set {_top = newValue}
  }
  /// Returns true if `top` has been explicitly set.
  var hasTop: Bool {return self._top != nil}
  /// Clears the value of `top`. Subsequent reads from it will return its default value.
  mutating func clearTop() {self._top = nil}

  var left: Float {
    get {return _left ?? 0}
    set {_left = newValue}
  }
  /// Returns true if `left` has been explicitly set.
  var hasLeft: Bool {return self._left != nil}
  /// Clears the value of `left`. Subsequent reads from it will return its default value.
  mutating func clearLeft() {self._left = nil}

  var bottom: Float {
    get {return _bottom ?? 0}
    set {_bottom = newValue}
  }
  /// Returns true if `bottom` has been explicitly set.
  var hasBottom: Bool {return self._bottom != nil}
  /// Clears the value of `bottom`. Subsequent reads from it will return its default value.
  mutating func clearBottom() {self._bottom = nil}

  var right: Float {
    get {return _right ?? 0}
    set {_right = newValue}
  }
  /// Returns true if `right` has been explicitly set.
  var hasRight: Bool {return self._right != nil}
  /// Clears the value of `right`. Subsequent reads from it will return its default value.
  mutating func clearRight() {self._right = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _top: Float? = nil
  fileprivate var _left: Float? = nil
  fileprivate var _bottom: Float? = nil
  fileprivate var _right: Float? = nil
}

struct TSD_GeometryArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var position: TSP_Point {
    get {return _position ?? TSP_Point()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var size: TSP_Size {
    get {return _size ?? TSP_Size()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var flags: UInt32 {
    get {return _flags ?? 0}
    set {_flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  var hasFlags: Bool {return self._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  mutating func clearFlags() {self._flags = nil}

  var angle: Float {
    get {return _angle ?? 0}
    set {_angle = newValue}
  }
  /// Returns true if `angle` has been explicitly set.
  var hasAngle: Bool {return self._angle != nil}
  /// Clears the value of `angle`. Subsequent reads from it will return its default value.
  mutating func clearAngle() {self._angle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _position: TSP_Point? = nil
  fileprivate var _size: TSP_Size? = nil
  fileprivate var _flags: UInt32? = nil
  fileprivate var _angle: Float? = nil
}

struct TSD_PointPathSourceArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: TSD_PointPathSourceArchive.PointPathSourceType {
    get {return _type ?? .kTsdleftSingleArrow}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var point: TSP_Point {
    get {return _point ?? TSP_Point()}
    set {_point = newValue}
  }
  /// Returns true if `point` has been explicitly set.
  var hasPoint: Bool {return self._point != nil}
  /// Clears the value of `point`. Subsequent reads from it will return its default value.
  mutating func clearPoint() {self._point = nil}

  var naturalSize: TSP_Size {
    get {return _naturalSize ?? TSP_Size()}
    set {_naturalSize = newValue}
  }
  /// Returns true if `naturalSize` has been explicitly set.
  var hasNaturalSize: Bool {return self._naturalSize != nil}
  /// Clears the value of `naturalSize`. Subsequent reads from it will return its default value.
  mutating func clearNaturalSize() {self._naturalSize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PointPathSourceType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kTsdleftSingleArrow = 0
    case kTsdrightSingleArrow = 1
    case kTsddoubleArrow = 10
    case kTsdstar = 100
    case kTsdplus = 200

    init() {
      self = .kTsdleftSingleArrow
    }

  }

  init() {}

  fileprivate var _type: TSD_PointPathSourceArchive.PointPathSourceType? = nil
  fileprivate var _point: TSP_Point? = nil
  fileprivate var _naturalSize: TSP_Size? = nil
}

struct TSD_ScalarPathSourceArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: TSD_ScalarPathSourceArchive.ScalarPathSourceType {
    get {return _type ?? .kTsdroundedRectangle}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var scalar: Float {
    get {return _scalar ?? 0}
    set {_scalar = newValue}
  }
  /// Returns true if `scalar` has been explicitly set.
  var hasScalar: Bool {return self._scalar != nil}
  /// Clears the value of `scalar`. Subsequent reads from it will return its default value.
  mutating func clearScalar() {self._scalar = nil}

  var naturalSize: TSP_Size {
    get {return _naturalSize ?? TSP_Size()}
    set {_naturalSize = newValue}
  }
  /// Returns true if `naturalSize` has been explicitly set.
  var hasNaturalSize: Bool {return self._naturalSize != nil}
  /// Clears the value of `naturalSize`. Subsequent reads from it will return its default value.
  mutating func clearNaturalSize() {self._naturalSize = nil}

  var isCurveContinuous: Bool {
    get {return _isCurveContinuous ?? false}
    set {_isCurveContinuous = newValue}
  }
  /// Returns true if `isCurveContinuous` has been explicitly set.
  var hasIsCurveContinuous: Bool {return self._isCurveContinuous != nil}
  /// Clears the value of `isCurveContinuous`. Subsequent reads from it will return its default value.
  mutating func clearIsCurveContinuous() {self._isCurveContinuous = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ScalarPathSourceType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kTsdroundedRectangle = 0
    case kTsdregularPolygon = 1
    case kTsdchevron = 2

    init() {
      self = .kTsdroundedRectangle
    }

  }

  init() {}

  fileprivate var _type: TSD_ScalarPathSourceArchive.ScalarPathSourceType? = nil
  fileprivate var _scalar: Float? = nil
  fileprivate var _naturalSize: TSP_Size? = nil
  fileprivate var _isCurveContinuous: Bool? = nil
}

struct TSD_BezierPathSourceArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// NOTE: This field was marked as deprecated in the .proto file.
  var pathString: String {
    get {return _pathString ?? String()}
    set {_pathString = newValue}
  }
  /// Returns true if `pathString` has been explicitly set.
  var hasPathString: Bool {return self._pathString != nil}
  /// Clears the value of `pathString`. Subsequent reads from it will return its default value.
  mutating func clearPathString() {self._pathString = nil}

  var naturalSize: TSP_Size {
    get {return _naturalSize ?? TSP_Size()}
    set {_naturalSize = newValue}
  }
  /// Returns true if `naturalSize` has been explicitly set.
  var hasNaturalSize: Bool {return self._naturalSize != nil}
  /// Clears the value of `naturalSize`. Subsequent reads from it will return its default value.
  mutating func clearNaturalSize() {self._naturalSize = nil}

  var path: TSP_Path {
    get {return _path ?? TSP_Path()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {self._path = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pathString: String? = nil
  fileprivate var _naturalSize: TSP_Size? = nil
  fileprivate var _path: TSP_Path? = nil
}

struct TSD_CalloutPathSourceArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var naturalSize: TSP_Size {
    get {return _naturalSize ?? TSP_Size()}
    set {_naturalSize = newValue}
  }
  /// Returns true if `naturalSize` has been explicitly set.
  var hasNaturalSize: Bool {return self._naturalSize != nil}
  /// Clears the value of `naturalSize`. Subsequent reads from it will return its default value.
  mutating func clearNaturalSize() {self._naturalSize = nil}

  var tailPosition: TSP_Point {
    get {return _tailPosition ?? TSP_Point()}
    set {_tailPosition = newValue}
  }
  /// Returns true if `tailPosition` has been explicitly set.
  var hasTailPosition: Bool {return self._tailPosition != nil}
  /// Clears the value of `tailPosition`. Subsequent reads from it will return its default value.
  mutating func clearTailPosition() {self._tailPosition = nil}

  var tailSize: Float {
    get {return _tailSize ?? 0}
    set {_tailSize = newValue}
  }
  /// Returns true if `tailSize` has been explicitly set.
  var hasTailSize: Bool {return self._tailSize != nil}
  /// Clears the value of `tailSize`. Subsequent reads from it will return its default value.
  mutating func clearTailSize() {self._tailSize = nil}

  var cornerRadius: Float {
    get {return _cornerRadius ?? 0}
    set {_cornerRadius = newValue}
  }
  /// Returns true if `cornerRadius` has been explicitly set.
  var hasCornerRadius: Bool {return self._cornerRadius != nil}
  /// Clears the value of `cornerRadius`. Subsequent reads from it will return its default value.
  mutating func clearCornerRadius() {self._cornerRadius = nil}

  var centerTail: Bool {
    get {return _centerTail ?? false}
    set {_centerTail = newValue}
  }
  /// Returns true if `centerTail` has been explicitly set.
  var hasCenterTail: Bool {return self._centerTail != nil}
  /// Clears the value of `centerTail`. Subsequent reads from it will return its default value.
  mutating func clearCenterTail() {self._centerTail = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _naturalSize: TSP_Size? = nil
  fileprivate var _tailPosition: TSP_Point? = nil
  fileprivate var _tailSize: Float? = nil
  fileprivate var _cornerRadius: Float? = nil
  fileprivate var _centerTail: Bool? = nil
}

struct TSD_ConnectionLinePathSourceArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_BezierPathSourceArchive {
    get {return _super ?? TSD_BezierPathSourceArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var type: TSD_ConnectionLinePathSourceArchive.ConnectionLinePathSourceType {
    get {return _type ?? .kTsdconnectionLineTypeQuadratic}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var outsetFrom: Float {
    get {return _outsetFrom ?? 0}
    set {_outsetFrom = newValue}
  }
  /// Returns true if `outsetFrom` has been explicitly set.
  var hasOutsetFrom: Bool {return self._outsetFrom != nil}
  /// Clears the value of `outsetFrom`. Subsequent reads from it will return its default value.
  mutating func clearOutsetFrom() {self._outsetFrom = nil}

  var outsetTo: Float {
    get {return _outsetTo ?? 0}
    set {_outsetTo = newValue}
  }
  /// Returns true if `outsetTo` has been explicitly set.
  var hasOutsetTo: Bool {return self._outsetTo != nil}
  /// Clears the value of `outsetTo`. Subsequent reads from it will return its default value.
  mutating func clearOutsetTo() {self._outsetTo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ConnectionLinePathSourceType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case kTsdconnectionLineTypeQuadratic = 0
    case kTsdconnectionLineTypeOrthogonal = 1

    init() {
      self = .kTsdconnectionLineTypeQuadratic
    }

  }

  init() {}

  fileprivate var _super: TSD_BezierPathSourceArchive? = nil
  fileprivate var _type: TSD_ConnectionLinePathSourceArchive.ConnectionLinePathSourceType? = nil
  fileprivate var _outsetFrom: Float? = nil
  fileprivate var _outsetTo: Float? = nil
}

struct TSD_EditableBezierPathSourceArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subpaths: [TSD_EditableBezierPathSourceArchive.Subpath] = []

  var naturalSize: TSP_Size {
    get {return _naturalSize ?? TSP_Size()}
    set {_naturalSize = newValue}
  }
  /// Returns true if `naturalSize` has been explicitly set.
  var hasNaturalSize: Bool {return self._naturalSize != nil}
  /// Clears the value of `naturalSize`. Subsequent reads from it will return its default value.
  mutating func clearNaturalSize() {self._naturalSize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum NodeType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case sharp = 1
    case bezier = 2
    case smooth = 3

    init() {
      self = .sharp
    }

  }

  struct Node: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var inControlPoint: TSP_Point {
      get {return _inControlPoint ?? TSP_Point()}
      set {_inControlPoint = newValue}
    }
    /// Returns true if `inControlPoint` has been explicitly set.
    var hasInControlPoint: Bool {return self._inControlPoint != nil}
    /// Clears the value of `inControlPoint`. Subsequent reads from it will return its default value.
    mutating func clearInControlPoint() {self._inControlPoint = nil}

    var nodePoint: TSP_Point {
      get {return _nodePoint ?? TSP_Point()}
      set {_nodePoint = newValue}
    }
    /// Returns true if `nodePoint` has been explicitly set.
    var hasNodePoint: Bool {return self._nodePoint != nil}
    /// Clears the value of `nodePoint`. Subsequent reads from it will return its default value.
    mutating func clearNodePoint() {self._nodePoint = nil}

    var outControlPoint: TSP_Point {
      get {return _outControlPoint ?? TSP_Point()}
      set {_outControlPoint = newValue}
    }
    /// Returns true if `outControlPoint` has been explicitly set.
    var hasOutControlPoint: Bool {return self._outControlPoint != nil}
    /// Clears the value of `outControlPoint`. Subsequent reads from it will return its default value.
    mutating func clearOutControlPoint() {self._outControlPoint = nil}

    var type: TSD_EditableBezierPathSourceArchive.NodeType {
      get {return _type ?? .sharp}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _inControlPoint: TSP_Point? = nil
    fileprivate var _nodePoint: TSP_Point? = nil
    fileprivate var _outControlPoint: TSP_Point? = nil
    fileprivate var _type: TSD_EditableBezierPathSourceArchive.NodeType? = nil
  }

  struct Subpath: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nodes: [TSD_EditableBezierPathSourceArchive.Node] = []

    var closed: Bool {
      get {return _closed ?? false}
      set {_closed = newValue}
    }
    /// Returns true if `closed` has been explicitly set.
    var hasClosed: Bool {return self._closed != nil}
    /// Clears the value of `closed`. Subsequent reads from it will return its default value.
    mutating func clearClosed() {self._closed = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _closed: Bool? = nil
  }

  init() {}

  fileprivate var _naturalSize: TSP_Size? = nil
}

struct TSD_PathSourceArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var horizontalFlip: Bool {
    get {return _storage._horizontalFlip ?? false}
    set {_uniqueStorage()._horizontalFlip = newValue}
  }
  /// Returns true if `horizontalFlip` has been explicitly set.
  var hasHorizontalFlip: Bool {return _storage._horizontalFlip != nil}
  /// Clears the value of `horizontalFlip`. Subsequent reads from it will return its default value.
  mutating func clearHorizontalFlip() {_uniqueStorage()._horizontalFlip = nil}

  var verticalFlip: Bool {
    get {return _storage._verticalFlip ?? false}
    set {_uniqueStorage()._verticalFlip = newValue}
  }
  /// Returns true if `verticalFlip` has been explicitly set.
  var hasVerticalFlip: Bool {return _storage._verticalFlip != nil}
  /// Clears the value of `verticalFlip`. Subsequent reads from it will return its default value.
  mutating func clearVerticalFlip() {_uniqueStorage()._verticalFlip = nil}

  var pointPathSource: TSD_PointPathSourceArchive {
    get {return _storage._pointPathSource ?? TSD_PointPathSourceArchive()}
    set {_uniqueStorage()._pointPathSource = newValue}
  }
  /// Returns true if `pointPathSource` has been explicitly set.
  var hasPointPathSource: Bool {return _storage._pointPathSource != nil}
  /// Clears the value of `pointPathSource`. Subsequent reads from it will return its default value.
  mutating func clearPointPathSource() {_uniqueStorage()._pointPathSource = nil}

  var scalarPathSource: TSD_ScalarPathSourceArchive {
    get {return _storage._scalarPathSource ?? TSD_ScalarPathSourceArchive()}
    set {_uniqueStorage()._scalarPathSource = newValue}
  }
  /// Returns true if `scalarPathSource` has been explicitly set.
  var hasScalarPathSource: Bool {return _storage._scalarPathSource != nil}
  /// Clears the value of `scalarPathSource`. Subsequent reads from it will return its default value.
  mutating func clearScalarPathSource() {_uniqueStorage()._scalarPathSource = nil}

  var bezierPathSource: TSD_BezierPathSourceArchive {
    get {return _storage._bezierPathSource ?? TSD_BezierPathSourceArchive()}
    set {_uniqueStorage()._bezierPathSource = newValue}
  }
  /// Returns true if `bezierPathSource` has been explicitly set.
  var hasBezierPathSource: Bool {return _storage._bezierPathSource != nil}
  /// Clears the value of `bezierPathSource`. Subsequent reads from it will return its default value.
  mutating func clearBezierPathSource() {_uniqueStorage()._bezierPathSource = nil}

  var calloutPathSource: TSD_CalloutPathSourceArchive {
    get {return _storage._calloutPathSource ?? TSD_CalloutPathSourceArchive()}
    set {_uniqueStorage()._calloutPathSource = newValue}
  }
  /// Returns true if `calloutPathSource` has been explicitly set.
  var hasCalloutPathSource: Bool {return _storage._calloutPathSource != nil}
  /// Clears the value of `calloutPathSource`. Subsequent reads from it will return its default value.
  mutating func clearCalloutPathSource() {_uniqueStorage()._calloutPathSource = nil}

  var connectionLinePathSource: TSD_ConnectionLinePathSourceArchive {
    get {return _storage._connectionLinePathSource ?? TSD_ConnectionLinePathSourceArchive()}
    set {_uniqueStorage()._connectionLinePathSource = newValue}
  }
  /// Returns true if `connectionLinePathSource` has been explicitly set.
  var hasConnectionLinePathSource: Bool {return _storage._connectionLinePathSource != nil}
  /// Clears the value of `connectionLinePathSource`. Subsequent reads from it will return its default value.
  mutating func clearConnectionLinePathSource() {_uniqueStorage()._connectionLinePathSource = nil}

  var editableBezierPathSource: TSD_EditableBezierPathSourceArchive {
    get {return _storage._editableBezierPathSource ?? TSD_EditableBezierPathSourceArchive()}
    set {_uniqueStorage()._editableBezierPathSource = newValue}
  }
  /// Returns true if `editableBezierPathSource` has been explicitly set.
  var hasEditableBezierPathSource: Bool {return _storage._editableBezierPathSource != nil}
  /// Clears the value of `editableBezierPathSource`. Subsequent reads from it will return its default value.
  mutating func clearEditableBezierPathSource() {_uniqueStorage()._editableBezierPathSource = nil}

  var localizationKey: String {
    get {return _storage._localizationKey ?? String()}
    set {_uniqueStorage()._localizationKey = newValue}
  }
  /// Returns true if `localizationKey` has been explicitly set.
  var hasLocalizationKey: Bool {return _storage._localizationKey != nil}
  /// Clears the value of `localizationKey`. Subsequent reads from it will return its default value.
  mutating func clearLocalizationKey() {_uniqueStorage()._localizationKey = nil}

  var userDefinedName: String {
    get {return _storage._userDefinedName ?? String()}
    set {_uniqueStorage()._userDefinedName = newValue}
  }
  /// Returns true if `userDefinedName` has been explicitly set.
  var hasUserDefinedName: Bool {return _storage._userDefinedName != nil}
  /// Clears the value of `userDefinedName`. Subsequent reads from it will return its default value.
  mutating func clearUserDefinedName() {_uniqueStorage()._userDefinedName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_AngleGradientArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gradientangle: Float {
    get {return _gradientangle ?? 0}
    set {_gradientangle = newValue}
  }
  /// Returns true if `gradientangle` has been explicitly set.
  var hasGradientangle: Bool {return self._gradientangle != nil}
  /// Clears the value of `gradientangle`. Subsequent reads from it will return its default value.
  mutating func clearGradientangle() {self._gradientangle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _gradientangle: Float? = nil
}

struct TSD_TransformGradientArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var start: TSP_Point {
    get {return _start ?? TSP_Point()}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  mutating func clearStart() {self._start = nil}

  var end: TSP_Point {
    get {return _end ?? TSP_Point()}
    set {_end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  var hasEnd: Bool {return self._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  mutating func clearEnd() {self._end = nil}

  var baseNaturalSize: TSP_Size {
    get {return _baseNaturalSize ?? TSP_Size()}
    set {_baseNaturalSize = newValue}
  }
  /// Returns true if `baseNaturalSize` has been explicitly set.
  var hasBaseNaturalSize: Bool {return self._baseNaturalSize != nil}
  /// Clears the value of `baseNaturalSize`. Subsequent reads from it will return its default value.
  mutating func clearBaseNaturalSize() {self._baseNaturalSize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _start: TSP_Point? = nil
  fileprivate var _end: TSP_Point? = nil
  fileprivate var _baseNaturalSize: TSP_Size? = nil
}

struct TSD_GradientArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: TSD_GradientArchive.GradientType {
    get {return _type ?? .linear}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var stops: [TSD_GradientArchive.GradientStop] = []

  var opacity: Float {
    get {return _opacity ?? 0}
    set {_opacity = newValue}
  }
  /// Returns true if `opacity` has been explicitly set.
  var hasOpacity: Bool {return self._opacity != nil}
  /// Clears the value of `opacity`. Subsequent reads from it will return its default value.
  mutating func clearOpacity() {self._opacity = nil}

  var advancedGradient: Bool {
    get {return _advancedGradient ?? false}
    set {_advancedGradient = newValue}
  }
  /// Returns true if `advancedGradient` has been explicitly set.
  var hasAdvancedGradient: Bool {return self._advancedGradient != nil}
  /// Clears the value of `advancedGradient`. Subsequent reads from it will return its default value.
  mutating func clearAdvancedGradient() {self._advancedGradient = nil}

  var anglegradient: TSD_AngleGradientArchive {
    get {return _anglegradient ?? TSD_AngleGradientArchive()}
    set {_anglegradient = newValue}
  }
  /// Returns true if `anglegradient` has been explicitly set.
  var hasAnglegradient: Bool {return self._anglegradient != nil}
  /// Clears the value of `anglegradient`. Subsequent reads from it will return its default value.
  mutating func clearAnglegradient() {self._anglegradient = nil}

  var transformgradient: TSD_TransformGradientArchive {
    get {return _transformgradient ?? TSD_TransformGradientArchive()}
    set {_transformgradient = newValue}
  }
  /// Returns true if `transformgradient` has been explicitly set.
  var hasTransformgradient: Bool {return self._transformgradient != nil}
  /// Clears the value of `transformgradient`. Subsequent reads from it will return its default value.
  mutating func clearTransformgradient() {self._transformgradient = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum GradientType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case linear = 0
    case radial = 1

    init() {
      self = .linear
    }

  }

  struct GradientStop: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var color: TSP_Color {
      get {return _color ?? TSP_Color()}
      set {_color = newValue}
    }
    /// Returns true if `color` has been explicitly set.
    var hasColor: Bool {return self._color != nil}
    /// Clears the value of `color`. Subsequent reads from it will return its default value.
    mutating func clearColor() {self._color = nil}

    var fraction: Float {
      get {return _fraction ?? 0}
      set {_fraction = newValue}
    }
    /// Returns true if `fraction` has been explicitly set.
    var hasFraction: Bool {return self._fraction != nil}
    /// Clears the value of `fraction`. Subsequent reads from it will return its default value.
    mutating func clearFraction() {self._fraction = nil}

    var inflection: Float {
      get {return _inflection ?? 0}
      set {_inflection = newValue}
    }
    /// Returns true if `inflection` has been explicitly set.
    var hasInflection: Bool {return self._inflection != nil}
    /// Clears the value of `inflection`. Subsequent reads from it will return its default value.
    mutating func clearInflection() {self._inflection = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _color: TSP_Color? = nil
    fileprivate var _fraction: Float? = nil
    fileprivate var _inflection: Float? = nil
  }

  init() {}

  fileprivate var _type: TSD_GradientArchive.GradientType? = nil
  fileprivate var _opacity: Float? = nil
  fileprivate var _advancedGradient: Bool? = nil
  fileprivate var _anglegradient: TSD_AngleGradientArchive? = nil
  fileprivate var _transformgradient: TSD_TransformGradientArchive? = nil
}

struct TSD_ImageFillArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var imagedata: TSP_DataReference {
    get {return _storage._imagedata ?? TSP_DataReference()}
    set {_uniqueStorage()._imagedata = newValue}
  }
  /// Returns true if `imagedata` has been explicitly set.
  var hasImagedata: Bool {return _storage._imagedata != nil}
  /// Clears the value of `imagedata`. Subsequent reads from it will return its default value.
  mutating func clearImagedata() {_uniqueStorage()._imagedata = nil}

  var technique: TSD_ImageFillArchive.ImageFillTechnique {
    get {return _storage._technique ?? .naturalSize}
    set {_uniqueStorage()._technique = newValue}
  }
  /// Returns true if `technique` has been explicitly set.
  var hasTechnique: Bool {return _storage._technique != nil}
  /// Clears the value of `technique`. Subsequent reads from it will return its default value.
  mutating func clearTechnique() {_uniqueStorage()._technique = nil}

  var tint: TSP_Color {
    get {return _storage._tint ?? TSP_Color()}
    set {_uniqueStorage()._tint = newValue}
  }
  /// Returns true if `tint` has been explicitly set.
  var hasTint: Bool {return _storage._tint != nil}
  /// Clears the value of `tint`. Subsequent reads from it will return its default value.
  mutating func clearTint() {_uniqueStorage()._tint = nil}

  var fillsize: TSP_Size {
    get {return _storage._fillsize ?? TSP_Size()}
    set {_uniqueStorage()._fillsize = newValue}
  }
  /// Returns true if `fillsize` has been explicitly set.
  var hasFillsize: Bool {return _storage._fillsize != nil}
  /// Clears the value of `fillsize`. Subsequent reads from it will return its default value.
  mutating func clearFillsize() {_uniqueStorage()._fillsize = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var originalimagedata: TSP_DataReference {
    get {return _storage._originalimagedata ?? TSP_DataReference()}
    set {_uniqueStorage()._originalimagedata = newValue}
  }
  /// Returns true if `originalimagedata` has been explicitly set.
  var hasOriginalimagedata: Bool {return _storage._originalimagedata != nil}
  /// Clears the value of `originalimagedata`. Subsequent reads from it will return its default value.
  mutating func clearOriginalimagedata() {_uniqueStorage()._originalimagedata = nil}

  var interpretsUntaggedImageDataAsGeneric: Bool {
    get {return _storage._interpretsUntaggedImageDataAsGeneric ?? false}
    set {_uniqueStorage()._interpretsUntaggedImageDataAsGeneric = newValue}
  }
  /// Returns true if `interpretsUntaggedImageDataAsGeneric` has been explicitly set.
  var hasInterpretsUntaggedImageDataAsGeneric: Bool {return _storage._interpretsUntaggedImageDataAsGeneric != nil}
  /// Clears the value of `interpretsUntaggedImageDataAsGeneric`. Subsequent reads from it will return its default value.
  mutating func clearInterpretsUntaggedImageDataAsGeneric() {_uniqueStorage()._interpretsUntaggedImageDataAsGeneric = nil}

  var referencecolor: TSP_Color {
    get {return _storage._referencecolor ?? TSP_Color()}
    set {_uniqueStorage()._referencecolor = newValue}
  }
  /// Returns true if `referencecolor` has been explicitly set.
  var hasReferencecolor: Bool {return _storage._referencecolor != nil}
  /// Clears the value of `referencecolor`. Subsequent reads from it will return its default value.
  mutating func clearReferencecolor() {_uniqueStorage()._referencecolor = nil}

  var databaseImagedata: TSP_Reference {
    get {return _storage._databaseImagedata ?? TSP_Reference()}
    set {_uniqueStorage()._databaseImagedata = newValue}
  }
  /// Returns true if `databaseImagedata` has been explicitly set.
  var hasDatabaseImagedata: Bool {return _storage._databaseImagedata != nil}
  /// Clears the value of `databaseImagedata`. Subsequent reads from it will return its default value.
  mutating func clearDatabaseImagedata() {_uniqueStorage()._databaseImagedata = nil}

  var databaseOriginalimagedata: TSP_Reference {
    get {return _storage._databaseOriginalimagedata ?? TSP_Reference()}
    set {_uniqueStorage()._databaseOriginalimagedata = newValue}
  }
  /// Returns true if `databaseOriginalimagedata` has been explicitly set.
  var hasDatabaseOriginalimagedata: Bool {return _storage._databaseOriginalimagedata != nil}
  /// Clears the value of `databaseOriginalimagedata`. Subsequent reads from it will return its default value.
  mutating func clearDatabaseOriginalimagedata() {_uniqueStorage()._databaseOriginalimagedata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ImageFillTechnique: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case naturalSize = 0
    case stretch = 1
    case tile = 2
    case scaleToFill = 3
    case scaleToFit = 4

    init() {
      self = .naturalSize
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_FillArchive: SwiftProtobuf.ExtensibleMessage, @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var color: TSP_Color {
    get {return _storage._color ?? TSP_Color()}
    set {_uniqueStorage()._color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return _storage._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {_uniqueStorage()._color = nil}

  var gradient: TSD_GradientArchive {
    get {return _storage._gradient ?? TSD_GradientArchive()}
    set {_uniqueStorage()._gradient = newValue}
  }
  /// Returns true if `gradient` has been explicitly set.
  var hasGradient: Bool {return _storage._gradient != nil}
  /// Clears the value of `gradient`. Subsequent reads from it will return its default value.
  mutating func clearGradient() {_uniqueStorage()._gradient = nil}

  var image: TSD_ImageFillArchive {
    get {return _storage._image ?? TSD_ImageFillArchive()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {_uniqueStorage()._image = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_StrokePatternArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: TSD_StrokePatternArchive.StrokePatternType {
    get {return _type ?? .tsdpattern}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var phase: Float {
    get {return _phase ?? 0}
    set {_phase = newValue}
  }
  /// Returns true if `phase` has been explicitly set.
  var hasPhase: Bool {return self._phase != nil}
  /// Clears the value of `phase`. Subsequent reads from it will return its default value.
  mutating func clearPhase() {self._phase = nil}

  var count: UInt32 {
    get {return _count ?? 0}
    set {_count = newValue}
  }
  /// Returns true if `count` has been explicitly set.
  var hasCount: Bool {return self._count != nil}
  /// Clears the value of `count`. Subsequent reads from it will return its default value.
  mutating func clearCount() {self._count = nil}

  var pattern: [Float] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum StrokePatternType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case tsdpattern = 0
    case tsdsolidPattern = 1
    case tsdemptyPattern = 2

    init() {
      self = .tsdpattern
    }

  }

  init() {}

  fileprivate var _type: TSD_StrokePatternArchive.StrokePatternType? = nil
  fileprivate var _phase: Float? = nil
  fileprivate var _count: UInt32? = nil
}

struct TSD_StrokeArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var color: TSP_Color {
    get {return _storage._color ?? TSP_Color()}
    set {_uniqueStorage()._color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return _storage._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {_uniqueStorage()._color = nil}

  var width: Float {
    get {return _storage._width ?? 0}
    set {_uniqueStorage()._width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  var hasWidth: Bool {return _storage._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  mutating func clearWidth() {_uniqueStorage()._width = nil}

  var cap: TSD_StrokeArchive.LineCap {
    get {return _storage._cap ?? .buttCap}
    set {_uniqueStorage()._cap = newValue}
  }
  /// Returns true if `cap` has been explicitly set.
  var hasCap: Bool {return _storage._cap != nil}
  /// Clears the value of `cap`. Subsequent reads from it will return its default value.
  mutating func clearCap() {_uniqueStorage()._cap = nil}

  var join: TSD_LineJoin {
    get {return _storage._join ?? .miterJoin}
    set {_uniqueStorage()._join = newValue}
  }
  /// Returns true if `join` has been explicitly set.
  var hasJoin: Bool {return _storage._join != nil}
  /// Clears the value of `join`. Subsequent reads from it will return its default value.
  mutating func clearJoin() {_uniqueStorage()._join = nil}

  var miterLimit: Float {
    get {return _storage._miterLimit ?? 0}
    set {_uniqueStorage()._miterLimit = newValue}
  }
  /// Returns true if `miterLimit` has been explicitly set.
  var hasMiterLimit: Bool {return _storage._miterLimit != nil}
  /// Clears the value of `miterLimit`. Subsequent reads from it will return its default value.
  mutating func clearMiterLimit() {_uniqueStorage()._miterLimit = nil}

  var pattern: TSD_StrokePatternArchive {
    get {return _storage._pattern ?? TSD_StrokePatternArchive()}
    set {_uniqueStorage()._pattern = newValue}
  }
  /// Returns true if `pattern` has been explicitly set.
  var hasPattern: Bool {return _storage._pattern != nil}
  /// Clears the value of `pattern`. Subsequent reads from it will return its default value.
  mutating func clearPattern() {_uniqueStorage()._pattern = nil}

  var smartStroke: TSD_SmartStrokeArchive {
    get {return _storage._smartStroke ?? TSD_SmartStrokeArchive()}
    set {_uniqueStorage()._smartStroke = newValue}
  }
  /// Returns true if `smartStroke` has been explicitly set.
  var hasSmartStroke: Bool {return _storage._smartStroke != nil}
  /// Clears the value of `smartStroke`. Subsequent reads from it will return its default value.
  mutating func clearSmartStroke() {_uniqueStorage()._smartStroke = nil}

  var frame: TSD_FrameArchive {
    get {return _storage._frame ?? TSD_FrameArchive()}
    set {_uniqueStorage()._frame = newValue}
  }
  /// Returns true if `frame` has been explicitly set.
  var hasFrame: Bool {return _storage._frame != nil}
  /// Clears the value of `frame`. Subsequent reads from it will return its default value.
  mutating func clearFrame() {_uniqueStorage()._frame = nil}

  var patternedStroke: TSD_PatternedStrokeArchive {
    get {return _storage._patternedStroke ?? TSD_PatternedStrokeArchive()}
    set {_uniqueStorage()._patternedStroke = newValue}
  }
  /// Returns true if `patternedStroke` has been explicitly set.
  var hasPatternedStroke: Bool {return _storage._patternedStroke != nil}
  /// Clears the value of `patternedStroke`. Subsequent reads from it will return its default value.
  mutating func clearPatternedStroke() {_uniqueStorage()._patternedStroke = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum LineCap: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case buttCap = 0
    case roundCap = 1
    case squareCap = 2

    init() {
      self = .buttCap
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_SmartStrokeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var strokeName: String {
    get {return _strokeName ?? String()}
    set {_strokeName = newValue}
  }
  /// Returns true if `strokeName` has been explicitly set.
  var hasStrokeName: Bool {return self._strokeName != nil}
  /// Clears the value of `strokeName`. Subsequent reads from it will return its default value.
  mutating func clearStrokeName() {self._strokeName = nil}

  var randomSeed: UInt32 {
    get {return _randomSeed ?? 0}
    set {_randomSeed = newValue}
  }
  /// Returns true if `randomSeed` has been explicitly set.
  var hasRandomSeed: Bool {return self._randomSeed != nil}
  /// Clears the value of `randomSeed`. Subsequent reads from it will return its default value.
  mutating func clearRandomSeed() {self._randomSeed = nil}

  var parameterValues: TSP_ReferenceDictionary {
    get {return _parameterValues ?? TSP_ReferenceDictionary()}
    set {_parameterValues = newValue}
  }
  /// Returns true if `parameterValues` has been explicitly set.
  var hasParameterValues: Bool {return self._parameterValues != nil}
  /// Clears the value of `parameterValues`. Subsequent reads from it will return its default value.
  mutating func clearParameterValues() {self._parameterValues = nil}

  var patternOffsetDistance: Double {
    get {return _patternOffsetDistance ?? 0}
    set {_patternOffsetDistance = newValue}
  }
  /// Returns true if `patternOffsetDistance` has been explicitly set.
  var hasPatternOffsetDistance: Bool {return self._patternOffsetDistance != nil}
  /// Clears the value of `patternOffsetDistance`. Subsequent reads from it will return its default value.
  mutating func clearPatternOffsetDistance() {self._patternOffsetDistance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _strokeName: String? = nil
  fileprivate var _randomSeed: UInt32? = nil
  fileprivate var _parameterValues: TSP_ReferenceDictionary? = nil
  fileprivate var _patternOffsetDistance: Double? = nil
}

struct TSD_FrameArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var frameName: String {
    get {return _frameName ?? String()}
    set {_frameName = newValue}
  }
  /// Returns true if `frameName` has been explicitly set.
  var hasFrameName: Bool {return self._frameName != nil}
  /// Clears the value of `frameName`. Subsequent reads from it will return its default value.
  mutating func clearFrameName() {self._frameName = nil}

  var assetScale: Float {
    get {return _assetScale ?? 0}
    set {_assetScale = newValue}
  }
  /// Returns true if `assetScale` has been explicitly set.
  var hasAssetScale: Bool {return self._assetScale != nil}
  /// Clears the value of `assetScale`. Subsequent reads from it will return its default value.
  mutating func clearAssetScale() {self._assetScale = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _frameName: String? = nil
  fileprivate var _assetScale: Float? = nil
}

struct TSD_PatternedStrokeArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var patternName: String {
    get {return _patternName ?? String()}
    set {_patternName = newValue}
  }
  /// Returns true if `patternName` has been explicitly set.
  var hasPatternName: Bool {return self._patternName != nil}
  /// Clears the value of `patternName`. Subsequent reads from it will return its default value.
  mutating func clearPatternName() {self._patternName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _patternName: String? = nil
}

struct TSD_LineEndArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var path: TSP_Path {
    get {return _path ?? TSP_Path()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {self._path = nil}

  var lineJoin: TSD_LineJoin {
    get {return _lineJoin ?? .miterJoin}
    set {_lineJoin = newValue}
  }
  /// Returns true if `lineJoin` has been explicitly set.
  var hasLineJoin: Bool {return self._lineJoin != nil}
  /// Clears the value of `lineJoin`. Subsequent reads from it will return its default value.
  mutating func clearLineJoin() {self._lineJoin = nil}

  var endPoint: TSP_Point {
    get {return _endPoint ?? TSP_Point()}
    set {_endPoint = newValue}
  }
  /// Returns true if `endPoint` has been explicitly set.
  var hasEndPoint: Bool {return self._endPoint != nil}
  /// Clears the value of `endPoint`. Subsequent reads from it will return its default value.
  mutating func clearEndPoint() {self._endPoint = nil}

  var isFilled: Bool {
    get {return _isFilled ?? false}
    set {_isFilled = newValue}
  }
  /// Returns true if `isFilled` has been explicitly set.
  var hasIsFilled: Bool {return self._isFilled != nil}
  /// Clears the value of `isFilled`. Subsequent reads from it will return its default value.
  mutating func clearIsFilled() {self._isFilled = nil}

  var identifier: String {
    get {return _identifier ?? String()}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {self._identifier = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _path: TSP_Path? = nil
  fileprivate var _lineJoin: TSD_LineJoin? = nil
  fileprivate var _endPoint: TSP_Point? = nil
  fileprivate var _isFilled: Bool? = nil
  fileprivate var _identifier: String? = nil
}

struct TSD_ShadowArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var color: TSP_Color {
    get {return _storage._color ?? TSP_Color()}
    set {_uniqueStorage()._color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return _storage._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {_uniqueStorage()._color = nil}

  var angle: Float {
    get {return _storage._angle ?? 315}
    set {_uniqueStorage()._angle = newValue}
  }
  /// Returns true if `angle` has been explicitly set.
  var hasAngle: Bool {return _storage._angle != nil}
  /// Clears the value of `angle`. Subsequent reads from it will return its default value.
  mutating func clearAngle() {_uniqueStorage()._angle = nil}

  var offset: Float {
    get {return _storage._offset ?? 5}
    set {_uniqueStorage()._offset = newValue}
  }
  /// Returns true if `offset` has been explicitly set.
  var hasOffset: Bool {return _storage._offset != nil}
  /// Clears the value of `offset`. Subsequent reads from it will return its default value.
  mutating func clearOffset() {_uniqueStorage()._offset = nil}

  var radius: Int32 {
    get {return _storage._radius ?? 1}
    set {_uniqueStorage()._radius = newValue}
  }
  /// Returns true if `radius` has been explicitly set.
  var hasRadius: Bool {return _storage._radius != nil}
  /// Clears the value of `radius`. Subsequent reads from it will return its default value.
  mutating func clearRadius() {_uniqueStorage()._radius = nil}

  var opacity: Float {
    get {return _storage._opacity ?? 1}
    set {_uniqueStorage()._opacity = newValue}
  }
  /// Returns true if `opacity` has been explicitly set.
  var hasOpacity: Bool {return _storage._opacity != nil}
  /// Clears the value of `opacity`. Subsequent reads from it will return its default value.
  mutating func clearOpacity() {_uniqueStorage()._opacity = nil}

  var isEnabled: Bool {
    get {return _storage._isEnabled ?? true}
    set {_uniqueStorage()._isEnabled = newValue}
  }
  /// Returns true if `isEnabled` has been explicitly set.
  var hasIsEnabled: Bool {return _storage._isEnabled != nil}
  /// Clears the value of `isEnabled`. Subsequent reads from it will return its default value.
  mutating func clearIsEnabled() {_uniqueStorage()._isEnabled = nil}

  var type: TSD_ShadowArchive.ShadowType {
    get {return _storage._type ?? .tsddropShadow}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  var dropShadow: TSD_DropShadowArchive {
    get {return _storage._dropShadow ?? TSD_DropShadowArchive()}
    set {_uniqueStorage()._dropShadow = newValue}
  }
  /// Returns true if `dropShadow` has been explicitly set.
  var hasDropShadow: Bool {return _storage._dropShadow != nil}
  /// Clears the value of `dropShadow`. Subsequent reads from it will return its default value.
  mutating func clearDropShadow() {_uniqueStorage()._dropShadow = nil}

  var contactShadow: TSD_ContactShadowArchive {
    get {return _storage._contactShadow ?? TSD_ContactShadowArchive()}
    set {_uniqueStorage()._contactShadow = newValue}
  }
  /// Returns true if `contactShadow` has been explicitly set.
  var hasContactShadow: Bool {return _storage._contactShadow != nil}
  /// Clears the value of `contactShadow`. Subsequent reads from it will return its default value.
  mutating func clearContactShadow() {_uniqueStorage()._contactShadow = nil}

  var curvedShadow: TSD_CurvedShadowArchive {
    get {return _storage._curvedShadow ?? TSD_CurvedShadowArchive()}
    set {_uniqueStorage()._curvedShadow = newValue}
  }
  /// Returns true if `curvedShadow` has been explicitly set.
  var hasCurvedShadow: Bool {return _storage._curvedShadow != nil}
  /// Clears the value of `curvedShadow`. Subsequent reads from it will return its default value.
  mutating func clearCurvedShadow() {_uniqueStorage()._curvedShadow = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ShadowType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case tsddropShadow = 0
    case tsdcontactShadow = 1
    case tsdcurvedShadow = 2

    init() {
      self = .tsddropShadow
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_DropShadowArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSD_ContactShadowArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var height: Float {
    get {return _height ?? 0.2}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {self._height = nil}

  var offset: Float {
    get {return _offset ?? 0}
    set {_offset = newValue}
  }
  /// Returns true if `offset` has been explicitly set.
  var hasOffset: Bool {return self._offset != nil}
  /// Clears the value of `offset`. Subsequent reads from it will return its default value.
  mutating func clearOffset() {self._offset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _height: Float? = nil
  fileprivate var _offset: Float? = nil
}

struct TSD_CurvedShadowArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var curve: Float {
    get {return _curve ?? 0.6}
    set {_curve = newValue}
  }
  /// Returns true if `curve` has been explicitly set.
  var hasCurve: Bool {return self._curve != nil}
  /// Clears the value of `curve`. Subsequent reads from it will return its default value.
  mutating func clearCurve() {self._curve = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _curve: Float? = nil
}

struct TSD_ReflectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var opacity: Float {
    get {return _opacity ?? 0.5}
    set {_opacity = newValue}
  }
  /// Returns true if `opacity` has been explicitly set.
  var hasOpacity: Bool {return self._opacity != nil}
  /// Clears the value of `opacity`. Subsequent reads from it will return its default value.
  mutating func clearOpacity() {self._opacity = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _opacity: Float? = nil
}

struct TSD_ImageAdjustmentsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var exposure: Float {
    get {return _exposure ?? 0}
    set {_exposure = newValue}
  }
  /// Returns true if `exposure` has been explicitly set.
  var hasExposure: Bool {return self._exposure != nil}
  /// Clears the value of `exposure`. Subsequent reads from it will return its default value.
  mutating func clearExposure() {self._exposure = nil}

  var saturation: Float {
    get {return _saturation ?? 0}
    set {_saturation = newValue}
  }
  /// Returns true if `saturation` has been explicitly set.
  var hasSaturation: Bool {return self._saturation != nil}
  /// Clears the value of `saturation`. Subsequent reads from it will return its default value.
  mutating func clearSaturation() {self._saturation = nil}

  var contrast: Float {
    get {return _contrast ?? 0}
    set {_contrast = newValue}
  }
  /// Returns true if `contrast` has been explicitly set.
  var hasContrast: Bool {return self._contrast != nil}
  /// Clears the value of `contrast`. Subsequent reads from it will return its default value.
  mutating func clearContrast() {self._contrast = nil}

  var highlights: Float {
    get {return _highlights ?? 0}
    set {_highlights = newValue}
  }
  /// Returns true if `highlights` has been explicitly set.
  var hasHighlights: Bool {return self._highlights != nil}
  /// Clears the value of `highlights`. Subsequent reads from it will return its default value.
  mutating func clearHighlights() {self._highlights = nil}

  var shadows: Float {
    get {return _shadows ?? 0}
    set {_shadows = newValue}
  }
  /// Returns true if `shadows` has been explicitly set.
  var hasShadows: Bool {return self._shadows != nil}
  /// Clears the value of `shadows`. Subsequent reads from it will return its default value.
  mutating func clearShadows() {self._shadows = nil}

  var sharpness: Float {
    get {return _sharpness ?? 0}
    set {_sharpness = newValue}
  }
  /// Returns true if `sharpness` has been explicitly set.
  var hasSharpness: Bool {return self._sharpness != nil}
  /// Clears the value of `sharpness`. Subsequent reads from it will return its default value.
  mutating func clearSharpness() {self._sharpness = nil}

  var denoise: Float {
    get {return _denoise ?? 0}
    set {_denoise = newValue}
  }
  /// Returns true if `denoise` has been explicitly set.
  var hasDenoise: Bool {return self._denoise != nil}
  /// Clears the value of `denoise`. Subsequent reads from it will return its default value.
  mutating func clearDenoise() {self._denoise = nil}

  var temperature: Float {
    get {return _temperature ?? 0}
    set {_temperature = newValue}
  }
  /// Returns true if `temperature` has been explicitly set.
  var hasTemperature: Bool {return self._temperature != nil}
  /// Clears the value of `temperature`. Subsequent reads from it will return its default value.
  mutating func clearTemperature() {self._temperature = nil}

  var tint: Float {
    get {return _tint ?? 0}
    set {_tint = newValue}
  }
  /// Returns true if `tint` has been explicitly set.
  var hasTint: Bool {return self._tint != nil}
  /// Clears the value of `tint`. Subsequent reads from it will return its default value.
  mutating func clearTint() {self._tint = nil}

  var bottomLevel: Float {
    get {return _bottomLevel ?? 0}
    set {_bottomLevel = newValue}
  }
  /// Returns true if `bottomLevel` has been explicitly set.
  var hasBottomLevel: Bool {return self._bottomLevel != nil}
  /// Clears the value of `bottomLevel`. Subsequent reads from it will return its default value.
  mutating func clearBottomLevel() {self._bottomLevel = nil}

  var topLevel: Float {
    get {return _topLevel ?? 1}
    set {_topLevel = newValue}
  }
  /// Returns true if `topLevel` has been explicitly set.
  var hasTopLevel: Bool {return self._topLevel != nil}
  /// Clears the value of `topLevel`. Subsequent reads from it will return its default value.
  mutating func clearTopLevel() {self._topLevel = nil}

  var gamma: Float {
    get {return _gamma ?? 0}
    set {_gamma = newValue}
  }
  /// Returns true if `gamma` has been explicitly set.
  var hasGamma: Bool {return self._gamma != nil}
  /// Clears the value of `gamma`. Subsequent reads from it will return its default value.
  mutating func clearGamma() {self._gamma = nil}

  var enhance: Bool {
    get {return _enhance ?? false}
    set {_enhance = newValue}
  }
  /// Returns true if `enhance` has been explicitly set.
  var hasEnhance: Bool {return self._enhance != nil}
  /// Clears the value of `enhance`. Subsequent reads from it will return its default value.
  mutating func clearEnhance() {self._enhance = nil}

  var representsSageAdjustments: Bool {
    get {return _representsSageAdjustments ?? false}
    set {_representsSageAdjustments = newValue}
  }
  /// Returns true if `representsSageAdjustments` has been explicitly set.
  var hasRepresentsSageAdjustments: Bool {return self._representsSageAdjustments != nil}
  /// Clears the value of `representsSageAdjustments`. Subsequent reads from it will return its default value.
  mutating func clearRepresentsSageAdjustments() {self._representsSageAdjustments = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _exposure: Float? = nil
  fileprivate var _saturation: Float? = nil
  fileprivate var _contrast: Float? = nil
  fileprivate var _highlights: Float? = nil
  fileprivate var _shadows: Float? = nil
  fileprivate var _sharpness: Float? = nil
  fileprivate var _denoise: Float? = nil
  fileprivate var _temperature: Float? = nil
  fileprivate var _tint: Float? = nil
  fileprivate var _bottomLevel: Float? = nil
  fileprivate var _topLevel: Float? = nil
  fileprivate var _gamma: Float? = nil
  fileprivate var _enhance: Bool? = nil
  fileprivate var _representsSageAdjustments: Bool? = nil
}

struct TSD_ShapeStylePropertiesArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fill: TSD_FillArchive {
    get {return _storage._fill ?? TSD_FillArchive()}
    set {_uniqueStorage()._fill = newValue}
  }
  /// Returns true if `fill` has been explicitly set.
  var hasFill: Bool {return _storage._fill != nil}
  /// Clears the value of `fill`. Subsequent reads from it will return its default value.
  mutating func clearFill() {_uniqueStorage()._fill = nil}

  var stroke: TSD_StrokeArchive {
    get {return _storage._stroke ?? TSD_StrokeArchive()}
    set {_uniqueStorage()._stroke = newValue}
  }
  /// Returns true if `stroke` has been explicitly set.
  var hasStroke: Bool {return _storage._stroke != nil}
  /// Clears the value of `stroke`. Subsequent reads from it will return its default value.
  mutating func clearStroke() {_uniqueStorage()._stroke = nil}

  var opacity: Float {
    get {return _storage._opacity ?? 0}
    set {_uniqueStorage()._opacity = newValue}
  }
  /// Returns true if `opacity` has been explicitly set.
  var hasOpacity: Bool {return _storage._opacity != nil}
  /// Clears the value of `opacity`. Subsequent reads from it will return its default value.
  mutating func clearOpacity() {_uniqueStorage()._opacity = nil}

  var shadow: TSD_ShadowArchive {
    get {return _storage._shadow ?? TSD_ShadowArchive()}
    set {_uniqueStorage()._shadow = newValue}
  }
  /// Returns true if `shadow` has been explicitly set.
  var hasShadow: Bool {return _storage._shadow != nil}
  /// Clears the value of `shadow`. Subsequent reads from it will return its default value.
  mutating func clearShadow() {_uniqueStorage()._shadow = nil}

  var reflection: TSD_ReflectionArchive {
    get {return _storage._reflection ?? TSD_ReflectionArchive()}
    set {_uniqueStorage()._reflection = newValue}
  }
  /// Returns true if `reflection` has been explicitly set.
  var hasReflection: Bool {return _storage._reflection != nil}
  /// Clears the value of `reflection`. Subsequent reads from it will return its default value.
  mutating func clearReflection() {_uniqueStorage()._reflection = nil}

  var headLineEnd: TSD_LineEndArchive {
    get {return _storage._headLineEnd ?? TSD_LineEndArchive()}
    set {_uniqueStorage()._headLineEnd = newValue}
  }
  /// Returns true if `headLineEnd` has been explicitly set.
  var hasHeadLineEnd: Bool {return _storage._headLineEnd != nil}
  /// Clears the value of `headLineEnd`. Subsequent reads from it will return its default value.
  mutating func clearHeadLineEnd() {_uniqueStorage()._headLineEnd = nil}

  var tailLineEnd: TSD_LineEndArchive {
    get {return _storage._tailLineEnd ?? TSD_LineEndArchive()}
    set {_uniqueStorage()._tailLineEnd = newValue}
  }
  /// Returns true if `tailLineEnd` has been explicitly set.
  var hasTailLineEnd: Bool {return _storage._tailLineEnd != nil}
  /// Clears the value of `tailLineEnd`. Subsequent reads from it will return its default value.
  mutating func clearTailLineEnd() {_uniqueStorage()._tailLineEnd = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_ShapeStyleArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_StyleArchive {
    get {return _super ?? TSS_StyleArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var overrideCount: UInt32 {
    get {return _overrideCount ?? 0}
    set {_overrideCount = newValue}
  }
  /// Returns true if `overrideCount` has been explicitly set.
  var hasOverrideCount: Bool {return self._overrideCount != nil}
  /// Clears the value of `overrideCount`. Subsequent reads from it will return its default value.
  mutating func clearOverrideCount() {self._overrideCount = nil}

  var shapeProperties: TSD_ShapeStylePropertiesArchive {
    get {return _shapeProperties ?? TSD_ShapeStylePropertiesArchive()}
    set {_shapeProperties = newValue}
  }
  /// Returns true if `shapeProperties` has been explicitly set.
  var hasShapeProperties: Bool {return self._shapeProperties != nil}
  /// Clears the value of `shapeProperties`. Subsequent reads from it will return its default value.
  mutating func clearShapeProperties() {self._shapeProperties = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSS_StyleArchive? = nil
  fileprivate var _overrideCount: UInt32? = nil
  fileprivate var _shapeProperties: TSD_ShapeStylePropertiesArchive? = nil
}

struct TSD_MediaStylePropertiesArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stroke: TSD_StrokeArchive {
    get {return _stroke ?? TSD_StrokeArchive()}
    set {_stroke = newValue}
  }
  /// Returns true if `stroke` has been explicitly set.
  var hasStroke: Bool {return self._stroke != nil}
  /// Clears the value of `stroke`. Subsequent reads from it will return its default value.
  mutating func clearStroke() {self._stroke = nil}

  var opacity: Float {
    get {return _opacity ?? 0}
    set {_opacity = newValue}
  }
  /// Returns true if `opacity` has been explicitly set.
  var hasOpacity: Bool {return self._opacity != nil}
  /// Clears the value of `opacity`. Subsequent reads from it will return its default value.
  mutating func clearOpacity() {self._opacity = nil}

  var shadow: TSD_ShadowArchive {
    get {return _shadow ?? TSD_ShadowArchive()}
    set {_shadow = newValue}
  }
  /// Returns true if `shadow` has been explicitly set.
  var hasShadow: Bool {return self._shadow != nil}
  /// Clears the value of `shadow`. Subsequent reads from it will return its default value.
  mutating func clearShadow() {self._shadow = nil}

  var reflection: TSD_ReflectionArchive {
    get {return _reflection ?? TSD_ReflectionArchive()}
    set {_reflection = newValue}
  }
  /// Returns true if `reflection` has been explicitly set.
  var hasReflection: Bool {return self._reflection != nil}
  /// Clears the value of `reflection`. Subsequent reads from it will return its default value.
  mutating func clearReflection() {self._reflection = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _stroke: TSD_StrokeArchive? = nil
  fileprivate var _opacity: Float? = nil
  fileprivate var _shadow: TSD_ShadowArchive? = nil
  fileprivate var _reflection: TSD_ReflectionArchive? = nil
}

struct TSD_MediaStyleArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSS_StyleArchive {
    get {return _super ?? TSS_StyleArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var overrideCount: UInt32 {
    get {return _overrideCount ?? 0}
    set {_overrideCount = newValue}
  }
  /// Returns true if `overrideCount` has been explicitly set.
  var hasOverrideCount: Bool {return self._overrideCount != nil}
  /// Clears the value of `overrideCount`. Subsequent reads from it will return its default value.
  mutating func clearOverrideCount() {self._overrideCount = nil}

  var mediaProperties: TSD_MediaStylePropertiesArchive {
    get {return _mediaProperties ?? TSD_MediaStylePropertiesArchive()}
    set {_mediaProperties = newValue}
  }
  /// Returns true if `mediaProperties` has been explicitly set.
  var hasMediaProperties: Bool {return self._mediaProperties != nil}
  /// Clears the value of `mediaProperties`. Subsequent reads from it will return its default value.
  mutating func clearMediaProperties() {self._mediaProperties = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSS_StyleArchive? = nil
  fileprivate var _overrideCount: UInt32? = nil
  fileprivate var _mediaProperties: TSD_MediaStylePropertiesArchive? = nil
}

struct TSD_ThemePresetsArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gradientFillPresets: [TSD_FillArchive] = []

  var imageFillPresets: [TSD_FillArchive] = []

  var shadowPresets: [TSD_ShadowArchive] = []

  var lineStylePresets: [TSP_Reference] = []

  var shapeStylePresets: [TSP_Reference] = []

  var textboxStylePresets: [TSP_Reference] = []

  var imageStylePresets: [TSP_Reference] = []

  var movieStylePresets: [TSP_Reference] = []

  var drawingLineStylePresets: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSD_ThemeReplaceFillPresetCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var theme: TSP_Reference {
    get {return _storage._theme ?? TSP_Reference()}
    set {_uniqueStorage()._theme = newValue}
  }
  /// Returns true if `theme` has been explicitly set.
  var hasTheme: Bool {return _storage._theme != nil}
  /// Clears the value of `theme`. Subsequent reads from it will return its default value.
  mutating func clearTheme() {_uniqueStorage()._theme = nil}

  var fill: TSD_FillArchive {
    get {return _storage._fill ?? TSD_FillArchive()}
    set {_uniqueStorage()._fill = newValue}
  }
  /// Returns true if `fill` has been explicitly set.
  var hasFill: Bool {return _storage._fill != nil}
  /// Clears the value of `fill`. Subsequent reads from it will return its default value.
  mutating func clearFill() {_uniqueStorage()._fill = nil}

  var oldFill: TSD_FillArchive {
    get {return _storage._oldFill ?? TSD_FillArchive()}
    set {_uniqueStorage()._oldFill = newValue}
  }
  /// Returns true if `oldFill` has been explicitly set.
  var hasOldFill: Bool {return _storage._oldFill != nil}
  /// Clears the value of `oldFill`. Subsequent reads from it will return its default value.
  mutating func clearOldFill() {_uniqueStorage()._oldFill = nil}

  var index: UInt32 {
    get {return _storage._index ?? 0}
    set {_uniqueStorage()._index = newValue}
  }
  /// Returns true if `index` has been explicitly set.
  var hasIndex: Bool {return _storage._index != nil}
  /// Clears the value of `index`. Subsequent reads from it will return its default value.
  mutating func clearIndex() {_uniqueStorage()._index = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_DrawableArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var geometry: TSD_GeometryArchive {
    get {return _storage._geometry ?? TSD_GeometryArchive()}
    set {_uniqueStorage()._geometry = newValue}
  }
  /// Returns true if `geometry` has been explicitly set.
  var hasGeometry: Bool {return _storage._geometry != nil}
  /// Clears the value of `geometry`. Subsequent reads from it will return its default value.
  mutating func clearGeometry() {_uniqueStorage()._geometry = nil}

  var parent: TSP_Reference {
    get {return _storage._parent ?? TSP_Reference()}
    set {_uniqueStorage()._parent = newValue}
  }
  /// Returns true if `parent` has been explicitly set.
  var hasParent: Bool {return _storage._parent != nil}
  /// Clears the value of `parent`. Subsequent reads from it will return its default value.
  mutating func clearParent() {_uniqueStorage()._parent = nil}

  var exteriorTextWrap: TSD_ExteriorTextWrapArchive {
    get {return _storage._exteriorTextWrap ?? TSD_ExteriorTextWrapArchive()}
    set {_uniqueStorage()._exteriorTextWrap = newValue}
  }
  /// Returns true if `exteriorTextWrap` has been explicitly set.
  var hasExteriorTextWrap: Bool {return _storage._exteriorTextWrap != nil}
  /// Clears the value of `exteriorTextWrap`. Subsequent reads from it will return its default value.
  mutating func clearExteriorTextWrap() {_uniqueStorage()._exteriorTextWrap = nil}

  var hyperlinkURL: String {
    get {return _storage._hyperlinkURL ?? String()}
    set {_uniqueStorage()._hyperlinkURL = newValue}
  }
  /// Returns true if `hyperlinkURL` has been explicitly set.
  var hasHyperlinkURL: Bool {return _storage._hyperlinkURL != nil}
  /// Clears the value of `hyperlinkURL`. Subsequent reads from it will return its default value.
  mutating func clearHyperlinkURL() {_uniqueStorage()._hyperlinkURL = nil}

  var locked: Bool {
    get {return _storage._locked ?? false}
    set {_uniqueStorage()._locked = newValue}
  }
  /// Returns true if `locked` has been explicitly set.
  var hasLocked: Bool {return _storage._locked != nil}
  /// Clears the value of `locked`. Subsequent reads from it will return its default value.
  mutating func clearLocked() {_uniqueStorage()._locked = nil}

  var comment: TSP_Reference {
    get {return _storage._comment ?? TSP_Reference()}
    set {_uniqueStorage()._comment = newValue}
  }
  /// Returns true if `comment` has been explicitly set.
  var hasComment: Bool {return _storage._comment != nil}
  /// Clears the value of `comment`. Subsequent reads from it will return its default value.
  mutating func clearComment() {_uniqueStorage()._comment = nil}

  var aspectRatioLocked: Bool {
    get {return _storage._aspectRatioLocked ?? false}
    set {_uniqueStorage()._aspectRatioLocked = newValue}
  }
  /// Returns true if `aspectRatioLocked` has been explicitly set.
  var hasAspectRatioLocked: Bool {return _storage._aspectRatioLocked != nil}
  /// Clears the value of `aspectRatioLocked`. Subsequent reads from it will return its default value.
  mutating func clearAspectRatioLocked() {_uniqueStorage()._aspectRatioLocked = nil}

  var accessibilityDescription: String {
    get {return _storage._accessibilityDescription ?? String()}
    set {_uniqueStorage()._accessibilityDescription = newValue}
  }
  /// Returns true if `accessibilityDescription` has been explicitly set.
  var hasAccessibilityDescription: Bool {return _storage._accessibilityDescription != nil}
  /// Clears the value of `accessibilityDescription`. Subsequent reads from it will return its default value.
  mutating func clearAccessibilityDescription() {_uniqueStorage()._accessibilityDescription = nil}

  var pencilAnnotations: [TSP_Reference] {
    get {return _storage._pencilAnnotations}
    set {_uniqueStorage()._pencilAnnotations = newValue}
  }

  var title: TSP_Reference {
    get {return _storage._title ?? TSP_Reference()}
    set {_uniqueStorage()._title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return _storage._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {_uniqueStorage()._title = nil}

  var caption: TSP_Reference {
    get {return _storage._caption ?? TSP_Reference()}
    set {_uniqueStorage()._caption = newValue}
  }
  /// Returns true if `caption` has been explicitly set.
  var hasCaption: Bool {return _storage._caption != nil}
  /// Clears the value of `caption`. Subsequent reads from it will return its default value.
  mutating func clearCaption() {_uniqueStorage()._caption = nil}

  var titleHidden: Bool {
    get {return _storage._titleHidden ?? false}
    set {_uniqueStorage()._titleHidden = newValue}
  }
  /// Returns true if `titleHidden` has been explicitly set.
  var hasTitleHidden: Bool {return _storage._titleHidden != nil}
  /// Clears the value of `titleHidden`. Subsequent reads from it will return its default value.
  mutating func clearTitleHidden() {_uniqueStorage()._titleHidden = nil}

  var captionHidden: Bool {
    get {return _storage._captionHidden ?? false}
    set {_uniqueStorage()._captionHidden = newValue}
  }
  /// Returns true if `captionHidden` has been explicitly set.
  var hasCaptionHidden: Bool {return _storage._captionHidden != nil}
  /// Clears the value of `captionHidden`. Subsequent reads from it will return its default value.
  mutating func clearCaptionHidden() {_uniqueStorage()._captionHidden = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_ContainerArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var geometry: TSD_GeometryArchive {
    get {return _geometry ?? TSD_GeometryArchive()}
    set {_geometry = newValue}
  }
  /// Returns true if `geometry` has been explicitly set.
  var hasGeometry: Bool {return self._geometry != nil}
  /// Clears the value of `geometry`. Subsequent reads from it will return its default value.
  mutating func clearGeometry() {self._geometry = nil}

  var parent: TSP_Reference {
    get {return _parent ?? TSP_Reference()}
    set {_parent = newValue}
  }
  /// Returns true if `parent` has been explicitly set.
  var hasParent: Bool {return self._parent != nil}
  /// Clears the value of `parent`. Subsequent reads from it will return its default value.
  mutating func clearParent() {self._parent = nil}

  var children: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _geometry: TSD_GeometryArchive? = nil
  fileprivate var _parent: TSP_Reference? = nil
}

struct TSD_GroupArchive: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_DrawableArchive {
    get {return _super ?? TSD_DrawableArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var children: [TSP_Reference] = []

  var fakeShapeForEmptyGroup: TSP_Reference {
    get {return _fakeShapeForEmptyGroup ?? TSP_Reference()}
    set {_fakeShapeForEmptyGroup = newValue}
  }
  /// Returns true if `fakeShapeForEmptyGroup` has been explicitly set.
  var hasFakeShapeForEmptyGroup: Bool {return self._fakeShapeForEmptyGroup != nil}
  /// Clears the value of `fakeShapeForEmptyGroup`. Subsequent reads from it will return its default value.
  mutating func clearFakeShapeForEmptyGroup() {self._fakeShapeForEmptyGroup = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _super: TSD_DrawableArchive? = nil
  fileprivate var _fakeShapeForEmptyGroup: TSP_Reference? = nil
}

struct TSD_FreehandDrawingAnimationArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var duration: Double {
    get {return _duration ?? 0}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  mutating func clearDuration() {self._duration = nil}

  var shouldLoop: Bool {
    get {return _shouldLoop ?? false}
    set {_shouldLoop = newValue}
  }
  /// Returns true if `shouldLoop` has been explicitly set.
  var hasShouldLoop: Bool {return self._shouldLoop != nil}
  /// Clears the value of `shouldLoop`. Subsequent reads from it will return its default value.
  mutating func clearShouldLoop() {self._shouldLoop = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _duration: Double? = nil
  fileprivate var _shouldLoop: Bool? = nil
}

struct TSD_FreehandDrawingArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var spacerShape: TSP_Reference {
    get {return _spacerShape ?? TSP_Reference()}
    set {_spacerShape = newValue}
  }
  /// Returns true if `spacerShape` has been explicitly set.
  var hasSpacerShape: Bool {return self._spacerShape != nil}
  /// Clears the value of `spacerShape`. Subsequent reads from it will return its default value.
  mutating func clearSpacerShape() {self._spacerShape = nil}

  var opacity: Double {
    get {return _opacity ?? 0}
    set {_opacity = newValue}
  }
  /// Returns true if `opacity` has been explicitly set.
  var hasOpacity: Bool {return self._opacity != nil}
  /// Clears the value of `opacity`. Subsequent reads from it will return its default value.
  mutating func clearOpacity() {self._opacity = nil}

  var animation: TSD_FreehandDrawingAnimationArchive {
    get {return _animation ?? TSD_FreehandDrawingAnimationArchive()}
    set {_animation = newValue}
  }
  /// Returns true if `animation` has been explicitly set.
  var hasAnimation: Bool {return self._animation != nil}
  /// Clears the value of `animation`. Subsequent reads from it will return its default value.
  mutating func clearAnimation() {self._animation = nil}

  var lastClampedScale: Double {
    get {return _lastClampedScale ?? 0}
    set {_lastClampedScale = newValue}
  }
  /// Returns true if `lastClampedScale` has been explicitly set.
  var hasLastClampedScale: Bool {return self._lastClampedScale != nil}
  /// Clears the value of `lastClampedScale`. Subsequent reads from it will return its default value.
  mutating func clearLastClampedScale() {self._lastClampedScale = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _spacerShape: TSP_Reference? = nil
  fileprivate var _opacity: Double? = nil
  fileprivate var _animation: TSD_FreehandDrawingAnimationArchive? = nil
  fileprivate var _lastClampedScale: Double? = nil
}

struct TSD_ShapeArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_DrawableArchive {
    get {return _storage._super ?? TSD_DrawableArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var style: TSP_Reference {
    get {return _storage._style ?? TSP_Reference()}
    set {_uniqueStorage()._style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  var hasStyle: Bool {return _storage._style != nil}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  mutating func clearStyle() {_uniqueStorage()._style = nil}

  var pathsource: TSD_PathSourceArchive {
    get {return _storage._pathsource ?? TSD_PathSourceArchive()}
    set {_uniqueStorage()._pathsource = newValue}
  }
  /// Returns true if `pathsource` has been explicitly set.
  var hasPathsource: Bool {return _storage._pathsource != nil}
  /// Clears the value of `pathsource`. Subsequent reads from it will return its default value.
  mutating func clearPathsource() {_uniqueStorage()._pathsource = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var headLineEnd: TSD_LineEndArchive {
    get {return _storage._headLineEnd ?? TSD_LineEndArchive()}
    set {_uniqueStorage()._headLineEnd = newValue}
  }
  /// Returns true if `headLineEnd` has been explicitly set.
  var hasHeadLineEnd: Bool {return _storage._headLineEnd != nil}
  /// Clears the value of `headLineEnd`. Subsequent reads from it will return its default value.
  mutating func clearHeadLineEnd() {_uniqueStorage()._headLineEnd = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var tailLineEnd: TSD_LineEndArchive {
    get {return _storage._tailLineEnd ?? TSD_LineEndArchive()}
    set {_uniqueStorage()._tailLineEnd = newValue}
  }
  /// Returns true if `tailLineEnd` has been explicitly set.
  var hasTailLineEnd: Bool {return _storage._tailLineEnd != nil}
  /// Clears the value of `tailLineEnd`. Subsequent reads from it will return its default value.
  mutating func clearTailLineEnd() {_uniqueStorage()._tailLineEnd = nil}

  var strokePatternOffsetDistance: Float {
    get {return _storage._strokePatternOffsetDistance ?? 0}
    set {_uniqueStorage()._strokePatternOffsetDistance = newValue}
  }
  /// Returns true if `strokePatternOffsetDistance` has been explicitly set.
  var hasStrokePatternOffsetDistance: Bool {return _storage._strokePatternOffsetDistance != nil}
  /// Clears the value of `strokePatternOffsetDistance`. Subsequent reads from it will return its default value.
  mutating func clearStrokePatternOffsetDistance() {_uniqueStorage()._strokePatternOffsetDistance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_ConnectionLineArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_ShapeArchive {
    get {return _super ?? TSD_ShapeArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var connectedFrom: TSP_Reference {
    get {return _connectedFrom ?? TSP_Reference()}
    set {_connectedFrom = newValue}
  }
  /// Returns true if `connectedFrom` has been explicitly set.
  var hasConnectedFrom: Bool {return self._connectedFrom != nil}
  /// Clears the value of `connectedFrom`. Subsequent reads from it will return its default value.
  mutating func clearConnectedFrom() {self._connectedFrom = nil}

  var connectedTo: TSP_Reference {
    get {return _connectedTo ?? TSP_Reference()}
    set {_connectedTo = newValue}
  }
  /// Returns true if `connectedTo` has been explicitly set.
  var hasConnectedTo: Bool {return self._connectedTo != nil}
  /// Clears the value of `connectedTo`. Subsequent reads from it will return its default value.
  mutating func clearConnectedTo() {self._connectedTo = nil}

  var connectedToUuid: TSP_UUID {
    get {return _connectedToUuid ?? TSP_UUID()}
    set {_connectedToUuid = newValue}
  }
  /// Returns true if `connectedToUuid` has been explicitly set.
  var hasConnectedToUuid: Bool {return self._connectedToUuid != nil}
  /// Clears the value of `connectedToUuid`. Subsequent reads from it will return its default value.
  mutating func clearConnectedToUuid() {self._connectedToUuid = nil}

  var connectedFromUuid: TSP_UUID {
    get {return _connectedFromUuid ?? TSP_UUID()}
    set {_connectedFromUuid = newValue}
  }
  /// Returns true if `connectedFromUuid` has been explicitly set.
  var hasConnectedFromUuid: Bool {return self._connectedFromUuid != nil}
  /// Clears the value of `connectedFromUuid`. Subsequent reads from it will return its default value.
  mutating func clearConnectedFromUuid() {self._connectedFromUuid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_ShapeArchive? = nil
  fileprivate var _connectedFrom: TSP_Reference? = nil
  fileprivate var _connectedTo: TSP_Reference? = nil
  fileprivate var _connectedToUuid: TSP_UUID? = nil
  fileprivate var _connectedFromUuid: TSP_UUID? = nil
}

struct TSD_ImageArchive: SwiftProtobuf.ExtensibleMessage, @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_DrawableArchive {
    get {return _storage._super ?? TSD_DrawableArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var data: TSP_DataReference {
    get {return _storage._data ?? TSP_DataReference()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {_uniqueStorage()._data = nil}

  var style: TSP_Reference {
    get {return _storage._style ?? TSP_Reference()}
    set {_uniqueStorage()._style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  var hasStyle: Bool {return _storage._style != nil}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  mutating func clearStyle() {_uniqueStorage()._style = nil}

  var originalSize: TSP_Size {
    get {return _storage._originalSize ?? TSP_Size()}
    set {_uniqueStorage()._originalSize = newValue}
  }
  /// Returns true if `originalSize` has been explicitly set.
  var hasOriginalSize: Bool {return _storage._originalSize != nil}
  /// Clears the value of `originalSize`. Subsequent reads from it will return its default value.
  mutating func clearOriginalSize() {_uniqueStorage()._originalSize = nil}

  var mask: TSP_Reference {
    get {return _storage._mask ?? TSP_Reference()}
    set {_uniqueStorage()._mask = newValue}
  }
  /// Returns true if `mask` has been explicitly set.
  var hasMask: Bool {return _storage._mask != nil}
  /// Clears the value of `mask`. Subsequent reads from it will return its default value.
  mutating func clearMask() {_uniqueStorage()._mask = nil}

  var thumbnailData: TSP_DataReference {
    get {return _storage._thumbnailData ?? TSP_DataReference()}
    set {_uniqueStorage()._thumbnailData = newValue}
  }
  /// Returns true if `thumbnailData` has been explicitly set.
  var hasThumbnailData: Bool {return _storage._thumbnailData != nil}
  /// Clears the value of `thumbnailData`. Subsequent reads from it will return its default value.
  mutating func clearThumbnailData() {_uniqueStorage()._thumbnailData = nil}

  var flags: UInt32 {
    get {return _storage._flags ?? 0}
    set {_uniqueStorage()._flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  var hasFlags: Bool {return _storage._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  mutating func clearFlags() {_uniqueStorage()._flags = nil}

  var originalData: TSP_DataReference {
    get {return _storage._originalData ?? TSP_DataReference()}
    set {_uniqueStorage()._originalData = newValue}
  }
  /// Returns true if `originalData` has been explicitly set.
  var hasOriginalData: Bool {return _storage._originalData != nil}
  /// Clears the value of `originalData`. Subsequent reads from it will return its default value.
  mutating func clearOriginalData() {_uniqueStorage()._originalData = nil}

  var originalSvgdata: TSP_DataReference {
    get {return _storage._originalSvgdata ?? TSP_DataReference()}
    set {_uniqueStorage()._originalSvgdata = newValue}
  }
  /// Returns true if `originalSvgdata` has been explicitly set.
  var hasOriginalSvgdata: Bool {return _storage._originalSvgdata != nil}
  /// Clears the value of `originalSvgdata`. Subsequent reads from it will return its default value.
  mutating func clearOriginalSvgdata() {_uniqueStorage()._originalSvgdata = nil}

  var naturalSize: TSP_Size {
    get {return _storage._naturalSize ?? TSP_Size()}
    set {_uniqueStorage()._naturalSize = newValue}
  }
  /// Returns true if `naturalSize` has been explicitly set.
  var hasNaturalSize: Bool {return _storage._naturalSize != nil}
  /// Clears the value of `naturalSize`. Subsequent reads from it will return its default value.
  mutating func clearNaturalSize() {_uniqueStorage()._naturalSize = nil}

  var instantAlphaPath: TSP_Path {
    get {return _storage._instantAlphaPath ?? TSP_Path()}
    set {_uniqueStorage()._instantAlphaPath = newValue}
  }
  /// Returns true if `instantAlphaPath` has been explicitly set.
  var hasInstantAlphaPath: Bool {return _storage._instantAlphaPath != nil}
  /// Clears the value of `instantAlphaPath`. Subsequent reads from it will return its default value.
  mutating func clearInstantAlphaPath() {_uniqueStorage()._instantAlphaPath = nil}

  var imageAdjustments: TSD_ImageAdjustmentsArchive {
    get {return _storage._imageAdjustments ?? TSD_ImageAdjustmentsArchive()}
    set {_uniqueStorage()._imageAdjustments = newValue}
  }
  /// Returns true if `imageAdjustments` has been explicitly set.
  var hasImageAdjustments: Bool {return _storage._imageAdjustments != nil}
  /// Clears the value of `imageAdjustments`. Subsequent reads from it will return its default value.
  mutating func clearImageAdjustments() {_uniqueStorage()._imageAdjustments = nil}

  var enhancedImageData: TSP_DataReference {
    get {return _storage._enhancedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._enhancedImageData = newValue}
  }
  /// Returns true if `enhancedImageData` has been explicitly set.
  var hasEnhancedImageData: Bool {return _storage._enhancedImageData != nil}
  /// Clears the value of `enhancedImageData`. Subsequent reads from it will return its default value.
  mutating func clearEnhancedImageData() {_uniqueStorage()._enhancedImageData = nil}

  var adjustedImageData: TSP_DataReference {
    get {return _storage._adjustedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._adjustedImageData = newValue}
  }
  /// Returns true if `adjustedImageData` has been explicitly set.
  var hasAdjustedImageData: Bool {return _storage._adjustedImageData != nil}
  /// Clears the value of `adjustedImageData`. Subsequent reads from it will return its default value.
  mutating func clearAdjustedImageData() {_uniqueStorage()._adjustedImageData = nil}

  var thumbnailAdjustedImageData: TSP_DataReference {
    get {return _storage._thumbnailAdjustedImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._thumbnailAdjustedImageData = newValue}
  }
  /// Returns true if `thumbnailAdjustedImageData` has been explicitly set.
  var hasThumbnailAdjustedImageData: Bool {return _storage._thumbnailAdjustedImageData != nil}
  /// Clears the value of `thumbnailAdjustedImageData`. Subsequent reads from it will return its default value.
  mutating func clearThumbnailAdjustedImageData() {_uniqueStorage()._thumbnailAdjustedImageData = nil}

  var interpretsUntaggedImageDataAsGeneric: Bool {
    get {return _storage._interpretsUntaggedImageDataAsGeneric ?? false}
    set {_uniqueStorage()._interpretsUntaggedImageDataAsGeneric = newValue}
  }
  /// Returns true if `interpretsUntaggedImageDataAsGeneric` has been explicitly set.
  var hasInterpretsUntaggedImageDataAsGeneric: Bool {return _storage._interpretsUntaggedImageDataAsGeneric != nil}
  /// Clears the value of `interpretsUntaggedImageDataAsGeneric`. Subsequent reads from it will return its default value.
  mutating func clearInterpretsUntaggedImageDataAsGeneric() {_uniqueStorage()._interpretsUntaggedImageDataAsGeneric = nil}

  var databaseData: TSP_Reference {
    get {return _storage._databaseData ?? TSP_Reference()}
    set {_uniqueStorage()._databaseData = newValue}
  }
  /// Returns true if `databaseData` has been explicitly set.
  var hasDatabaseData: Bool {return _storage._databaseData != nil}
  /// Clears the value of `databaseData`. Subsequent reads from it will return its default value.
  mutating func clearDatabaseData() {_uniqueStorage()._databaseData = nil}

  var databaseThumbnailData: TSP_Reference {
    get {return _storage._databaseThumbnailData ?? TSP_Reference()}
    set {_uniqueStorage()._databaseThumbnailData = newValue}
  }
  /// Returns true if `databaseThumbnailData` has been explicitly set.
  var hasDatabaseThumbnailData: Bool {return _storage._databaseThumbnailData != nil}
  /// Clears the value of `databaseThumbnailData`. Subsequent reads from it will return its default value.
  mutating func clearDatabaseThumbnailData() {_uniqueStorage()._databaseThumbnailData = nil}

  var databaseOriginalData: TSP_Reference {
    get {return _storage._databaseOriginalData ?? TSP_Reference()}
    set {_uniqueStorage()._databaseOriginalData = newValue}
  }
  /// Returns true if `databaseOriginalData` has been explicitly set.
  var hasDatabaseOriginalData: Bool {return _storage._databaseOriginalData != nil}
  /// Clears the value of `databaseOriginalData`. Subsequent reads from it will return its default value.
  mutating func clearDatabaseOriginalData() {_uniqueStorage()._databaseOriginalData = nil}

  var tracedPath: TSP_Path {
    get {return _storage._tracedPath ?? TSP_Path()}
    set {_uniqueStorage()._tracedPath = newValue}
  }
  /// Returns true if `tracedPath` has been explicitly set.
  var hasTracedPath: Bool {return _storage._tracedPath != nil}
  /// Clears the value of `tracedPath`. Subsequent reads from it will return its default value.
  mutating func clearTracedPath() {_uniqueStorage()._tracedPath = nil}

  var attribution: TSD_Attribution {
    get {return _storage._attribution ?? TSD_Attribution()}
    set {_uniqueStorage()._attribution = newValue}
  }
  /// Returns true if `attribution` has been explicitly set.
  var hasAttribution: Bool {return _storage._attribution != nil}
  /// Clears the value of `attribution`. Subsequent reads from it will return its default value.
  mutating func clearAttribution() {_uniqueStorage()._attribution = nil}

  var shouldTracePdfContent: Bool {
    get {return _storage._shouldTracePdfContent ?? false}
    set {_uniqueStorage()._shouldTracePdfContent = newValue}
  }
  /// Returns true if `shouldTracePdfContent` has been explicitly set.
  var hasShouldTracePdfContent: Bool {return _storage._shouldTracePdfContent != nil}
  /// Clears the value of `shouldTracePdfContent`. Subsequent reads from it will return its default value.
  mutating func clearShouldTracePdfContent() {_uniqueStorage()._shouldTracePdfContent = nil}

  var backgroundRemoved: Bool {
    get {return _storage._backgroundRemoved ?? false}
    set {_uniqueStorage()._backgroundRemoved = newValue}
  }
  /// Returns true if `backgroundRemoved` has been explicitly set.
  var hasBackgroundRemoved: Bool {return _storage._backgroundRemoved != nil}
  /// Clears the value of `backgroundRemoved`. Subsequent reads from it will return its default value.
  mutating func clearBackgroundRemoved() {_uniqueStorage()._backgroundRemoved = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_MaskArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_DrawableArchive {
    get {return _super ?? TSD_DrawableArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var pathsource: TSD_PathSourceArchive {
    get {return _pathsource ?? TSD_PathSourceArchive()}
    set {_pathsource = newValue}
  }
  /// Returns true if `pathsource` has been explicitly set.
  var hasPathsource: Bool {return self._pathsource != nil}
  /// Clears the value of `pathsource`. Subsequent reads from it will return its default value.
  mutating func clearPathsource() {self._pathsource = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_DrawableArchive? = nil
  fileprivate var _pathsource: TSD_PathSourceArchive? = nil
}

struct TSD_ImageDataAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pixelSize: TSP_Size {
    get {return _pixelSize ?? TSP_Size()}
    set {_pixelSize = newValue}
  }
  /// Returns true if `pixelSize` has been explicitly set.
  var hasPixelSize: Bool {return self._pixelSize != nil}
  /// Clears the value of `pixelSize`. Subsequent reads from it will return its default value.
  mutating func clearPixelSize() {self._pixelSize = nil}

  var imageIsSrgb: Bool {
    get {return _imageIsSrgb ?? false}
    set {_imageIsSrgb = newValue}
  }
  /// Returns true if `imageIsSrgb` has been explicitly set.
  var hasImageIsSrgb: Bool {return self._imageIsSrgb != nil}
  /// Clears the value of `imageIsSrgb`. Subsequent reads from it will return its default value.
  mutating func clearImageIsSrgb() {self._imageIsSrgb = nil}

  var shouldBeInterpretedAsGenericIfUntagged: Bool {
    get {return _shouldBeInterpretedAsGenericIfUntagged ?? false}
    set {_shouldBeInterpretedAsGenericIfUntagged = newValue}
  }
  /// Returns true if `shouldBeInterpretedAsGenericIfUntagged` has been explicitly set.
  var hasShouldBeInterpretedAsGenericIfUntagged: Bool {return self._shouldBeInterpretedAsGenericIfUntagged != nil}
  /// Clears the value of `shouldBeInterpretedAsGenericIfUntagged`. Subsequent reads from it will return its default value.
  mutating func clearShouldBeInterpretedAsGenericIfUntagged() {self._shouldBeInterpretedAsGenericIfUntagged = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pixelSize: TSP_Size? = nil
  fileprivate var _imageIsSrgb: Bool? = nil
  fileprivate var _shouldBeInterpretedAsGenericIfUntagged: Bool? = nil
}

struct TSD_MovieArchive: SwiftProtobuf.ExtensibleMessage, @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_DrawableArchive {
    get {return _storage._super ?? TSD_DrawableArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var movieData: TSP_DataReference {
    get {return _storage._movieData ?? TSP_DataReference()}
    set {_uniqueStorage()._movieData = newValue}
  }
  /// Returns true if `movieData` has been explicitly set.
  var hasMovieData: Bool {return _storage._movieData != nil}
  /// Clears the value of `movieData`. Subsequent reads from it will return its default value.
  mutating func clearMovieData() {_uniqueStorage()._movieData = nil}

  var importedAuxiliaryMovieData: TSP_DataReference {
    get {return _storage._importedAuxiliaryMovieData ?? TSP_DataReference()}
    set {_uniqueStorage()._importedAuxiliaryMovieData = newValue}
  }
  /// Returns true if `importedAuxiliaryMovieData` has been explicitly set.
  var hasImportedAuxiliaryMovieData: Bool {return _storage._importedAuxiliaryMovieData != nil}
  /// Clears the value of `importedAuxiliaryMovieData`. Subsequent reads from it will return its default value.
  mutating func clearImportedAuxiliaryMovieData() {_uniqueStorage()._importedAuxiliaryMovieData = nil}

  var importedAuxiliaryMovieDataOriginalFilename: String {
    get {return _storage._importedAuxiliaryMovieDataOriginalFilename ?? String()}
    set {_uniqueStorage()._importedAuxiliaryMovieDataOriginalFilename = newValue}
  }
  /// Returns true if `importedAuxiliaryMovieDataOriginalFilename` has been explicitly set.
  var hasImportedAuxiliaryMovieDataOriginalFilename: Bool {return _storage._importedAuxiliaryMovieDataOriginalFilename != nil}
  /// Clears the value of `importedAuxiliaryMovieDataOriginalFilename`. Subsequent reads from it will return its default value.
  mutating func clearImportedAuxiliaryMovieDataOriginalFilename() {_uniqueStorage()._importedAuxiliaryMovieDataOriginalFilename = nil}

  var movieRemoteURL: String {
    get {return _storage._movieRemoteURL ?? String()}
    set {_uniqueStorage()._movieRemoteURL = newValue}
  }
  /// Returns true if `movieRemoteURL` has been explicitly set.
  var hasMovieRemoteURL: Bool {return _storage._movieRemoteURL != nil}
  /// Clears the value of `movieRemoteURL`. Subsequent reads from it will return its default value.
  mutating func clearMovieRemoteURL() {_uniqueStorage()._movieRemoteURL = nil}

  var startTime: Float {
    get {return _storage._startTime ?? 0}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  var endTime: Float {
    get {return _storage._endTime ?? 0}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  var posterTime: Float {
    get {return _storage._posterTime ?? 0}
    set {_uniqueStorage()._posterTime = newValue}
  }
  /// Returns true if `posterTime` has been explicitly set.
  var hasPosterTime: Bool {return _storage._posterTime != nil}
  /// Clears the value of `posterTime`. Subsequent reads from it will return its default value.
  mutating func clearPosterTime() {_uniqueStorage()._posterTime = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var loopOptionAsInteger: UInt32 {
    get {return _storage._loopOptionAsInteger ?? 0}
    set {_uniqueStorage()._loopOptionAsInteger = newValue}
  }
  /// Returns true if `loopOptionAsInteger` has been explicitly set.
  var hasLoopOptionAsInteger: Bool {return _storage._loopOptionAsInteger != nil}
  /// Clears the value of `loopOptionAsInteger`. Subsequent reads from it will return its default value.
  mutating func clearLoopOptionAsInteger() {_uniqueStorage()._loopOptionAsInteger = nil}

  var loopOption: TSD_MovieArchive.MovieLoopOption {
    get {return _storage._loopOption ?? .none}
    set {_uniqueStorage()._loopOption = newValue}
  }
  /// Returns true if `loopOption` has been explicitly set.
  var hasLoopOption: Bool {return _storage._loopOption != nil}
  /// Clears the value of `loopOption`. Subsequent reads from it will return its default value.
  mutating func clearLoopOption() {_uniqueStorage()._loopOption = nil}

  var volume: Float {
    get {return _storage._volume ?? 0}
    set {_uniqueStorage()._volume = newValue}
  }
  /// Returns true if `volume` has been explicitly set.
  var hasVolume: Bool {return _storage._volume != nil}
  /// Clears the value of `volume`. Subsequent reads from it will return its default value.
  mutating func clearVolume() {_uniqueStorage()._volume = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var autoPlay: Bool {
    get {return _storage._autoPlay ?? false}
    set {_uniqueStorage()._autoPlay = newValue}
  }
  /// Returns true if `autoPlay` has been explicitly set.
  var hasAutoPlay: Bool {return _storage._autoPlay != nil}
  /// Clears the value of `autoPlay`. Subsequent reads from it will return its default value.
  mutating func clearAutoPlay() {_uniqueStorage()._autoPlay = nil}

  var audioOnly: Bool {
    get {return _storage._audioOnly ?? false}
    set {_uniqueStorage()._audioOnly = newValue}
  }
  /// Returns true if `audioOnly` has been explicitly set.
  var hasAudioOnly: Bool {return _storage._audioOnly != nil}
  /// Clears the value of `audioOnly`. Subsequent reads from it will return its default value.
  mutating func clearAudioOnly() {_uniqueStorage()._audioOnly = nil}

  var streaming: Bool {
    get {return _storage._streaming ?? false}
    set {_uniqueStorage()._streaming = newValue}
  }
  /// Returns true if `streaming` has been explicitly set.
  var hasStreaming: Bool {return _storage._streaming != nil}
  /// Clears the value of `streaming`. Subsequent reads from it will return its default value.
  mutating func clearStreaming() {_uniqueStorage()._streaming = nil}

  var nativeAudioRecording: Bool {
    get {return _storage._nativeAudioRecording ?? false}
    set {_uniqueStorage()._nativeAudioRecording = newValue}
  }
  /// Returns true if `nativeAudioRecording` has been explicitly set.
  var hasNativeAudioRecording: Bool {return _storage._nativeAudioRecording != nil}
  /// Clears the value of `nativeAudioRecording`. Subsequent reads from it will return its default value.
  mutating func clearNativeAudioRecording() {_uniqueStorage()._nativeAudioRecording = nil}

  var playsAcrossSlides: Bool {
    get {return _storage._playsAcrossSlides ?? false}
    set {_uniqueStorage()._playsAcrossSlides = newValue}
  }
  /// Returns true if `playsAcrossSlides` has been explicitly set.
  var hasPlaysAcrossSlides: Bool {return _storage._playsAcrossSlides != nil}
  /// Clears the value of `playsAcrossSlides`. Subsequent reads from it will return its default value.
  mutating func clearPlaysAcrossSlides() {_uniqueStorage()._playsAcrossSlides = nil}

  var posterImageData: TSP_DataReference {
    get {return _storage._posterImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._posterImageData = newValue}
  }
  /// Returns true if `posterImageData` has been explicitly set.
  var hasPosterImageData: Bool {return _storage._posterImageData != nil}
  /// Clears the value of `posterImageData`. Subsequent reads from it will return its default value.
  mutating func clearPosterImageData() {_uniqueStorage()._posterImageData = nil}

  var audioOnlyImageData: TSP_DataReference {
    get {return _storage._audioOnlyImageData ?? TSP_DataReference()}
    set {_uniqueStorage()._audioOnlyImageData = newValue}
  }
  /// Returns true if `audioOnlyImageData` has been explicitly set.
  var hasAudioOnlyImageData: Bool {return _storage._audioOnlyImageData != nil}
  /// Clears the value of `audioOnlyImageData`. Subsequent reads from it will return its default value.
  mutating func clearAudioOnlyImageData() {_uniqueStorage()._audioOnlyImageData = nil}

  var posterImageGeneratedWithAlphaSupport: Bool {
    get {return _storage._posterImageGeneratedWithAlphaSupport ?? false}
    set {_uniqueStorage()._posterImageGeneratedWithAlphaSupport = newValue}
  }
  /// Returns true if `posterImageGeneratedWithAlphaSupport` has been explicitly set.
  var hasPosterImageGeneratedWithAlphaSupport: Bool {return _storage._posterImageGeneratedWithAlphaSupport != nil}
  /// Clears the value of `posterImageGeneratedWithAlphaSupport`. Subsequent reads from it will return its default value.
  mutating func clearPosterImageGeneratedWithAlphaSupport() {_uniqueStorage()._posterImageGeneratedWithAlphaSupport = nil}

  var playableState: UInt32 {
    get {return _storage._playableState ?? 0}
    set {_uniqueStorage()._playableState = newValue}
  }
  /// Returns true if `playableState` has been explicitly set.
  var hasPlayableState: Bool {return _storage._playableState != nil}
  /// Clears the value of `playableState`. Subsequent reads from it will return its default value.
  mutating func clearPlayableState() {_uniqueStorage()._playableState = nil}

  var flags: UInt32 {
    get {return _storage._flags ?? 0}
    set {_uniqueStorage()._flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  var hasFlags: Bool {return _storage._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  mutating func clearFlags() {_uniqueStorage()._flags = nil}

  var databaseMovieData: TSP_Reference {
    get {return _storage._databaseMovieData ?? TSP_Reference()}
    set {_uniqueStorage()._databaseMovieData = newValue}
  }
  /// Returns true if `databaseMovieData` has been explicitly set.
  var hasDatabaseMovieData: Bool {return _storage._databaseMovieData != nil}
  /// Clears the value of `databaseMovieData`. Subsequent reads from it will return its default value.
  mutating func clearDatabaseMovieData() {_uniqueStorage()._databaseMovieData = nil}

  var databasePosterImageData: TSP_Reference {
    get {return _storage._databasePosterImageData ?? TSP_Reference()}
    set {_uniqueStorage()._databasePosterImageData = newValue}
  }
  /// Returns true if `databasePosterImageData` has been explicitly set.
  var hasDatabasePosterImageData: Bool {return _storage._databasePosterImageData != nil}
  /// Clears the value of `databasePosterImageData`. Subsequent reads from it will return its default value.
  mutating func clearDatabasePosterImageData() {_uniqueStorage()._databasePosterImageData = nil}

  var databaseAudioOnlyImageData: TSP_Reference {
    get {return _storage._databaseAudioOnlyImageData ?? TSP_Reference()}
    set {_uniqueStorage()._databaseAudioOnlyImageData = newValue}
  }
  /// Returns true if `databaseAudioOnlyImageData` has been explicitly set.
  var hasDatabaseAudioOnlyImageData: Bool {return _storage._databaseAudioOnlyImageData != nil}
  /// Clears the value of `databaseAudioOnlyImageData`. Subsequent reads from it will return its default value.
  mutating func clearDatabaseAudioOnlyImageData() {_uniqueStorage()._databaseAudioOnlyImageData = nil}

  var style: TSP_Reference {
    get {return _storage._style ?? TSP_Reference()}
    set {_uniqueStorage()._style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  var hasStyle: Bool {return _storage._style != nil}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  mutating func clearStyle() {_uniqueStorage()._style = nil}

  var originalSize: TSP_Size {
    get {return _storage._originalSize ?? TSP_Size()}
    set {_uniqueStorage()._originalSize = newValue}
  }
  /// Returns true if `originalSize` has been explicitly set.
  var hasOriginalSize: Bool {return _storage._originalSize != nil}
  /// Clears the value of `originalSize`. Subsequent reads from it will return its default value.
  mutating func clearOriginalSize() {_uniqueStorage()._originalSize = nil}

  var naturalSize: TSP_Size {
    get {return _storage._naturalSize ?? TSP_Size()}
    set {_uniqueStorage()._naturalSize = newValue}
  }
  /// Returns true if `naturalSize` has been explicitly set.
  var hasNaturalSize: Bool {return _storage._naturalSize != nil}
  /// Clears the value of `naturalSize`. Subsequent reads from it will return its default value.
  mutating func clearNaturalSize() {_uniqueStorage()._naturalSize = nil}

  var attribution: TSD_Attribution {
    get {return _storage._attribution ?? TSD_Attribution()}
    set {_uniqueStorage()._attribution = newValue}
  }
  /// Returns true if `attribution` has been explicitly set.
  var hasAttribution: Bool {return _storage._attribution != nil}
  /// Clears the value of `attribution`. Subsequent reads from it will return its default value.
  mutating func clearAttribution() {_uniqueStorage()._attribution = nil}

  var fingerprint: TSD_MovieFingerprint {
    get {return _storage._fingerprint ?? TSD_MovieFingerprint()}
    set {_uniqueStorage()._fingerprint = newValue}
  }
  /// Returns true if `fingerprint` has been explicitly set.
  var hasFingerprint: Bool {return _storage._fingerprint != nil}
  /// Clears the value of `fingerprint`. Subsequent reads from it will return its default value.
  mutating func clearFingerprint() {_uniqueStorage()._fingerprint = nil}

  var isLiveVideo: Bool {
    get {return _storage._isLiveVideo ?? false}
    set {_uniqueStorage()._isLiveVideo = newValue}
  }
  /// Returns true if `isLiveVideo` has been explicitly set.
  var hasIsLiveVideo: Bool {return _storage._isLiveVideo != nil}
  /// Clears the value of `isLiveVideo`. Subsequent reads from it will return its default value.
  mutating func clearIsLiveVideo() {_uniqueStorage()._isLiveVideo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum MovieLoopOption: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case none = 0
    case `repeat` = 1
    case backAndForth = 2

    init() {
      self = .none
    }

  }

  init() {}

  var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_ExteriorTextWrapArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: UInt32 {
    get {return _type ?? 0}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var direction: UInt32 {
    get {return _direction ?? 0}
    set {_direction = newValue}
  }
  /// Returns true if `direction` has been explicitly set.
  var hasDirection: Bool {return self._direction != nil}
  /// Clears the value of `direction`. Subsequent reads from it will return its default value.
  mutating func clearDirection() {self._direction = nil}

  var fitType: UInt32 {
    get {return _fitType ?? 0}
    set {_fitType = newValue}
  }
  /// Returns true if `fitType` has been explicitly set.
  var hasFitType: Bool {return self._fitType != nil}
  /// Clears the value of `fitType`. Subsequent reads from it will return its default value.
  mutating func clearFitType() {self._fitType = nil}

  var margin: Float {
    get {return _margin ?? 0}
    set {_margin = newValue}
  }
  /// Returns true if `margin` has been explicitly set.
  var hasMargin: Bool {return self._margin != nil}
  /// Clears the value of `margin`. Subsequent reads from it will return its default value.
  mutating func clearMargin() {self._margin = nil}

  var alphaThreshold: Float {
    get {return _alphaThreshold ?? 0}
    set {_alphaThreshold = newValue}
  }
  /// Returns true if `alphaThreshold` has been explicitly set.
  var hasAlphaThreshold: Bool {return self._alphaThreshold != nil}
  /// Clears the value of `alphaThreshold`. Subsequent reads from it will return its default value.
  mutating func clearAlphaThreshold() {self._alphaThreshold = nil}

  var isHtmlWrap: Bool {
    get {return _isHtmlWrap ?? false}
    set {_isHtmlWrap = newValue}
  }
  /// Returns true if `isHtmlWrap` has been explicitly set.
  var hasIsHtmlWrap: Bool {return self._isHtmlWrap != nil}
  /// Clears the value of `isHtmlWrap`. Subsequent reads from it will return its default value.
  mutating func clearIsHtmlWrap() {self._isHtmlWrap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: UInt32? = nil
  fileprivate var _direction: UInt32? = nil
  fileprivate var _fitType: UInt32? = nil
  fileprivate var _margin: Float? = nil
  fileprivate var _alphaThreshold: Float? = nil
  fileprivate var _isHtmlWrap: Bool? = nil
}

struct TSD_DrawableContentDescription: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var elementKind: UInt32 {
    get {return _elementKind ?? 0}
    set {_elementKind = newValue}
  }
  /// Returns true if `elementKind` has been explicitly set.
  var hasElementKind: Bool {return self._elementKind != nil}
  /// Clears the value of `elementKind`. Subsequent reads from it will return its default value.
  mutating func clearElementKind() {self._elementKind = nil}

  var isAnchoredToText: Bool {
    get {return _isAnchoredToText ?? false}
    set {_isAnchoredToText = newValue}
  }
  /// Returns true if `isAnchoredToText` has been explicitly set.
  var hasIsAnchoredToText: Bool {return self._isAnchoredToText != nil}
  /// Clears the value of `isAnchoredToText`. Subsequent reads from it will return its default value.
  mutating func clearIsAnchoredToText() {self._isAnchoredToText = nil}

  var isFloatingAboveText: Bool {
    get {return _isFloatingAboveText ?? false}
    set {_isFloatingAboveText = newValue}
  }
  /// Returns true if `isFloatingAboveText` has been explicitly set.
  var hasIsFloatingAboveText: Bool {return self._isFloatingAboveText != nil}
  /// Clears the value of `isFloatingAboveText`. Subsequent reads from it will return its default value.
  mutating func clearIsFloatingAboveText() {self._isFloatingAboveText = nil}

  var isInlineWithText: Bool {
    get {return _isInlineWithText ?? false}
    set {_isInlineWithText = newValue}
  }
  /// Returns true if `isInlineWithText` has been explicitly set.
  var hasIsInlineWithText: Bool {return self._isInlineWithText != nil}
  /// Clears the value of `isInlineWithText`. Subsequent reads from it will return its default value.
  mutating func clearIsInlineWithText() {self._isInlineWithText = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _elementKind: UInt32? = nil
  fileprivate var _isAnchoredToText: Bool? = nil
  fileprivate var _isFloatingAboveText: Bool? = nil
  fileprivate var _isInlineWithText: Bool? = nil
}

struct TSD_FreehandDrawingContentDescription: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_DrawableContentDescription {
    get {return _super ?? TSD_DrawableContentDescription()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var sourceDocWantedSpacerShape: Bool {
    get {return _sourceDocWantedSpacerShape ?? false}
    set {_sourceDocWantedSpacerShape = newValue}
  }
  /// Returns true if `sourceDocWantedSpacerShape` has been explicitly set.
  var hasSourceDocWantedSpacerShape: Bool {return self._sourceDocWantedSpacerShape != nil}
  /// Clears the value of `sourceDocWantedSpacerShape`. Subsequent reads from it will return its default value.
  mutating func clearSourceDocWantedSpacerShape() {self._sourceDocWantedSpacerShape = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_DrawableContentDescription? = nil
  fileprivate var _sourceDocWantedSpacerShape: Bool? = nil
}

struct TSD_FreehandDrawingToolkitUIState: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// NOTE: This field was marked as deprecated in the .proto file.
  var currentColor: TSP_Color {
    get {return _storage._currentColor ?? TSP_Color()}
    set {_uniqueStorage()._currentColor = newValue}
  }
  /// Returns true if `currentColor` has been explicitly set.
  var hasCurrentColor: Bool {return _storage._currentColor != nil}
  /// Clears the value of `currentColor`. Subsequent reads from it will return its default value.
  mutating func clearCurrentColor() {_uniqueStorage()._currentColor = nil}

  var mostRecentRestorableToolType: TSD_FreehandDrawingToolkitUIState.FreehandDrawingToolType {
    get {return _storage._mostRecentRestorableToolType ?? .pen}
    set {_uniqueStorage()._mostRecentRestorableToolType = newValue}
  }
  /// Returns true if `mostRecentRestorableToolType` has been explicitly set.
  var hasMostRecentRestorableToolType: Bool {return _storage._mostRecentRestorableToolType != nil}
  /// Clears the value of `mostRecentRestorableToolType`. Subsequent reads from it will return its default value.
  mutating func clearMostRecentRestorableToolType() {_uniqueStorage()._mostRecentRestorableToolType = nil}

  var penToolOpacity: Float {
    get {return _storage._penToolOpacity ?? 0}
    set {_uniqueStorage()._penToolOpacity = newValue}
  }
  /// Returns true if `penToolOpacity` has been explicitly set.
  var hasPenToolOpacity: Bool {return _storage._penToolOpacity != nil}
  /// Clears the value of `penToolOpacity`. Subsequent reads from it will return its default value.
  mutating func clearPenToolOpacity() {_uniqueStorage()._penToolOpacity = nil}

  var penToolUnscaledWidth: Float {
    get {return _storage._penToolUnscaledWidth ?? 0}
    set {_uniqueStorage()._penToolUnscaledWidth = newValue}
  }
  /// Returns true if `penToolUnscaledWidth` has been explicitly set.
  var hasPenToolUnscaledWidth: Bool {return _storage._penToolUnscaledWidth != nil}
  /// Clears the value of `penToolUnscaledWidth`. Subsequent reads from it will return its default value.
  mutating func clearPenToolUnscaledWidth() {_uniqueStorage()._penToolUnscaledWidth = nil}

  var pencilToolOpacity: Float {
    get {return _storage._pencilToolOpacity ?? 0}
    set {_uniqueStorage()._pencilToolOpacity = newValue}
  }
  /// Returns true if `pencilToolOpacity` has been explicitly set.
  var hasPencilToolOpacity: Bool {return _storage._pencilToolOpacity != nil}
  /// Clears the value of `pencilToolOpacity`. Subsequent reads from it will return its default value.
  mutating func clearPencilToolOpacity() {_uniqueStorage()._pencilToolOpacity = nil}

  var pencilToolUnscaledWidth: Float {
    get {return _storage._pencilToolUnscaledWidth ?? 0}
    set {_uniqueStorage()._pencilToolUnscaledWidth = newValue}
  }
  /// Returns true if `pencilToolUnscaledWidth` has been explicitly set.
  var hasPencilToolUnscaledWidth: Bool {return _storage._pencilToolUnscaledWidth != nil}
  /// Clears the value of `pencilToolUnscaledWidth`. Subsequent reads from it will return its default value.
  mutating func clearPencilToolUnscaledWidth() {_uniqueStorage()._pencilToolUnscaledWidth = nil}

  var crayonToolOpacity: Float {
    get {return _storage._crayonToolOpacity ?? 0}
    set {_uniqueStorage()._crayonToolOpacity = newValue}
  }
  /// Returns true if `crayonToolOpacity` has been explicitly set.
  var hasCrayonToolOpacity: Bool {return _storage._crayonToolOpacity != nil}
  /// Clears the value of `crayonToolOpacity`. Subsequent reads from it will return its default value.
  mutating func clearCrayonToolOpacity() {_uniqueStorage()._crayonToolOpacity = nil}

  var crayonToolUnscaledWidth: Float {
    get {return _storage._crayonToolUnscaledWidth ?? 0}
    set {_uniqueStorage()._crayonToolUnscaledWidth = newValue}
  }
  /// Returns true if `crayonToolUnscaledWidth` has been explicitly set.
  var hasCrayonToolUnscaledWidth: Bool {return _storage._crayonToolUnscaledWidth != nil}
  /// Clears the value of `crayonToolUnscaledWidth`. Subsequent reads from it will return its default value.
  mutating func clearCrayonToolUnscaledWidth() {_uniqueStorage()._crayonToolUnscaledWidth = nil}

  var fillToolOpacity: Float {
    get {return _storage._fillToolOpacity ?? 0}
    set {_uniqueStorage()._fillToolOpacity = newValue}
  }
  /// Returns true if `fillToolOpacity` has been explicitly set.
  var hasFillToolOpacity: Bool {return _storage._fillToolOpacity != nil}
  /// Clears the value of `fillToolOpacity`. Subsequent reads from it will return its default value.
  mutating func clearFillToolOpacity() {_uniqueStorage()._fillToolOpacity = nil}

  var eraserToolScaledWidth: Float {
    get {return _storage._eraserToolScaledWidth ?? 0}
    set {_uniqueStorage()._eraserToolScaledWidth = newValue}
  }
  /// Returns true if `eraserToolScaledWidth` has been explicitly set.
  var hasEraserToolScaledWidth: Bool {return _storage._eraserToolScaledWidth != nil}
  /// Clears the value of `eraserToolScaledWidth`. Subsequent reads from it will return its default value.
  mutating func clearEraserToolScaledWidth() {_uniqueStorage()._eraserToolScaledWidth = nil}

  var eraserToolErasesWholeObjects: Bool {
    get {return _storage._eraserToolErasesWholeObjects ?? false}
    set {_uniqueStorage()._eraserToolErasesWholeObjects = newValue}
  }
  /// Returns true if `eraserToolErasesWholeObjects` has been explicitly set.
  var hasEraserToolErasesWholeObjects: Bool {return _storage._eraserToolErasesWholeObjects != nil}
  /// Clears the value of `eraserToolErasesWholeObjects`. Subsequent reads from it will return its default value.
  mutating func clearEraserToolErasesWholeObjects() {_uniqueStorage()._eraserToolErasesWholeObjects = nil}

  var penToolColor: TSP_Color {
    get {return _storage._penToolColor ?? TSP_Color()}
    set {_uniqueStorage()._penToolColor = newValue}
  }
  /// Returns true if `penToolColor` has been explicitly set.
  var hasPenToolColor: Bool {return _storage._penToolColor != nil}
  /// Clears the value of `penToolColor`. Subsequent reads from it will return its default value.
  mutating func clearPenToolColor() {_uniqueStorage()._penToolColor = nil}

  var pencilToolColor: TSP_Color {
    get {return _storage._pencilToolColor ?? TSP_Color()}
    set {_uniqueStorage()._pencilToolColor = newValue}
  }
  /// Returns true if `pencilToolColor` has been explicitly set.
  var hasPencilToolColor: Bool {return _storage._pencilToolColor != nil}
  /// Clears the value of `pencilToolColor`. Subsequent reads from it will return its default value.
  mutating func clearPencilToolColor() {_uniqueStorage()._pencilToolColor = nil}

  var crayonToolColor: TSP_Color {
    get {return _storage._crayonToolColor ?? TSP_Color()}
    set {_uniqueStorage()._crayonToolColor = newValue}
  }
  /// Returns true if `crayonToolColor` has been explicitly set.
  var hasCrayonToolColor: Bool {return _storage._crayonToolColor != nil}
  /// Clears the value of `crayonToolColor`. Subsequent reads from it will return its default value.
  mutating func clearCrayonToolColor() {_uniqueStorage()._crayonToolColor = nil}

  var fillToolColor: TSP_Color {
    get {return _storage._fillToolColor ?? TSP_Color()}
    set {_uniqueStorage()._fillToolColor = newValue}
  }
  /// Returns true if `fillToolColor` has been explicitly set.
  var hasFillToolColor: Bool {return _storage._fillToolColor != nil}
  /// Clears the value of `fillToolColor`. Subsequent reads from it will return its default value.
  mutating func clearFillToolColor() {_uniqueStorage()._fillToolColor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum FreehandDrawingToolType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case pen = 0
    case pencil = 1
    case crayon = 2
    case fill = 3
    case eraser = 4
    case marqueeSelect = 5

    init() {
      self = .pen
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_StandinCaptionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSD_GuideArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: TSD_GuideArchive.GuideType {
    get {return _type ?? .horizontal}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var offset: Float {
    get {return _offset ?? 0}
    set {_offset = newValue}
  }
  /// Returns true if `offset` has been explicitly set.
  var hasOffset: Bool {return self._offset != nil}
  /// Clears the value of `offset`. Subsequent reads from it will return its default value.
  mutating func clearOffset() {self._offset = nil}

  var start: Float {
    get {return _start ?? 0}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  mutating func clearStart() {self._start = nil}

  var end: Float {
    get {return _end ?? 0}
    set {_end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  var hasEnd: Bool {return self._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  mutating func clearEnd() {self._end = nil}

  var dynamic: Bool {
    get {return _dynamic ?? false}
    set {_dynamic = newValue}
  }
  /// Returns true if `dynamic` has been explicitly set.
  var hasDynamic: Bool {return self._dynamic != nil}
  /// Clears the value of `dynamic`. Subsequent reads from it will return its default value.
  mutating func clearDynamic() {self._dynamic = nil}

  var infinite: Bool {
    get {return _infinite ?? false}
    set {_infinite = newValue}
  }
  /// Returns true if `infinite` has been explicitly set.
  var hasInfinite: Bool {return self._infinite != nil}
  /// Clears the value of `infinite`. Subsequent reads from it will return its default value.
  mutating func clearInfinite() {self._infinite = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum GuideType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case horizontal = 0
    case vertical = 1

    init() {
      self = .horizontal
    }

  }

  init() {}

  fileprivate var _type: TSD_GuideArchive.GuideType? = nil
  fileprivate var _offset: Float? = nil
  fileprivate var _start: Float? = nil
  fileprivate var _end: Float? = nil
  fileprivate var _dynamic: Bool? = nil
  fileprivate var _infinite: Bool? = nil
}

struct TSD_UserDefinedGuideArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: TSD_UserDefinedGuideArchive.GuideType {
    get {return _type ?? .horizontal}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var position: Float {
    get {return _position ?? 0}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum GuideType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case horizontal = 0
    case vertical = 1

    init() {
      self = .horizontal
    }

  }

  init() {}

  fileprivate var _type: TSD_UserDefinedGuideArchive.GuideType? = nil
  fileprivate var _position: Float? = nil
}

struct TSD_GuideStorageArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userDefinedGuides: [TSD_UserDefinedGuideArchive] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSD_CanvasSelectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var infos: [TSP_Reference] = []

  var nonInteractiveInfos: [TSP_Reference] = []

  /// NOTE: This field was marked as deprecated in the .proto file.
  var container: TSP_Reference {
    get {return _container ?? TSP_Reference()}
    set {_container = newValue}
  }
  /// Returns true if `container` has been explicitly set.
  var hasContainer: Bool {return self._container != nil}
  /// Clears the value of `container`. Subsequent reads from it will return its default value.
  mutating func clearContainer() {self._container = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _container: TSP_Reference? = nil
}

struct TSD_DrawableSelectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var infos: [TSP_Reference] = []

  var nonInteractiveInfos: [TSP_Reference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSD_GroupSelectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSD_DrawableSelectionArchive {
    get {return _super ?? TSD_DrawableSelectionArchive()}
    set {_super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return self._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {self._super = nil}

  var hasSelectedInfosInNonGroupContainer_p: Bool {
    get {return _hasSelectedInfosInNonGroupContainer_p ?? false}
    set {_hasSelectedInfosInNonGroupContainer_p = newValue}
  }
  /// Returns true if `hasSelectedInfosInNonGroupContainer_p` has been explicitly set.
  var hasHasSelectedInfosInNonGroupContainer_p: Bool {return self._hasSelectedInfosInNonGroupContainer_p != nil}
  /// Clears the value of `hasSelectedInfosInNonGroupContainer_p`. Subsequent reads from it will return its default value.
  mutating func clearHasSelectedInfosInNonGroupContainer_p() {self._hasSelectedInfosInNonGroupContainer_p = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _super: TSD_DrawableSelectionArchive? = nil
  fileprivate var _hasSelectedInfosInNonGroupContainer_p: Bool? = nil
}

struct TSD_PathSelectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSD_InfoHyperlinkSelectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSD_CommentStorageArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: String {
    get {return _text ?? String()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {self._text = nil}

  var creationDate: TSP_Date {
    get {return _creationDate ?? TSP_Date()}
    set {_creationDate = newValue}
  }
  /// Returns true if `creationDate` has been explicitly set.
  var hasCreationDate: Bool {return self._creationDate != nil}
  /// Clears the value of `creationDate`. Subsequent reads from it will return its default value.
  mutating func clearCreationDate() {self._creationDate = nil}

  var author: TSP_Reference {
    get {return _author ?? TSP_Reference()}
    set {_author = newValue}
  }
  /// Returns true if `author` has been explicitly set.
  var hasAuthor: Bool {return self._author != nil}
  /// Clears the value of `author`. Subsequent reads from it will return its default value.
  mutating func clearAuthor() {self._author = nil}

  var replies: [TSP_Reference] = []

  var storageUuid: TSP_UUID {
    get {return _storageUuid ?? TSP_UUID()}
    set {_storageUuid = newValue}
  }
  /// Returns true if `storageUuid` has been explicitly set.
  var hasStorageUuid: Bool {return self._storageUuid != nil}
  /// Clears the value of `storageUuid`. Subsequent reads from it will return its default value.
  mutating func clearStorageUuid() {self._storageUuid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _text: String? = nil
  fileprivate var _creationDate: TSP_Date? = nil
  fileprivate var _author: TSP_Reference? = nil
  fileprivate var _storageUuid: TSP_UUID? = nil
}

struct TSD_ReplaceAnnotationAuthorCommandArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `super`: TSK_CommandArchive {
    get {return _storage._super ?? TSK_CommandArchive()}
    set {_uniqueStorage()._super = newValue}
  }
  /// Returns true if ``super`` has been explicitly set.
  var hasSuper: Bool {return _storage._super != nil}
  /// Clears the value of ``super``. Subsequent reads from it will return its default value.
  mutating func clearSuper() {_uniqueStorage()._super = nil}

  var oldAnnotationAuthor: TSP_Reference {
    get {return _storage._oldAnnotationAuthor ?? TSP_Reference()}
    set {_uniqueStorage()._oldAnnotationAuthor = newValue}
  }
  /// Returns true if `oldAnnotationAuthor` has been explicitly set.
  var hasOldAnnotationAuthor: Bool {return _storage._oldAnnotationAuthor != nil}
  /// Clears the value of `oldAnnotationAuthor`. Subsequent reads from it will return its default value.
  mutating func clearOldAnnotationAuthor() {_uniqueStorage()._oldAnnotationAuthor = nil}

  var newAnnotationAuthor: TSP_Reference {
    get {return _storage._newAnnotationAuthor ?? TSP_Reference()}
    set {_uniqueStorage()._newAnnotationAuthor = newValue}
  }
  /// Returns true if `newAnnotationAuthor` has been explicitly set.
  var hasNewAnnotationAuthor: Bool {return _storage._newAnnotationAuthor != nil}
  /// Clears the value of `newAnnotationAuthor`. Subsequent reads from it will return its default value.
  mutating func clearNewAnnotationAuthor() {_uniqueStorage()._newAnnotationAuthor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_PencilAnnotationArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pencilAnnotationStorage: TSP_Reference {
    get {return _pencilAnnotationStorage ?? TSP_Reference()}
    set {_pencilAnnotationStorage = newValue}
  }
  /// Returns true if `pencilAnnotationStorage` has been explicitly set.
  var hasPencilAnnotationStorage: Bool {return self._pencilAnnotationStorage != nil}
  /// Clears the value of `pencilAnnotationStorage`. Subsequent reads from it will return its default value.
  mutating func clearPencilAnnotationStorage() {self._pencilAnnotationStorage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pencilAnnotationStorage: TSP_Reference? = nil
}

struct TSD_PencilAnnotationSelectionArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pencilAnnotation: TSP_Reference {
    get {return _pencilAnnotation ?? TSP_Reference()}
    set {_pencilAnnotation = newValue}
  }
  /// Returns true if `pencilAnnotation` has been explicitly set.
  var hasPencilAnnotation: Bool {return self._pencilAnnotation != nil}
  /// Clears the value of `pencilAnnotation`. Subsequent reads from it will return its default value.
  mutating func clearPencilAnnotation() {self._pencilAnnotation = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pencilAnnotation: TSP_Reference? = nil
}

struct TSD_PencilAnnotationStorageArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var attachedLocation: Int32 {
    get {return _storage._attachedLocation ?? 0}
    set {_uniqueStorage()._attachedLocation = newValue}
  }
  /// Returns true if `attachedLocation` has been explicitly set.
  var hasAttachedLocation: Bool {return _storage._attachedLocation != nil}
  /// Clears the value of `attachedLocation`. Subsequent reads from it will return its default value.
  mutating func clearAttachedLocation() {_uniqueStorage()._attachedLocation = nil}

  var markupOffset: TSP_Point {
    get {return _storage._markupOffset ?? TSP_Point()}
    set {_uniqueStorage()._markupOffset = newValue}
  }
  /// Returns true if `markupOffset` has been explicitly set.
  var hasMarkupOffset: Bool {return _storage._markupOffset != nil}
  /// Clears the value of `markupOffset`. Subsequent reads from it will return its default value.
  mutating func clearMarkupOffset() {_uniqueStorage()._markupOffset = nil}

  var rasterizedImage: TSP_DataReference {
    get {return _storage._rasterizedImage ?? TSP_DataReference()}
    set {_uniqueStorage()._rasterizedImage = newValue}
  }
  /// Returns true if `rasterizedImage` has been explicitly set.
  var hasRasterizedImage: Bool {return _storage._rasterizedImage != nil}
  /// Clears the value of `rasterizedImage`. Subsequent reads from it will return its default value.
  mutating func clearRasterizedImage() {_uniqueStorage()._rasterizedImage = nil}

  var legacyEncodedDrawing: TSP_DataReference {
    get {return _storage._legacyEncodedDrawing ?? TSP_DataReference()}
    set {_uniqueStorage()._legacyEncodedDrawing = newValue}
  }
  /// Returns true if `legacyEncodedDrawing` has been explicitly set.
  var hasLegacyEncodedDrawing: Bool {return _storage._legacyEncodedDrawing != nil}
  /// Clears the value of `legacyEncodedDrawing`. Subsequent reads from it will return its default value.
  mutating func clearLegacyEncodedDrawing() {_uniqueStorage()._legacyEncodedDrawing = nil}

  var drawingPath: TSP_Path {
    get {return _storage._drawingPath ?? TSP_Path()}
    set {_uniqueStorage()._drawingPath = newValue}
  }
  /// Returns true if `drawingPath` has been explicitly set.
  var hasDrawingPath: Bool {return _storage._drawingPath != nil}
  /// Clears the value of `drawingPath`. Subsequent reads from it will return its default value.
  mutating func clearDrawingPath() {_uniqueStorage()._drawingPath = nil}

  var strokesBoundingBoxOrigin: TSP_Point {
    get {return _storage._strokesBoundingBoxOrigin ?? TSP_Point()}
    set {_uniqueStorage()._strokesBoundingBoxOrigin = newValue}
  }
  /// Returns true if `strokesBoundingBoxOrigin` has been explicitly set.
  var hasStrokesBoundingBoxOrigin: Bool {return _storage._strokesBoundingBoxOrigin != nil}
  /// Clears the value of `strokesBoundingBoxOrigin`. Subsequent reads from it will return its default value.
  mutating func clearStrokesBoundingBoxOrigin() {_uniqueStorage()._strokesBoundingBoxOrigin = nil}

  var strokesBoundingBoxSize: TSP_Size {
    get {return _storage._strokesBoundingBoxSize ?? TSP_Size()}
    set {_uniqueStorage()._strokesBoundingBoxSize = newValue}
  }
  /// Returns true if `strokesBoundingBoxSize` has been explicitly set.
  var hasStrokesBoundingBoxSize: Bool {return _storage._strokesBoundingBoxSize != nil}
  /// Clears the value of `strokesBoundingBoxSize`. Subsequent reads from it will return its default value.
  mutating func clearStrokesBoundingBoxSize() {_uniqueStorage()._strokesBoundingBoxSize = nil}

  var attachedType: Int32 {
    get {return _storage._attachedType ?? 0}
    set {_uniqueStorage()._attachedType = newValue}
  }
  /// Returns true if `attachedType` has been explicitly set.
  var hasAttachedType: Bool {return _storage._attachedType != nil}
  /// Clears the value of `attachedType`. Subsequent reads from it will return its default value.
  mutating func clearAttachedType() {_uniqueStorage()._attachedType = nil}

  var originalAttachedSize: TSP_Size {
    get {return _storage._originalAttachedSize ?? TSP_Size()}
    set {_uniqueStorage()._originalAttachedSize = newValue}
  }
  /// Returns true if `originalAttachedSize` has been explicitly set.
  var hasOriginalAttachedSize: Bool {return _storage._originalAttachedSize != nil}
  /// Clears the value of `originalAttachedSize`. Subsequent reads from it will return its default value.
  mutating func clearOriginalAttachedSize() {_uniqueStorage()._originalAttachedSize = nil}

  var percentOfPaContainedInParentRep: Double {
    get {return _storage._percentOfPaContainedInParentRep ?? 0}
    set {_uniqueStorage()._percentOfPaContainedInParentRep = newValue}
  }
  /// Returns true if `percentOfPaContainedInParentRep` has been explicitly set.
  var hasPercentOfPaContainedInParentRep: Bool {return _storage._percentOfPaContainedInParentRep != nil}
  /// Clears the value of `percentOfPaContainedInParentRep`. Subsequent reads from it will return its default value.
  mutating func clearPercentOfPaContainedInParentRep() {_uniqueStorage()._percentOfPaContainedInParentRep = nil}

  var textBaselinesTouchedCount: UInt64 {
    get {return _storage._textBaselinesTouchedCount ?? 0}
    set {_uniqueStorage()._textBaselinesTouchedCount = newValue}
  }
  /// Returns true if `textBaselinesTouchedCount` has been explicitly set.
  var hasTextBaselinesTouchedCount: Bool {return _storage._textBaselinesTouchedCount != nil}
  /// Clears the value of `textBaselinesTouchedCount`. Subsequent reads from it will return its default value.
  mutating func clearTextBaselinesTouchedCount() {_uniqueStorage()._textBaselinesTouchedCount = nil}

  var visibleStrokesCount: UInt64 {
    get {return _storage._visibleStrokesCount ?? 0}
    set {_uniqueStorage()._visibleStrokesCount = newValue}
  }
  /// Returns true if `visibleStrokesCount` has been explicitly set.
  var hasVisibleStrokesCount: Bool {return _storage._visibleStrokesCount != nil}
  /// Clears the value of `visibleStrokesCount`. Subsequent reads from it will return its default value.
  mutating func clearVisibleStrokesCount() {_uniqueStorage()._visibleStrokesCount = nil}

  var penColor: TSP_Color {
    get {return _storage._penColor ?? TSP_Color()}
    set {_uniqueStorage()._penColor = newValue}
  }
  /// Returns true if `penColor` has been explicitly set.
  var hasPenColor: Bool {return _storage._penColor != nil}
  /// Clears the value of `penColor`. Subsequent reads from it will return its default value.
  mutating func clearPenColor() {_uniqueStorage()._penColor = nil}

  var toolType: Int32 {
    get {return _storage._toolType ?? 0}
    set {_uniqueStorage()._toolType = newValue}
  }
  /// Returns true if `toolType` has been explicitly set.
  var hasToolType: Bool {return _storage._toolType != nil}
  /// Clears the value of `toolType`. Subsequent reads from it will return its default value.
  mutating func clearToolType() {_uniqueStorage()._toolType = nil}

  var calloutSubStorages: [TSP_Reference] {
    get {return _storage._calloutSubStorages}
    set {_uniqueStorage()._calloutSubStorages = newValue}
  }

  var creationDate: TSP_Date {
    get {return _storage._creationDate ?? TSP_Date()}
    set {_uniqueStorage()._creationDate = newValue}
  }
  /// Returns true if `creationDate` has been explicitly set.
  var hasCreationDate: Bool {return _storage._creationDate != nil}
  /// Clears the value of `creationDate`. Subsequent reads from it will return its default value.
  mutating func clearCreationDate() {_uniqueStorage()._creationDate = nil}

  var pencilAnnotationDrawingScale: Double {
    get {return _storage._pencilAnnotationDrawingScale ?? 0}
    set {_uniqueStorage()._pencilAnnotationDrawingScale = newValue}
  }
  /// Returns true if `pencilAnnotationDrawingScale` has been explicitly set.
  var hasPencilAnnotationDrawingScale: Bool {return _storage._pencilAnnotationDrawingScale != nil}
  /// Clears the value of `pencilAnnotationDrawingScale`. Subsequent reads from it will return its default value.
  mutating func clearPencilAnnotationDrawingScale() {_uniqueStorage()._pencilAnnotationDrawingScale = nil}

  var compoundAnnotationType: Int32 {
    get {return _storage._compoundAnnotationType ?? 0}
    set {_uniqueStorage()._compoundAnnotationType = newValue}
  }
  /// Returns true if `compoundAnnotationType` has been explicitly set.
  var hasCompoundAnnotationType: Bool {return _storage._compoundAnnotationType != nil}
  /// Clears the value of `compoundAnnotationType`. Subsequent reads from it will return its default value.
  mutating func clearCompoundAnnotationType() {_uniqueStorage()._compoundAnnotationType = nil}

  var subStorages: [TSP_Reference] {
    get {return _storage._subStorages}
    set {_uniqueStorage()._subStorages = newValue}
  }

  var encodedDrawing: TSP_DataReference {
    get {return _storage._encodedDrawing ?? TSP_DataReference()}
    set {_uniqueStorage()._encodedDrawing = newValue}
  }
  /// Returns true if `encodedDrawing` has been explicitly set.
  var hasEncodedDrawing: Bool {return _storage._encodedDrawing != nil}
  /// Clears the value of `encodedDrawing`. Subsequent reads from it will return its default value.
  mutating func clearEncodedDrawing() {_uniqueStorage()._encodedDrawing = nil}

  var strokePointsFrameOrigin: TSP_Point {
    get {return _storage._strokePointsFrameOrigin ?? TSP_Point()}
    set {_uniqueStorage()._strokePointsFrameOrigin = newValue}
  }
  /// Returns true if `strokePointsFrameOrigin` has been explicitly set.
  var hasStrokePointsFrameOrigin: Bool {return _storage._strokePointsFrameOrigin != nil}
  /// Clears the value of `strokePointsFrameOrigin`. Subsequent reads from it will return its default value.
  mutating func clearStrokePointsFrameOrigin() {_uniqueStorage()._strokePointsFrameOrigin = nil}

  var strokePointsFrameSize: TSP_Size {
    get {return _storage._strokePointsFrameSize ?? TSP_Size()}
    set {_uniqueStorage()._strokePointsFrameSize = newValue}
  }
  /// Returns true if `strokePointsFrameSize` has been explicitly set.
  var hasStrokePointsFrameSize: Bool {return _storage._strokePointsFrameSize != nil}
  /// Clears the value of `strokePointsFrameSize`. Subsequent reads from it will return its default value.
  mutating func clearStrokePointsFrameSize() {_uniqueStorage()._strokePointsFrameSize = nil}

  var renderedFrameOrigin: TSP_Point {
    get {return _storage._renderedFrameOrigin ?? TSP_Point()}
    set {_uniqueStorage()._renderedFrameOrigin = newValue}
  }
  /// Returns true if `renderedFrameOrigin` has been explicitly set.
  var hasRenderedFrameOrigin: Bool {return _storage._renderedFrameOrigin != nil}
  /// Clears the value of `renderedFrameOrigin`. Subsequent reads from it will return its default value.
  mutating func clearRenderedFrameOrigin() {_uniqueStorage()._renderedFrameOrigin = nil}

  var renderedFrameSize: TSP_Size {
    get {return _storage._renderedFrameSize ?? TSP_Size()}
    set {_uniqueStorage()._renderedFrameSize = newValue}
  }
  /// Returns true if `renderedFrameSize` has been explicitly set.
  var hasRenderedFrameSize: Bool {return _storage._renderedFrameSize != nil}
  /// Clears the value of `renderedFrameSize`. Subsequent reads from it will return its default value.
  mutating func clearRenderedFrameSize() {_uniqueStorage()._renderedFrameSize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_SpecColorFillSetColorArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var color: TSP_Color {
    get {return _color ?? TSP_Color()}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {self._color = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _color: TSP_Color? = nil
}

struct TSD_SpecFrameSetAssetScaleArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assetScale: Double {
    get {return _assetScale ?? 0}
    set {_assetScale = newValue}
  }
  /// Returns true if `assetScale` has been explicitly set.
  var hasAssetScale: Bool {return self._assetScale != nil}
  /// Clears the value of `assetScale`. Subsequent reads from it will return its default value.
  mutating func clearAssetScale() {self._assetScale = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _assetScale: Double? = nil
}

struct TSD_SpecGradientFillSetAngleArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var angle: Double {
    get {return _angle ?? 0}
    set {_angle = newValue}
  }
  /// Returns true if `angle` has been explicitly set.
  var hasAngle: Bool {return self._angle != nil}
  /// Clears the value of `angle`. Subsequent reads from it will return its default value.
  mutating func clearAngle() {self._angle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _angle: Double? = nil
}

struct TSD_SpecImageFillSetTechniqueArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var technique: Int32 {
    get {return _technique ?? 0}
    set {_technique = newValue}
  }
  /// Returns true if `technique` has been explicitly set.
  var hasTechnique: Bool {return self._technique != nil}
  /// Clears the value of `technique`. Subsequent reads from it will return its default value.
  mutating func clearTechnique() {self._technique = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _technique: Int32? = nil
}

struct TSD_SpecReflectionSetOpacityArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var opacity: Double {
    get {return _opacity ?? 0}
    set {_opacity = newValue}
  }
  /// Returns true if `opacity` has been explicitly set.
  var hasOpacity: Bool {return self._opacity != nil}
  /// Clears the value of `opacity`. Subsequent reads from it will return its default value.
  mutating func clearOpacity() {self._opacity = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _opacity: Double? = nil
}

struct TSD_SpecShadowSetAngleArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var angle: Double {
    get {return _angle ?? 0}
    set {_angle = newValue}
  }
  /// Returns true if `angle` has been explicitly set.
  var hasAngle: Bool {return self._angle != nil}
  /// Clears the value of `angle`. Subsequent reads from it will return its default value.
  mutating func clearAngle() {self._angle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _angle: Double? = nil
}

struct TSD_SpecShadowSetColorArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var color: TSP_Color {
    get {return _color ?? TSP_Color()}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {self._color = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _color: TSP_Color? = nil
}

struct TSD_SpecShadowSetOffsetArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offset: Double {
    get {return _offset ?? 0}
    set {_offset = newValue}
  }
  /// Returns true if `offset` has been explicitly set.
  var hasOffset: Bool {return self._offset != nil}
  /// Clears the value of `offset`. Subsequent reads from it will return its default value.
  mutating func clearOffset() {self._offset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _offset: Double? = nil
}

struct TSD_SpecShadowSetOpacityArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var opacity: Double {
    get {return _opacity ?? 0}
    set {_opacity = newValue}
  }
  /// Returns true if `opacity` has been explicitly set.
  var hasOpacity: Bool {return self._opacity != nil}
  /// Clears the value of `opacity`. Subsequent reads from it will return its default value.
  mutating func clearOpacity() {self._opacity = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _opacity: Double? = nil
}

struct TSD_SpecShadowSetRadiusArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var radius: Int32 {
    get {return _radius ?? 0}
    set {_radius = newValue}
  }
  /// Returns true if `radius` has been explicitly set.
  var hasRadius: Bool {return self._radius != nil}
  /// Clears the value of `radius`. Subsequent reads from it will return its default value.
  mutating func clearRadius() {self._radius = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _radius: Int32? = nil
}

struct TSD_SpecStrokeSetColorArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var color: TSP_Color {
    get {return _color ?? TSP_Color()}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {self._color = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _color: TSP_Color? = nil
}

struct TSD_SpecStrokeSetPatternArchive: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lineCap: Int32 {
    get {return _storage._lineCap ?? 0}
    set {_uniqueStorage()._lineCap = newValue}
  }
  /// Returns true if `lineCap` has been explicitly set.
  var hasLineCap: Bool {return _storage._lineCap != nil}
  /// Clears the value of `lineCap`. Subsequent reads from it will return its default value.
  mutating func clearLineCap() {_uniqueStorage()._lineCap = nil}

  var lineJoin: Int32 {
    get {return _storage._lineJoin ?? 0}
    set {_uniqueStorage()._lineJoin = newValue}
  }
  /// Returns true if `lineJoin` has been explicitly set.
  var hasLineJoin: Bool {return _storage._lineJoin != nil}
  /// Clears the value of `lineJoin`. Subsequent reads from it will return its default value.
  mutating func clearLineJoin() {_uniqueStorage()._lineJoin = nil}

  var miterLimit: Double {
    get {return _storage._miterLimit ?? 0}
    set {_uniqueStorage()._miterLimit = newValue}
  }
  /// Returns true if `miterLimit` has been explicitly set.
  var hasMiterLimit: Bool {return _storage._miterLimit != nil}
  /// Clears the value of `miterLimit`. Subsequent reads from it will return its default value.
  mutating func clearMiterLimit() {_uniqueStorage()._miterLimit = nil}

  var width: Double {
    get {return _storage._width ?? 0}
    set {_uniqueStorage()._width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  var hasWidth: Bool {return _storage._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  mutating func clearWidth() {_uniqueStorage()._width = nil}

  var color: TSP_Color {
    get {return _storage._color ?? TSP_Color()}
    set {_uniqueStorage()._color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return _storage._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {_uniqueStorage()._color = nil}

  var pattern: TSD_StrokePatternArchive {
    get {return _storage._pattern ?? TSD_StrokePatternArchive()}
    set {_uniqueStorage()._pattern = newValue}
  }
  /// Returns true if `pattern` has been explicitly set.
  var hasPattern: Bool {return _storage._pattern != nil}
  /// Clears the value of `pattern`. Subsequent reads from it will return its default value.
  mutating func clearPattern() {_uniqueStorage()._pattern = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct TSD_SpecStrokeSetWidthArchive: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var width: Double {
    get {return _width ?? 0}
    set {_width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  var hasWidth: Bool {return self._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  mutating func clearWidth() {self._width = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _width: Double? = nil
}

struct TSD_Attribution: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {self._title = nil}

  var descriptionText: String {
    get {return _descriptionText ?? String()}
    set {_descriptionText = newValue}
  }
  /// Returns true if `descriptionText` has been explicitly set.
  var hasDescriptionText: Bool {return self._descriptionText != nil}
  /// Clears the value of `descriptionText`. Subsequent reads from it will return its default value.
  mutating func clearDescriptionText() {self._descriptionText = nil}

  var externalURL: String {
    get {return _externalURL ?? String()}
    set {_externalURL = newValue}
  }
  /// Returns true if `externalURL` has been explicitly set.
  var hasExternalURL: Bool {return self._externalURL != nil}
  /// Clears the value of `externalURL`. Subsequent reads from it will return its default value.
  mutating func clearExternalURL() {self._externalURL = nil}

  var authorName: String {
    get {return _authorName ?? String()}
    set {_authorName = newValue}
  }
  /// Returns true if `authorName` has been explicitly set.
  var hasAuthorName: Bool {return self._authorName != nil}
  /// Clears the value of `authorName`. Subsequent reads from it will return its default value.
  mutating func clearAuthorName() {self._authorName = nil}

  var authorURL: String {
    get {return _authorURL ?? String()}
    set {_authorURL = newValue}
  }
  /// Returns true if `authorURL` has been explicitly set.
  var hasAuthorURL: Bool {return self._authorURL != nil}
  /// Clears the value of `authorURL`. Subsequent reads from it will return its default value.
  mutating func clearAuthorURL() {self._authorURL = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _title: String? = nil
  fileprivate var _descriptionText: String? = nil
  fileprivate var _externalURL: String? = nil
  fileprivate var _authorName: String? = nil
  fileprivate var _authorURL: String? = nil
}

struct TSD_MovieFingerprint: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tracks: [TSD_MovieFingerprintTrack] = []

  var version: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TSD_MovieFingerprintTrack: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mediaType: String {
    get {return _storage._mediaType ?? String()}
    set {_uniqueStorage()._mediaType = newValue}
  }
  /// Returns true if `mediaType` has been explicitly set.
  var hasMediaType: Bool {return _storage._mediaType != nil}
  /// Clears the value of `mediaType`. Subsequent reads from it will return its default value.
  mutating func clearMediaType() {_uniqueStorage()._mediaType = nil}

  var enabled: Bool {
    get {return _storage._enabled ?? false}
    set {_uniqueStorage()._enabled = newValue}
  }
  /// Returns true if `enabled` has been explicitly set.
  var hasEnabled: Bool {return _storage._enabled != nil}
  /// Clears the value of `enabled`. Subsequent reads from it will return its default value.
  mutating func clearEnabled() {_uniqueStorage()._enabled = nil}

  var totalSampleDataLength: Int64 {
    get {return _storage._totalSampleDataLength ?? 0}
    set {_uniqueStorage()._totalSampleDataLength = newValue}
  }
  /// Returns true if `totalSampleDataLength` has been explicitly set.
  var hasTotalSampleDataLength: Bool {return _storage._totalSampleDataLength != nil}
  /// Clears the value of `totalSampleDataLength`. Subsequent reads from it will return its default value.
  mutating func clearTotalSampleDataLength() {_uniqueStorage()._totalSampleDataLength = nil}

  var sampleDataDigestString: String {
    get {return _storage._sampleDataDigestString ?? String()}
    set {_uniqueStorage()._sampleDataDigestString = newValue}
  }
  /// Returns true if `sampleDataDigestString` has been explicitly set.
  var hasSampleDataDigestString: Bool {return _storage._sampleDataDigestString != nil}
  /// Clears the value of `sampleDataDigestString`. Subsequent reads from it will return its default value.
  mutating func clearSampleDataDigestString() {_uniqueStorage()._sampleDataDigestString = nil}

  var timeRangeStartValue: Int64 {
    get {return _storage._timeRangeStartValue ?? 0}
    set {_uniqueStorage()._timeRangeStartValue = newValue}
  }
  /// Returns true if `timeRangeStartValue` has been explicitly set.
  var hasTimeRangeStartValue: Bool {return _storage._timeRangeStartValue != nil}
  /// Clears the value of `timeRangeStartValue`. Subsequent reads from it will return its default value.
  mutating func clearTimeRangeStartValue() {_uniqueStorage()._timeRangeStartValue = nil}

  var timeRangeStartTimescale: Int32 {
    get {return _storage._timeRangeStartTimescale ?? 0}
    set {_uniqueStorage()._timeRangeStartTimescale = newValue}
  }
  /// Returns true if `timeRangeStartTimescale` has been explicitly set.
  var hasTimeRangeStartTimescale: Bool {return _storage._timeRangeStartTimescale != nil}
  /// Clears the value of `timeRangeStartTimescale`. Subsequent reads from it will return its default value.
  mutating func clearTimeRangeStartTimescale() {_uniqueStorage()._timeRangeStartTimescale = nil}

  var timeRangeStartIsValid: Bool {
    get {return _storage._timeRangeStartIsValid ?? false}
    set {_uniqueStorage()._timeRangeStartIsValid = newValue}
  }
  /// Returns true if `timeRangeStartIsValid` has been explicitly set.
  var hasTimeRangeStartIsValid: Bool {return _storage._timeRangeStartIsValid != nil}
  /// Clears the value of `timeRangeStartIsValid`. Subsequent reads from it will return its default value.
  mutating func clearTimeRangeStartIsValid() {_uniqueStorage()._timeRangeStartIsValid = nil}

  var timeRangeDurationValue: Int64 {
    get {return _storage._timeRangeDurationValue ?? 0}
    set {_uniqueStorage()._timeRangeDurationValue = newValue}
  }
  /// Returns true if `timeRangeDurationValue` has been explicitly set.
  var hasTimeRangeDurationValue: Bool {return _storage._timeRangeDurationValue != nil}
  /// Clears the value of `timeRangeDurationValue`. Subsequent reads from it will return its default value.
  mutating func clearTimeRangeDurationValue() {_uniqueStorage()._timeRangeDurationValue = nil}

  var timeRangeDurationTimescale: Int32 {
    get {return _storage._timeRangeDurationTimescale ?? 0}
    set {_uniqueStorage()._timeRangeDurationTimescale = newValue}
  }
  /// Returns true if `timeRangeDurationTimescale` has been explicitly set.
  var hasTimeRangeDurationTimescale: Bool {return _storage._timeRangeDurationTimescale != nil}
  /// Clears the value of `timeRangeDurationTimescale`. Subsequent reads from it will return its default value.
  mutating func clearTimeRangeDurationTimescale() {_uniqueStorage()._timeRangeDurationTimescale = nil}

  var timeRangeDurationIsValid: Bool {
    get {return _storage._timeRangeDurationIsValid ?? false}
    set {_uniqueStorage()._timeRangeDurationIsValid = newValue}
  }
  /// Returns true if `timeRangeDurationIsValid` has been explicitly set.
  var hasTimeRangeDurationIsValid: Bool {return _storage._timeRangeDurationIsValid != nil}
  /// Clears the value of `timeRangeDurationIsValid`. Subsequent reads from it will return its default value.
  mutating func clearTimeRangeDurationIsValid() {_uniqueStorage()._timeRangeDurationIsValid = nil}

  var naturalSize: TSP_Size {
    get {return _storage._naturalSize ?? TSP_Size()}
    set {_uniqueStorage()._naturalSize = newValue}
  }
  /// Returns true if `naturalSize` has been explicitly set.
  var hasNaturalSize: Bool {return _storage._naturalSize != nil}
  /// Clears the value of `naturalSize`. Subsequent reads from it will return its default value.
  mutating func clearNaturalSize() {_uniqueStorage()._naturalSize = nil}

  var preferredTransformA: Double {
    get {return _storage._preferredTransformA ?? 0}
    set {_uniqueStorage()._preferredTransformA = newValue}
  }
  /// Returns true if `preferredTransformA` has been explicitly set.
  var hasPreferredTransformA: Bool {return _storage._preferredTransformA != nil}
  /// Clears the value of `preferredTransformA`. Subsequent reads from it will return its default value.
  mutating func clearPreferredTransformA() {_uniqueStorage()._preferredTransformA = nil}

  var preferredTransformB: Double {
    get {return _storage._preferredTransformB ?? 0}
    set {_uniqueStorage()._preferredTransformB = newValue}
  }
  /// Returns true if `preferredTransformB` has been explicitly set.
  var hasPreferredTransformB: Bool {return _storage._preferredTransformB != nil}
  /// Clears the value of `preferredTransformB`. Subsequent reads from it will return its default value.
  mutating func clearPreferredTransformB() {_uniqueStorage()._preferredTransformB = nil}

  var preferredTransformC: Double {
    get {return _storage._preferredTransformC ?? 0}
    set {_uniqueStorage()._preferredTransformC = newValue}
  }
  /// Returns true if `preferredTransformC` has been explicitly set.
  var hasPreferredTransformC: Bool {return _storage._preferredTransformC != nil}
  /// Clears the value of `preferredTransformC`. Subsequent reads from it will return its default value.
  mutating func clearPreferredTransformC() {_uniqueStorage()._preferredTransformC = nil}

  var preferredTransformD: Double {
    get {return _storage._preferredTransformD ?? 0}
    set {_uniqueStorage()._preferredTransformD = newValue}
  }
  /// Returns true if `preferredTransformD` has been explicitly set.
  var hasPreferredTransformD: Bool {return _storage._preferredTransformD != nil}
  /// Clears the value of `preferredTransformD`. Subsequent reads from it will return its default value.
  mutating func clearPreferredTransformD() {_uniqueStorage()._preferredTransformD = nil}

  var preferredTransformTx: Double {
    get {return _storage._preferredTransformTx ?? 0}
    set {_uniqueStorage()._preferredTransformTx = newValue}
  }
  /// Returns true if `preferredTransformTx` has been explicitly set.
  var hasPreferredTransformTx: Bool {return _storage._preferredTransformTx != nil}
  /// Clears the value of `preferredTransformTx`. Subsequent reads from it will return its default value.
  mutating func clearPreferredTransformTx() {_uniqueStorage()._preferredTransformTx = nil}

  var preferredTransformTy: Double {
    get {return _storage._preferredTransformTy ?? 0}
    set {_uniqueStorage()._preferredTransformTy = newValue}
  }
  /// Returns true if `preferredTransformTy` has been explicitly set.
  var hasPreferredTransformTy: Bool {return _storage._preferredTransformTy != nil}
  /// Clears the value of `preferredTransformTy`. Subsequent reads from it will return its default value.
  mutating func clearPreferredTransformTy() {_uniqueStorage()._preferredTransformTy = nil}

  var preferredVolume: Double {
    get {return _storage._preferredVolume ?? 0}
    set {_uniqueStorage()._preferredVolume = newValue}
  }
  /// Returns true if `preferredVolume` has been explicitly set.
  var hasPreferredVolume: Bool {return _storage._preferredVolume != nil}
  /// Clears the value of `preferredVolume`. Subsequent reads from it will return its default value.
  mutating func clearPreferredVolume() {_uniqueStorage()._preferredVolume = nil}

  var languageCode: String {
    get {return _storage._languageCode ?? String()}
    set {_uniqueStorage()._languageCode = newValue}
  }
  /// Returns true if `languageCode` has been explicitly set.
  var hasLanguageCode: Bool {return _storage._languageCode != nil}
  /// Clears the value of `languageCode`. Subsequent reads from it will return its default value.
  mutating func clearLanguageCode() {_uniqueStorage()._languageCode = nil}

  var extendedLanguageTag: String {
    get {return _storage._extendedLanguageTag ?? String()}
    set {_uniqueStorage()._extendedLanguageTag = newValue}
  }
  /// Returns true if `extendedLanguageTag` has been explicitly set.
  var hasExtendedLanguageTag: Bool {return _storage._extendedLanguageTag != nil}
  /// Clears the value of `extendedLanguageTag`. Subsequent reads from it will return its default value.
  mutating func clearExtendedLanguageTag() {_uniqueStorage()._extendedLanguageTag = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Extension support defined in TSDArchives.proto.

// MARK: - Extension Properties

// Swift Extensions on the extended Messages to add easy access to the declared
// extension fields. The names are based on the extension field name from the proto
// declaration. To avoid naming collisions, the names are prefixed with the name of
// the scope where the extend directive occurs.

extension TSD_GroupArchive {

  var TSD_FreehandDrawingArchive_freehandDrawingArchive: TSD_FreehandDrawingArchive {
    get {return getExtensionValue(ext: TSD_FreehandDrawingArchive.Extensions.freehand_drawing_archive) ?? TSD_FreehandDrawingArchive()}
    set {setExtensionValue(ext: TSD_FreehandDrawingArchive.Extensions.freehand_drawing_archive, value: newValue)}
  }
  /// Returns true if extension `TSD_FreehandDrawingArchive.Extensions.freehand_drawing_archive`
  /// has been explicitly set.
  var hasTSD_FreehandDrawingArchive_freehandDrawingArchive: Bool {
    return hasExtensionValue(ext: TSD_FreehandDrawingArchive.Extensions.freehand_drawing_archive)
  }
  /// Clears the value of extension `TSD_FreehandDrawingArchive.Extensions.freehand_drawing_archive`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTSD_FreehandDrawingArchive_freehandDrawingArchive() {
    clearExtensionValue(ext: TSD_FreehandDrawingArchive.Extensions.freehand_drawing_archive)
  }
}

extension TSP_DataAttributes {

  var TSD_ImageDataAttributes_imageDataAttributes: TSD_ImageDataAttributes {
    get {return getExtensionValue(ext: TSD_ImageDataAttributes.Extensions.image_data_attributes) ?? TSD_ImageDataAttributes()}
    set {setExtensionValue(ext: TSD_ImageDataAttributes.Extensions.image_data_attributes, value: newValue)}
  }
  /// Returns true if extension `TSD_ImageDataAttributes.Extensions.image_data_attributes`
  /// has been explicitly set.
  var hasTSD_ImageDataAttributes_imageDataAttributes: Bool {
    return hasExtensionValue(ext: TSD_ImageDataAttributes.Extensions.image_data_attributes)
  }
  /// Clears the value of extension `TSD_ImageDataAttributes.Extensions.image_data_attributes`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTSD_ImageDataAttributes_imageDataAttributes() {
    clearExtensionValue(ext: TSD_ImageDataAttributes.Extensions.image_data_attributes)
  }
}

extension TSS_CommandPropertyEntryArchive {

  var TSD_fill: TSD_FillArchive {
    get {return getExtensionValue(ext: TSD_Extensions_fill) ?? TSD_FillArchive()}
    set {setExtensionValue(ext: TSD_Extensions_fill, value: newValue)}
  }
  /// Returns true if extension `TSD_Extensions_fill`
  /// has been explicitly set.
  var hasTSD_fill: Bool {
    return hasExtensionValue(ext: TSD_Extensions_fill)
  }
  /// Clears the value of extension `TSD_Extensions_fill`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTSD_fill() {
    clearExtensionValue(ext: TSD_Extensions_fill)
  }

  var TSD_stroke: TSD_StrokeArchive {
    get {return getExtensionValue(ext: TSD_Extensions_stroke) ?? TSD_StrokeArchive()}
    set {setExtensionValue(ext: TSD_Extensions_stroke, value: newValue)}
  }
  /// Returns true if extension `TSD_Extensions_stroke`
  /// has been explicitly set.
  var hasTSD_stroke: Bool {
    return hasExtensionValue(ext: TSD_Extensions_stroke)
  }
  /// Clears the value of extension `TSD_Extensions_stroke`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTSD_stroke() {
    clearExtensionValue(ext: TSD_Extensions_stroke)
  }
}

extension TSS_ThemeArchive {

  var TSD_ThemePresetsArchive_extension: TSD_ThemePresetsArchive {
    get {return getExtensionValue(ext: TSD_ThemePresetsArchive.Extensions.extension) ?? TSD_ThemePresetsArchive()}
    set {setExtensionValue(ext: TSD_ThemePresetsArchive.Extensions.extension, value: newValue)}
  }
  /// Returns true if extension `TSD_ThemePresetsArchive.Extensions.extension`
  /// has been explicitly set.
  var hasTSD_ThemePresetsArchive_extension: Bool {
    return hasExtensionValue(ext: TSD_ThemePresetsArchive.Extensions.extension)
  }
  /// Clears the value of extension `TSD_ThemePresetsArchive.Extensions.extension`.
  /// Subsequent reads from it will return its default value.
  mutating func clearTSD_ThemePresetsArchive_extension() {
    clearExtensionValue(ext: TSD_ThemePresetsArchive.Extensions.extension)
  }

}

// MARK: - File's ExtensionMap: TSD_Tsdarchives_Extensions

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
let TSD_Tsdarchives_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  TSD_Extensions_fill,
  TSD_Extensions_stroke,
  TSD_ThemePresetsArchive.Extensions.extension,
  TSD_FreehandDrawingArchive.Extensions.freehand_drawing_archive,
  TSD_ImageDataAttributes.Extensions.image_data_attributes
]

// Extension Objects - The only reason these might be needed is when manually
// constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
// accessors for the extension fields on the messages directly.

let TSD_Extensions_fill = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TSD_FillArchive>, TSS_CommandPropertyEntryArchive>(
  _protobuf_fieldNumber: 200,
  fieldName: "TSD.fill"
)

let TSD_Extensions_stroke = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TSD_StrokeArchive>, TSS_CommandPropertyEntryArchive>(
  _protobuf_fieldNumber: 201,
  fieldName: "TSD.stroke"
)

extension TSD_ThemePresetsArchive {
  enum Extensions {
    static let `extension` = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TSD_ThemePresetsArchive>, TSS_ThemeArchive>(
      _protobuf_fieldNumber: 100,
      fieldName: "TSD.ThemePresetsArchive.extension"
    )
  }
}

extension TSD_FreehandDrawingArchive {
  enum Extensions {
    static let freehand_drawing_archive = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TSD_FreehandDrawingArchive>, TSD_GroupArchive>(
      _protobuf_fieldNumber: 100,
      fieldName: "TSD.FreehandDrawingArchive.freehand_drawing_archive"
    )
  }
}

extension TSD_ImageDataAttributes {
  enum Extensions {
    static let image_data_attributes = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<TSD_ImageDataAttributes>, TSP_DataAttributes>(
      _protobuf_fieldNumber: 100,
      fieldName: "TSD.ImageDataAttributes.image_data_attributes"
    )
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TSD"

extension TSD_LineJoin: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0MiterJoin\0\u{1}RoundJoin\0\u{1}BevelJoin\0")
}

extension TSD_EdgeInsetsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EdgeInsetsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}top\0\u{1}left\0\u{1}bottom\0\u{1}right\0")

  public var isInitialized: Bool {
    if self._top == nil {return false}
    if self._left == nil {return false}
    if self._bottom == nil {return false}
    if self._right == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._top) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._left) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._bottom) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._right) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._top {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._left {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._bottom {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._right {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_EdgeInsetsArchive, rhs: TSD_EdgeInsetsArchive) -> Bool {
    if lhs._top != rhs._top {return false}
    if lhs._left != rhs._left {return false}
    if lhs._bottom != rhs._bottom {return false}
    if lhs._right != rhs._right {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_GeometryArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GeometryArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}position\0\u{1}size\0\u{1}flags\0\u{1}angle\0")

  public var isInitialized: Bool {
    if let v = self._position, !v.isInitialized {return false}
    if let v = self._size, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._flags) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._angle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._flags {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._angle {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_GeometryArchive, rhs: TSD_GeometryArchive) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs._size != rhs._size {return false}
    if lhs._flags != rhs._flags {return false}
    if lhs._angle != rhs._angle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_PointPathSourceArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PointPathSourceArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}point\0\u{1}naturalSize\0")

  public var isInitialized: Bool {
    if let v = self._point, !v.isInitialized {return false}
    if let v = self._naturalSize, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._point) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._naturalSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._point {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._naturalSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_PointPathSourceArchive, rhs: TSD_PointPathSourceArchive) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._point != rhs._point {return false}
    if lhs._naturalSize != rhs._naturalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_PointPathSourceArchive.PointPathSourceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kTSDLeftSingleArrow\0\u{1}kTSDRightSingleArrow\0\u{2}\u{9}kTSDDoubleArrow\0\u{2}Z\u{1}kTSDStar\0\u{2}d\u{1}kTSDPlus\0")
}

extension TSD_ScalarPathSourceArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScalarPathSourceArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}scalar\0\u{1}naturalSize\0\u{3}is_curve_continuous\0")

  public var isInitialized: Bool {
    if let v = self._naturalSize, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._scalar) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._naturalSize) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._isCurveContinuous) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._scalar {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._naturalSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._isCurveContinuous {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ScalarPathSourceArchive, rhs: TSD_ScalarPathSourceArchive) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._scalar != rhs._scalar {return false}
    if lhs._naturalSize != rhs._naturalSize {return false}
    if lhs._isCurveContinuous != rhs._isCurveContinuous {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ScalarPathSourceArchive.ScalarPathSourceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kTSDRoundedRectangle\0\u{1}kTSDRegularPolygon\0\u{1}kTSDChevron\0")
}

extension TSD_BezierPathSourceArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BezierPathSourceArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}path_string\0\u{1}naturalSize\0\u{1}path\0")

  public var isInitialized: Bool {
    if let v = self._naturalSize, !v.isInitialized {return false}
    if let v = self._path, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._pathString) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._naturalSize) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pathString {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._naturalSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._path {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_BezierPathSourceArchive, rhs: TSD_BezierPathSourceArchive) -> Bool {
    if lhs._pathString != rhs._pathString {return false}
    if lhs._naturalSize != rhs._naturalSize {return false}
    if lhs._path != rhs._path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_CalloutPathSourceArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CalloutPathSourceArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}natural_size\0\u{3}tail_position\0\u{3}tail_size\0\u{3}corner_radius\0\u{3}center_tail\0")

  public var isInitialized: Bool {
    if let v = self._naturalSize, !v.isInitialized {return false}
    if let v = self._tailPosition, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._naturalSize) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tailPosition) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._tailSize) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._cornerRadius) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._centerTail) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._naturalSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tailPosition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._tailSize {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._cornerRadius {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._centerTail {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_CalloutPathSourceArchive, rhs: TSD_CalloutPathSourceArchive) -> Bool {
    if lhs._naturalSize != rhs._naturalSize {return false}
    if lhs._tailPosition != rhs._tailPosition {return false}
    if lhs._tailSize != rhs._tailSize {return false}
    if lhs._cornerRadius != rhs._cornerRadius {return false}
    if lhs._centerTail != rhs._centerTail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ConnectionLinePathSourceArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionLinePathSourceArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}type\0\u{3}outset_from\0\u{3}outset_to\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._outsetFrom) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._outsetTo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._outsetFrom {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._outsetTo {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ConnectionLinePathSourceArchive, rhs: TSD_ConnectionLinePathSourceArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._type != rhs._type {return false}
    if lhs._outsetFrom != rhs._outsetFrom {return false}
    if lhs._outsetTo != rhs._outsetTo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ConnectionLinePathSourceArchive.ConnectionLinePathSourceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0kTSDConnectionLineTypeQuadratic\0\u{1}kTSDConnectionLineTypeOrthogonal\0")
}

extension TSD_EditableBezierPathSourceArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EditableBezierPathSourceArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}subpaths\0\u{1}naturalSize\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.subpaths) {return false}
    if let v = self._naturalSize, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.subpaths) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._naturalSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.subpaths.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subpaths, fieldNumber: 1)
    }
    try { if let v = self._naturalSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_EditableBezierPathSourceArchive, rhs: TSD_EditableBezierPathSourceArchive) -> Bool {
    if lhs.subpaths != rhs.subpaths {return false}
    if lhs._naturalSize != rhs._naturalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_EditableBezierPathSourceArchive.NodeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}sharp\0\u{1}bezier\0\u{1}smooth\0")
}

extension TSD_EditableBezierPathSourceArchive.Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSD_EditableBezierPathSourceArchive.protoMessageName + ".Node"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}inControlPoint\0\u{1}nodePoint\0\u{1}outControlPoint\0\u{1}type\0")

  public var isInitialized: Bool {
    if self._inControlPoint == nil {return false}
    if self._nodePoint == nil {return false}
    if self._outControlPoint == nil {return false}
    if self._type == nil {return false}
    if let v = self._inControlPoint, !v.isInitialized {return false}
    if let v = self._nodePoint, !v.isInitialized {return false}
    if let v = self._outControlPoint, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._inControlPoint) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._nodePoint) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._outControlPoint) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._inControlPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nodePoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._outControlPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_EditableBezierPathSourceArchive.Node, rhs: TSD_EditableBezierPathSourceArchive.Node) -> Bool {
    if lhs._inControlPoint != rhs._inControlPoint {return false}
    if lhs._nodePoint != rhs._nodePoint {return false}
    if lhs._outControlPoint != rhs._outControlPoint {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_EditableBezierPathSourceArchive.Subpath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSD_EditableBezierPathSourceArchive.protoMessageName + ".Subpath"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}nodes\0\u{1}closed\0")

  public var isInitialized: Bool {
    if self._closed == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.nodes) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._closed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    try { if let v = self._closed {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_EditableBezierPathSourceArchive.Subpath, rhs: TSD_EditableBezierPathSourceArchive.Subpath) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs._closed != rhs._closed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_PathSourceArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PathSourceArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}horizontalFlip\0\u{1}verticalFlip\0\u{3}point_path_source\0\u{3}scalar_path_source\0\u{3}bezier_path_source\0\u{3}callout_path_source\0\u{3}connection_line_path_source\0\u{3}editable_bezier_path_source\0\u{1}localizationKey\0\u{1}userDefinedName\0")

  fileprivate class _StorageClass {
    var _horizontalFlip: Bool? = nil
    var _verticalFlip: Bool? = nil
    var _pointPathSource: TSD_PointPathSourceArchive? = nil
    var _scalarPathSource: TSD_ScalarPathSourceArchive? = nil
    var _bezierPathSource: TSD_BezierPathSourceArchive? = nil
    var _calloutPathSource: TSD_CalloutPathSourceArchive? = nil
    var _connectionLinePathSource: TSD_ConnectionLinePathSourceArchive? = nil
    var _editableBezierPathSource: TSD_EditableBezierPathSourceArchive? = nil
    var _localizationKey: String? = nil
    var _userDefinedName: String? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _horizontalFlip = source._horizontalFlip
      _verticalFlip = source._verticalFlip
      _pointPathSource = source._pointPathSource
      _scalarPathSource = source._scalarPathSource
      _bezierPathSource = source._bezierPathSource
      _calloutPathSource = source._calloutPathSource
      _connectionLinePathSource = source._connectionLinePathSource
      _editableBezierPathSource = source._editableBezierPathSource
      _localizationKey = source._localizationKey
      _userDefinedName = source._userDefinedName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._pointPathSource, !v.isInitialized {return false}
      if let v = _storage._scalarPathSource, !v.isInitialized {return false}
      if let v = _storage._bezierPathSource, !v.isInitialized {return false}
      if let v = _storage._calloutPathSource, !v.isInitialized {return false}
      if let v = _storage._connectionLinePathSource, !v.isInitialized {return false}
      if let v = _storage._editableBezierPathSource, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._horizontalFlip) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._verticalFlip) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._pointPathSource) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._scalarPathSource) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._bezierPathSource) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._calloutPathSource) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._connectionLinePathSource) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._editableBezierPathSource) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._localizationKey) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._userDefinedName) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._horizontalFlip {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._verticalFlip {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._pointPathSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._scalarPathSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._bezierPathSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._calloutPathSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._connectionLinePathSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._editableBezierPathSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._localizationKey {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._userDefinedName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_PathSourceArchive, rhs: TSD_PathSourceArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._horizontalFlip != rhs_storage._horizontalFlip {return false}
        if _storage._verticalFlip != rhs_storage._verticalFlip {return false}
        if _storage._pointPathSource != rhs_storage._pointPathSource {return false}
        if _storage._scalarPathSource != rhs_storage._scalarPathSource {return false}
        if _storage._bezierPathSource != rhs_storage._bezierPathSource {return false}
        if _storage._calloutPathSource != rhs_storage._calloutPathSource {return false}
        if _storage._connectionLinePathSource != rhs_storage._connectionLinePathSource {return false}
        if _storage._editableBezierPathSource != rhs_storage._editableBezierPathSource {return false}
        if _storage._localizationKey != rhs_storage._localizationKey {return false}
        if _storage._userDefinedName != rhs_storage._userDefinedName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_AngleGradientArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AngleGradientArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}gradientangle\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularFloatField(value: &self._gradientangle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._gradientangle {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_AngleGradientArchive, rhs: TSD_AngleGradientArchive) -> Bool {
    if lhs._gradientangle != rhs._gradientangle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_TransformGradientArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransformGradientArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}start\0\u{1}end\0\u{1}baseNaturalSize\0")

  public var isInitialized: Bool {
    if let v = self._start, !v.isInitialized {return false}
    if let v = self._end, !v.isInitialized {return false}
    if let v = self._baseNaturalSize, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._start) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._end) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._baseNaturalSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._start {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._end {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._baseNaturalSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_TransformGradientArchive, rhs: TSD_TransformGradientArchive) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._end != rhs._end {return false}
    if lhs._baseNaturalSize != rhs._baseNaturalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_GradientArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GradientArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}stops\0\u{1}opacity\0\u{1}advancedGradient\0\u{1}anglegradient\0\u{1}transformgradient\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.stops) {return false}
    if let v = self._transformgradient, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.stops) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._opacity) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._advancedGradient) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._anglegradient) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._transformgradient) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.stops.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stops, fieldNumber: 2)
    }
    try { if let v = self._opacity {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._advancedGradient {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._anglegradient {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._transformgradient {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_GradientArchive, rhs: TSD_GradientArchive) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.stops != rhs.stops {return false}
    if lhs._opacity != rhs._opacity {return false}
    if lhs._advancedGradient != rhs._advancedGradient {return false}
    if lhs._anglegradient != rhs._anglegradient {return false}
    if lhs._transformgradient != rhs._transformgradient {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_GradientArchive.GradientType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Linear\0\u{1}Radial\0")
}

extension TSD_GradientArchive.GradientStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TSD_GradientArchive.protoMessageName + ".GradientStop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}color\0\u{1}fraction\0\u{1}inflection\0")

  public var isInitialized: Bool {
    if let v = self._color, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._fraction) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._inflection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fraction {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._inflection {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_GradientArchive.GradientStop, rhs: TSD_GradientArchive.GradientStop) -> Bool {
    if lhs._color != rhs._color {return false}
    if lhs._fraction != rhs._fraction {return false}
    if lhs._inflection != rhs._inflection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ImageFillArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageFillArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}database_imagedata\0\u{1}technique\0\u{1}tint\0\u{1}fillsize\0\u{3}database_originalimagedata\0\u{1}imagedata\0\u{1}originalimagedata\0\u{1}interpretsUntaggedImageDataAsGeneric\0\u{1}referencecolor\0")

  fileprivate class _StorageClass {
    var _imagedata: TSP_DataReference? = nil
    var _technique: TSD_ImageFillArchive.ImageFillTechnique? = nil
    var _tint: TSP_Color? = nil
    var _fillsize: TSP_Size? = nil
    var _originalimagedata: TSP_DataReference? = nil
    var _interpretsUntaggedImageDataAsGeneric: Bool? = nil
    var _referencecolor: TSP_Color? = nil
    var _databaseImagedata: TSP_Reference? = nil
    var _databaseOriginalimagedata: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _imagedata = source._imagedata
      _technique = source._technique
      _tint = source._tint
      _fillsize = source._fillsize
      _originalimagedata = source._originalimagedata
      _interpretsUntaggedImageDataAsGeneric = source._interpretsUntaggedImageDataAsGeneric
      _referencecolor = source._referencecolor
      _databaseImagedata = source._databaseImagedata
      _databaseOriginalimagedata = source._databaseOriginalimagedata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._imagedata, !v.isInitialized {return false}
      if let v = _storage._tint, !v.isInitialized {return false}
      if let v = _storage._fillsize, !v.isInitialized {return false}
      if let v = _storage._originalimagedata, !v.isInitialized {return false}
      if let v = _storage._referencecolor, !v.isInitialized {return false}
      if let v = _storage._databaseImagedata, !v.isInitialized {return false}
      if let v = _storage._databaseOriginalimagedata, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._databaseImagedata) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._technique) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._tint) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._fillsize) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._databaseOriginalimagedata) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._imagedata) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._originalimagedata) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._interpretsUntaggedImageDataAsGeneric) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._referencecolor) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._databaseImagedata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._technique {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._tint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._fillsize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._databaseOriginalimagedata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._imagedata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._originalimagedata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._interpretsUntaggedImageDataAsGeneric {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._referencecolor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ImageFillArchive, rhs: TSD_ImageFillArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._imagedata != rhs_storage._imagedata {return false}
        if _storage._technique != rhs_storage._technique {return false}
        if _storage._tint != rhs_storage._tint {return false}
        if _storage._fillsize != rhs_storage._fillsize {return false}
        if _storage._originalimagedata != rhs_storage._originalimagedata {return false}
        if _storage._interpretsUntaggedImageDataAsGeneric != rhs_storage._interpretsUntaggedImageDataAsGeneric {return false}
        if _storage._referencecolor != rhs_storage._referencecolor {return false}
        if _storage._databaseImagedata != rhs_storage._databaseImagedata {return false}
        if _storage._databaseOriginalimagedata != rhs_storage._databaseOriginalimagedata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ImageFillArchive.ImageFillTechnique: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NaturalSize\0\u{1}Stretch\0\u{1}Tile\0\u{1}ScaleToFill\0\u{1}ScaleToFit\0")
}

extension TSD_FillArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FillArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}color\0\u{1}gradient\0\u{1}image\0")

  fileprivate class _StorageClass {
    var _color: TSP_Color? = nil
    var _gradient: TSD_GradientArchive? = nil
    var _image: TSD_ImageFillArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _color = source._color
      _gradient = source._gradient
      _image = source._image
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._color, !v.isInitialized {return false}
      if let v = _storage._gradient, !v.isInitialized {return false}
      if let v = _storage._image, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._color) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._gradient) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._image) }()
        case 100..<536870912:
          try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TSD_FillArchive.self, fieldNumber: fieldNumber) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._color {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._gradient {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._image {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 100, end: 536870912)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_FillArchive, rhs: TSD_FillArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._color != rhs_storage._color {return false}
        if _storage._gradient != rhs_storage._gradient {return false}
        if _storage._image != rhs_storage._image {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TSD_StrokePatternArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StrokePatternArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}phase\0\u{1}count\0\u{1}pattern\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._phase) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._count) }()
      case 4: try { try decoder.decodeRepeatedFloatField(value: &self.pattern) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._phase {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._count {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    if !self.pattern.isEmpty {
      try visitor.visitRepeatedFloatField(value: self.pattern, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_StrokePatternArchive, rhs: TSD_StrokePatternArchive) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._phase != rhs._phase {return false}
    if lhs._count != rhs._count {return false}
    if lhs.pattern != rhs.pattern {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_StrokePatternArchive.StrokePatternType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TSDPattern\0\u{1}TSDSolidPattern\0\u{1}TSDEmptyPattern\0")
}

extension TSD_StrokeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StrokeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}color\0\u{1}width\0\u{1}cap\0\u{1}join\0\u{3}miter_limit\0\u{1}pattern\0\u{3}smart_stroke\0\u{1}frame\0\u{3}patterned_stroke\0")

  fileprivate class _StorageClass {
    var _color: TSP_Color? = nil
    var _width: Float? = nil
    var _cap: TSD_StrokeArchive.LineCap? = nil
    var _join: TSD_LineJoin? = nil
    var _miterLimit: Float? = nil
    var _pattern: TSD_StrokePatternArchive? = nil
    var _smartStroke: TSD_SmartStrokeArchive? = nil
    var _frame: TSD_FrameArchive? = nil
    var _patternedStroke: TSD_PatternedStrokeArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _color = source._color
      _width = source._width
      _cap = source._cap
      _join = source._join
      _miterLimit = source._miterLimit
      _pattern = source._pattern
      _smartStroke = source._smartStroke
      _frame = source._frame
      _patternedStroke = source._patternedStroke
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._color, !v.isInitialized {return false}
      if let v = _storage._smartStroke, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._color) }()
        case 2: try { try decoder.decodeSingularFloatField(value: &_storage._width) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._cap) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._join) }()
        case 5: try { try decoder.decodeSingularFloatField(value: &_storage._miterLimit) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._pattern) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._smartStroke) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._frame) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._patternedStroke) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._color {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._width {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._cap {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._join {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._miterLimit {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._pattern {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._smartStroke {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._frame {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._patternedStroke {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_StrokeArchive, rhs: TSD_StrokeArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._color != rhs_storage._color {return false}
        if _storage._width != rhs_storage._width {return false}
        if _storage._cap != rhs_storage._cap {return false}
        if _storage._join != rhs_storage._join {return false}
        if _storage._miterLimit != rhs_storage._miterLimit {return false}
        if _storage._pattern != rhs_storage._pattern {return false}
        if _storage._smartStroke != rhs_storage._smartStroke {return false}
        if _storage._frame != rhs_storage._frame {return false}
        if _storage._patternedStroke != rhs_storage._patternedStroke {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_StrokeArchive.LineCap: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ButtCap\0\u{1}RoundCap\0\u{1}SquareCap\0")
}

extension TSD_SmartStrokeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SmartStrokeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{2}stroke_name\0\u{3}random_seed\0\u{1}parameterValues\0\u{3}pattern_offset_distance\0")

  public var isInitialized: Bool {
    if let v = self._parameterValues, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._strokeName) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._randomSeed) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._parameterValues) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self._patternOffsetDistance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._strokeName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._randomSeed {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._parameterValues {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._patternOffsetDistance {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_SmartStrokeArchive, rhs: TSD_SmartStrokeArchive) -> Bool {
    if lhs._strokeName != rhs._strokeName {return false}
    if lhs._randomSeed != rhs._randomSeed {return false}
    if lhs._parameterValues != rhs._parameterValues {return false}
    if lhs._patternOffsetDistance != rhs._patternOffsetDistance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_FrameArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FrameArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}frameName\0\u{1}assetScale\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._frameName) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._assetScale) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._frameName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._assetScale {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_FrameArchive, rhs: TSD_FrameArchive) -> Bool {
    if lhs._frameName != rhs._frameName {return false}
    if lhs._assetScale != rhs._assetScale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_PatternedStrokeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PatternedStrokeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{2}pattern_name\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._patternName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._patternName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_PatternedStrokeArchive, rhs: TSD_PatternedStrokeArchive) -> Bool {
    if lhs._patternName != rhs._patternName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_LineEndArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LineEndArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}path\0\u{3}line_join\0\u{3}end_point\0\u{3}is_filled\0\u{1}identifier\0")

  public var isInitialized: Bool {
    if let v = self._path, !v.isInitialized {return false}
    if let v = self._endPoint, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._path) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._lineJoin) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._endPoint) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._isFilled) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._identifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._path {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lineJoin {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._endPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._isFilled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._identifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_LineEndArchive, rhs: TSD_LineEndArchive) -> Bool {
    if lhs._path != rhs._path {return false}
    if lhs._lineJoin != rhs._lineJoin {return false}
    if lhs._endPoint != rhs._endPoint {return false}
    if lhs._isFilled != rhs._isFilled {return false}
    if lhs._identifier != rhs._identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ShadowArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShadowArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}color\0\u{1}angle\0\u{1}offset\0\u{1}radius\0\u{1}opacity\0\u{3}is_enabled\0\u{1}type\0\u{1}dropShadow\0\u{1}contactShadow\0\u{1}curvedShadow\0")

  fileprivate class _StorageClass {
    var _color: TSP_Color? = nil
    var _angle: Float? = nil
    var _offset: Float? = nil
    var _radius: Int32? = nil
    var _opacity: Float? = nil
    var _isEnabled: Bool? = nil
    var _type: TSD_ShadowArchive.ShadowType? = nil
    var _dropShadow: TSD_DropShadowArchive? = nil
    var _contactShadow: TSD_ContactShadowArchive? = nil
    var _curvedShadow: TSD_CurvedShadowArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _color = source._color
      _angle = source._angle
      _offset = source._offset
      _radius = source._radius
      _opacity = source._opacity
      _isEnabled = source._isEnabled
      _type = source._type
      _dropShadow = source._dropShadow
      _contactShadow = source._contactShadow
      _curvedShadow = source._curvedShadow
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._color, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._color) }()
        case 2: try { try decoder.decodeSingularFloatField(value: &_storage._angle) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._offset) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._radius) }()
        case 5: try { try decoder.decodeSingularFloatField(value: &_storage._opacity) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._isEnabled) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._dropShadow) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._contactShadow) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._curvedShadow) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._color {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._angle {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._offset {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._radius {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._opacity {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._isEnabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._dropShadow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._contactShadow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._curvedShadow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ShadowArchive, rhs: TSD_ShadowArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._color != rhs_storage._color {return false}
        if _storage._angle != rhs_storage._angle {return false}
        if _storage._offset != rhs_storage._offset {return false}
        if _storage._radius != rhs_storage._radius {return false}
        if _storage._opacity != rhs_storage._opacity {return false}
        if _storage._isEnabled != rhs_storage._isEnabled {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._dropShadow != rhs_storage._dropShadow {return false}
        if _storage._contactShadow != rhs_storage._contactShadow {return false}
        if _storage._curvedShadow != rhs_storage._curvedShadow {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ShadowArchive.ShadowType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TSDDropShadow\0\u{1}TSDContactShadow\0\u{1}TSDCurvedShadow\0")
}

extension TSD_DropShadowArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DropShadowArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_DropShadowArchive, rhs: TSD_DropShadowArchive) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ContactShadowArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContactShadowArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}height\0\u{2}\u{2}offset\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularFloatField(value: &self._height) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._height {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._offset {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ContactShadowArchive, rhs: TSD_ContactShadowArchive) -> Bool {
    if lhs._height != rhs._height {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_CurvedShadowArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CurvedShadowArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}curve\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._curve) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._curve {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_CurvedShadowArchive, rhs: TSD_CurvedShadowArchive) -> Bool {
    if lhs._curve != rhs._curve {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ReflectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReflectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}opacity\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._opacity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._opacity {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ReflectionArchive, rhs: TSD_ReflectionArchive) -> Bool {
    if lhs._opacity != rhs._opacity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ImageAdjustmentsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageAdjustmentsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}exposure\0\u{1}saturation\0\u{1}contrast\0\u{1}highlights\0\u{1}shadows\0\u{1}sharpness\0\u{1}denoise\0\u{1}temperature\0\u{1}tint\0\u{3}bottom_level\0\u{3}top_level\0\u{1}gamma\0\u{1}enhance\0\u{3}represents_sage_adjustments\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._exposure) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._saturation) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._contrast) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._highlights) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._shadows) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self._sharpness) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self._denoise) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self._temperature) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self._tint) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self._bottomLevel) }()
      case 11: try { try decoder.decodeSingularFloatField(value: &self._topLevel) }()
      case 12: try { try decoder.decodeSingularFloatField(value: &self._gamma) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self._enhance) }()
      case 14: try { try decoder.decodeSingularBoolField(value: &self._representsSageAdjustments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._exposure {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._saturation {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._contrast {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._highlights {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._shadows {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._sharpness {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._denoise {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._temperature {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._tint {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._bottomLevel {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._topLevel {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._gamma {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._enhance {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._representsSageAdjustments {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ImageAdjustmentsArchive, rhs: TSD_ImageAdjustmentsArchive) -> Bool {
    if lhs._exposure != rhs._exposure {return false}
    if lhs._saturation != rhs._saturation {return false}
    if lhs._contrast != rhs._contrast {return false}
    if lhs._highlights != rhs._highlights {return false}
    if lhs._shadows != rhs._shadows {return false}
    if lhs._sharpness != rhs._sharpness {return false}
    if lhs._denoise != rhs._denoise {return false}
    if lhs._temperature != rhs._temperature {return false}
    if lhs._tint != rhs._tint {return false}
    if lhs._bottomLevel != rhs._bottomLevel {return false}
    if lhs._topLevel != rhs._topLevel {return false}
    if lhs._gamma != rhs._gamma {return false}
    if lhs._enhance != rhs._enhance {return false}
    if lhs._representsSageAdjustments != rhs._representsSageAdjustments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ShapeStylePropertiesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShapeStylePropertiesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}fill\0\u{1}stroke\0\u{1}opacity\0\u{1}shadow\0\u{1}reflection\0\u{3}head_line_end\0\u{3}tail_line_end\0")

  fileprivate class _StorageClass {
    var _fill: TSD_FillArchive? = nil
    var _stroke: TSD_StrokeArchive? = nil
    var _opacity: Float? = nil
    var _shadow: TSD_ShadowArchive? = nil
    var _reflection: TSD_ReflectionArchive? = nil
    var _headLineEnd: TSD_LineEndArchive? = nil
    var _tailLineEnd: TSD_LineEndArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _fill = source._fill
      _stroke = source._stroke
      _opacity = source._opacity
      _shadow = source._shadow
      _reflection = source._reflection
      _headLineEnd = source._headLineEnd
      _tailLineEnd = source._tailLineEnd
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._fill, !v.isInitialized {return false}
      if let v = _storage._stroke, !v.isInitialized {return false}
      if let v = _storage._shadow, !v.isInitialized {return false}
      if let v = _storage._headLineEnd, !v.isInitialized {return false}
      if let v = _storage._tailLineEnd, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._fill) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._stroke) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._opacity) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._shadow) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._reflection) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._headLineEnd) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._tailLineEnd) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._fill {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._stroke {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._opacity {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._shadow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._reflection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._headLineEnd {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._tailLineEnd {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ShapeStylePropertiesArchive, rhs: TSD_ShapeStylePropertiesArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._fill != rhs_storage._fill {return false}
        if _storage._stroke != rhs_storage._stroke {return false}
        if _storage._opacity != rhs_storage._opacity {return false}
        if _storage._shadow != rhs_storage._shadow {return false}
        if _storage._reflection != rhs_storage._reflection {return false}
        if _storage._headLineEnd != rhs_storage._headLineEnd {return false}
        if _storage._tailLineEnd != rhs_storage._tailLineEnd {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ShapeStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShapeStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{9}override_count\0\u{3}shape_properties\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._shapeProperties, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._overrideCount) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._shapeProperties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._overrideCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._shapeProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ShapeStyleArchive, rhs: TSD_ShapeStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._overrideCount != rhs._overrideCount {return false}
    if lhs._shapeProperties != rhs._shapeProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_MediaStylePropertiesArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaStylePropertiesArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}stroke\0\u{1}opacity\0\u{1}shadow\0\u{1}reflection\0")

  public var isInitialized: Bool {
    if let v = self._stroke, !v.isInitialized {return false}
    if let v = self._shadow, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._stroke) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._opacity) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._shadow) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._reflection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stroke {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._opacity {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._shadow {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._reflection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_MediaStylePropertiesArchive, rhs: TSD_MediaStylePropertiesArchive) -> Bool {
    if lhs._stroke != rhs._stroke {return false}
    if lhs._opacity != rhs._opacity {return false}
    if lhs._shadow != rhs._shadow {return false}
    if lhs._reflection != rhs._reflection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_MediaStyleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaStyleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{4}\u{9}override_count\0\u{3}media_properties\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._mediaProperties, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._overrideCount) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._mediaProperties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._overrideCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._mediaProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_MediaStyleArchive, rhs: TSD_MediaStyleArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._overrideCount != rhs._overrideCount {return false}
    if lhs._mediaProperties != rhs._mediaProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ThemePresetsArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThemePresetsArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}gradient_fill_presets\0\u{3}image_fill_presets\0\u{3}shadow_presets\0\u{3}line_style_presets\0\u{3}shape_style_presets\0\u{3}textbox_style_presets\0\u{3}image_style_presets\0\u{3}movie_style_presets\0\u{3}drawing_line_style_presets\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.gradientFillPresets) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.imageFillPresets) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.shadowPresets) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.lineStylePresets) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.shapeStylePresets) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.textboxStylePresets) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.imageStylePresets) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.movieStylePresets) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.drawingLineStylePresets) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gradientFillPresets) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.imageFillPresets) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.shadowPresets) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.lineStylePresets) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.shapeStylePresets) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.textboxStylePresets) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.imageStylePresets) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.movieStylePresets) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.drawingLineStylePresets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gradientFillPresets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gradientFillPresets, fieldNumber: 1)
    }
    if !self.imageFillPresets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.imageFillPresets, fieldNumber: 2)
    }
    if !self.shadowPresets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shadowPresets, fieldNumber: 3)
    }
    if !self.lineStylePresets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lineStylePresets, fieldNumber: 4)
    }
    if !self.shapeStylePresets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shapeStylePresets, fieldNumber: 5)
    }
    if !self.textboxStylePresets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.textboxStylePresets, fieldNumber: 6)
    }
    if !self.imageStylePresets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.imageStylePresets, fieldNumber: 7)
    }
    if !self.movieStylePresets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.movieStylePresets, fieldNumber: 8)
    }
    if !self.drawingLineStylePresets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.drawingLineStylePresets, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ThemePresetsArchive, rhs: TSD_ThemePresetsArchive) -> Bool {
    if lhs.gradientFillPresets != rhs.gradientFillPresets {return false}
    if lhs.imageFillPresets != rhs.imageFillPresets {return false}
    if lhs.shadowPresets != rhs.shadowPresets {return false}
    if lhs.lineStylePresets != rhs.lineStylePresets {return false}
    if lhs.shapeStylePresets != rhs.shapeStylePresets {return false}
    if lhs.textboxStylePresets != rhs.textboxStylePresets {return false}
    if lhs.imageStylePresets != rhs.imageStylePresets {return false}
    if lhs.movieStylePresets != rhs.movieStylePresets {return false}
    if lhs.drawingLineStylePresets != rhs.drawingLineStylePresets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ThemeReplaceFillPresetCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThemeReplaceFillPresetCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}theme\0\u{1}fill\0\u{3}old_fill\0\u{1}index\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _theme: TSP_Reference? = nil
    var _fill: TSD_FillArchive? = nil
    var _oldFill: TSD_FillArchive? = nil
    var _index: UInt32? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _theme = source._theme
      _fill = source._fill
      _oldFill = source._oldFill
      _index = source._index
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if _storage._theme == nil {return false}
      if _storage._fill == nil {return false}
      if _storage._oldFill == nil {return false}
      if _storage._index == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._theme, !v.isInitialized {return false}
      if let v = _storage._fill, !v.isInitialized {return false}
      if let v = _storage._oldFill, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._theme) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._fill) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._oldFill) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._index) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._theme {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._fill {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._oldFill {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._index {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ThemeReplaceFillPresetCommandArchive, rhs: TSD_ThemeReplaceFillPresetCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._theme != rhs_storage._theme {return false}
        if _storage._fill != rhs_storage._fill {return false}
        if _storage._oldFill != rhs_storage._oldFill {return false}
        if _storage._index != rhs_storage._index {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_DrawableArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawableArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}geometry\0\u{1}parent\0\u{3}exterior_text_wrap\0\u{3}hyperlink_url\0\u{1}locked\0\u{1}comment\0\u{3}aspect_ratio_locked\0\u{3}accessibility_description\0\u{3}pencil_annotations\0\u{1}title\0\u{1}caption\0\u{3}title_hidden\0\u{3}caption_hidden\0")

  fileprivate class _StorageClass {
    var _geometry: TSD_GeometryArchive? = nil
    var _parent: TSP_Reference? = nil
    var _exteriorTextWrap: TSD_ExteriorTextWrapArchive? = nil
    var _hyperlinkURL: String? = nil
    var _locked: Bool? = nil
    var _comment: TSP_Reference? = nil
    var _aspectRatioLocked: Bool? = nil
    var _accessibilityDescription: String? = nil
    var _pencilAnnotations: [TSP_Reference] = []
    var _title: TSP_Reference? = nil
    var _caption: TSP_Reference? = nil
    var _titleHidden: Bool? = nil
    var _captionHidden: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _geometry = source._geometry
      _parent = source._parent
      _exteriorTextWrap = source._exteriorTextWrap
      _hyperlinkURL = source._hyperlinkURL
      _locked = source._locked
      _comment = source._comment
      _aspectRatioLocked = source._aspectRatioLocked
      _accessibilityDescription = source._accessibilityDescription
      _pencilAnnotations = source._pencilAnnotations
      _title = source._title
      _caption = source._caption
      _titleHidden = source._titleHidden
      _captionHidden = source._captionHidden
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._geometry, !v.isInitialized {return false}
      if let v = _storage._parent, !v.isInitialized {return false}
      if let v = _storage._comment, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._pencilAnnotations) {return false}
      if let v = _storage._title, !v.isInitialized {return false}
      if let v = _storage._caption, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._geometry) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._parent) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._exteriorTextWrap) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._hyperlinkURL) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._locked) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._comment) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._aspectRatioLocked) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._accessibilityDescription) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._pencilAnnotations) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._title) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._caption) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._titleHidden) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._captionHidden) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._geometry {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._parent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._exteriorTextWrap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._hyperlinkURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._locked {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._comment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._aspectRatioLocked {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._accessibilityDescription {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      } }()
      if !_storage._pencilAnnotations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pencilAnnotations, fieldNumber: 9)
      }
      try { if let v = _storage._title {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._caption {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._titleHidden {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._captionHidden {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_DrawableArchive, rhs: TSD_DrawableArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._geometry != rhs_storage._geometry {return false}
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._exteriorTextWrap != rhs_storage._exteriorTextWrap {return false}
        if _storage._hyperlinkURL != rhs_storage._hyperlinkURL {return false}
        if _storage._locked != rhs_storage._locked {return false}
        if _storage._comment != rhs_storage._comment {return false}
        if _storage._aspectRatioLocked != rhs_storage._aspectRatioLocked {return false}
        if _storage._accessibilityDescription != rhs_storage._accessibilityDescription {return false}
        if _storage._pencilAnnotations != rhs_storage._pencilAnnotations {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._caption != rhs_storage._caption {return false}
        if _storage._titleHidden != rhs_storage._titleHidden {return false}
        if _storage._captionHidden != rhs_storage._captionHidden {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ContainerArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContainerArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}geometry\0\u{1}parent\0\u{1}children\0")

  public var isInitialized: Bool {
    if let v = self._geometry, !v.isInitialized {return false}
    if let v = self._parent, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.children) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._geometry) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._parent) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.children) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._geometry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._parent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.children.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.children, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ContainerArchive, rhs: TSD_ContainerArchive) -> Bool {
    if lhs._geometry != rhs._geometry {return false}
    if lhs._parent != rhs._parent {return false}
    if lhs.children != rhs.children {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_GroupArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}children\0\u{3}fake_shape_for_empty_group\0")

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.children) {return false}
    if let v = self._fakeShapeForEmptyGroup, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.children) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._fakeShapeForEmptyGroup) }()
      case 100..<536870912:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TSD_GroupArchive.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.children.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.children, fieldNumber: 2)
    }
    try { if let v = self._fakeShapeForEmptyGroup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 100, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_GroupArchive, rhs: TSD_GroupArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs.children != rhs.children {return false}
    if lhs._fakeShapeForEmptyGroup != rhs._fakeShapeForEmptyGroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TSD_FreehandDrawingAnimationArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FreehandDrawingAnimationArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}duration\0\u{3}should_loop\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._duration) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._shouldLoop) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._duration {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._shouldLoop {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_FreehandDrawingAnimationArchive, rhs: TSD_FreehandDrawingAnimationArchive) -> Bool {
    if lhs._duration != rhs._duration {return false}
    if lhs._shouldLoop != rhs._shouldLoop {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_FreehandDrawingArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FreehandDrawingArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}spacer_shape\0\u{1}opacity\0\u{1}animation\0\u{3}last_clamped_scale\0")

  public var isInitialized: Bool {
    if let v = self._spacerShape, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spacerShape) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._opacity) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._animation) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._lastClampedScale) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spacerShape {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._opacity {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._animation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._lastClampedScale {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_FreehandDrawingArchive, rhs: TSD_FreehandDrawingArchive) -> Bool {
    if lhs._spacerShape != rhs._spacerShape {return false}
    if lhs._opacity != rhs._opacity {return false}
    if lhs._animation != rhs._animation {return false}
    if lhs._lastClampedScale != rhs._lastClampedScale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ShapeArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShapeArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}style\0\u{1}pathsource\0\u{3}head_line_end\0\u{3}tail_line_end\0\u{1}strokePatternOffsetDistance\0")

  fileprivate class _StorageClass {
    var _super: TSD_DrawableArchive? = nil
    var _style: TSP_Reference? = nil
    var _pathsource: TSD_PathSourceArchive? = nil
    var _headLineEnd: TSD_LineEndArchive? = nil
    var _tailLineEnd: TSD_LineEndArchive? = nil
    var _strokePatternOffsetDistance: Float? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _style = source._style
      _pathsource = source._pathsource
      _headLineEnd = source._headLineEnd
      _tailLineEnd = source._tailLineEnd
      _strokePatternOffsetDistance = source._strokePatternOffsetDistance
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._style, !v.isInitialized {return false}
      if let v = _storage._pathsource, !v.isInitialized {return false}
      if let v = _storage._headLineEnd, !v.isInitialized {return false}
      if let v = _storage._tailLineEnd, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._style) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._pathsource) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._headLineEnd) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._tailLineEnd) }()
        case 6: try { try decoder.decodeSingularFloatField(value: &_storage._strokePatternOffsetDistance) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._pathsource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._headLineEnd {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._tailLineEnd {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._strokePatternOffsetDistance {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ShapeArchive, rhs: TSD_ShapeArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._style != rhs_storage._style {return false}
        if _storage._pathsource != rhs_storage._pathsource {return false}
        if _storage._headLineEnd != rhs_storage._headLineEnd {return false}
        if _storage._tailLineEnd != rhs_storage._tailLineEnd {return false}
        if _storage._strokePatternOffsetDistance != rhs_storage._strokePatternOffsetDistance {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ConnectionLineArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionLineArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}connected_from\0\u{3}connected_to\0\u{3}connected_to_uuid\0\u{3}connected_from_uuid\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._connectedFrom, !v.isInitialized {return false}
    if let v = self._connectedTo, !v.isInitialized {return false}
    if let v = self._connectedToUuid, !v.isInitialized {return false}
    if let v = self._connectedFromUuid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._connectedFrom) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._connectedTo) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._connectedToUuid) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._connectedFromUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._connectedFrom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._connectedTo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._connectedToUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._connectedFromUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ConnectionLineArchive, rhs: TSD_ConnectionLineArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._connectedFrom != rhs._connectedFrom {return false}
    if lhs._connectedTo != rhs._connectedTo {return false}
    if lhs._connectedToUuid != rhs._connectedToUuid {return false}
    if lhs._connectedFromUuid != rhs._connectedFromUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ImageArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}database_data\0\u{1}style\0\u{1}originalSize\0\u{1}mask\0\u{3}database_thumbnailData\0\u{1}flags\0\u{3}database_originalData\0\u{1}naturalSize\0\u{1}instantAlphaPath\0\u{1}data\0\u{1}thumbnailData\0\u{1}originalData\0\u{1}imageAdjustments\0\u{1}adjustedImageData\0\u{1}thumbnailAdjustedImageData\0\u{1}enhancedImageData\0\u{1}interpretsUntaggedImageDataAsGeneric\0\u{3}traced_path\0\u{1}attribution\0\u{3}should_trace_pdf_content\0\u{3}background_removed\0\u{1}originalSVGData\0")

  fileprivate class _StorageClass {
    var _super: TSD_DrawableArchive? = nil
    var _data: TSP_DataReference? = nil
    var _style: TSP_Reference? = nil
    var _originalSize: TSP_Size? = nil
    var _mask: TSP_Reference? = nil
    var _thumbnailData: TSP_DataReference? = nil
    var _flags: UInt32? = nil
    var _originalData: TSP_DataReference? = nil
    var _originalSvgdata: TSP_DataReference? = nil
    var _naturalSize: TSP_Size? = nil
    var _instantAlphaPath: TSP_Path? = nil
    var _imageAdjustments: TSD_ImageAdjustmentsArchive? = nil
    var _enhancedImageData: TSP_DataReference? = nil
    var _adjustedImageData: TSP_DataReference? = nil
    var _thumbnailAdjustedImageData: TSP_DataReference? = nil
    var _interpretsUntaggedImageDataAsGeneric: Bool? = nil
    var _databaseData: TSP_Reference? = nil
    var _databaseThumbnailData: TSP_Reference? = nil
    var _databaseOriginalData: TSP_Reference? = nil
    var _tracedPath: TSP_Path? = nil
    var _attribution: TSD_Attribution? = nil
    var _shouldTracePdfContent: Bool? = nil
    var _backgroundRemoved: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _data = source._data
      _style = source._style
      _originalSize = source._originalSize
      _mask = source._mask
      _thumbnailData = source._thumbnailData
      _flags = source._flags
      _originalData = source._originalData
      _originalSvgdata = source._originalSvgdata
      _naturalSize = source._naturalSize
      _instantAlphaPath = source._instantAlphaPath
      _imageAdjustments = source._imageAdjustments
      _enhancedImageData = source._enhancedImageData
      _adjustedImageData = source._adjustedImageData
      _thumbnailAdjustedImageData = source._thumbnailAdjustedImageData
      _interpretsUntaggedImageDataAsGeneric = source._interpretsUntaggedImageDataAsGeneric
      _databaseData = source._databaseData
      _databaseThumbnailData = source._databaseThumbnailData
      _databaseOriginalData = source._databaseOriginalData
      _tracedPath = source._tracedPath
      _attribution = source._attribution
      _shouldTracePdfContent = source._shouldTracePdfContent
      _backgroundRemoved = source._backgroundRemoved
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._data, !v.isInitialized {return false}
      if let v = _storage._style, !v.isInitialized {return false}
      if let v = _storage._originalSize, !v.isInitialized {return false}
      if let v = _storage._mask, !v.isInitialized {return false}
      if let v = _storage._thumbnailData, !v.isInitialized {return false}
      if let v = _storage._originalData, !v.isInitialized {return false}
      if let v = _storage._originalSvgdata, !v.isInitialized {return false}
      if let v = _storage._naturalSize, !v.isInitialized {return false}
      if let v = _storage._instantAlphaPath, !v.isInitialized {return false}
      if let v = _storage._enhancedImageData, !v.isInitialized {return false}
      if let v = _storage._adjustedImageData, !v.isInitialized {return false}
      if let v = _storage._thumbnailAdjustedImageData, !v.isInitialized {return false}
      if let v = _storage._databaseData, !v.isInitialized {return false}
      if let v = _storage._databaseThumbnailData, !v.isInitialized {return false}
      if let v = _storage._databaseOriginalData, !v.isInitialized {return false}
      if let v = _storage._tracedPath, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._databaseData) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._style) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._originalSize) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._mask) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._databaseThumbnailData) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._flags) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._databaseOriginalData) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._naturalSize) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._instantAlphaPath) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._thumbnailData) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._originalData) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._imageAdjustments) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._adjustedImageData) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._thumbnailAdjustedImageData) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._enhancedImageData) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._interpretsUntaggedImageDataAsGeneric) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._tracedPath) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._attribution) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._shouldTracePdfContent) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._backgroundRemoved) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._originalSvgdata) }()
        case 100..<1000:
          try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TSD_ImageArchive.self, fieldNumber: fieldNumber) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._databaseData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._originalSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._mask {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._databaseThumbnailData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._flags {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._databaseOriginalData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._naturalSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._instantAlphaPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._thumbnailData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._originalData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._imageAdjustments {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._adjustedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._thumbnailAdjustedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._enhancedImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._interpretsUntaggedImageDataAsGeneric {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._tracedPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._attribution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._shouldTracePdfContent {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._backgroundRemoved {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._originalSvgdata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 100, end: 1000)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ImageArchive, rhs: TSD_ImageArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._style != rhs_storage._style {return false}
        if _storage._originalSize != rhs_storage._originalSize {return false}
        if _storage._mask != rhs_storage._mask {return false}
        if _storage._thumbnailData != rhs_storage._thumbnailData {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._originalData != rhs_storage._originalData {return false}
        if _storage._originalSvgdata != rhs_storage._originalSvgdata {return false}
        if _storage._naturalSize != rhs_storage._naturalSize {return false}
        if _storage._instantAlphaPath != rhs_storage._instantAlphaPath {return false}
        if _storage._imageAdjustments != rhs_storage._imageAdjustments {return false}
        if _storage._enhancedImageData != rhs_storage._enhancedImageData {return false}
        if _storage._adjustedImageData != rhs_storage._adjustedImageData {return false}
        if _storage._thumbnailAdjustedImageData != rhs_storage._thumbnailAdjustedImageData {return false}
        if _storage._interpretsUntaggedImageDataAsGeneric != rhs_storage._interpretsUntaggedImageDataAsGeneric {return false}
        if _storage._databaseData != rhs_storage._databaseData {return false}
        if _storage._databaseThumbnailData != rhs_storage._databaseThumbnailData {return false}
        if _storage._databaseOriginalData != rhs_storage._databaseOriginalData {return false}
        if _storage._tracedPath != rhs_storage._tracedPath {return false}
        if _storage._attribution != rhs_storage._attribution {return false}
        if _storage._shouldTracePdfContent != rhs_storage._shouldTracePdfContent {return false}
        if _storage._backgroundRemoved != rhs_storage._backgroundRemoved {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TSD_MaskArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MaskArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{1}pathsource\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    if let v = self._pathsource, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pathsource) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pathsource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_MaskArchive, rhs: TSD_MaskArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._pathsource != rhs._pathsource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ImageDataAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageDataAttributes"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}pixel_size\0\u{3}image_is_srgb\0\u{3}should_be_interpreted_as_generic_if_untagged\0")

  public var isInitialized: Bool {
    if let v = self._pixelSize, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pixelSize) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._imageIsSrgb) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._shouldBeInterpretedAsGenericIfUntagged) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pixelSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._imageIsSrgb {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._shouldBeInterpretedAsGenericIfUntagged {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ImageDataAttributes, rhs: TSD_ImageDataAttributes) -> Bool {
    if lhs._pixelSize != rhs._pixelSize {return false}
    if lhs._imageIsSrgb != rhs._imageIsSrgb {return false}
    if lhs._shouldBeInterpretedAsGenericIfUntagged != rhs._shouldBeInterpretedAsGenericIfUntagged {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_MovieArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MovieArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}database_movieData\0\u{1}startTime\0\u{1}endTime\0\u{1}posterTime\0\u{1}loopOptionAsInteger\0\u{1}volume\0\u{1}autoPlay\0\u{1}audioOnly\0\u{3}database_posterImageData\0\u{3}database_audioOnlyImageData\0\u{1}playableState\0\u{1}flags\0\u{1}movieData\0\u{1}posterImageData\0\u{1}audioOnlyImageData\0\u{1}movieRemoteURL\0\u{1}streaming\0\u{1}style\0\u{1}originalSize\0\u{1}naturalSize\0\u{1}importedAuxiliaryMovieData\0\u{3}poster_image_generated_with_alpha_support\0\u{3}loop_option\0\u{3}imported_auxiliary_movie_data_original_filename\0\u{1}attribution\0\u{1}nativeAudioRecording\0\u{1}playsAcrossSlides\0\u{1}fingerprint\0\u{3}is_live_video\0")

  fileprivate class _StorageClass {
    var _super: TSD_DrawableArchive? = nil
    var _movieData: TSP_DataReference? = nil
    var _importedAuxiliaryMovieData: TSP_DataReference? = nil
    var _importedAuxiliaryMovieDataOriginalFilename: String? = nil
    var _movieRemoteURL: String? = nil
    var _startTime: Float? = nil
    var _endTime: Float? = nil
    var _posterTime: Float? = nil
    var _loopOptionAsInteger: UInt32? = nil
    var _loopOption: TSD_MovieArchive.MovieLoopOption? = nil
    var _volume: Float? = nil
    var _autoPlay: Bool? = nil
    var _audioOnly: Bool? = nil
    var _streaming: Bool? = nil
    var _nativeAudioRecording: Bool? = nil
    var _playsAcrossSlides: Bool? = nil
    var _posterImageData: TSP_DataReference? = nil
    var _audioOnlyImageData: TSP_DataReference? = nil
    var _posterImageGeneratedWithAlphaSupport: Bool? = nil
    var _playableState: UInt32? = nil
    var _flags: UInt32? = nil
    var _databaseMovieData: TSP_Reference? = nil
    var _databasePosterImageData: TSP_Reference? = nil
    var _databaseAudioOnlyImageData: TSP_Reference? = nil
    var _style: TSP_Reference? = nil
    var _originalSize: TSP_Size? = nil
    var _naturalSize: TSP_Size? = nil
    var _attribution: TSD_Attribution? = nil
    var _fingerprint: TSD_MovieFingerprint? = nil
    var _isLiveVideo: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _movieData = source._movieData
      _importedAuxiliaryMovieData = source._importedAuxiliaryMovieData
      _importedAuxiliaryMovieDataOriginalFilename = source._importedAuxiliaryMovieDataOriginalFilename
      _movieRemoteURL = source._movieRemoteURL
      _startTime = source._startTime
      _endTime = source._endTime
      _posterTime = source._posterTime
      _loopOptionAsInteger = source._loopOptionAsInteger
      _loopOption = source._loopOption
      _volume = source._volume
      _autoPlay = source._autoPlay
      _audioOnly = source._audioOnly
      _streaming = source._streaming
      _nativeAudioRecording = source._nativeAudioRecording
      _playsAcrossSlides = source._playsAcrossSlides
      _posterImageData = source._posterImageData
      _audioOnlyImageData = source._audioOnlyImageData
      _posterImageGeneratedWithAlphaSupport = source._posterImageGeneratedWithAlphaSupport
      _playableState = source._playableState
      _flags = source._flags
      _databaseMovieData = source._databaseMovieData
      _databasePosterImageData = source._databasePosterImageData
      _databaseAudioOnlyImageData = source._databaseAudioOnlyImageData
      _style = source._style
      _originalSize = source._originalSize
      _naturalSize = source._naturalSize
      _attribution = source._attribution
      _fingerprint = source._fingerprint
      _isLiveVideo = source._isLiveVideo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._movieData, !v.isInitialized {return false}
      if let v = _storage._importedAuxiliaryMovieData, !v.isInitialized {return false}
      if let v = _storage._posterImageData, !v.isInitialized {return false}
      if let v = _storage._audioOnlyImageData, !v.isInitialized {return false}
      if let v = _storage._databaseMovieData, !v.isInitialized {return false}
      if let v = _storage._databasePosterImageData, !v.isInitialized {return false}
      if let v = _storage._databaseAudioOnlyImageData, !v.isInitialized {return false}
      if let v = _storage._style, !v.isInitialized {return false}
      if let v = _storage._originalSize, !v.isInitialized {return false}
      if let v = _storage._naturalSize, !v.isInitialized {return false}
      if let v = _storage._fingerprint, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._databaseMovieData) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._startTime) }()
        case 4: try { try decoder.decodeSingularFloatField(value: &_storage._endTime) }()
        case 5: try { try decoder.decodeSingularFloatField(value: &_storage._posterTime) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._loopOptionAsInteger) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._volume) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._autoPlay) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._audioOnly) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._databasePosterImageData) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._databaseAudioOnlyImageData) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._playableState) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._flags) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._movieData) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._posterImageData) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._audioOnlyImageData) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._movieRemoteURL) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._streaming) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._style) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._originalSize) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._naturalSize) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._importedAuxiliaryMovieData) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._posterImageGeneratedWithAlphaSupport) }()
        case 24: try { try decoder.decodeSingularEnumField(value: &_storage._loopOption) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._importedAuxiliaryMovieDataOriginalFilename) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._attribution) }()
        case 27: try { try decoder.decodeSingularBoolField(value: &_storage._nativeAudioRecording) }()
        case 28: try { try decoder.decodeSingularBoolField(value: &_storage._playsAcrossSlides) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._fingerprint) }()
        case 30: try { try decoder.decodeSingularBoolField(value: &_storage._isLiveVideo) }()
        case 100..<1000:
          try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TSD_MovieArchive.self, fieldNumber: fieldNumber) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._databaseMovieData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._startTime {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._endTime {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._posterTime {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._loopOptionAsInteger {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._volume {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._autoPlay {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._audioOnly {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._databasePosterImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._databaseAudioOnlyImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._playableState {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._flags {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._movieData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._posterImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._audioOnlyImageData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._movieRemoteURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._streaming {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._originalSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._naturalSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._importedAuxiliaryMovieData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._posterImageGeneratedWithAlphaSupport {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._loopOption {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._importedAuxiliaryMovieDataOriginalFilename {
        try visitor.visitSingularStringField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._attribution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._nativeAudioRecording {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 27)
      } }()
      try { if let v = _storage._playsAcrossSlides {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._fingerprint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._isLiveVideo {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 30)
      } }()
      try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 100, end: 1000)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_MovieArchive, rhs: TSD_MovieArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._movieData != rhs_storage._movieData {return false}
        if _storage._importedAuxiliaryMovieData != rhs_storage._importedAuxiliaryMovieData {return false}
        if _storage._importedAuxiliaryMovieDataOriginalFilename != rhs_storage._importedAuxiliaryMovieDataOriginalFilename {return false}
        if _storage._movieRemoteURL != rhs_storage._movieRemoteURL {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._posterTime != rhs_storage._posterTime {return false}
        if _storage._loopOptionAsInteger != rhs_storage._loopOptionAsInteger {return false}
        if _storage._loopOption != rhs_storage._loopOption {return false}
        if _storage._volume != rhs_storage._volume {return false}
        if _storage._autoPlay != rhs_storage._autoPlay {return false}
        if _storage._audioOnly != rhs_storage._audioOnly {return false}
        if _storage._streaming != rhs_storage._streaming {return false}
        if _storage._nativeAudioRecording != rhs_storage._nativeAudioRecording {return false}
        if _storage._playsAcrossSlides != rhs_storage._playsAcrossSlides {return false}
        if _storage._posterImageData != rhs_storage._posterImageData {return false}
        if _storage._audioOnlyImageData != rhs_storage._audioOnlyImageData {return false}
        if _storage._posterImageGeneratedWithAlphaSupport != rhs_storage._posterImageGeneratedWithAlphaSupport {return false}
        if _storage._playableState != rhs_storage._playableState {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._databaseMovieData != rhs_storage._databaseMovieData {return false}
        if _storage._databasePosterImageData != rhs_storage._databasePosterImageData {return false}
        if _storage._databaseAudioOnlyImageData != rhs_storage._databaseAudioOnlyImageData {return false}
        if _storage._style != rhs_storage._style {return false}
        if _storage._originalSize != rhs_storage._originalSize {return false}
        if _storage._naturalSize != rhs_storage._naturalSize {return false}
        if _storage._attribution != rhs_storage._attribution {return false}
        if _storage._fingerprint != rhs_storage._fingerprint {return false}
        if _storage._isLiveVideo != rhs_storage._isLiveVideo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TSD_MovieArchive.MovieLoopOption: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0None\0\u{1}Repeat\0\u{1}BackAndForth\0")
}

extension TSD_ExteriorTextWrapArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExteriorTextWrapArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}direction\0\u{3}fit_type\0\u{1}margin\0\u{3}alpha_threshold\0\u{3}is_html_wrap\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._type) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._direction) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._fitType) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._margin) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._alphaThreshold) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._isHtmlWrap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._direction {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._fitType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._margin {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._alphaThreshold {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._isHtmlWrap {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ExteriorTextWrapArchive, rhs: TSD_ExteriorTextWrapArchive) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._direction != rhs._direction {return false}
    if lhs._fitType != rhs._fitType {return false}
    if lhs._margin != rhs._margin {return false}
    if lhs._alphaThreshold != rhs._alphaThreshold {return false}
    if lhs._isHtmlWrap != rhs._isHtmlWrap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_DrawableContentDescription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawableContentDescription"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}element_kind\0\u{3}is_anchored_to_text\0\u{3}is_floating_above_text\0\u{3}is_inline_with_text\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._elementKind) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isAnchoredToText) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._isFloatingAboveText) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._isInlineWithText) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._elementKind {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._isAnchoredToText {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._isFloatingAboveText {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._isInlineWithText {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_DrawableContentDescription, rhs: TSD_DrawableContentDescription) -> Bool {
    if lhs._elementKind != rhs._elementKind {return false}
    if lhs._isAnchoredToText != rhs._isAnchoredToText {return false}
    if lhs._isFloatingAboveText != rhs._isFloatingAboveText {return false}
    if lhs._isInlineWithText != rhs._isInlineWithText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_FreehandDrawingContentDescription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FreehandDrawingContentDescription"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}source_doc_wanted_spacer_shape\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._sourceDocWantedSpacerShape) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sourceDocWantedSpacerShape {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_FreehandDrawingContentDescription, rhs: TSD_FreehandDrawingContentDescription) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._sourceDocWantedSpacerShape != rhs._sourceDocWantedSpacerShape {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_FreehandDrawingToolkitUIState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FreehandDrawingToolkitUIState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}current_color\0\u{3}most_recent_restorable_tool_type\0\u{3}pen_tool_opacity\0\u{3}pen_tool_unscaled_width\0\u{3}pencil_tool_opacity\0\u{3}pencil_tool_unscaled_width\0\u{3}crayon_tool_opacity\0\u{3}crayon_tool_unscaled_width\0\u{3}fill_tool_opacity\0\u{3}eraser_tool_scaled_width\0\u{3}eraser_tool_erases_whole_objects\0\u{3}pen_tool_color\0\u{3}pencil_tool_color\0\u{3}crayon_tool_color\0\u{3}fill_tool_color\0")

  fileprivate class _StorageClass {
    var _currentColor: TSP_Color? = nil
    var _mostRecentRestorableToolType: TSD_FreehandDrawingToolkitUIState.FreehandDrawingToolType? = nil
    var _penToolOpacity: Float? = nil
    var _penToolUnscaledWidth: Float? = nil
    var _pencilToolOpacity: Float? = nil
    var _pencilToolUnscaledWidth: Float? = nil
    var _crayonToolOpacity: Float? = nil
    var _crayonToolUnscaledWidth: Float? = nil
    var _fillToolOpacity: Float? = nil
    var _eraserToolScaledWidth: Float? = nil
    var _eraserToolErasesWholeObjects: Bool? = nil
    var _penToolColor: TSP_Color? = nil
    var _pencilToolColor: TSP_Color? = nil
    var _crayonToolColor: TSP_Color? = nil
    var _fillToolColor: TSP_Color? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _currentColor = source._currentColor
      _mostRecentRestorableToolType = source._mostRecentRestorableToolType
      _penToolOpacity = source._penToolOpacity
      _penToolUnscaledWidth = source._penToolUnscaledWidth
      _pencilToolOpacity = source._pencilToolOpacity
      _pencilToolUnscaledWidth = source._pencilToolUnscaledWidth
      _crayonToolOpacity = source._crayonToolOpacity
      _crayonToolUnscaledWidth = source._crayonToolUnscaledWidth
      _fillToolOpacity = source._fillToolOpacity
      _eraserToolScaledWidth = source._eraserToolScaledWidth
      _eraserToolErasesWholeObjects = source._eraserToolErasesWholeObjects
      _penToolColor = source._penToolColor
      _pencilToolColor = source._pencilToolColor
      _crayonToolColor = source._crayonToolColor
      _fillToolColor = source._fillToolColor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._currentColor, !v.isInitialized {return false}
      if let v = _storage._penToolColor, !v.isInitialized {return false}
      if let v = _storage._pencilToolColor, !v.isInitialized {return false}
      if let v = _storage._crayonToolColor, !v.isInitialized {return false}
      if let v = _storage._fillToolColor, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._currentColor) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._mostRecentRestorableToolType) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._penToolOpacity) }()
        case 4: try { try decoder.decodeSingularFloatField(value: &_storage._penToolUnscaledWidth) }()
        case 5: try { try decoder.decodeSingularFloatField(value: &_storage._pencilToolOpacity) }()
        case 6: try { try decoder.decodeSingularFloatField(value: &_storage._pencilToolUnscaledWidth) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._crayonToolOpacity) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._crayonToolUnscaledWidth) }()
        case 9: try { try decoder.decodeSingularFloatField(value: &_storage._fillToolOpacity) }()
        case 10: try { try decoder.decodeSingularFloatField(value: &_storage._eraserToolScaledWidth) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._eraserToolErasesWholeObjects) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._penToolColor) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._pencilToolColor) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._crayonToolColor) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._fillToolColor) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._currentColor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._mostRecentRestorableToolType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._penToolOpacity {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._penToolUnscaledWidth {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._pencilToolOpacity {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._pencilToolUnscaledWidth {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._crayonToolOpacity {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._crayonToolUnscaledWidth {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._fillToolOpacity {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._eraserToolScaledWidth {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._eraserToolErasesWholeObjects {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._penToolColor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._pencilToolColor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._crayonToolColor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._fillToolColor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_FreehandDrawingToolkitUIState, rhs: TSD_FreehandDrawingToolkitUIState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._currentColor != rhs_storage._currentColor {return false}
        if _storage._mostRecentRestorableToolType != rhs_storage._mostRecentRestorableToolType {return false}
        if _storage._penToolOpacity != rhs_storage._penToolOpacity {return false}
        if _storage._penToolUnscaledWidth != rhs_storage._penToolUnscaledWidth {return false}
        if _storage._pencilToolOpacity != rhs_storage._pencilToolOpacity {return false}
        if _storage._pencilToolUnscaledWidth != rhs_storage._pencilToolUnscaledWidth {return false}
        if _storage._crayonToolOpacity != rhs_storage._crayonToolOpacity {return false}
        if _storage._crayonToolUnscaledWidth != rhs_storage._crayonToolUnscaledWidth {return false}
        if _storage._fillToolOpacity != rhs_storage._fillToolOpacity {return false}
        if _storage._eraserToolScaledWidth != rhs_storage._eraserToolScaledWidth {return false}
        if _storage._eraserToolErasesWholeObjects != rhs_storage._eraserToolErasesWholeObjects {return false}
        if _storage._penToolColor != rhs_storage._penToolColor {return false}
        if _storage._pencilToolColor != rhs_storage._pencilToolColor {return false}
        if _storage._crayonToolColor != rhs_storage._crayonToolColor {return false}
        if _storage._fillToolColor != rhs_storage._fillToolColor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_FreehandDrawingToolkitUIState.FreehandDrawingToolType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Pen\0\u{1}Pencil\0\u{1}Crayon\0\u{1}Fill\0\u{1}Eraser\0\u{1}MarqueeSelect\0")
}

extension TSD_StandinCaptionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StandinCaptionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_StandinCaptionArchive, rhs: TSD_StandinCaptionArchive) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_GuideArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GuideArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}offset\0\u{1}start\0\u{1}end\0\u{1}dynamic\0\u{1}infinite\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._offset) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._start) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._end) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._dynamic) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._infinite) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._offset {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._start {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._end {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._dynamic {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._infinite {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_GuideArchive, rhs: TSD_GuideArchive) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs._start != rhs._start {return false}
    if lhs._end != rhs._end {return false}
    if lhs._dynamic != rhs._dynamic {return false}
    if lhs._infinite != rhs._infinite {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_GuideArchive.GuideType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Horizontal\0\u{1}Vertical\0")
}

extension TSD_UserDefinedGuideArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserDefinedGuideArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}position\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._position) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._position {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_UserDefinedGuideArchive, rhs: TSD_UserDefinedGuideArchive) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._position != rhs._position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_UserDefinedGuideArchive.GuideType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Horizontal\0\u{1}Vertical\0")
}

extension TSD_GuideStorageArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GuideStorageArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}userDefinedGuides\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.userDefinedGuides) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userDefinedGuides.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userDefinedGuides, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_GuideStorageArchive, rhs: TSD_GuideStorageArchive) -> Bool {
    if lhs.userDefinedGuides != rhs.userDefinedGuides {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_CanvasSelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CanvasSelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}infos\0\u{1}container\0\u{3}non_interactive_infos\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.infos) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.nonInteractiveInfos) {return false}
    if let v = self._container, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.infos) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._container) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.nonInteractiveInfos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.infos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infos, fieldNumber: 1)
    }
    try { if let v = self._container {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.nonInteractiveInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nonInteractiveInfos, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_CanvasSelectionArchive, rhs: TSD_CanvasSelectionArchive) -> Bool {
    if lhs.infos != rhs.infos {return false}
    if lhs.nonInteractiveInfos != rhs.nonInteractiveInfos {return false}
    if lhs._container != rhs._container {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_DrawableSelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DrawableSelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}infos\0\u{3}non_interactive_infos\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.infos) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.nonInteractiveInfos) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.infos) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.nonInteractiveInfos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.infos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.infos, fieldNumber: 2)
    }
    if !self.nonInteractiveInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nonInteractiveInfos, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_DrawableSelectionArchive, rhs: TSD_DrawableSelectionArchive) -> Bool {
    if lhs.infos != rhs.infos {return false}
    if lhs.nonInteractiveInfos != rhs.nonInteractiveInfos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_GroupSelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupSelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}has_selected_infos_in_non_group_container\0")

  public var isInitialized: Bool {
    if self._super == nil {return false}
    if let v = self._super, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._super) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._hasSelectedInfosInNonGroupContainer_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._super {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._hasSelectedInfosInNonGroupContainer_p {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_GroupSelectionArchive, rhs: TSD_GroupSelectionArchive) -> Bool {
    if lhs._super != rhs._super {return false}
    if lhs._hasSelectedInfosInNonGroupContainer_p != rhs._hasSelectedInfosInNonGroupContainer_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_PathSelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PathSelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_PathSelectionArchive, rhs: TSD_PathSelectionArchive) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_InfoHyperlinkSelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InfoHyperlinkSelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_InfoHyperlinkSelectionArchive, rhs: TSD_InfoHyperlinkSelectionArchive) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_CommentStorageArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommentStorageArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}text\0\u{3}creation_date\0\u{1}author\0\u{1}replies\0\u{3}storage_uuid\0")

  public var isInitialized: Bool {
    if let v = self._creationDate, !v.isInitialized {return false}
    if let v = self._author, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.replies) {return false}
    if let v = self._storageUuid, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._creationDate) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._author) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.replies) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._storageUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._creationDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._author {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.replies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.replies, fieldNumber: 4)
    }
    try { if let v = self._storageUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_CommentStorageArchive, rhs: TSD_CommentStorageArchive) -> Bool {
    if lhs._text != rhs._text {return false}
    if lhs._creationDate != rhs._creationDate {return false}
    if lhs._author != rhs._author {return false}
    if lhs.replies != rhs.replies {return false}
    if lhs._storageUuid != rhs._storageUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_ReplaceAnnotationAuthorCommandArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReplaceAnnotationAuthorCommandArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}super\0\u{3}old_annotation_author\0\u{3}new_annotation_author\0")

  fileprivate class _StorageClass {
    var _super: TSK_CommandArchive? = nil
    var _oldAnnotationAuthor: TSP_Reference? = nil
    var _newAnnotationAuthor: TSP_Reference? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _super = source._super
      _oldAnnotationAuthor = source._oldAnnotationAuthor
      _newAnnotationAuthor = source._newAnnotationAuthor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._super == nil {return false}
      if let v = _storage._super, !v.isInitialized {return false}
      if let v = _storage._oldAnnotationAuthor, !v.isInitialized {return false}
      if let v = _storage._newAnnotationAuthor, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._super) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._oldAnnotationAuthor) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._newAnnotationAuthor) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._super {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._oldAnnotationAuthor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._newAnnotationAuthor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_ReplaceAnnotationAuthorCommandArchive, rhs: TSD_ReplaceAnnotationAuthorCommandArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._super != rhs_storage._super {return false}
        if _storage._oldAnnotationAuthor != rhs_storage._oldAnnotationAuthor {return false}
        if _storage._newAnnotationAuthor != rhs_storage._newAnnotationAuthor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_PencilAnnotationArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PencilAnnotationArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}pencil_annotation_storage\0")

  public var isInitialized: Bool {
    if let v = self._pencilAnnotationStorage, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pencilAnnotationStorage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pencilAnnotationStorage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_PencilAnnotationArchive, rhs: TSD_PencilAnnotationArchive) -> Bool {
    if lhs._pencilAnnotationStorage != rhs._pencilAnnotationStorage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_PencilAnnotationSelectionArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PencilAnnotationSelectionArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}pencil_annotation\0")

  public var isInitialized: Bool {
    if let v = self._pencilAnnotation, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pencilAnnotation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pencilAnnotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_PencilAnnotationSelectionArchive, rhs: TSD_PencilAnnotationSelectionArchive) -> Bool {
    if lhs._pencilAnnotation != rhs._pencilAnnotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_PencilAnnotationStorageArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PencilAnnotationStorageArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}attached_location\0\u{3}markup_offset\0\u{3}rasterized_image\0\u{3}legacy_encoded_drawing\0\u{3}drawing_path\0\u{3}strokes_bounding_box_origin\0\u{3}strokes_bounding_box_size\0\u{3}attached_type\0\u{3}original_attached_size\0\u{3}percent_of_pa_contained_in_parent_rep\0\u{3}text_baselines_touched_count\0\u{3}visible_strokes_count\0\u{3}pen_color\0\u{3}tool_type\0\u{3}callout_sub_storages\0\u{3}creation_date\0\u{3}pencil_annotation_drawing_scale\0\u{3}compound_annotation_type\0\u{3}sub_storages\0\u{3}encoded_drawing\0\u{3}stroke_points_frame_origin\0\u{3}stroke_points_frame_size\0\u{3}rendered_frame_origin\0\u{3}rendered_frame_size\0")

  fileprivate class _StorageClass {
    var _attachedLocation: Int32? = nil
    var _markupOffset: TSP_Point? = nil
    var _rasterizedImage: TSP_DataReference? = nil
    var _legacyEncodedDrawing: TSP_DataReference? = nil
    var _drawingPath: TSP_Path? = nil
    var _strokesBoundingBoxOrigin: TSP_Point? = nil
    var _strokesBoundingBoxSize: TSP_Size? = nil
    var _attachedType: Int32? = nil
    var _originalAttachedSize: TSP_Size? = nil
    var _percentOfPaContainedInParentRep: Double? = nil
    var _textBaselinesTouchedCount: UInt64? = nil
    var _visibleStrokesCount: UInt64? = nil
    var _penColor: TSP_Color? = nil
    var _toolType: Int32? = nil
    var _calloutSubStorages: [TSP_Reference] = []
    var _creationDate: TSP_Date? = nil
    var _pencilAnnotationDrawingScale: Double? = nil
    var _compoundAnnotationType: Int32? = nil
    var _subStorages: [TSP_Reference] = []
    var _encodedDrawing: TSP_DataReference? = nil
    var _strokePointsFrameOrigin: TSP_Point? = nil
    var _strokePointsFrameSize: TSP_Size? = nil
    var _renderedFrameOrigin: TSP_Point? = nil
    var _renderedFrameSize: TSP_Size? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _attachedLocation = source._attachedLocation
      _markupOffset = source._markupOffset
      _rasterizedImage = source._rasterizedImage
      _legacyEncodedDrawing = source._legacyEncodedDrawing
      _drawingPath = source._drawingPath
      _strokesBoundingBoxOrigin = source._strokesBoundingBoxOrigin
      _strokesBoundingBoxSize = source._strokesBoundingBoxSize
      _attachedType = source._attachedType
      _originalAttachedSize = source._originalAttachedSize
      _percentOfPaContainedInParentRep = source._percentOfPaContainedInParentRep
      _textBaselinesTouchedCount = source._textBaselinesTouchedCount
      _visibleStrokesCount = source._visibleStrokesCount
      _penColor = source._penColor
      _toolType = source._toolType
      _calloutSubStorages = source._calloutSubStorages
      _creationDate = source._creationDate
      _pencilAnnotationDrawingScale = source._pencilAnnotationDrawingScale
      _compoundAnnotationType = source._compoundAnnotationType
      _subStorages = source._subStorages
      _encodedDrawing = source._encodedDrawing
      _strokePointsFrameOrigin = source._strokePointsFrameOrigin
      _strokePointsFrameSize = source._strokePointsFrameSize
      _renderedFrameOrigin = source._renderedFrameOrigin
      _renderedFrameSize = source._renderedFrameSize
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._markupOffset, !v.isInitialized {return false}
      if let v = _storage._rasterizedImage, !v.isInitialized {return false}
      if let v = _storage._legacyEncodedDrawing, !v.isInitialized {return false}
      if let v = _storage._drawingPath, !v.isInitialized {return false}
      if let v = _storage._strokesBoundingBoxOrigin, !v.isInitialized {return false}
      if let v = _storage._strokesBoundingBoxSize, !v.isInitialized {return false}
      if let v = _storage._originalAttachedSize, !v.isInitialized {return false}
      if let v = _storage._penColor, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._calloutSubStorages) {return false}
      if let v = _storage._creationDate, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._subStorages) {return false}
      if let v = _storage._encodedDrawing, !v.isInitialized {return false}
      if let v = _storage._strokePointsFrameOrigin, !v.isInitialized {return false}
      if let v = _storage._strokePointsFrameSize, !v.isInitialized {return false}
      if let v = _storage._renderedFrameOrigin, !v.isInitialized {return false}
      if let v = _storage._renderedFrameSize, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._attachedLocation) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._markupOffset) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._rasterizedImage) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._legacyEncodedDrawing) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._drawingPath) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._strokesBoundingBoxOrigin) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._strokesBoundingBoxSize) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._attachedType) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._originalAttachedSize) }()
        case 10: try { try decoder.decodeSingularDoubleField(value: &_storage._percentOfPaContainedInParentRep) }()
        case 11: try { try decoder.decodeSingularUInt64Field(value: &_storage._textBaselinesTouchedCount) }()
        case 12: try { try decoder.decodeSingularUInt64Field(value: &_storage._visibleStrokesCount) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._penColor) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._toolType) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._calloutSubStorages) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._creationDate) }()
        case 17: try { try decoder.decodeSingularDoubleField(value: &_storage._pencilAnnotationDrawingScale) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._compoundAnnotationType) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._subStorages) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._encodedDrawing) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._strokePointsFrameOrigin) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._strokePointsFrameSize) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._renderedFrameOrigin) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._renderedFrameSize) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._attachedLocation {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._markupOffset {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._rasterizedImage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._legacyEncodedDrawing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._drawingPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._strokesBoundingBoxOrigin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._strokesBoundingBoxSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._attachedType {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._originalAttachedSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._percentOfPaContainedInParentRep {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._textBaselinesTouchedCount {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._visibleStrokesCount {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._penColor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._toolType {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 14)
      } }()
      if !_storage._calloutSubStorages.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._calloutSubStorages, fieldNumber: 15)
      }
      try { if let v = _storage._creationDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._pencilAnnotationDrawingScale {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._compoundAnnotationType {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 18)
      } }()
      if !_storage._subStorages.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._subStorages, fieldNumber: 19)
      }
      try { if let v = _storage._encodedDrawing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._strokePointsFrameOrigin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._strokePointsFrameSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._renderedFrameOrigin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._renderedFrameSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_PencilAnnotationStorageArchive, rhs: TSD_PencilAnnotationStorageArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._attachedLocation != rhs_storage._attachedLocation {return false}
        if _storage._markupOffset != rhs_storage._markupOffset {return false}
        if _storage._rasterizedImage != rhs_storage._rasterizedImage {return false}
        if _storage._legacyEncodedDrawing != rhs_storage._legacyEncodedDrawing {return false}
        if _storage._drawingPath != rhs_storage._drawingPath {return false}
        if _storage._strokesBoundingBoxOrigin != rhs_storage._strokesBoundingBoxOrigin {return false}
        if _storage._strokesBoundingBoxSize != rhs_storage._strokesBoundingBoxSize {return false}
        if _storage._attachedType != rhs_storage._attachedType {return false}
        if _storage._originalAttachedSize != rhs_storage._originalAttachedSize {return false}
        if _storage._percentOfPaContainedInParentRep != rhs_storage._percentOfPaContainedInParentRep {return false}
        if _storage._textBaselinesTouchedCount != rhs_storage._textBaselinesTouchedCount {return false}
        if _storage._visibleStrokesCount != rhs_storage._visibleStrokesCount {return false}
        if _storage._penColor != rhs_storage._penColor {return false}
        if _storage._toolType != rhs_storage._toolType {return false}
        if _storage._calloutSubStorages != rhs_storage._calloutSubStorages {return false}
        if _storage._creationDate != rhs_storage._creationDate {return false}
        if _storage._pencilAnnotationDrawingScale != rhs_storage._pencilAnnotationDrawingScale {return false}
        if _storage._compoundAnnotationType != rhs_storage._compoundAnnotationType {return false}
        if _storage._subStorages != rhs_storage._subStorages {return false}
        if _storage._encodedDrawing != rhs_storage._encodedDrawing {return false}
        if _storage._strokePointsFrameOrigin != rhs_storage._strokePointsFrameOrigin {return false}
        if _storage._strokePointsFrameSize != rhs_storage._strokePointsFrameSize {return false}
        if _storage._renderedFrameOrigin != rhs_storage._renderedFrameOrigin {return false}
        if _storage._renderedFrameSize != rhs_storage._renderedFrameSize {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_SpecColorFillSetColorArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecColorFillSetColorArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}color\0")

  public var isInitialized: Bool {
    if self._color == nil {return false}
    if let v = self._color, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_SpecColorFillSetColorArchive, rhs: TSD_SpecColorFillSetColorArchive) -> Bool {
    if lhs._color != rhs._color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_SpecFrameSetAssetScaleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecFrameSetAssetScaleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}asset_scale\0")

  public var isInitialized: Bool {
    if self._assetScale == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._assetScale) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._assetScale {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_SpecFrameSetAssetScaleArchive, rhs: TSD_SpecFrameSetAssetScaleArchive) -> Bool {
    if lhs._assetScale != rhs._assetScale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_SpecGradientFillSetAngleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecGradientFillSetAngleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}angle\0")

  public var isInitialized: Bool {
    if self._angle == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._angle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._angle {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_SpecGradientFillSetAngleArchive, rhs: TSD_SpecGradientFillSetAngleArchive) -> Bool {
    if lhs._angle != rhs._angle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_SpecImageFillSetTechniqueArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecImageFillSetTechniqueArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}technique\0")

  public var isInitialized: Bool {
    if self._technique == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._technique) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._technique {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_SpecImageFillSetTechniqueArchive, rhs: TSD_SpecImageFillSetTechniqueArchive) -> Bool {
    if lhs._technique != rhs._technique {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_SpecReflectionSetOpacityArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecReflectionSetOpacityArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}opacity\0")

  public var isInitialized: Bool {
    if self._opacity == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._opacity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._opacity {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_SpecReflectionSetOpacityArchive, rhs: TSD_SpecReflectionSetOpacityArchive) -> Bool {
    if lhs._opacity != rhs._opacity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_SpecShadowSetAngleArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecShadowSetAngleArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}angle\0")

  public var isInitialized: Bool {
    if self._angle == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._angle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._angle {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_SpecShadowSetAngleArchive, rhs: TSD_SpecShadowSetAngleArchive) -> Bool {
    if lhs._angle != rhs._angle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_SpecShadowSetColorArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecShadowSetColorArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}color\0")

  public var isInitialized: Bool {
    if self._color == nil {return false}
    if let v = self._color, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_SpecShadowSetColorArchive, rhs: TSD_SpecShadowSetColorArchive) -> Bool {
    if lhs._color != rhs._color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_SpecShadowSetOffsetArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecShadowSetOffsetArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}offset\0")

  public var isInitialized: Bool {
    if self._offset == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._offset {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_SpecShadowSetOffsetArchive, rhs: TSD_SpecShadowSetOffsetArchive) -> Bool {
    if lhs._offset != rhs._offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_SpecShadowSetOpacityArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecShadowSetOpacityArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}opacity\0")

  public var isInitialized: Bool {
    if self._opacity == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._opacity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._opacity {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_SpecShadowSetOpacityArchive, rhs: TSD_SpecShadowSetOpacityArchive) -> Bool {
    if lhs._opacity != rhs._opacity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_SpecShadowSetRadiusArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecShadowSetRadiusArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}radius\0")

  public var isInitialized: Bool {
    if self._radius == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._radius) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._radius {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_SpecShadowSetRadiusArchive, rhs: TSD_SpecShadowSetRadiusArchive) -> Bool {
    if lhs._radius != rhs._radius {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_SpecStrokeSetColorArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecStrokeSetColorArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}color\0")

  public var isInitialized: Bool {
    if self._color == nil {return false}
    if let v = self._color, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_SpecStrokeSetColorArchive, rhs: TSD_SpecStrokeSetColorArchive) -> Bool {
    if lhs._color != rhs._color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_SpecStrokeSetPatternArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecStrokeSetPatternArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}line_cap\0\u{3}line_join\0\u{3}miter_limit\0\u{1}width\0\u{1}color\0\u{1}pattern\0")

  fileprivate class _StorageClass {
    var _lineCap: Int32? = nil
    var _lineJoin: Int32? = nil
    var _miterLimit: Double? = nil
    var _width: Double? = nil
    var _color: TSP_Color? = nil
    var _pattern: TSD_StrokePatternArchive? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _lineCap = source._lineCap
      _lineJoin = source._lineJoin
      _miterLimit = source._miterLimit
      _width = source._width
      _color = source._color
      _pattern = source._pattern
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._pattern == nil {return false}
      if let v = _storage._color, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._lineCap) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._lineJoin) }()
        case 3: try { try decoder.decodeSingularDoubleField(value: &_storage._miterLimit) }()
        case 4: try { try decoder.decodeSingularDoubleField(value: &_storage._width) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._color) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._pattern) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._lineCap {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._lineJoin {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._miterLimit {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._width {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._color {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._pattern {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_SpecStrokeSetPatternArchive, rhs: TSD_SpecStrokeSetPatternArchive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._lineCap != rhs_storage._lineCap {return false}
        if _storage._lineJoin != rhs_storage._lineJoin {return false}
        if _storage._miterLimit != rhs_storage._miterLimit {return false}
        if _storage._width != rhs_storage._width {return false}
        if _storage._color != rhs_storage._color {return false}
        if _storage._pattern != rhs_storage._pattern {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_SpecStrokeSetWidthArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecStrokeSetWidthArchive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}width\0")

  public var isInitialized: Bool {
    if self._width == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._width) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._width {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_SpecStrokeSetWidthArchive, rhs: TSD_SpecStrokeSetWidthArchive) -> Bool {
    if lhs._width != rhs._width {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_Attribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Attribution"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}title\0\u{3}description_text\0\u{3}external_url\0\u{3}author_name\0\u{3}author_url\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._descriptionText) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._externalURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._authorName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._authorURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._descriptionText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._externalURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._authorName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._authorURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_Attribution, rhs: TSD_Attribution) -> Bool {
    if lhs._title != rhs._title {return false}
    if lhs._descriptionText != rhs._descriptionText {return false}
    if lhs._externalURL != rhs._externalURL {return false}
    if lhs._authorName != rhs._authorName {return false}
    if lhs._authorURL != rhs._authorURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_MovieFingerprint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MovieFingerprint"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}tracks\0\u{1}version\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.tracks) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tracks) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tracks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tracks, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_MovieFingerprint, rhs: TSD_MovieFingerprint) -> Bool {
    if lhs.tracks != rhs.tracks {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TSD_MovieFingerprintTrack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MovieFingerprintTrack"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}media_type\0\u{1}enabled\0\u{3}total_sample_data_length\0\u{3}sample_data_digest_string\0\u{3}time_range_start_value\0\u{3}time_range_start_timescale\0\u{3}time_range_start_is_valid\0\u{3}time_range_duration_value\0\u{3}time_range_duration_timescale\0\u{3}time_range_duration_is_valid\0\u{3}natural_size\0\u{3}preferred_transform_a\0\u{3}preferred_transform_b\0\u{3}preferred_transform_c\0\u{3}preferred_transform_d\0\u{3}preferred_transform_tx\0\u{3}preferred_transform_ty\0\u{3}preferred_volume\0\u{3}language_code\0\u{3}extended_language_tag\0")

  fileprivate class _StorageClass {
    var _mediaType: String? = nil
    var _enabled: Bool? = nil
    var _totalSampleDataLength: Int64? = nil
    var _sampleDataDigestString: String? = nil
    var _timeRangeStartValue: Int64? = nil
    var _timeRangeStartTimescale: Int32? = nil
    var _timeRangeStartIsValid: Bool? = nil
    var _timeRangeDurationValue: Int64? = nil
    var _timeRangeDurationTimescale: Int32? = nil
    var _timeRangeDurationIsValid: Bool? = nil
    var _naturalSize: TSP_Size? = nil
    var _preferredTransformA: Double? = nil
    var _preferredTransformB: Double? = nil
    var _preferredTransformC: Double? = nil
    var _preferredTransformD: Double? = nil
    var _preferredTransformTx: Double? = nil
    var _preferredTransformTy: Double? = nil
    var _preferredVolume: Double? = nil
    var _languageCode: String? = nil
    var _extendedLanguageTag: String? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _mediaType = source._mediaType
      _enabled = source._enabled
      _totalSampleDataLength = source._totalSampleDataLength
      _sampleDataDigestString = source._sampleDataDigestString
      _timeRangeStartValue = source._timeRangeStartValue
      _timeRangeStartTimescale = source._timeRangeStartTimescale
      _timeRangeStartIsValid = source._timeRangeStartIsValid
      _timeRangeDurationValue = source._timeRangeDurationValue
      _timeRangeDurationTimescale = source._timeRangeDurationTimescale
      _timeRangeDurationIsValid = source._timeRangeDurationIsValid
      _naturalSize = source._naturalSize
      _preferredTransformA = source._preferredTransformA
      _preferredTransformB = source._preferredTransformB
      _preferredTransformC = source._preferredTransformC
      _preferredTransformD = source._preferredTransformD
      _preferredTransformTx = source._preferredTransformTx
      _preferredTransformTy = source._preferredTransformTy
      _preferredVolume = source._preferredVolume
      _languageCode = source._languageCode
      _extendedLanguageTag = source._extendedLanguageTag
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._naturalSize, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._mediaType) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._enabled) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._totalSampleDataLength) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._sampleDataDigestString) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._timeRangeStartValue) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._timeRangeStartTimescale) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._timeRangeStartIsValid) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._timeRangeDurationValue) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._timeRangeDurationTimescale) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._timeRangeDurationIsValid) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._naturalSize) }()
        case 12: try { try decoder.decodeSingularDoubleField(value: &_storage._preferredTransformA) }()
        case 13: try { try decoder.decodeSingularDoubleField(value: &_storage._preferredTransformB) }()
        case 14: try { try decoder.decodeSingularDoubleField(value: &_storage._preferredTransformC) }()
        case 15: try { try decoder.decodeSingularDoubleField(value: &_storage._preferredTransformD) }()
        case 16: try { try decoder.decodeSingularDoubleField(value: &_storage._preferredTransformTx) }()
        case 17: try { try decoder.decodeSingularDoubleField(value: &_storage._preferredTransformTy) }()
        case 18: try { try decoder.decodeSingularDoubleField(value: &_storage._preferredVolume) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._languageCode) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._extendedLanguageTag) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._mediaType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._enabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._totalSampleDataLength {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._sampleDataDigestString {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._timeRangeStartValue {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._timeRangeStartTimescale {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._timeRangeStartIsValid {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._timeRangeDurationValue {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._timeRangeDurationTimescale {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._timeRangeDurationIsValid {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._naturalSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._preferredTransformA {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._preferredTransformB {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._preferredTransformC {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._preferredTransformD {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._preferredTransformTx {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._preferredTransformTy {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._preferredVolume {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._languageCode {
        try visitor.visitSingularStringField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._extendedLanguageTag {
        try visitor.visitSingularStringField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TSD_MovieFingerprintTrack, rhs: TSD_MovieFingerprintTrack) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._mediaType != rhs_storage._mediaType {return false}
        if _storage._enabled != rhs_storage._enabled {return false}
        if _storage._totalSampleDataLength != rhs_storage._totalSampleDataLength {return false}
        if _storage._sampleDataDigestString != rhs_storage._sampleDataDigestString {return false}
        if _storage._timeRangeStartValue != rhs_storage._timeRangeStartValue {return false}
        if _storage._timeRangeStartTimescale != rhs_storage._timeRangeStartTimescale {return false}
        if _storage._timeRangeStartIsValid != rhs_storage._timeRangeStartIsValid {return false}
        if _storage._timeRangeDurationValue != rhs_storage._timeRangeDurationValue {return false}
        if _storage._timeRangeDurationTimescale != rhs_storage._timeRangeDurationTimescale {return false}
        if _storage._timeRangeDurationIsValid != rhs_storage._timeRangeDurationIsValid {return false}
        if _storage._naturalSize != rhs_storage._naturalSize {return false}
        if _storage._preferredTransformA != rhs_storage._preferredTransformA {return false}
        if _storage._preferredTransformB != rhs_storage._preferredTransformB {return false}
        if _storage._preferredTransformC != rhs_storage._preferredTransformC {return false}
        if _storage._preferredTransformD != rhs_storage._preferredTransformD {return false}
        if _storage._preferredTransformTx != rhs_storage._preferredTransformTx {return false}
        if _storage._preferredTransformTy != rhs_storage._preferredTransformTy {return false}
        if _storage._preferredVolume != rhs_storage._preferredVolume {return false}
        if _storage._languageCode != rhs_storage._languageCode {return false}
        if _storage._extendedLanguageTag != rhs_storage._extendedLanguageTag {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
