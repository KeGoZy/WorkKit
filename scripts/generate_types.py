#!/usr/bin/env python3
import json
import sys
from pathlib import Path
from typing import Dict, List, Optional
from collections import defaultdict


def format_swift_name(class_name: str) -> str:
    """Convert protobuf class name to Swift format."""
    
    swift_name = class_name.replace('.', '_', 1)
    
    swift_name = swift_name.replace('TSCH_PreUFF.', 'TSCH_PreUFF_')
    return swift_name


def group_by_class_name(mapping: Dict[str, str]) -> Dict[str, List[str]]:
    """Group type IDs by their class name."""
    groups = defaultdict(list)
    for type_id, class_name in mapping.items():
        groups[class_name].append(type_id)
    return groups


def load_extensions_map(extensions_file: Path) -> Dict[str, List[str]]:
    """Load the extensions map generated by the Swift extension scanner."""
    if not extensions_file.exists():
        print(f"Warning: {extensions_file} not found, proceeding without extensions...", file=sys.stderr)
        return {}
    
    with open(extensions_file) as f:
        return json.load(f)


def generate_decoder(
    json_file: Path,
    output_file: Path,
    function_name: str,
    fallback_to_common: bool,
    extensions_map: Dict[str, List[str]]
) -> None:
    """Generate Swift decoder function with extension support."""
    print(f"Generating {output_file} from {json_file}...")
    
    with open(json_file) as f:
        mapping: Dict[str, str] = json.load(f)
    
    
    class_groups = group_by_class_name(mapping)
    
    with open(output_file, 'w') as out:
        out.write("import Foundation\n")
        out.write("import SwiftProtobuf\n")
        out.write("\n")
        out.write(f"package func {function_name}(type: UInt32, data: Data) throws -> SwiftProtobuf.Message {{\n")
        out.write("    switch type {\n")
        
        
        for class_name in sorted(class_groups.keys()):
            type_ids = sorted(class_groups[class_name], key=int)
            swift_name = format_swift_name(class_name)
            
            
            out.write(f"    case {', '.join(type_ids)}:\n")
            
            
            if swift_name in extensions_map and extensions_map[swift_name]:
                extensions = extensions_map[swift_name]
                out.write(f"        return try {swift_name}(serializedBytes: data, extensions: SwiftProtobuf.SimpleExtensionMap([\n")
                for ext in extensions:
                    out.write(f"            {ext},\n")
                out.write("        ]))\n")
            else:
                
                out.write(f"        return try {swift_name}(serializedBytes: data)\n")
        
        out.write("    default:\n")
        if fallback_to_common:
            out.write("        return try decodeCommon(type: type, data: data)\n")
        else:
            out.write("        throw DecodingError.dataCorrupted(\n")
            out.write("            DecodingError.Context(\n")
            out.write("                codingPath: [],\n")
            out.write('                debugDescription: "Unknown type: \\(type)"\n')
            out.write("            )\n")
            out.write("        )\n")
        
        out.write("    }\n")
        out.write("}\n")
    
    print(f"✓ Generated {output_file}")


def main():
    """Generate all decoders with extension support."""
    
    extensions_map = load_extensions_map(Path("extensions_map.json"))
    
    if extensions_map:
        print(f"Loaded extensions for {len(extensions_map)} types")
        for type_name, exts in extensions_map.items():
            print(f"  - {type_name}: {len(exts)} extension(s)")
        print()
    
    configs = [
        
        ("common_registry.json", "CommonDecoder.swift", "decodeCommon", False),
        ("keynote_registry.json", "KeynoteDecoder.swift", "decodeKeynote", True),
        ("numbers_registry.json", "NumbersDecoder.swift", "decodeNumbers", True),
        ("pages_registry.json", "PagesDecoder.swift", "decodePages", True),
    ]
    
    for json_file, decoder_file, func_name, fallback in configs:
        json_path = Path(json_file)
        
        if not json_path.exists():
            print(f"Warning: {json_file} not found, skipping...", file=sys.stderr)
            continue
        
        
        generate_decoder(
            json_path,
            Path(decoder_file),
            func_name,
            fallback,
            extensions_map
        )
    
    print("✓ All decoders generated successfully!")


if __name__ == "__main__":
    main()